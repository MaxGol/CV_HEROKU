/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 24);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(25);
} else {
  module.exports = __webpack_require__(26);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(18);
var isBuffer = __webpack_require__(38);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(3);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(5);
  var warning = __webpack_require__(7);
  var ReactPropTypesSecret = __webpack_require__(9);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(27);
} else {
  module.exports = __webpack_require__(30);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(2);
var normalizeHeaderName = __webpack_require__(40);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(19);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(19);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(3);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(28);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(2);
var settle = __webpack_require__(41);
var buildURL = __webpack_require__(43);
var parseHeaders = __webpack_require__(44);
var isURLSameOrigin = __webpack_require__(45);
var createError = __webpack_require__(20);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(46);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(47);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(42);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(64)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(65)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(10);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _app = __webpack_require__(35);

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_reactDom2.default.render(_react2.default.createElement(_app2.default, { url: 'http://localhost:8000/api/data' }), document.querySelector('.container'));
// ReactDOM.render(<App url="https://maxgolubev-cv.herokuapp.com/api/data" />, document.querySelector('.container'));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(4),
    n = __webpack_require__(6),
    p = __webpack_require__(3);
function q(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var r = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function t(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}t.prototype.isReactComponent = {};t.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? q("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};t.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function u(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}function v() {}v.prototype = t.prototype;var w = u.prototype = new v();w.constructor = u;m(w, t.prototype);w.isPureReactComponent = !0;function x(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}var y = x.prototype = new v();y.constructor = x;m(y, t.prototype);y.unstable_isAsyncReactComponent = !0;y.render = function () {
  return this.props.children;
};
var z = { current: null },
    A = Object.prototype.hasOwnProperty,
    B = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    C = { key: !0, ref: !0, __self: !0, __source: !0 };
function D(a, b, e) {
  var d,
      c = {},
      h = null,
      k = null;if (null != b) for (d in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (h = "" + b.key), b) {
    A.call(b, d) && !C.hasOwnProperty(d) && (c[d] = b[d]);
  }var f = arguments.length - 2;if (1 === f) c.children = e;else if (1 < f) {
    for (var g = Array(f), l = 0; l < f; l++) {
      g[l] = arguments[l + 2];
    }c.children = g;
  }if (a && a.defaultProps) for (d in f = a.defaultProps, f) {
    void 0 === c[d] && (c[d] = f[d]);
  }return { $$typeof: B, type: a, key: h, ref: k, props: c, _owner: z.current };
}function E(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === B;
}
var F = "function" === typeof Symbol && Symbol.iterator,
    G = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    H = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.portal") || 60106;function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var I = /\/+/g,
    J = [];
function K(a, b, e, d) {
  if (J.length) {
    var c = J.pop();c.result = a;c.keyPrefix = b;c.func = e;c.context = d;c.count = 0;return c;
  }return { result: a, keyPrefix: b, func: e, context: d, count: 0 };
}function L(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > J.length && J.push(a);
}
function M(a, b, e, d) {
  var c = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === c || "boolean" === c) a = null;if (null === a || "string" === c || "number" === c || "object" === c && a.$$typeof === G || "object" === c && a.$$typeof === H) return e(d, a, "" === b ? "." + N(a, 0) : b), 1;var h = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    c = a[k];var f = b + N(c, k);h += M(c, f, e, d);
  } else if (f = F && a[F] || a["@@iterator"], "function" === typeof f) for (a = f.call(a), k = 0; !(c = a.next()).done;) {
    c = c.value, f = b + N(c, k++), h += M(c, f, e, d);
  } else "object" === c && (e = "" + a, q("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));return h;
}function N(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function O(a, b) {
  a.func.call(a.context, b, a.count++);
}
function P(a, b, e) {
  var d = a.result,
      c = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? Q(a, d, e, p.thatReturnsArgument) : null != a && (E(a) && (b = c + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(I, "$\x26/") + "/") + e, a = { $$typeof: B, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), d.push(a));
}function Q(a, b, e, d, c) {
  var h = "";null != e && (h = ("" + e).replace(I, "$\x26/") + "/");b = K(b, h, d, c);null == a || M(a, "", P, b);L(b);
}"function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.fragment");
var R = { Children: { map: function map(a, b, e) {
      if (null == a) return a;var d = [];Q(a, d, null, b, e);return d;
    }, forEach: function forEach(a, b, e) {
      if (null == a) return a;b = K(null, null, b, e);null == a || M(a, "", O, b);L(b);
    }, count: function count(a) {
      return null == a ? 0 : M(a, "", p.thatReturnsNull, null);
    }, toArray: function toArray(a) {
      var b = [];Q(a, b, null, p.thatReturnsArgument);return b;
    }, only: function only(a) {
      E(a) ? void 0 : q("143");return a;
    } }, Component: t, PureComponent: u, unstable_AsyncComponent: x, createElement: D, cloneElement: function cloneElement(a, b, e) {
    var d = m({}, a.props),
        c = a.key,
        h = a.ref,
        k = a._owner;if (null != b) {
      void 0 !== b.ref && (h = b.ref, k = z.current);void 0 !== b.key && (c = "" + b.key);if (a.type && a.type.defaultProps) var f = a.type.defaultProps;for (g in b) {
        A.call(b, g) && !C.hasOwnProperty(g) && (d[g] = void 0 === b[g] && void 0 !== f ? f[g] : b[g]);
      }
    }var g = arguments.length - 2;if (1 === g) d.children = e;else if (1 < g) {
      f = Array(g);for (var l = 0; l < g; l++) {
        f[l] = arguments[l + 2];
      }d.children = f;
    }return { $$typeof: B, type: a.type, key: c, ref: h, props: d, _owner: k };
  }, createFactory: function createFactory(a) {
    var b = D.bind(null, a);b.type = a;return b;
  }, isValidElement: E,
  version: "16.1.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: z, assign: m } },
    S = Object.freeze({ default: R }),
    T = S && R || S;module.exports = T["default"] ? T["default"] : T;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.1.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(4);
    var invariant = __webpack_require__(5);
    var emptyObject = __webpack_require__(6);
    var warning = __webpack_require__(7);
    var emptyFunction = __webpack_require__(3);
    var checkPropTypes = __webpack_require__(8);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.1.0';

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    // Exports React.Fragment
    var enableReactFragment = false;
    // Exports ReactDOM.createRoot


    // Mutating mode (React DOM, React ART, React Native):

    // Experimental noop mode (currently unused):

    // Experimental persistent mode (CS):


    // Only used in www builds.

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    // The Symbol used to tag the ReactElement type. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE$1,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE$1) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE$1;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    // The Symbol used to tag the ReactElement type. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
    var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      if (children === null || type === 'string' || type === 'number' ||
      // The following is inlined from ReactElement. This means we can optimize
      // some checks. React Fiber also inlines this logic for similar purposes.
      type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE || type === 'object' && children.$$typeof === REACT_PORTAL_TYPE) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE$1) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var REACT_FRAGMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    var ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL$1 = '@@iterator'; // Before Symbol spec.

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = ITERATOR_SYMBOL$1 && node[ITERATOR_SYMBOL$1] || node[FAUX_ITERATOR_SYMBOL$1];
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;

      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE$1) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var REACT_FRAGMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    if (enableReactFragment) {
      React.Fragment = REACT_FRAGMENT_TYPE;
    }

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(0),
    m = __webpack_require__(12),
    A = __webpack_require__(4),
    B = __webpack_require__(3),
    ca = __webpack_require__(13),
    da = __webpack_require__(14),
    ea = __webpack_require__(15),
    ha = __webpack_require__(16),
    ia = __webpack_require__(17),
    C = __webpack_require__(6);
function D(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : D("227");
var la = { children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0 };function qa(a, b) {
  return (a & b) === b;
}
var ra = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = ra,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      sa.hasOwnProperty(f) ? D("48", f) : void 0;var g = f.toLowerCase(),
          k = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: qa(k, b.MUST_USE_PROPERTY),
        hasBooleanValue: qa(k, b.HAS_BOOLEAN_VALUE), hasNumericValue: qa(k, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: qa(k, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: qa(k, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: qa(k, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : D("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);sa[f] = g;
    }
  } },
    sa = {};
function ta(a, b) {
  if (la.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
      return la.hasOwnProperty(a) ? a = !0 : (b = ua(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;case "undefined":case "number":case "string":case "object":
      return !0;default:
      return !1;}
}function ua(a) {
  return sa.hasOwnProperty(a) ? sa[a] : null;
}
var va = ra,
    wa = va.MUST_USE_PROPERTY,
    H = va.HAS_BOOLEAN_VALUE,
    xa = va.HAS_NUMERIC_VALUE,
    ya = va.HAS_POSITIVE_NUMERIC_VALUE,
    za = va.HAS_STRING_BOOLEAN_VALUE,
    Aa = { Properties: { allowFullScreen: H, autoFocus: za, async: H, autoPlay: H, capture: H, checked: wa | H, cols: ya, contentEditable: za, controls: H, "default": H, defer: H, disabled: H, download: va.HAS_OVERLOADED_BOOLEAN_VALUE, draggable: za, formNoValidate: H, hidden: H, loop: H, multiple: wa | H, muted: wa | H, noValidate: H, open: H, playsInline: H, readOnly: H, required: H, reversed: H, rows: ya, rowSpan: xa,
    scoped: H, seamless: H, selected: wa | H, size: ya, start: xa, span: ya, spellCheck: za, style: 0, tabIndex: 0, itemScope: H, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: za }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    Ba = va.HAS_STRING_BOOLEAN_VALUE,
    K = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    Ca = { Properties: { autoReverse: Ba, externalResourcesRequired: Ba, preserveAlpha: Ba }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: K.xlink, xlinkArcrole: K.xlink, xlinkHref: K.xlink, xlinkRole: K.xlink, xlinkShow: K.xlink, xlinkTitle: K.xlink, xlinkType: K.xlink,
    xmlBase: K.xml, xmlLang: K.xml, xmlSpace: K.xml } },
    Da = /[\-\:]([a-z])/g;function Ea(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Da, Ea);Ca.Properties[b] = 0;Ca.DOMAttributeNames[b] = a;
});va.injectDOMPropertyConfig(Aa);va.injectDOMPropertyConfig(Ca);
var N = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? D("197") : void 0;Ha = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, k, h) {
    Ha.apply(N, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, k, h) {
    N.invokeGuardedCallback.apply(this, arguments);if (N.hasCaughtError()) {
      var r = N.clearCaughtError();N._hasRethrowError || (N._hasRethrowError = !0, N._rethrowError = r);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return Ia.apply(N, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return N._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (N._hasCaughtError) {
      var a = N._caughtError;N._caughtError = null;N._hasCaughtError = !1;return a;
    }D("198");
  } };function Ha(a, b, c, d, e, f, g, k, h) {
  N._hasCaughtError = !1;N._caughtError = null;var r = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, r);
  } catch (n) {
    N._caughtError = n, N._hasCaughtError = !0;
  }
}
function Ia() {
  if (N._hasRethrowError) {
    var a = N._rethrowError;N._rethrowError = null;N._hasRethrowError = !1;throw a;
  }
}var Ja = null,
    Ka = {};
function La() {
  if (Ja) for (var a in Ka) {
    var b = Ka[a],
        c = Ja.indexOf(a);-1 < c ? void 0 : D("96", a);if (!Ma[c]) {
      b.extractEvents ? void 0 : D("97", a);Ma[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            k = d;Na.hasOwnProperty(k) ? D("99", k) : void 0;Na[k] = f;var h = f.phasedRegistrationNames;if (h) {
          for (e in h) {
            h.hasOwnProperty(e) && Oa(h[e], g, k);
          }e = !0;
        } else f.registrationName ? (Oa(f.registrationName, g, k), e = !0) : e = !1;e ? void 0 : D("98", d, a);
      }
    }
  }
}
function Oa(a, b, c) {
  Pa[a] ? D("100", a) : void 0;Pa[a] = b;Qa[a] = b.eventTypes[c].dependencies;
}var Ma = [],
    Na = {},
    Pa = {},
    Qa = {};function Ra(a) {
  Ja ? D("101") : void 0;Ja = Array.prototype.slice.call(a);La();
}function Sa(a) {
  var b = !1,
      c;for (c in a) {
    if (a.hasOwnProperty(c)) {
      var d = a[c];Ka.hasOwnProperty(c) && Ka[c] === d || (Ka[c] ? D("102", c) : void 0, Ka[c] = d, b = !0);
    }
  }b && La();
}
var Ta = Object.freeze({ plugins: Ma, eventNameDispatchConfigs: Na, registrationNameModules: Pa, registrationNameDependencies: Qa, possibleRegistrationNames: null, injectEventPluginOrder: Ra, injectEventPluginsByName: Sa }),
    Ua = null,
    Va = null,
    Wa = null;function Xa(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = Wa(d);N.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
function Ya(a, b) {
  null == b ? D("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}function Za(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var $a = null;
function ab(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      Xa(a, b, c[e], d[e]);
    } else c && Xa(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function bb(a) {
  return ab(a, !0);
}function cb(a) {
  return ab(a, !1);
}var db = { injectEventPluginOrder: Ra, injectEventPluginsByName: Sa };
function eb(a, b) {
  var c = a.stateNode;if (!c) return null;var d = Ua(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? D("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function jb(a, b, c, d) {
  for (var e, f = 0; f < Ma.length; f++) {
    var g = Ma[f];g && (g = g.extractEvents(a, b, c, d)) && (e = Ya(e, g));
  }return e;
}function kb(a) {
  a && ($a = Ya($a, a));
}function lb(a) {
  var b = $a;$a = null;a ? Za(b, bb) : Za(b, cb);$a ? D("95") : void 0;N.rethrowCaughtError();
}var mb = Object.freeze({ injection: db, getListener: eb, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb }),
    nb = Math.random().toString(36).slice(2),
    O = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;
function pb(a) {
  if (a[O]) return a[O];for (var b = []; !a[O];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = void 0,
      d = a[O];if (5 === d.tag || 6 === d.tag) return d;for (; a && (d = a[O]); a = b.pop()) {
    c = d;
  }return c;
}function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;D("33");
}function rb(a) {
  return a[ob] || null;
}
var sb = Object.freeze({ precacheFiberNode: function precacheFiberNode(a, b) {
    b[O] = a;
  }, getClosestInstanceFromNode: pb, getInstanceFromNode: function getInstanceFromNode(a) {
    a = a[O];return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps: function updateFiberProps(a, b) {
    a[ob] = b;
  } });function Q(a) {
  do {
    a = a["return"];
  } while (a && 5 !== a.tag);return a ? a : null;
}function tb(a, b, c) {
  for (var d = []; a;) {
    d.push(a), a = Q(a);
  }for (a = d.length; 0 < a--;) {
    b(d[a], "captured", c);
  }for (a = 0; a < d.length; a++) {
    b(d[a], "bubbled", c);
  }
}
function ub(a, b, c) {
  if (b = eb(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = Ya(c._dispatchListeners, b), c._dispatchInstances = Ya(c._dispatchInstances, a);
}function vb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && tb(a._targetInst, ub, a);
}function wb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? Q(b) : null;tb(b, ub, a);
  }
}
function xb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = eb(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = Ya(c._dispatchListeners, b), c._dispatchInstances = Ya(c._dispatchInstances, a));
}function yb(a) {
  a && a.dispatchConfig.registrationName && xb(a._targetInst, null, a);
}function zb(a) {
  Za(a, vb);
}
function Ab(a, b, c, d) {
  if (c && d) a: {
    var e = c;for (var f = d, g = 0, k = e; k; k = Q(k)) {
      g++;
    }k = 0;for (var h = f; h; h = Q(h)) {
      k++;
    }for (; 0 < g - k;) {
      e = Q(e), g--;
    }for (; 0 < k - g;) {
      f = Q(f), k--;
    }for (; g--;) {
      if (e === f || e === f.alternate) break a;e = Q(e);f = Q(f);
    }e = null;
  } else e = null;f = e;for (e = []; c && c !== f;) {
    g = c.alternate;if (null !== g && g === f) break;e.push(c);c = Q(c);
  }for (c = []; d && d !== f;) {
    g = d.alternate;if (null !== g && g === f) break;c.push(d);d = Q(d);
  }for (d = 0; d < e.length; d++) {
    xb(e[d], "bubbled", a);
  }for (a = c.length; 0 < a--;) {
    xb(c[a], "captured", b);
  }
}
var Bb = Object.freeze({ accumulateTwoPhaseDispatches: zb, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    Za(a, wb);
  }, accumulateEnterLeaveDispatches: Ab, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    Za(a, yb);
  } }),
    Cb = null;function Db() {
  !Cb && m.canUseDOM && (Cb = "textContent" in document.documentElement ? "textContent" : "innerText");return Cb;
}var R = { _root: null, _startText: null, _fallbackText: null };
function Eb() {
  if (R._fallbackText) return R._fallbackText;var a,
      b = R._startText,
      c = b.length,
      d,
      e = Fb(),
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}R._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return R._fallbackText;
}function Fb() {
  return "value" in R._root ? R._root.value : R._root[Db()];
}
var Gb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Hb = { type: null, target: null, currentTarget: B.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function S(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? B.thatReturnsTrue : B.thatReturnsFalse;this.isPropagationStopped = B.thatReturnsFalse;return this;
}
A(S.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = B.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = B.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = B.thatReturnsTrue;
  }, isPersistent: B.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Gb.length; a++) {
      this[Gb[a]] = null;
    }
  } });S.Interface = Hb;S.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();A(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = A({}, this.Interface, b);a.augmentClass = this.augmentClass;Ib(a);
};Ib(S);function Jb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function Qb(a) {
  a instanceof this ? void 0 : D("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Ib(a) {
  a.eventPool = [];a.getPooled = Jb;a.release = Qb;
}function Rb(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Rb, { data: null });function Sb(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Sb, { data: null });var Tb = [9, 13, 27, 32],
    Ub = m.canUseDOM && "CompositionEvent" in window,
    Vb = null;m.canUseDOM && "documentMode" in document && (Vb = document.documentMode);var Wb;
if (Wb = m.canUseDOM && "TextEvent" in window && !Vb) {
  var Xb = window.opera;Wb = !("object" === (typeof Xb === "undefined" ? "undefined" : _typeof(Xb)) && "function" === typeof Xb.version && 12 >= parseInt(Xb.version(), 10));
}
var Yb = Wb,
    Zb = m.canUseDOM && (!Ub || Vb && 8 < Vb && 11 >= Vb),
    $b = String.fromCharCode(32),
    ac = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    bc = !1;
function cc(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== Tb.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function dc(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var ec = !1;function fc(a, b) {
  switch (a) {case "topCompositionEnd":
      return dc(b);case "topKeyPress":
      if (32 !== b.which) return null;bc = !0;return $b;case "topTextInput":
      return a = b.data, a === $b && bc ? null : a;default:
      return null;}
}
function gc(a, b) {
  if (ec) return "topCompositionEnd" === a || !Ub && cc(a, b) ? (a = Eb(), R._root = null, R._startText = null, R._fallbackText = null, ec = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return Zb ? null : b.data;default:
      return null;}
}
var hc = { eventTypes: ac, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (Ub) b: {
      switch (a) {case "topCompositionStart":
          var f = ac.compositionStart;break b;case "topCompositionEnd":
          f = ac.compositionEnd;break b;case "topCompositionUpdate":
          f = ac.compositionUpdate;break b;}f = void 0;
    } else ec ? cc(a, c) && (f = ac.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = ac.compositionStart);f ? (Zb && (ec || f !== ac.compositionStart ? f === ac.compositionEnd && ec && (e = Eb()) : (R._root = d, R._startText = Fb(), ec = !0)), f = Rb.getPooled(f, b, c, d), e ? f.data = e : (e = dc(c), null !== e && (f.data = e)), zb(f), e = f) : e = null;(a = Yb ? fc(a, c) : gc(a, c)) ? (b = Sb.getPooled(ac.beforeInput, b, c, d), b.data = a, zb(b)) : b = null;return [e, b];
  } },
    ic = null,
    jc = null,
    kc = null;function lc(a) {
  if (a = Va(a)) {
    ic && "function" === typeof ic.restoreControlledState ? void 0 : D("194");var b = Ua(a.stateNode);ic.restoreControlledState(a.stateNode, a.type, b);
  }
}var mc = { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
    ic = a;
  } };function nc(a) {
  jc ? kc ? kc.push(a) : kc = [a] : jc = a;
}
function oc() {
  if (jc) {
    var a = jc,
        b = kc;kc = jc = null;lc(a);if (b) for (a = 0; a < b.length; a++) {
      lc(b[a]);
    }
  }
}var pc = Object.freeze({ injection: mc, enqueueStateRestore: nc, restoreStateIfNeeded: oc });function qc(a, b) {
  return a(b);
}var rc = !1;function sc(a, b) {
  if (rc) return qc(a, b);rc = !0;try {
    return qc(a, b);
  } finally {
    rc = !1, oc();
  }
}var tc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function uc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!tc[a.type] : "textarea" === b ? !0 : !1;
}function vc(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var wc;m.canUseDOM && (wc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function xc(a, b) {
  if (!m.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && wc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function yc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function zc(a) {
  var b = yc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
function Ac(a) {
  a._valueTracker || (a._valueTracker = zc(a));
}function Bc(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = yc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}var Cc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };
function Dc(a, b, c) {
  a = S.getPooled(Cc.change, a, b, c);a.type = "change";nc(c);zb(a);return a;
}var Ec = null,
    Fc = null;function Gc(a) {
  kb(a);lb(!1);
}function Hc(a) {
  var b = qb(a);if (Bc(b)) return a;
}function Ic(a, b) {
  if ("topChange" === a) return b;
}var Jc = !1;m.canUseDOM && (Jc = xc("input") && (!document.documentMode || 9 < document.documentMode));function Qc() {
  Ec && (Ec.detachEvent("onpropertychange", Rc), Fc = Ec = null);
}function Rc(a) {
  "value" === a.propertyName && Hc(Fc) && (a = Dc(Fc, a, vc(a)), sc(Gc, a));
}
function Sc(a, b, c) {
  "topFocus" === a ? (Qc(), Ec = b, Fc = c, Ec.attachEvent("onpropertychange", Rc)) : "topBlur" === a && Qc();
}function Tc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Hc(Fc);
}function Uc(a, b) {
  if ("topClick" === a) return Hc(b);
}function Vc(a, b) {
  if ("topInput" === a || "topChange" === a) return Hc(b);
}
var Wc = { eventTypes: Cc, _isInputEventSupported: Jc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Ic;else if (uc(e)) {
      if (Jc) g = Vc;else {
        g = Tc;var k = Sc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Uc);if (g && (g = g(a, b))) return Dc(g, c, d);k && k(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function Xc(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Xc, { view: null, detail: null });var Yc = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function Zc(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = Yc[a]) ? !!b[a] : !1;
}function $c() {
  return Zc;
}function ad(a, b, c, d) {
  return S.call(this, a, b, c, d);
}
Xc.augmentClass(ad, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: $c, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var bd = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    cd = { eventTypes: bd, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : qb(a);e = null == b ? e : qb(b);var g = ad.getPooled(bd.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = ad.getPooled(bd.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Ab(g, c, a, b);return [g, c];
  } },
    dd = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function ed(a) {
  a = a.type;return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}
function fd(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }return 3 === b.tag ? 2 : 3;
}function gd(a) {
  return (a = a._reactInternalFiber) ? 2 === fd(a) : !1;
}function hd(a) {
  2 !== fd(a) ? D("188") : void 0;
}
function id(a) {
  var b = a.alternate;if (!b) return b = fd(a), 3 === b ? D("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return hd(e), a;if (g === d) return hd(e), b;g = g.sibling;
      }D("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var k = e.child; k;) {
        if (k === c) {
          g = !0;c = e;d = f;break;
        }if (k === d) {
          g = !0;d = e;c = f;break;
        }k = k.sibling;
      }if (!g) {
        for (k = f.child; k;) {
          if (k === c) {
            g = !0;c = f;d = e;break;
          }if (k === d) {
            g = !0;d = f;c = e;break;
          }k = k.sibling;
        }g ? void 0 : D("189");
      }
    }c.alternate !== d ? D("190") : void 0;
  }3 !== c.tag ? D("188") : void 0;return c.stateNode.current === c ? a : b;
}function jd(a) {
  a = id(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}
function kd(a) {
  a = id(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}var ld = [];
function md(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c;for (c = b; c["return"];) {
      c = c["return"];
    }c = 3 !== c.tag ? null : c.stateNode.containerInfo;if (!c) break;a.ancestors.push(b);b = pb(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], nd(a.topLevelType, b, a.nativeEvent, vc(a.nativeEvent));
  }
}var od = !0,
    nd = void 0;function pd(a) {
  od = !!a;
}function U(a, b, c) {
  return c ? ca.listen(c, b, qd.bind(null, a)) : null;
}function rd(a, b, c) {
  return c ? ca.capture(c, b, qd.bind(null, a)) : null;
}
function qd(a, b) {
  if (od) {
    var c = vc(b);c = pb(c);null === c || "number" !== typeof c.tag || 2 === fd(c) || (c = null);if (ld.length) {
      var d = ld.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      sc(md, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > ld.length && ld.push(a);
    }
  }
}
var sd = Object.freeze({ get _enabled() {
    return od;
  }, get _handleTopLevel() {
    return nd;
  }, setHandleTopLevel: function setHandleTopLevel(a) {
    nd = a;
  }, setEnabled: pd, isEnabled: function isEnabled() {
    return od;
  }, trapBubbledEvent: U, trapCapturedEvent: rd, dispatchEvent: qd });function td(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var ud = { animationend: td("Animation", "AnimationEnd"), animationiteration: td("Animation", "AnimationIteration"), animationstart: td("Animation", "AnimationStart"), transitionend: td("Transition", "TransitionEnd") },
    vd = {},
    wd = {};m.canUseDOM && (wd = document.createElement("div").style, "AnimationEvent" in window || (delete ud.animationend.animation, delete ud.animationiteration.animation, delete ud.animationstart.animation), "TransitionEvent" in window || delete ud.transitionend.transition);
function xd(a) {
  if (vd[a]) return vd[a];if (!ud[a]) return a;var b = ud[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in wd) return vd[a] = b[c];
  }return "";
}
var yd = { topAbort: "abort", topAnimationEnd: xd("animationend") || "animationend", topAnimationIteration: xd("animationiteration") || "animationiteration", topAnimationStart: xd("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: xd("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    zd = {},
    Ad = 0,
    Bd = "_reactListenersID" + ("" + Math.random()).slice(2);function Cd(a) {
  Object.prototype.hasOwnProperty.call(a, Bd) || (a[Bd] = Ad++, zd[a[Bd]] = {});return zd[a[Bd]];
}function Dd(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Ed(a, b) {
  var c = Dd(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Dd(c);
  }
}function Fd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}
var Gd = m.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Hd = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Id = null,
    Jd = null,
    Kd = null,
    Ld = !1;
function Md(a, b) {
  if (Ld || null == Id || Id !== da()) return null;var c = Id;"selectionStart" in c && Fd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return Kd && ea(Kd, c) ? null : (Kd = c, a = S.getPooled(Hd.select, Jd, a, b), a.type = "select", a.target = Id, zb(a), a);
}
var Nd = { eventTypes: Hd, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Cd(e);f = Qa.onSelect;for (var g = 0; g < f.length; g++) {
          var k = f[g];if (!e.hasOwnProperty(k) || !e[k]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? qb(b) : window;switch (a) {case "topFocus":
        if (uc(e) || "true" === e.contentEditable) Id = e, Jd = b, Kd = null;break;case "topBlur":
        Kd = Jd = Id = null;break;case "topMouseDown":
        Ld = !0;break;case "topContextMenu":case "topMouseUp":
        return Ld = !1, Md(c, d);case "topSelectionChange":
        if (Gd) break;
      case "topKeyDown":case "topKeyUp":
        return Md(c, d);}return null;
  } };function Od(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Od, { animationName: null, elapsedTime: null, pseudoElement: null });function Pd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Pd, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function Qd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}Xc.augmentClass(Qd, { relatedTarget: null });
function Rd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var Sd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Td = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function Ud(a, b, c, d) {
  return S.call(this, a, b, c, d);
}
Xc.augmentClass(Ud, { key: function key(a) {
    if (a.key) {
      var b = Sd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = Rd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Td[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: $c, charCode: function charCode(a) {
    return "keypress" === a.type ? Rd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? Rd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function Vd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}ad.augmentClass(Vd, { dataTransfer: null });function Wd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}Xc.augmentClass(Wd, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: $c });function Xd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Xd, { propertyName: null, elapsedTime: null, pseudoElement: null });
function Yd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}ad.augmentClass(Yd, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var Zd = {},
    $d = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };Zd[a] = c;$d[b] = c;
});
var ae = { eventTypes: Zd, extractEvents: function extractEvents(a, b, c, d) {
    var e = $d[a];if (!e) return null;switch (a) {case "topKeyPress":
        if (0 === Rd(c)) return null;case "topKeyDown":case "topKeyUp":
        a = Ud;break;case "topBlur":case "topFocus":
        a = Qd;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        a = ad;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        a = Vd;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        a = Wd;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        a = Od;break;case "topTransitionEnd":
        a = Xd;break;case "topScroll":
        a = Xc;break;case "topWheel":
        a = Yd;break;case "topCopy":case "topCut":case "topPaste":
        a = Pd;break;default:
        a = S;}b = a.getPooled(e, b, c, d);zb(b);return b;
  } };nd = function nd(a, b, c, d) {
  a = jb(a, b, c, d);kb(a);lb(!1);
};db.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Ua = sb.getFiberCurrentPropsFromNode;Va = sb.getInstanceFromNode;Wa = sb.getNodeFromInstance;db.injectEventPluginsByName({ SimpleEventPlugin: ae, EnterLeaveEventPlugin: cd, ChangeEventPlugin: Wc, SelectEventPlugin: Nd, BeforeInputEventPlugin: hc });var be = [],
    ce = -1;function V(a) {
  0 > ce || (a.current = be[ce], be[ce] = null, ce--);
}function W(a, b) {
  ce++;be[ce] = a.current;a.current = b;
}new Set();var de = { current: C },
    X = { current: !1 },
    ee = C;function fe(a) {
  return ge(a) ? ee : de.current;
}
function he(a, b) {
  var c = a.type.contextTypes;if (!c) return C;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function ge(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}function ie(a) {
  ge(a) && (V(X, a), V(de, a));
}
function je(a, b, c) {
  null != de.cursor ? D("168") : void 0;W(de, b, a);W(X, c, a);
}function ke(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : D("108", ed(a) || "Unknown", e);
  }return A({}, b, c);
}function le(a) {
  if (!ge(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || C;ee = de.current;W(de, b, a);W(X, X.current, a);return !0;
}
function me(a, b) {
  var c = a.stateNode;c ? void 0 : D("169");if (b) {
    var d = ke(a, ee);c.__reactInternalMemoizedMergedChildContext = d;V(X, a);V(de, a);W(de, d, a);
  } else V(X, a);W(X, b, a);
}
function Y(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.expirationTime = 0;this.alternate = null;
}
function ne(a, b, c) {
  var d = a.alternate;null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.expirationTime = c;d.pendingProps = b;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.sibling = a.sibling;d.index = a.index;d.ref = a.ref;return d;
}
function oe(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;"function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : D("130", null == e ? e : typeof e === "undefined" ? "undefined" : _typeof(e), "");d.expirationTime = c;return d;
}function pe(a, b, c, d) {
  b = new Y(10, d, b);b.pendingProps = a;b.expirationTime = c;return b;
}
function qe(a, b, c) {
  b = new Y(6, null, b);b.pendingProps = a;b.expirationTime = c;return b;
}function re(a, b, c) {
  b = new Y(7, a.key, b);b.type = a.handler;b.pendingProps = a;b.expirationTime = c;return b;
}function se(a, b, c) {
  a = new Y(9, null, b);a.expirationTime = c;return a;
}function te(a, b, c) {
  b = new Y(4, a.key, b);b.pendingProps = a.children || [];b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}var ue = null,
    ve = null;
function we(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}function xe(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);ue = we(function (a) {
      return b.onCommitFiberRoot(c, a);
    });ve = we(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}function ye(a) {
  "function" === typeof ue && ue(a);
}function ze(a) {
  "function" === typeof ve && ve(a);
}
function Ae(a) {
  return { baseState: a, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1 };
}function Be(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}
function Ce(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = Ae(null));null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Ae(null))) : a = null;a = a !== d ? a : null;null === a ? Be(d, b) : null === d.last || null === a.last ? (Be(d, b), Be(a, b)) : (Be(d, b), a.last = b);
}function De(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
function Ke(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = { baseState: c.baseState, expirationTime: c.expirationTime, first: c.first, last: c.last, isInitialized: c.isInitialized, callbackList: null, hasForceUpdate: !1 });c.expirationTime = 0;c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);for (var g = !0, k = c.first, h = !1; null !== k;) {
    var r = k.expirationTime;if (r > f) {
      var n = c.expirationTime;if (0 === n || n > r) c.expirationTime = r;h || (h = !0, c.baseState = a);
    } else {
      h || (c.first = k.next, null === c.first && (c.last = null));if (k.isReplace) a = De(k, d, a, e), g = !0;else if (r = De(k, d, a, e)) a = g ? A({}, a, r) : A(a, r), g = !1;k.isForced && (c.hasForceUpdate = !0);null !== k.callback && (r = c.callbackList, null === r && (r = c.callbackList = []), r.push(k));
    }k = k.next;
  }null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);h || (c.baseState = a);return a;
}
function Le(a, b) {
  var c = a.callbackList;if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;d.callback = null;"function" !== typeof e ? D("191", e) : void 0;e.call(b);
  }
}
function Me(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;b._reactInternalFiber = a;
  }var f = { isMounted: gd, enqueueSetState: function enqueueSetState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);Ce(c, { expirationTime: g, partialState: d, callback: e, isReplace: !1, isForced: !1, nextCallback: null, next: null });a(c, g);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var f = b(c);Ce(c, { expirationTime: f, partialState: d, callback: e, isReplace: !0, isForced: !1, nextCallback: null, next: null });
      a(c, f);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = c._reactInternalFiber;d = void 0 === d ? null : d;var e = b(c);Ce(c, { expirationTime: e, partialState: null, callback: d, isReplace: !1, isForced: !0, nextCallback: null, next: null });a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = fe(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? he(a, d) : C;b = new c(b, g);e(a, b);f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : D("158");var k = fe(a);d.props = g;d.state = a.memoizedState = e;d.refs = C;d.context = he(a, k);null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);"function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Ke(c, a, e, d, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= 4);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var k = b.memoizedProps,
          h = b.pendingProps;h || (h = k, null == h ? D("159") : void 0);var u = g.context,
          x = fe(b);x = he(b, x);"function" !== typeof g.componentWillReceiveProps || k === h && u === x || (u = g.state, g.componentWillReceiveProps(h, x), g.state !== u && f.enqueueReplaceState(g, g.state, null));u = b.memoizedState;e = null !== b.updateQueue ? Ke(a, b, b.updateQueue, g, h, e) : u;if (!(k !== h || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || k === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;var F = h;if (null === k || null !== b.updateQueue && b.updateQueue.hasForceUpdate) F = !0;else {
        var L = b.stateNode,
            G = b.type;F = "function" === typeof L.shouldComponentUpdate ? L.shouldComponentUpdate(F, e, x) : G.prototype && G.prototype.isPureReactComponent ? !ea(k, F) || !ea(u, e) : !0;
      }F ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(h, e, x), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || k === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, h), d(b, e));g.props = h;g.state = e;g.context = x;return F;
    } };
}var Ne = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.portal") || 60106;function Oe(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: Ne, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}var Pe = Array.isArray,
    Qe = "function" === typeof Symbol && Symbol.iterator,
    Re,
    Se,
    Te,
    Ue;
"function" === typeof Symbol && Symbol["for"] ? (Re = Symbol["for"]("react.element"), Se = Symbol["for"]("react.call"), Te = Symbol["for"]("react.return"), Ue = Symbol["for"]("react.fragment")) : (Re = 60103, Se = 60104, Te = 60105, Ue = 60107);function Ve(a) {
  if (null === a || "undefined" === typeof a) return null;a = Qe && a[Qe] || a["@@iterator"];return "function" === typeof a ? a : null;
}
function We(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && (2 !== b.tag ? D("110") : void 0, d = b.stateNode);d ? void 0 : D("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === C ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? D("148") : void 0;b._owner ? void 0 : D("149", c);
  }return c;
}
function Xe(a, b) {
  "textarea" !== a.type && D("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function Ye(a, b) {
  function c(c, d) {
    if (b) {
      if (!a) {
        if (null === d.alternate) return;d = d.alternate;
      }var p = c.lastEffect;null !== p ? (p.nextEffect = d, c.lastEffect = d) : c.firstEffect = c.lastEffect = d;d.nextEffect = null;d.effectTag = 8;
    }
  }function d(a, d) {
    if (!b) return null;for (; null !== d;) {
      c(a, d), d = d.sibling;
    }return null;
  }function e(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function f(b, c, d) {
    if (a) return b = ne(b, c, d), b.index = 0, b.sibling = null, b;b.expirationTime = d;b.effectTag = 0;b.index = 0;b.sibling = null;b.pendingProps = c;return b;
  }function g(a, c, d) {
    a.index = d;if (!b) return c;d = a.alternate;if (null !== d) return d = d.index, d < c ? (a.effectTag = 2, c) : d;a.effectTag = 2;return c;
  }function k(a) {
    b && null === a.alternate && (a.effectTag = 2);return a;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = qe(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function r(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = f(b, c.props, d), d.ref = We(b, c), d["return"] = a, d;d = oe(c, a.internalContextTag, d);
    d.ref = We(b, c);d["return"] = a;return d;
  }function n(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = re(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = se(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = f(b, null, d);b.type = c.value;b["return"] = a;return b;
  }function u(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = te(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c.children || [], d);b["return"] = a;return b;
  }function x(a, b, c, d, e) {
    if (null === b || 10 !== b.tag) return b = pe(c, a.internalContextTag, d, e), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function F(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = qe("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Re:
          if (b.type === Ue) return b = pe(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;c = oe(b, a.internalContextTag, c);
          c.ref = We(null, b);c["return"] = a;return c;case Se:
          return b = re(b, a.internalContextTag, c), b["return"] = a, b;case Te:
          return c = se(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case Ne:
          return b = te(b, a.internalContextTag, c), b["return"] = a, b;}if (Pe(b) || Ve(b)) return b = pe(b, a.internalContextTag, c, null), b["return"] = a, b;Xe(a, b);
    }return null;
  }function L(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Re:
          return c.key === e ? c.type === Ue ? x(a, b, c.props.children, d, e) : r(a, b, c, d) : null;case Se:
          return c.key === e ? n(a, b, c, d) : null;case Te:
          return null === e ? y(a, b, c, d) : null;case Ne:
          return c.key === e ? u(a, b, c, d) : null;}if (Pe(c) || Ve(c)) return null !== e ? null : x(a, b, c, d, null);Xe(a, c);
    }return null;
  }function G(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ue ? x(b, a, d.props.children, e, d.key) : r(b, a, d, e);case Se:
          return a = a.get(null === d.key ? c : d.key) || null, n(b, a, d, e);case Te:
          return a = a.get(c) || null, y(b, a, d, e);case Ne:
          return a = a.get(null === d.key ? c : d.key) || null, u(b, a, d, e);}if (Pe(d) || Ve(d)) return a = a.get(c) || null, x(b, a, d, e, null);Xe(b, d);
    }return null;
  }function T(a, f, v, k) {
    for (var p = null, z = null, l = f, h = f = 0, t = null; null !== l && h < v.length; h++) {
      l.index > h ? (t = l, l = null) : t = l.sibling;var w = L(a, l, v[h], k);if (null === w) {
        null === l && (l = t);break;
      }b && l && null === w.alternate && c(a, l);f = g(w, f, h);null === z ? p = w : z.sibling = w;z = w;
      l = t;
    }if (h === v.length) return d(a, l), p;if (null === l) {
      for (; h < v.length; h++) {
        if (l = F(a, v[h], k)) f = g(l, f, h), null === z ? p = l : z.sibling = l, z = l;
      }return p;
    }for (l = e(a, l); h < v.length; h++) {
      if (t = G(l, a, h, v[h], k)) {
        if (b && null !== t.alternate) l["delete"](null === t.key ? h : t.key);f = g(t, f, h);null === z ? p = t : z.sibling = t;z = t;
      }
    }b && l.forEach(function (b) {
      return c(a, b);
    });return p;
  }function I(a, f, v, k) {
    var p = Ve(v);"function" !== typeof p ? D("150") : void 0;v = p.call(v);null == v ? D("151") : void 0;for (var h = p = null, l = f, z = f = 0, t = null, w = v.next(); null !== l && !w.done; z++, w = v.next()) {
      l.index > z ? (t = l, l = null) : t = l.sibling;var n = L(a, l, w.value, k);if (null === n) {
        l || (l = t);break;
      }b && l && null === n.alternate && c(a, l);f = g(n, f, z);null === h ? p = n : h.sibling = n;h = n;l = t;
    }if (w.done) return d(a, l), p;if (null === l) {
      for (; !w.done; z++, w = v.next()) {
        w = F(a, w.value, k), null !== w && (f = g(w, f, z), null === h ? p = w : h.sibling = w, h = w);
      }return p;
    }for (l = e(a, l); !w.done; z++, w = v.next()) {
      if (w = G(l, a, z, w.value, k), null !== w) {
        if (b && null !== w.alternate) l["delete"](null === w.key ? z : w.key);f = g(w, f, z);null === h ? p = w : h.sibling = w;h = w;
      }
    }b && l.forEach(function (b) {
      return c(a, b);
    });return p;
  }return function (a, b, e, g) {
    var h = "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;if (h) switch (e.$$typeof) {case Re:
        a: {
          var v = e.key;for (h = b; null !== h;) {
            if (h.key === v) {
              if (10 === h.tag ? e.type === Ue : h.type === e.type) {
                d(a, h.sibling);b = f(h, e.type === Ue ? e.props.children : e.props, g);b.ref = We(h, e);b["return"] = a;a = b;break a;
              } else {
                d(a, h);break;
              }
            } else c(a, h);h = h.sibling;
          }e.type === Ue ? (e = pe(e.props.children, a.internalContextTag, g, e.key), e["return"] = a, a = e) : (g = oe(e, a.internalContextTag, g), g.ref = We(b, e), g["return"] = a, a = g);
        }return k(a);
      case Se:
        a: {
          for (h = e.key; null !== b;) {
            if (b.key === h) {
              if (7 === b.tag) {
                d(a, b.sibling);e = f(b, e, g);e["return"] = a;a = e;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = re(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return k(a);case Te:
        a: {
          if (null !== b) if (9 === b.tag) {
            d(a, b.sibling);b = f(b, null, g);b.type = e.value;b["return"] = a;a = b;break a;
          } else d(a, b);b = se(e, a.internalContextTag, g);b.type = e.value;b["return"] = a;a = b;
        }return k(a);case Ne:
        a: {
          for (h = e.key; null !== b;) {
            if (b.key === h) {
              if (4 === b.tag && b.stateNode.containerInfo === e.containerInfo && b.stateNode.implementation === e.implementation) {
                d(a, b.sibling);e = f(b, e.children || [], g);e["return"] = a;a = e;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = te(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return k(a);}if ("string" === typeof e || "number" === typeof e) return e = "" + e, null !== b && 6 === b.tag ? (d(a, b.sibling), e = f(b, e, g)) : (d(a, b), e = qe(e, a.internalContextTag, g)), e["return"] = a, a = e, k(a);if (Pe(e)) return T(a, b, e, g);if (Ve(e)) return I(a, b, e, g);h && Xe(a, e);if ("undefined" === typeof e) switch (a.tag) {case 2:case 1:
        e = a.type, D("152", e.displayName || e.name || "Component");}return d(a, b);
  };
}var Ze = Ye(!0, !0),
    $e = Ye(!1, !0),
    af = Ye(!1, !1);
function bf(a, b, c, d, e) {
  function f(a, b, c) {
    g(a, b, c, b.expirationTime);
  }function g(a, b, c, d) {
    b.child = null === a ? af(b, b.child, c, d) : a.child === b.child ? Ze(b, b.child, c, d) : $e(b, b.child, c, d);
  }function k(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= 128);
  }function h(a, b, c, d) {
    k(a, b);if (!c) return d && me(b, !1), n(a, b);c = b.stateNode;dd.current = b;var e = c.render();b.effectTag |= 1;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && me(b, !0);return b.child;
  }function r(a) {
    var b = a.stateNode;b.pendingContext ? je(a, b.pendingContext, b.pendingContext !== b.context) : b.context && je(a, b.context, !1);G(a, b.containerInfo);
  }function n(a, b) {
    null !== a && b.child !== a.child ? D("153") : void 0;if (null !== b.child) {
      a = b.child;var c = ne(a, a.pendingProps, a.expirationTime);b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = ne(a, a.pendingProps, a.expirationTime), c["return"] = b;
      }c.sibling = null;
    }return b.child;
  }function y(a, b) {
    switch (b.tag) {case 3:
        r(b);break;case 2:
        le(b);break;case 4:
        G(b, b.stateNode.containerInfo);}return null;
  }var u = a.shouldSetTextContent,
      x = a.useSyncScheduling,
      F = a.shouldDeprioritizeSubtree,
      L = b.pushHostContext,
      G = b.pushHostContainer,
      T = c.enterHydrationState,
      I = c.resetHydrationState,
      z = c.tryToClaimNextHydratableInstance;a = Me(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var p = a.adoptClassInstance,
      v = a.constructClassInstance,
      t = a.mountClassInstance,
      Kb = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return y(a, b);switch (b.tag) {case 0:
          null !== a ? D("155") : void 0;var d = b.type,
              e = b.pendingProps,
              g = fe(b);g = he(b, g);d = d(e, g);b.effectTag |= 1;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = 2, e = le(b), p(b, d), t(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case 1:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = n(a, b);break a;
            }d = fe(b);d = he(b, d);e = e(c, d);b.effectTag |= 1;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case 2:
          return e = le(b), d = void 0, null === a ? b.stateNode ? D("153") : (v(b, b.pendingProps), t(b, c), d = !0) : d = Kb(a, b, c), h(a, b, d, e);case 3:
          return r(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Ke(a, b, e, null, null, c), d === e ? (I(), b = n(a, b)) : (d = e.element, g = b.stateNode, (null === a || null === a.child) && g.hydrate && T(b) ? (b.effectTag |= 2, b.child = af(b, b.child, d, c)) : (I(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (I(), b = n(a, b)), b;case 5:
          L(b);null === a && z(b);e = b.type;var l = b.memoizedProps;d = b.pendingProps;null === d && (d = l, null === d ? D("154") : void 0);g = null !== a ? a.memoizedProps : null;X.current || null !== d && l !== d ? (l = d.children, u(e, d) ? l = null : g && u(e, g) && (b.effectTag |= 16), k(a, b), 2147483647 !== c && !x && F(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, l), b.memoizedProps = d, b = b.child)) : b = n(a, b);return b;case 6:
          return null === a && z(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case 8:
          b.tag = 7;case 7:
          e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null === e ? D("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;d = e.children;b.stateNode = null === a ? af(b, b.stateNode, d, c) : a.child === b.child ? Ze(b, b.stateNode, d, c) : $e(b, b.stateNode, d, c);b.memoizedProps = e;return b.stateNode;case 9:
          return null;case 4:
          a: {
            G(b, b.stateNode.containerInfo);e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null == e ? D("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = n(a, b);break a;
            }null === a ? b.child = $e(b, b.child, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case 10:
          a: {
            c = b.pendingProps;if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = n(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          D("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case 2:
          le(b);break;case 3:
          r(b);break;default:
          D("157");}b.effectTag |= 64;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (0 === b.expirationTime || b.expirationTime > c) return y(a, b);b.firstEffect = null;b.lastEffect = null;g(a, b, null, c);2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
function cf(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      k = a.finalizeInitialChildren,
      h = a.prepareUpdate,
      r = a.persistence,
      n = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      x = b.popHostContainer,
      F = c.prepareToHydrateHostInstance,
      L = c.prepareToHydrateHostTextInstance,
      G = c.popHydrationState,
      T = void 0,
      I = void 0,
      z = void 0;a.mutation ? (T = function T() {}, I = function I(a, b, c) {
    (b.updateQueue = c) && d(b);
  }, z = function z(a, b, c, e) {
    c !== e && d(b);
  }) : r ? D("235") : D("236");
  return { completeWork: function completeWork(a, b, c) {
      var p = b.pendingProps;if (null === p) p = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;switch (b.tag) {case 1:
          return null;case 2:
          return ie(b), null;case 3:
          x(b);V(X, b);V(de, b);p = b.stateNode;p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null);if (null === a || null === a.child) G(b), b.effectTag &= -3;T(b);return null;case 5:
          y(b);c = n();var v = b.type;if (null !== a && null != b.stateNode) {
            var l = a.memoizedProps,
                t = b.stateNode,
                r = u();t = h(t, v, l, p, c, r);I(a, b, t, v, l, p, c);a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!p) return null === b.stateNode ? D("166") : void 0, null;a = u();if (G(b)) F(b, c, a) && d(b);else {
              a = e(v, p, c, a, b);a: for (l = b.child; null !== l;) {
                if (5 === l.tag || 6 === l.tag) g(a, l.stateNode);else if (4 !== l.tag && null !== l.child) {
                  l.child["return"] = l;l = l.child;continue;
                }if (l === b) break;for (; null === l.sibling;) {
                  if (null === l["return"] || l["return"] === b) break a;l = l["return"];
                }l.sibling["return"] = l["return"];l = l.sibling;
              }k(a, v, p, c) && d(b);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= 128);
          }return null;case 6:
          if (a && null != b.stateNode) z(a, b, a.memoizedProps, p);else {
            if ("string" !== typeof p) return null === b.stateNode ? D("166") : void 0, null;a = n();c = u();G(b) ? L(b) && d(b) : b.stateNode = f(p, a, c, b);
          }return null;case 7:
          (p = b.memoizedProps) ? void 0 : D("165");b.tag = 8;v = [];a: for ((l = b.stateNode) && (l["return"] = b); null !== l;) {
            if (5 === l.tag || 6 === l.tag || 4 === l.tag) D("247");else if (9 === l.tag) v.push(l.type);else if (null !== l.child) {
              l.child["return"] = l;l = l.child;continue;
            }for (; null === l.sibling;) {
              if (null === l["return"] || l["return"] === b) break a;l = l["return"];
            }l.sibling["return"] = l["return"];l = l.sibling;
          }l = p.handler;p = l(p.props, v);b.child = Ze(b, null !== a ? a.child : null, p, c);return b.child;case 8:
          return b.tag = 7, null;case 9:
          return null;case 10:
          return null;case 4:
          return x(b), T(b), null;case 0:
          D("167");default:
          D("156");}
    } };
}
function df(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (v) {
      b(a, v);
    }
  }function d(a) {
    "function" === typeof ze && ze(a);switch (a.tag) {case 2:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (v) {
          b(a, v);
        }break;case 5:
        c(a);break;case 7:
        e(a.stateNode);break;case 4:
        h && g(a);}
  }function e(a) {
    for (var b = a;;) {
      if (d(b), null === b.child || h && 4 === b.tag) {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      } else b.child["return"] = b, b = b.child;
    }
  }function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? D("160") : void 0;switch (c.tag) {case 5:
              f = c.stateNode;g = !1;break a;case 3:
              f = c.stateNode.containerInfo;g = !0;break a;case 4:
              f = c.stateNode.containerInfo;g = !0;break a;}c = c["return"];
        }c = !0;
      }if (5 === b.tag || 6 === b.tag) e(b), g ? I(f, b.stateNode) : T(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];4 === b.tag && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }var k = a.getPublicInstance,
      h = a.mutation;a = a.persistence;h || (a ? D("235") : D("236"));var r = h.commitMount,
      n = h.commitUpdate,
      y = h.resetTextContent,
      u = h.commitTextUpdate,
      x = h.appendChild,
      F = h.appendChildToContainer,
      L = h.insertBefore,
      G = h.insertInContainerBefore,
      T = h.removeChild,
      I = h.removeChildFromContainer;return { commitResetTextContent: function commitResetTextContent(a) {
      y(a.stateNode);
    }, commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;break a;
          }b = b["return"];
        }D("160");c = void 0;
      }var d = b = void 0;switch (c.tag) {case 5:
          b = c.stateNode;d = !1;break;case 3:
          b = c.stateNode.containerInfo;d = !0;break;case 4:
          b = c.stateNode.containerInfo;d = !0;break;default:
          D("161");}c.effectTag & 16 && (y(b), c.effectTag &= -17);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & 2)) {
          c = c.stateNode;break a;
        }
      }for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? G(b, e.stateNode, c) : L(b, e.stateNode, c) : d ? F(b, e.stateNode) : x(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;e = e.child;continue;
        }if (e === a) break;for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;e = e["return"];
        }e.sibling["return"] = e["return"];e = e.sibling;
      }
    }, commitDeletion: function commitDeletion(a) {
      g(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case 2:
          break;case 5:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && n(c, f, e, a, d, b);
          }break;case 6:
          null === b.stateNode ? D("162") : void 0;c = b.memoizedProps;u(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case 3:
          break;default:
          D("163");}
    }, commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case 2:
          var c = b.stateNode;if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b = b.updateQueue;null !== b && Le(b, c);break;case 3:
          c = b.updateQueue;null !== c && Le(c, null !== b.child ? b.child.stateNode : null);break;case 5:
          c = b.stateNode;null === a && b.effectTag & 4 && r(c, b.type, b.memoizedProps, b);break;case 6:
          break;case 4:
          break;default:
          D("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case 5:
            b(k(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var ef = {};
function ff(a) {
  function b(a) {
    a === ef ? D("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = { current: ef },
      f = { current: ef },
      g = { current: ef };return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      V(e, a);V(f, a);V(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (V(e, a), V(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      W(g, b, a);b = d(b);W(f, a, a);W(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          k = b(e.current);
      d = c(k, a.type, d);k !== d && (W(f, a, a), W(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = ef;g.current = ef;
    } };
}
function gf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);c.type = "DELETED";c.stateNode = b;c["return"] = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case 5:
        return f(b, a.type, a.pendingProps);case 6:
        return g(b, a.pendingProps);default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent;a = a.hydration;if (!a) return { enterHydrationState: function enterHydrationState() {
      return !1;
    },
    resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      D("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      D("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      k = a.getNextHydratableSibling,
      h = a.getFirstHydratableChild,
      r = a.hydrateInstance,
      n = a.hydrateTextInstance,
      y = null,
      u = null,
      x = !1;return { enterHydrationState: function enterHydrationState(a) {
      u = h(a.stateNode.containerInfo);y = a;return x = !0;
    }, resetHydrationState: function resetHydrationState() {
      u = y = null;x = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (x) {
        var d = u;if (d) {
          if (!c(a, d)) {
            d = k(d);if (!d || !c(a, d)) {
              a.effectTag |= 2;x = !1;y = a;return;
            }b(y, u);
          }a.stateNode = d;y = a;u = h(d);
        } else a.effectTag |= 2, x = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = r(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return n(a.stateNode, a.memoizedProps, a);
    }, popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!x) return d(a), x = !0, !1;var c = a.type;if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) {
        b(a, c), c = k(c);
      }d(a);u = y ? k(a.stateNode) : null;return !0;
    } };
}
function hf(a) {
  function b(a) {
    Lb = ma = !0;var b = a.stateNode;b.current === a ? D("177") : void 0;b.isReadyForCommit = !1;dd.current = null;if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;ug();for (q = c; null !== q;) {
      var d = !1,
          e = void 0;try {
        for (; null !== q;) {
          var f = q.effectTag;f & 16 && vg(q);if (f & 128) {
            var g = q.alternate;null !== g && wg(g);
          }switch (f & -242) {case 2:
              Ge(q);q.effectTag &= -3;break;case 6:
              Ge(q);q.effectTag &= -3;He(q.alternate, q);break;case 4:
              He(q.alternate, q);break;case 8:
              Lc = !0, xg(q), Lc = !1;}q = q.nextEffect;
        }
      } catch (Mc) {
        d = !0, e = Mc;
      }d && (null === q ? D("178") : void 0, k(q, e), null !== q && (q = q.nextEffect));
    }yg();b.current = a;for (q = c; null !== q;) {
      c = !1;d = void 0;try {
        for (; null !== q;) {
          var h = q.effectTag;h & 36 && zg(q.alternate, q);h & 128 && Ag(q);if (h & 64) switch (e = q, f = void 0, null !== P && (f = P.get(e), P["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = P.get(e), P["delete"](e))), null == f ? D("184") : void 0, e.tag) {case 2:
              e.stateNode.componentDidCatch(f.error, { componentStack: f.componentStack });
              break;case 3:
              null === ba && (ba = f.error);break;default:
              D("157");}var Fa = q.nextEffect;q.nextEffect = null;q = Fa;
        }
      } catch (Mc) {
        c = !0, d = Mc;
      }c && (null === q ? D("178") : void 0, k(q, d), null !== q && (q = q.nextEffect));
    }ma = Lb = !1;"function" === typeof ye && ye(a.stateNode);fa && (fa.forEach(F), fa = null);null !== ba && (a = ba, ba = null, v(a));b = b.current.expirationTime;0 === b && (na = P = null);return b;
  }function c(a) {
    for (;;) {
      var b = ng(a.alternate, a, J),
          c = a["return"],
          d = a.sibling;var e = a;if (2147483647 === J || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }e.expirationTime = f;
      }if (null !== b) return b;null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;break;
      }
    }return null;
  }function d(a) {
    var b = w(a.alternate, a, J);null === b && (b = c(a));dd.current = null;return b;
  }function e(a) {
    var b = mg(a.alternate, a, J);null === b && (b = c(a));dd.current = null;return b;
  }function f(a) {
    if (null !== P) {
      if (!(0 === J || J > a)) if (J <= Nc) for (; null !== E;) {
        E = h(E) ? e(E) : d(E);
      } else for (; null !== E && !p();) {
        E = h(E) ? e(E) : d(E);
      }
    } else if (!(0 === J || J > a)) if (J <= Nc) for (; null !== E;) {
      E = d(E);
    } else for (; null !== E && !p();) {
      E = d(E);
    }
  }function g(a, b) {
    ma ? D("243") : void 0;ma = !0;a.isReadyForCommit = !1;if (a !== fb || b !== J || null === E) {
      for (; -1 < ce;) {
        be[ce] = null, ce--;
      }ee = C;de.current = C;X.current = !1;lg();fb = a;J = b;E = ne(fb.current, null, b);
    }var c = !1,
        d = null;try {
      f(b);
    } catch (Kc) {
      c = !0, d = Kc;
    }for (; c;) {
      if (gb) {
        ba = d;break;
      }var g = E;if (null === g) gb = !0;else {
        var h = k(g, d);null === h ? D("183") : void 0;if (!gb) {
          try {
            c = h;d = b;for (h = c; null !== g;) {
              switch (g.tag) {case 2:
                  ie(g);break;case 5:
                  l(g);break;case 3:
                  Ee(g);break;case 4:
                  Ee(g);}if (g === h || g.alternate === h) break;g = g["return"];
            }E = e(c);f(d);
          } catch (Kc) {
            c = !0;d = Kc;continue;
          }break;
        }
      }
    }b = ba;gb = ma = !1;
    ba = null;null !== b && v(b);return a.isReadyForCommit ? a.current.alternate : null;
  }function k(a, b) {
    var c = dd.current = null,
        d = !1,
        e = !1,
        f = null;if (3 === a.tag) c = a, r(a) && (gb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = ed(g), c = g, e = !0) : 3 === g.tag && (c = g);if (r(g)) {
        if (Lc || null !== fa && (fa.has(g) || null !== g.alternate && fa.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === na && (na = new Set());na.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case 0:case 1:case 2:case 5:
            var k = g._debugOwner,
                l = g._debugSource;var Fa = ed(g);var n = null;k && (n = ed(k));k = l;Fa = "\n    in " + (Fa || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");break a;default:
            Fa = "";}h += Fa;g = g["return"];
      } while (g);g = h;a = ed(a);null === P && (P = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };P.set(c, b);try {
        console.error(b.error);
      } catch (Bg) {
        console.error(Bg);
      }Lb ? (null === fa && (fa = new Set()), fa.add(c)) : F(c);return c;
    }null === ba && (ba = b);return null;
  }function h(a) {
    return null !== P && (P.has(a) || null !== a.alternate && P.has(a.alternate));
  }function r(a) {
    return null !== na && (na.has(a) || null !== a.alternate && na.has(a.alternate));
  }function n() {
    return 20 * (((L() + 100) / 20 | 0) + 1);
  }function y(a) {
    return 0 !== ja ? ja : ma ? Lb ? 1 : J : !Cg || a.internalContextTag & 1 ? n() : 1;
  }function u(a, b) {
    return x(a, b, !1);
  }function x(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;!ma && c === fb && b <= J && (E = fb = null, J = 0);var d = b;Mb > Dg && D("185");if (null === c.nextScheduledRoot) c.remainingExpirationTime = d, null === M ? (oa = M = c, c.nextScheduledRoot = c) : (M = M.nextScheduledRoot = c, M.nextScheduledRoot = oa);else {
          var e = c.remainingExpirationTime;if (0 === e || d < e) c.remainingExpirationTime = d;
        }Ga || (ka ? Nb && z(c, 1) : 1 === d ? I(1, null) : hb || (hb = !0, Ie(T)));
      } else break;a = a["return"];
    }
  }function F(a) {
    x(a, 1, !0);
  }function L() {
    return Nc = ((Je() - Eg) / 10 | 0) + 2;
  }function G() {
    var a = 0,
        b = null;if (null !== M) for (var c = M, d = oa; null !== d;) {
      var e = d.remainingExpirationTime;if (0 === e) {
        null === c || null === M ? D("244") : void 0;if (d === d.nextScheduledRoot) {
          oa = M = d.nextScheduledRoot = null;break;
        } else if (d === oa) oa = e = d.nextScheduledRoot, M.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === M) {
          M = c;M.nextScheduledRoot = oa;d.nextScheduledRoot = null;break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;if (d === M) break;c = d;d = d.nextScheduledRoot;
      }
    }c = pa;null !== c && c === b ? Mb++ : Mb = 0;pa = b;Ob = a;
  }function T(a) {
    I(0, a);
  }function I(a, b) {
    ib = b;for (G(); null !== pa && 0 !== Ob && (0 === a || Ob <= a) && !Oc;) {
      z(pa, Ob), G();
    }null !== ib && (hb = !1);null === pa || hb || (hb = !0, Ie(T));ib = null;Oc = !1;Mb = 0;if (Pb) throw a = Pc, Pc = null, Pb = !1, a;
  }function z(a, c) {
    Ga ? D("245") : void 0;Ga = !0;if (c <= L()) {
      var d = a.finishedWork;null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (p() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));Ga = !1;
  }function p() {
    return null === ib || ib.timeRemaining() > Fg ? !1 : Oc = !0;
  }function v(a) {
    null === pa ? D("246") : void 0;pa.remainingExpirationTime = 0;Pb || (Pb = !0, Pc = a);
  }var t = ff(a),
      Kb = gf(a),
      Ee = t.popHostContainer,
      l = t.popHostContext,
      lg = t.resetHostContainer,
      Fe = bf(a, t, Kb, u, y),
      w = Fe.beginWork,
      mg = Fe.beginFailedWork,
      ng = cf(a, t, Kb).completeWork;
  t = df(a, k);var vg = t.commitResetTextContent,
      Ge = t.commitPlacement,
      xg = t.commitDeletion,
      He = t.commitWork,
      zg = t.commitLifeCycles,
      Ag = t.commitAttachRef,
      wg = t.commitDetachRef,
      Je = a.now,
      Ie = a.scheduleDeferredCallback,
      Cg = a.useSyncScheduling,
      ug = a.prepareForCommit,
      yg = a.resetAfterCommit,
      Eg = Je(),
      Nc = 2,
      ja = 0,
      ma = !1,
      E = null,
      fb = null,
      J = 0,
      q = null,
      P = null,
      na = null,
      fa = null,
      ba = null,
      gb = !1,
      Lb = !1,
      Lc = !1,
      oa = null,
      M = null,
      hb = !1,
      Ga = !1,
      pa = null,
      Ob = 0,
      Oc = !1,
      Pb = !1,
      Pc = null,
      ib = null,
      ka = !1,
      Nb = !1,
      Dg = 1E3,
      Mb = 0,
      Fg = 1;return { computeAsyncExpiration: n, computeExpirationForFiber: y,
    scheduleWork: u, batchedUpdates: function batchedUpdates(a, b) {
      var c = ka;ka = !0;try {
        return a(b);
      } finally {
        (ka = c) || Ga || I(1, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      if (ka && !Nb) {
        Nb = !0;try {
          return a();
        } finally {
          Nb = !1;
        }
      }return a();
    }, flushSync: function flushSync(a) {
      var b = ka;ka = !0;try {
        a: {
          var c = ja;ja = 1;try {
            var d = a();break a;
          } finally {
            ja = c;
          }d = void 0;
        }return d;
      } finally {
        ka = b, Ga ? D("187") : void 0, I(1, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = ja;ja = n();try {
        return a();
      } finally {
        ja = b;
      }
    } };
}
function jf(a) {
  function b(a) {
    a = jd(a);return null === a ? null : a.stateNode;
  }var c = a.getPublicInstance;a = hf(a);var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;return { createContainer: function createContainer(a, b) {
      var c = new Y(3, null, 0);a = { current: c, containerInfo: a, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: b, nextScheduledRoot: null };return c.stateNode = a;
    }, updateContainer: function updateContainer(a, b, c, r) {
      var g = b.current;if (c) {
        c = c._reactInternalFiber;var h;b: {
          2 === fd(c) && 2 === c.tag ? void 0 : D("170");for (h = c; 3 !== h.tag;) {
            if (ge(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }(h = h["return"]) ? void 0 : D("171");
          }h = h.stateNode.context;
        }c = ge(c) ? ke(c, h) : h;
      } else c = C;null === b.context ? b.context = c : b.pendingContext = c;b = r;b = void 0 === b ? null : b;r = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);Ce(g, { expirationTime: r, partialState: { element: a }, callback: b, isReplace: !1, isForced: !1,
        nextCallback: null, next: null });f(g, r);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
          return c(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: b, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = kd(a);return null === a ? null : a.stateNode;
    }, injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;return xe(A({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        }, findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        } }));
    } };
}var kf = Object.freeze({ default: jf }),
    lf = kf && jf || kf,
    mf = lf["default"] ? lf["default"] : lf,
    nf = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    of = void 0;of = nf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};var pf = void 0;
if (m.canUseDOM) {
  if ("function" !== typeof requestIdleCallback) {
    var qf = null,
        rf = !1,
        sf = !1,
        tf = 0,
        uf = 33,
        vf = 33,
        wf;wf = nf ? { timeRemaining: function timeRemaining() {
        return tf - performance.now();
      } } : { timeRemaining: function timeRemaining() {
        return tf - Date.now();
      } };var xf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      a.source === window && a.data === xf && (rf = !1, a = qf, qf = null, null !== a && a(wf));
    }, !1);var yf = function yf(a) {
      sf = !1;var b = a - tf + vf;b < vf && uf < vf ? (8 > b && (b = 8), vf = b < uf ? uf : b) : uf = b;tf = a + vf;rf || (rf = !0, window.postMessage(xf, "*"));
    };pf = function pf(a) {
      qf = a;sf || (sf = !0, requestAnimationFrame(yf));return 0;
    };
  } else pf = requestIdleCallback;
} else pf = function pf(a) {
  setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });return 0;
};
var zf = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Af = {},
    Bf = {};function Cf(a) {
  if (Bf.hasOwnProperty(a)) return !0;if (Af.hasOwnProperty(a)) return !1;if (zf.test(a)) return Bf[a] = !0;Af[a] = !0;return !1;
}
function Df(a, b, c) {
  var d = ua(b);if (d && ta(b, c)) {
    var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Ef(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Ff(a, b, ta(b, c) ? c : null);
}
function Ff(a, b, c) {
  Cf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}function Ef(a, b) {
  var c = ua(b);c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}
function Gf(a, b) {
  var c = b.value,
      d = b.checked;return A({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
}function Hf(a, b) {
  var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function If(a, b) {
  var c = b.checked;null != c && Df(a, "checked", c || !1);c = b.value;if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Jf(a, b) {
  switch (b.type) {case "submit":case "reset":
      break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
      a.value = "";a.value = a.defaultValue;break;default:
      a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
}function Kf(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}
function Lf(a, b) {
  a = A({ children: void 0 }, b);if (b = Kf(b.children)) a.children = b;return a;
}function Mf(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + c;b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function Nf(a, b) {
  var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
}function Of(a, b) {
  null != b.dangerouslySetInnerHTML ? D("91") : void 0;return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function Pf(a, b) {
  var c = b.value,
      d = c;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? D("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : D("93"), b = b[0]), c = "" + b), null == c && (c = ""), d = c);a._wrapperState = { initialValue: "" + d };
}
function Qf(a, b) {
  var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
}function Rf(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var Sf = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Tf(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function Uf(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Tf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var Vf = void 0,
    Wf = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Sf.svg || "innerHTML" in a) a.innerHTML = b;else {
    Vf = Vf || document.createElement("div");Vf.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";for (b = Vf.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
}),
    Xf = /["'&<>]/;
function Yf(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
m.canUseDOM && ("textContent" in document.documentElement || (Yf = function Yf(a, b) {
  if (3 === a.nodeType) a.nodeValue = b;else {
    if ("boolean" === typeof b || "number" === typeof b) b = "" + b;else {
      b = "" + b;var c = Xf.exec(b);if (c) {
        var d = "",
            e,
            f = 0;for (e = c.index; e < b.length; e++) {
          switch (b.charCodeAt(e)) {case 34:
              c = "\x26quot;";break;case 38:
              c = "\x26amp;";break;case 39:
              c = "\x26#x27;";break;case 60:
              c = "\x26lt;";break;case 62:
              c = "\x26gt;";break;default:
              continue;}f !== e && (d += b.substring(f, e));f = e + 1;d += c;
        }b = f !== e ? d + b.substring(f, e) : d;
      }
    }Wf(a, b);
  }
}));
var Zf = Yf,
    $f = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0,
  floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    ag = ["Webkit", "ms", "Moz", "O"];Object.keys($f).forEach(function (a) {
  ag.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);$f[b] = $f[a];
  });
});
function bg(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || $f.hasOwnProperty(e) && $f[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var cg = A({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function dg(a, b, c) {
  b && (cg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? D("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? D("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : D("61")), null != b.style && "object" !== _typeof(b.style) ? D("62", c()) : void 0);
}
function eg(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}var fg = Sf.html,
    gg = B.thatReturns("");
function hg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Cd(a);b = Qa[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];c.hasOwnProperty(e) && c[e] || ("topWheel" === e ? xc("wheel") ? U("topWheel", "wheel", a) : xc("mousewheel") ? U("topWheel", "mousewheel", a) : U("topWheel", "DOMMouseScroll", a) : "topScroll" === e ? rd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (rd("topFocus", "focus", a), rd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (xc("cancel", !0) && rd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (xc("close", !0) && rd("topClose", "close", a), c.topClose = !0) : yd.hasOwnProperty(e) && U(e, yd[e], a), c[e] = !0);
  }
}
var ig = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" };function jg(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;d === fg && (d = Tf(a));d === fg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
}function kg(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}
function og(a, b, c, d) {
  var e = eg(b, c);switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);var f = c;break;case "video":case "audio":
      for (f in ig) {
        ig.hasOwnProperty(f) && U(f, ig[f], a);
      }f = c;break;case "source":
      U("topError", "error", a);f = c;break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);f = c;break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);f = c;break;case "details":
      U("topToggle", "toggle", a);f = c;break;case "input":
      Hf(a, c);f = Gf(a, c);U("topInvalid", "invalid", a);
      hg(d, "onChange");break;case "option":
      f = Lf(a, c);break;case "select":
      Nf(a, c);f = A({}, c, { value: void 0 });U("topInvalid", "invalid", a);hg(d, "onChange");break;case "textarea":
      Pf(a, c);f = Of(a, c);U("topInvalid", "invalid", a);hg(d, "onChange");break;default:
      f = c;}dg(b, f, gg);var g = f,
      k;for (k in g) {
    if (g.hasOwnProperty(k)) {
      var h = g[k];"style" === k ? bg(a, h, gg) : "dangerouslySetInnerHTML" === k ? (h = h ? h.__html : void 0, null != h && Wf(a, h)) : "children" === k ? "string" === typeof h ? ("textarea" !== b || "" !== h) && Zf(a, h) : "number" === typeof h && Zf(a, "" + h) : "suppressContentEditableWarning" !== k && "suppressHydrationWarning" !== k && "autoFocus" !== k && (Pa.hasOwnProperty(k) ? null != h && hg(d, k) : e ? Ff(a, k, h) : null != h && Df(a, k, h));
    }
  }switch (b) {case "input":
      Ac(a);Jf(a, c);break;case "textarea":
      Ac(a);Rf(a, c);break;case "option":
      null != c.value && a.setAttribute("value", c.value);break;case "select":
      a.multiple = !!c.multiple;b = c.value;null != b ? Mf(a, !!c.multiple, b, !1) : null != c.defaultValue && Mf(a, !!c.multiple, c.defaultValue, !0);break;default:
      "function" === typeof f.onClick && (a.onclick = B);}
}
function pg(a, b, c, d, e) {
  var f = null;switch (b) {case "input":
      c = Gf(a, c);d = Gf(a, d);f = [];break;case "option":
      c = Lf(a, c);d = Lf(a, d);f = [];break;case "select":
      c = A({}, c, { value: void 0 });d = A({}, d, { value: void 0 });f = [];break;case "textarea":
      c = Of(a, c);d = Of(a, d);f = [];break;default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = B);}dg(b, d, gg);var g, k;a = null;for (g in c) {
    if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (k in b = c[g], b) {
      b.hasOwnProperty(k) && (a || (a = {}), a[k] = "");
    } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Pa.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
  }for (g in d) {
    var h = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && h !== b && (null != h || null != b)) if ("style" === g) {
      if (b) {
        for (k in b) {
          !b.hasOwnProperty(k) || h && h.hasOwnProperty(k) || (a || (a = {}), a[k] = "");
        }for (k in h) {
          h.hasOwnProperty(k) && b[k] !== h[k] && (a || (a = {}), a[k] = h[k]);
        }
      } else a || (f || (f = []), f.push(g, a)), a = h;
    } else "dangerouslySetInnerHTML" === g ? (h = h ? h.__html : void 0, b = b ? b.__html : void 0, null != h && b !== h && (f = f || []).push(g, "" + h)) : "children" === g ? b === h || "string" !== typeof h && "number" !== typeof h || (f = f || []).push(g, "" + h) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Pa.hasOwnProperty(g) ? (null != h && hg(e, g), f || b === h || (f = [])) : (f = f || []).push(g, h));
  }a && (f = f || []).push("style", a);return f;
}
function qg(a, b, c, d, e) {
  eg(c, d);d = eg(c, e);for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        k = b[f + 1];"style" === g ? bg(a, k, gg) : "dangerouslySetInnerHTML" === g ? Wf(a, k) : "children" === g ? Zf(a, k) : d ? null != k ? Ff(a, g, k) : a.removeAttribute(g) : null != k ? Df(a, g, k) : Ef(a, g);
  }switch (c) {case "input":
      If(a, e);Bc(a);break;case "textarea":
      Qf(a, e);break;case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Mf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Mf(a, !!e.multiple, e.defaultValue, !0) : Mf(a, !!e.multiple, e.multiple ? [] : "", !1));}
}
function rg(a, b, c, d, e) {
  switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);break;case "video":case "audio":
      for (var f in ig) {
        ig.hasOwnProperty(f) && U(f, ig[f], a);
      }break;case "source":
      U("topError", "error", a);break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);break;case "details":
      U("topToggle", "toggle", a);break;case "input":
      Hf(a, c);U("topInvalid", "invalid", a);hg(e, "onChange");break;case "select":
      Nf(a, c);
      U("topInvalid", "invalid", a);hg(e, "onChange");break;case "textarea":
      Pf(a, c), U("topInvalid", "invalid", a), hg(e, "onChange");}dg(b, c, gg);d = null;for (var g in c) {
    c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Pa.hasOwnProperty(g) && null != f && hg(e, g));
  }switch (b) {case "input":
      Ac(a);Jf(a, c);break;case "textarea":
      Ac(a);Rf(a, c);break;case "select":case "option":
      break;default:
      "function" === typeof c.onClick && (a.onclick = B);}return d;
}function sg(a, b) {
  return a.nodeValue !== b;
}
var tg = Object.freeze({ createElement: jg, createTextNode: kg, setInitialProperties: og, diffProperties: pg, updateProperties: qg, diffHydratedProperties: rg, diffHydratedText: sg, warnForUnmatchedText: function warnForUnmatchedText() {}, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        If(a, c);b = c.name;if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) {
            c = c.parentNode;
          }c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
            var d = c[b];if (d !== a && d.form === a.form) {
              var e = rb(d);e ? void 0 : D("90");If(d, e);
            }
          }
        }break;case "textarea":
        Qf(a, c);break;case "select":
        b = c.value, null != b && Mf(a, !!c.multiple, b, !1);}
  } });mc.injectFiberControlledHostComponent(tg);var Gg = null,
    Hg = null;function Ig(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function Jg(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}
var Z = mf({ getRootHostContext: function getRootHostContext(a) {
    var b = a.nodeType;switch (b) {case 9:case 11:
        a = (a = a.documentElement) ? a.namespaceURI : Uf(null, "");break;default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = Uf(a, b);}return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return Uf(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    Gg = od;var a = da();if (Fd(a)) {
      if ("selectionStart" in a) var b = { start: a.selectionStart, end: a.selectionEnd };else a: {
        var c = window.getSelection && window.getSelection();
        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;var d = c.anchorOffset,
              e = c.focusNode;c = c.focusOffset;try {
            b.nodeType, e.nodeType;
          } catch (x) {
            b = null;break a;
          }var f = 0,
              g = -1,
              k = -1,
              h = 0,
              r = 0,
              n = a,
              y = null;b: for (;;) {
            for (var u;;) {
              n !== b || 0 !== d && 3 !== n.nodeType || (g = f + d);n !== e || 0 !== c && 3 !== n.nodeType || (k = f + c);3 === n.nodeType && (f += n.nodeValue.length);if (null === (u = n.firstChild)) break;y = n;n = u;
            }for (;;) {
              if (n === a) break b;y === b && ++h === d && (g = f);y === e && ++r === c && (k = f);if (null !== (u = n.nextSibling)) break;n = y;y = n.parentNode;
            }n = u;
          }b = -1 === g || -1 === k ? null : { start: g, end: k };
        } else b = null;
      }b = b || { start: 0, end: 0 };
    } else b = null;Hg = { focusedElem: a, selectionRange: b };pd(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    var a = Hg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;if (b !== c && ha(document.documentElement, c)) {
      if (Fd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();var e = c[Db()].length;a = Math.min(d.start, e);d = void 0 === d.end ? a : Math.min(d.end, e);!b.extend && a > d && (e = d, d = a, a = e);e = Ed(c, a);var f = Ed(c, d);if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();g.setStart(e.node, e.offset);b.removeAllRanges();a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }b = [];for (a = c; a = a.parentNode;) {
        1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ia(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }Hg = null;pd(Gg);Gg = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = jg(a, b, c, d);a[O] = e;a[ob] = b;return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    og(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return pg(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = kg(a, b);a[O] = d;return a;
  }, now: of, mutation: { commitMount: function commitMount(a) {
      a.focus();
    }, commitUpdate: function commitUpdate(a, b, c, d, e) {
      a[ob] = e;qg(a, b, c, d, e);
    }, resetTextContent: function resetTextContent(a) {
      a.textContent = "";
    }, commitTextUpdate: function commitTextUpdate(a, b, c) {
      a.nodeValue = c;
    }, appendChild: function appendChild(a, b) {
      a.appendChild(b);
    }, appendChildToContainer: function appendChildToContainer(a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    }, insertBefore: function insertBefore(a, b, c) {
      a.insertBefore(b, c);
    }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    }, removeChild: function removeChild(a, b) {
      a.removeChild(b);
    }, removeChildFromContainer: function removeChildFromContainer(a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    } }, hydration: { canHydrateInstance: function canHydrateInstance(a, b) {
      return 1 === a.nodeType && b.toLowerCase() === a.nodeName.toLowerCase();
    }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
      return "" === b ? !1 : 3 === a.nodeType;
    }, getNextHydratableSibling: function getNextHydratableSibling(a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, getFirstHydratableChild: function getFirstHydratableChild(a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
      a[O] = f;a[ob] = c;return rg(a, b, c, e, d);
    }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
      a[O] = c;return sg(a, b);
    }, didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance() {},
    didNotHydrateContainerInstance: function didNotHydrateContainerInstance() {}, didNotHydrateInstance: function didNotHydrateInstance() {}, didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance: function didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance() {} }, scheduleDeferredCallback: pf, useSyncScheduling: !0 });qc = Z.batchedUpdates;
function Kg(a, b, c, d, e) {
  Ig(c) ? void 0 : D("200");var f = c._reactRootContainer;if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Jg(c);if (!d) for (f = void 0; f = c.lastChild;) {
      c.removeChild(f);
    }var g = Z.createContainer(c, d);f = c._reactRootContainer = g;Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }return Z.getPublicRootInstance(f);
}function Lg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Ig(b) ? void 0 : D("200");return Oe(a, b, null, c);
}
function Mg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}Mg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};Mg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};
var Ng = { createPortal: Lg, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;if (b) return Z.findHostInstance(b);"function" === typeof a.render ? D("188") : D("213", Object.keys(a));
  }, hydrate: function hydrate(a, b, c) {
    return Kg(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Kg(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? D("38") : void 0;return Kg(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Ig(a) ? void 0 : D("40");return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Kg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: Lg, unstable_batchedUpdates: sc, unstable_deferredUpdates: Z.deferredUpdates, flushSync: Z.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: mb, EventPluginRegistry: Ta, EventPropagators: Bb, ReactControlledComponent: pc, ReactDOMComponentTree: sb, ReactDOMEventListener: sd } };
Z.injectIntoDevTools({ findFiberByHostInstance: pb, bundleType: 0, version: "16.1.0", rendererPackageName: "react-dom" });var Og = Object.freeze({ default: Ng }),
    Pg = Og && Ng || Og;module.exports = Pg["default"] ? Pg["default"] : Pg;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(29);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.1.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(0);var invariant=__webpack_require__(5);var warning=__webpack_require__(7);var ExecutionEnvironment=__webpack_require__(12);var _assign=__webpack_require__(4);var emptyFunction$1=__webpack_require__(3);var EventListener=__webpack_require__(13);var getActiveElement=__webpack_require__(14);var shallowEqual=__webpack_require__(15);var containsNode=__webpack_require__(16);var focusNode=__webpack_require__(17);var emptyObject=__webpack_require__(6);var checkPropTypes=__webpack_require__(8);var hyphenateStyleName=__webpack_require__(31);var camelizeStyleName=__webpack_require__(33);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,autoFocus:HAS_STRING_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// autoFocus is polyfilled/normalized by AutoFocusUtils
// autoFocus: HAS_BOOLEAN_VALUE,
autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction$1.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction$1.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction$1.thatReturnsFalse;}this.isPropagationStopped=emptyFunction$1.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction$1.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction$1.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction$1.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction$1.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction$1));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction$1));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topWheel'){if(isEventSupported('wheel')){trapBubbledEvent('topWheel','wheel',mountAt);}else if(isEventSupported('mousewheel')){trapBubbledEvent('topWheel','mousewheel',mountAt);}else{// Firefox needs to capture a different mouse scroll event.
// @see http://www.quirksmode.org/dom/events/tests/scroll.html
trapBubbledEvent('topWheel','DOMMouseScroll',mountAt);}}else if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode;var anchorOffset=selection.anchorOffset;var focusNode$$1=selection.focusNode;var focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports React.Fragment
var enableReactFragment=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){invariant(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){!(_typeof(workInProgress.type.childContextTypes)==='object')?invariant(false,'%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',getComponentName(workInProgress)):void 0;}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the special React types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_PORTAL_TYPE=typeof Symbol==='function'&&Symbol['for']&&Symbol['for']('react.portal')||0xeaca;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;var ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';// Before Symbol spec.
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE;var REACT_CALL_TYPE;var REACT_RETURN_TYPE;var REACT_FRAGMENT_TYPE;if(typeof Symbol==='function'&&Symbol['for']){REACT_ELEMENT_TYPE=Symbol['for']('react.element');REACT_CALL_TYPE=Symbol['for']('react.call');REACT_RETURN_TYPE=Symbol['for']('react.return');REACT_FRAGMENT_TYPE=Symbol['for']('react.fragment');}else{REACT_ELEMENT_TYPE=0xeac7;REACT_CALL_TYPE=0xeac8;REACT_RETURN_TYPE=0xeac9;REACT_FRAGMENT_TYPE=0xeacb;}function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var iteratorFn=ITERATOR_SYMBOL&&maybeIterable[ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof iteratorFn==='function'){return iteratorFn;}return null;}function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldClone,shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}if(!shouldClone){// When we're reconciling in place we have a work in progress copy. We
// actually want the current copy. If there is no current copy, then we
// don't need to track deletion side-effects.
if(childToDelete.alternate===null){return;}childToDelete=childToDelete.alternate;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
if(shouldClone){var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}else{// We override the expiration time even if it is earlier, because if
// we're reconciling at a later time that means that this was
// down-prioritized.
fiber.expirationTime=expirationTime;fiber.effectTag=NoEffect;fiber.index=0;fiber.sibling=null;fiber.pendingProps=pendingProps;return fiber;}}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if(enableReactFragment&&(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true,true);var reconcileChildFibersInPlace=ChildReconciler(false,true);var mountChildFibersInPlace=ChildReconciler(false,false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}else if(current.child===workInProgress.child){// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}else{// If, on the other hand, it is already using a clone, that means we've
// already begun some work on this tree and we can continue where we left
// off by reconciling against the existing children.
workInProgress.child=reconcileChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibersInPlace(workInProgress,workInProgress.child,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibersInPlace(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else if(current.child===workInProgress.child){workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibersInPlace(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work — work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function canHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;return canHydrateInstance(nextInstance,type,props);}case HostText:{var text=fiber.pendingProps;return canHydrateTextInstance(nextInstance,text);}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!canHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!canHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}fiber.stateNode=nextInstance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary -— we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
console.error(e);}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;if(!isWorking&&root===nextRoot&&expirationTime<=nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}requestWork(root,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var isCallbackScheduled=false;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
performWorkOnRoot(root,Sync);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else if(!isCallbackScheduled){isCallbackScheduled=true;scheduleDeferredCallback(performAsyncWork);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadlne.
findHighestPriorityRoot();while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){isCallbackScheduled=false;}// If there's work left over, schedule a new callback.
if(nextFlushedRoot!==null&&!isCallbackScheduled){isCallbackScheduled=true;scheduleDeferredCallback(performAsyncWork);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;// TODO: this is special because it gets imported during build.
var ReactVersion='16.1.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});return 0;};}else if(typeof requestIdleCallback!=='function'){// Polyfill requestIdleCallback.
var scheduledRICCallback=null;var isIdleScheduled=false;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
return frameDeadline-performance.now();}};}else{frameDeadlineObject={timeRemaining:function timeRemaining(){// Fallback to Date.now()
return frameDeadline-Date.now();}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};}else{rIC=requestIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked||false);}var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var value=props.value;var initialValue=value;// Only bother fetching default value if we're going to use it
if(value==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */var matchHtmlRegExp=/["'&<>]/;/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */function escapeHtml(string){var str=''+string;var match=matchHtmlRegExp.exec(str);if(!match){return str;}var escape;var html='';var index=0;var lastIndex=0;for(index=match.index;index<str.length;index++){switch(str.charCodeAt(index)){case 34:// "
escape='&quot;';break;case 38:// &
escape='&amp;';break;case 39:// '
escape='&#x27;';// modified from escape-html; used to be '&#39'
break;case 60:// <
escape='&lt;';break;case 62:// >
escape='&gt;';break;default:continue;}if(lastIndex!==index){html+=str.substring(lastIndex,index);}lastIndex=index+1;html+=escape;}return lastIndex!==index?html+str.substring(lastIndex,index):html;}// end code copied and modified from escape-html
/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */function escapeTextContentForBrowser(text){if(typeof text==='boolean'||typeof text==='number'){// this shortcircuit helps perf for types that we know will never have
// special characters, especially given that this function is used often
// for numeric dom ids.
return''+text;}return escapeHtml(text);}/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};if(ExecutionEnvironment.canUseDOM){if(!('textContent'in document.documentElement)){setTextContent=function setTextContent(node,text){if(node.nodeType===TEXT_NODE){node.nodeValue=text;return;}setInnerHTML(node,escapeTextContentForBrowser(text));};}}var setTextContent$1=setTextContent;/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction$1;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on[A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}if(registrationNameModules.hasOwnProperty(name)){return true;}if(plugins.length===0&&EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we might be in a server environment.
// Don't check events in this case.
return true;}var lowerCasedName=name.toLowerCase();var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(lowerCasedName.indexOf('on')===0&&lowerCasedName.length>2){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key]);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction$1.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction$1;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent$1(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent$1(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent$1(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);// We also check that we haven't missed a value update, such as a
// Radio group shifting the checked value to another named radio input.
updateValueIfChanged(domElement);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction$1;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){return instance.nodeType===ELEMENT_NODE&&type.toLowerCase()===instance.nodeName.toLowerCase();},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''){// Empty strings are not parsed by HTML so there won't be a correct match here.
return false;}return instance.nodeType===TEXT_NODE;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(32);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(34);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _axios = __webpack_require__(36);

var _axios2 = _interopRequireDefault(_axios);

var _basicinfo = __webpack_require__(55);

var _basicinfo2 = _interopRequireDefault(_basicinfo);

var _bio = __webpack_require__(56);

var _bio2 = _interopRequireDefault(_bio);

var _techskills = __webpack_require__(57);

var _techskills2 = _interopRequireDefault(_techskills);

var _experience = __webpack_require__(59);

var _experience2 = _interopRequireDefault(_experience);

var _projects = __webpack_require__(61);

var _projects2 = _interopRequireDefault(_projects);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.state = {
      data: {}
    };

    _this.loadCommentsFromServer = _this.loadCommentsFromServer.bind(_this);

    return _this;
  }

  _createClass(App, [{
    key: 'loadCommentsFromServer',
    value: function loadCommentsFromServer() {
      var _this2 = this;

      _axios2.default.get(this.props.url).then(function (res) {
        _this2.setState({ data: res.data[0] });
      });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.loadCommentsFromServer();
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wrapper' },
        _react2.default.createElement(_basicinfo2.default, { info: this.state.data.basicinfo }),
        _react2.default.createElement(_bio2.default, { info: this.state.data.bio }),
        _react2.default.createElement(_techskills2.default, { info: this.state.data.skills }),
        _react2.default.createElement(_experience2.default, { info: this.state.data.experience }),
        _react2.default.createElement(_projects2.default, null)
      );
    }
  }]);

  return App;
}(_react.Component);

exports.default = App;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(37);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);
var bind = __webpack_require__(18);
var Axios = __webpack_require__(39);
var defaults = __webpack_require__(11);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(22);
axios.CancelToken = __webpack_require__(53);
axios.isCancel = __webpack_require__(21);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(54);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(11);
var utils = __webpack_require__(2);
var InterceptorManager = __webpack_require__(48);
var dispatchRequest = __webpack_require__(49);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(20);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);
var transformData = __webpack_require__(50);
var isCancel = __webpack_require__(21);
var defaults = __webpack_require__(11);
var isAbsoluteURL = __webpack_require__(51);
var combineURLs = __webpack_require__(52);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(22);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BasicInfo = function BasicInfo(props) {

  if (!props.info) {
    return _react2.default.createElement(
      "div",
      null,
      "Loading ",
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  $(function () {
    $('[data-toggle="tooltip"]').tooltip({
      html: true
    });
  });

  var tooltipText = "This CV has been build with MongoDB, Express, React and Node";

  return _react2.default.createElement(
    "div",
    { className: "component-container" },
    _react2.default.createElement(
      "a",
      { href: "/docs/Max__Golubev_CV.docx", className: "download-icon", "data-toggle": "tooltip", "data-placement": "left", title: "download cv.docx" },
      _react2.default.createElement("i", { className: "fa fa-download fa-2x", "aria-hidden": "true" })
    ),
    _react2.default.createElement(
      "a",
      { className: "info", href: "https://github.com/MaxGol/CV_HEROKU", "data-toggle": "tooltip", "data-placement": "left", title: tooltipText },
      _react2.default.createElement("span", { className: "fa fa-2x fa-github" })
    ),
    _react2.default.createElement(
      "div",
      { className: "row" },
      _react2.default.createElement(
        "div",
        { className: "col-xs-12" },
        _react2.default.createElement("img", { src: "/images/max.png", className: "img-circle center-block" }),
        _react2.default.createElement(
          "h4",
          { className: "text-center" },
          props.info.name
        ),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.title
          )
        ),
        _react2.default.createElement("hr", { className: "small-divider" }),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.address
          )
        ),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.email
          )
        ),
        _react2.default.createElement("hr", { className: "small-divider" }),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            "07739 365430"
          )
        )
      )
    )
  );
};

exports.default = BasicInfo;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Bio = function Bio(props) {

  if (!props.info) {
    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  return _react2.default.createElement(
    "div",
    { className: "component-container" },
    _react2.default.createElement(
      "div",
      { className: "row" },
      _react2.default.createElement(
        "div",
        { className: "col-xs-12" },
        _react2.default.createElement(
          "h4",
          { className: "section-title" },
          props.info.title
        ),
        _react2.default.createElement("hr", { className: "normal-divider" }),
        _react2.default.createElement(
          "p",
          null,
          props.info.about_me
        )
      )
    )
  );
};

exports.default = Bio;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _skillslist = __webpack_require__(58);

var _skillslist2 = _interopRequireDefault(_skillslist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TechSkills = function TechSkills(props) {

  if (!props.info) {
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('i', { className: 'fa fa-spinner fa-spin', 'aria-hidden': 'true' })
    );
  }

  var skillList = Object.keys(props.info.skills_stack).map(function (skillname, index) {
    return _react2.default.createElement(_skillslist2.default, { key: index, name: skillname, skills: props.info.skills_stack[skillname] });
  });

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          props.info.title
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' }),
        skillList
      )
    )
  );
};

exports.default = TechSkills;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SkillsList = function SkillsList(props) {

  if (!props.skills) {
    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  var skillsItems = props.skills.map(function (item) {
    if (props.skills.indexOf(item) === props.skills.length - 1) {
      return item;
    } else {
      return item + ', ';
    }
  });

  return _react2.default.createElement(
    "div",
    { className: "row" },
    _react2.default.createElement(
      "div",
      { className: "col-sm-2 text-right" },
      _react2.default.createElement(
        "strong",
        null,
        props.name,
        ":"
      )
    ),
    _react2.default.createElement(
      "div",
      { className: "col-sm-10" },
      skillsItems
    )
  );
};

exports.default = SkillsList;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _experienselist = __webpack_require__(60);

var _experienselist2 = _interopRequireDefault(_experienselist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Experience = function Experience(props) {

  if (!props.info) {
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('i', { className: 'fa fa-spinner fa-spin', 'aria-hidden': 'true' })
    );
  }

  var experienceListItem = props.info.work.map(function (item, index) {
    return _react2.default.createElement(_experienselist2.default, { key: index, work: item });
  });

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          props.info.title
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' }),
        experienceListItem
      )
    )
  );
};

exports.default = Experience;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ExperienceItem = function ExperienceItem(props) {

  var duty = props.work.duty.map(function (itemduty, index) {
    return _react2.default.createElement(
      "li",
      { key: index },
      itemduty
    );
  });

  return _react2.default.createElement(
    "div",
    { className: "row work-info" },
    _react2.default.createElement(
      "div",
      { className: "col-xs-12" },
      _react2.default.createElement(
        "h4",
        null,
        props.work.company,
        _react2.default.createElement(
          "span",
          { className: "pull-right" },
          props.work.time
        )
      ),
      _react2.default.createElement(
        "p",
        null,
        props.work.overview
      ),
      _react2.default.createElement(
        "h5",
        null,
        _react2.default.createElement(
          "strong",
          null,
          props.work.jobtitle
        )
      ),
      _react2.default.createElement(
        "ul",
        null,
        duty
      )
    )
  );
};

exports.default = ExperienceItem;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactOwlCarousel = __webpack_require__(62);

var _reactOwlCarousel2 = _interopRequireDefault(_reactOwlCarousel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Projects = function Projects(props) {

  var options = {
    items: 4,
    nav: true,
    rewind: true,
    responsive: {
      0: {
        items: 1,
        nav: true
      },
      600: {
        items: 3,
        nav: true
      },
      1000: {
        items: 4,
        nav: true
      }
    }
  };

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          'Project'
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' })
      ),
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          _reactOwlCarousel2.default,
          { options: options },
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/home', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Lemonade',
                  _react2.default.createElement('br', null),
                  ' Money'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonadereward.com', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Lemonade',
                  _react2.default.createElement('br', null),
                  ' Reward'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/budget/income', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Budget',
                  _react2.default.createElement('br', null),
                  ' Calculator'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/financial-health-check/income', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Financial',
                  _react2.default.createElement('br', null),
                  ' Health'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://siemens.lemonadereward.com/DIGITAL/PAGES/pension_modeller/', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Pension',
                  _react2.default.createElement('br', null),
                  ' Moduller'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/mortgage-app/which-property', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Mortgage',
                  _react2.default.createElement('br', null),
                  ' Calculator'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/react-cards', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Credit',
                  _react2.default.createElement('br', null),
                  ' (React)'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/CV_HEROKU', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'CV',
                  _react2.default.createElement('br', null),
                  '(React)'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/MERN', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'MERN',
                  _react2.default.createElement('br', null),
                  ' (React)'
                )
              )
            )
          )
        )
      )
    )
  );
};

exports.default = Projects;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(23), __webpack_require__(0), __webpack_require__(10));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(23), __webpack_require__(0), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["react-owl-carousel2"] = factory(require("prop-types"), require("react"), require("react-dom"));else root["react-owl-carousel2"] = factory(root["PropTypes"], root["React"], root["ReactDOM"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(7);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(8);\n\nvar _propTypes = __webpack_require__(6);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\n__webpack_require__(5);\n\n__webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar owlCarouselOptions = {\n\tcore: ['items', 'loop', 'center', 'rewind', 'mouseDrag', 'touchDrag', 'pullDrag', 'freeDrag', 'margin', 'stagePadding', 'merge', 'mergeFit', 'autoWidth', 'startPosition', 'rtl', 'smartSpeed', 'fluidSpeed', 'dragEndSpeed', 'responsive', 'responsiveRefreshRate', 'responsiveBaseElement', 'fallbackEasing', 'info', 'nestedItemSelector', 'itemElement', 'stageElement', 'refreshClass', 'loadedClass', 'loadingClass', 'rtlClass', 'responsiveClass', 'dragClass', 'itemClass', 'stageClass', 'stageOuterClass', 'grabClass'],\n\tautorefresh: ['autoRefresh', 'autoRefreshInterval'],\n\tlazy: ['lazyLoad'],\n\tautoHeight: ['autoHeight', 'autoHeightClass'],\n\tvideo: ['video', 'videoHeight', 'videoWidth'],\n\tanimate: ['animateOut', 'animateIn'],\n\tautoplay: ['autoplay', 'autoplayTimeout', 'autoplayHoverPause', 'autoplaySpeed'],\n\tnavigation: ['nav', 'navText', 'navSpeed', 'navElement', 'navContainer', 'navContainerClass', 'navClass', 'slideBy', 'dotClass', 'dotsClass', 'dots', 'dotsEach', 'dotsData', 'dotsSpeed', 'dotsContainer'],\n\thash: ['URLhashListener']\n};\n\nvar owlCarouselEvents = {\n\tcore: ['onInitialize', 'onInitialized', 'onResize', 'onResized', 'onRefresh', 'onRefreshed', 'onDrag', 'onDragged', 'onTranslate', 'onTranslated', 'onChange', 'onChanged'],\n\tlazy: ['onLoadLazy', 'onLoadedLazy'],\n\tvideo: ['onStopVideo', 'onPlayVideo']\n};\n\nvar OwlCarousel = function (_React$Component) {\n\t_inherits(OwlCarousel, _React$Component);\n\n\tfunction OwlCarousel(props, context) {\n\t\t_classCallCheck(this, OwlCarousel);\n\n\t\tvar _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));\n\n\t\t_this.onTranslate = function (next) {\n\t\t\treturn function (event) {\n\t\t\t\t_this.currentPosition = event.item.index;\n\t\t\t\tif (next) next(event);\n\t\t\t};\n\t\t};\n\n\t\t_this.next = function () {\n\t\t\treturn _this.$car.next();\n\t\t};\n\t\t_this.prev = function () {\n\t\t\treturn _this.$car.prev();\n\t\t};\n\t\t_this.goTo = function (x) {\n\t\t\treturn _this.$car.to(x);\n\t\t};\n\n\t\t_this.currentPosition = 0;\n\t\t_this.onTranslate = _this.onTranslate.bind(_this);\n\t\treturn _this;\n\t}\n\n\t_createClass(OwlCarousel, [{\n\t\tkey: 'componentDidMount',\n\t\tvalue: function componentDidMount() {\n\t\t\tthis.$node = $((0, _reactDom.findDOMNode)(this));\n\t\t\tvar options = this.getOptions();\n\t\t\tthis.init(options);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillReceiveProps',\n\t\tvalue: function componentWillReceiveProps(nextProps) {\n\t\t\tthis.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'componentDidUpdate',\n\t\tvalue: function componentDidUpdate(prevProps, prevState) {\n\t\t\tvar options = this.getOptions();\n\t\t\toptions.startPosition = this.currentPosition;\n\t\t\tthis.init(options);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillUnmount',\n\t\tvalue: function componentWillUnmount() {\n\t\t\tthis.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'init',\n\t\tvalue: function init(options) {\n\t\t\tvar next = options.onTranslate;\n\t\t\toptions.onTranslate = this.onTranslate(next);\n\t\t\tthis.$node.owlCarousel(options);\n\t\t\tthis.$car = this.$node.data('owl.carousel');\n\t\t}\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tthis.$car.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'getOptions',\n\t\tvalue: function getOptions() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar options = {};\n\n\t\t\tvar carOptions = Object.values(owlCarouselOptions).reduce(function (a, v) {\n\t\t\t\treturn a.concat(v);\n\t\t\t}, []);\n\n\t\t\tcarOptions.forEach(function (val) {\n\t\t\t\tif (val in _this2.props.options) options[val] = _this2.props.options[val];\n\t\t\t});\n\n\t\t\tvar carEvents = Object.values(owlCarouselEvents).reduce(function (a, v) {\n\t\t\t\treturn a.concat(v);\n\t\t\t}, []);\n\n\t\t\tcarEvents.forEach(function (val) {\n\t\t\t\tif (val in _this2.props.events) options[val] = _this2.props.events[val];\n\t\t\t});\n\n\t\t\treturn options;\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\tvar _props = this.props,\n\t\t\t    options = _props.options,\n\t\t\t    events = _props.events,\n\t\t\t    children = _props.children,\n\t\t\t    props = _objectWithoutProperties(_props, ['options', 'events', 'children']);\n\n\t\t\treturn _react2.default.createElement(\n\t\t\t\t'div',\n\t\t\t\t_extends({ className: 'owl-carousel owl-theme' }, props),\n\t\t\t\tchildren\n\t\t\t);\n\t\t}\n\t}]);\n\n\treturn OwlCarousel;\n}(_react2.default.Component);\n\nOwlCarousel.propTypes = {\n\tchildren: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.arrayOf(_propTypes2.default.element.isRequired)]).isRequired,\n\n\tstyle: _propTypes2.default.object,\n\tid: _propTypes2.default.string,\n\n\toptions: _propTypes2.default.shape({\n\t\t// core\n\t\titems: _propTypes2.default.number,\n\t\tloop: _propTypes2.default.bool,\n\t\tcenter: _propTypes2.default.bool,\n\t\trewind: _propTypes2.default.bool,\n\n\t\tmouseDrag: _propTypes2.default.bool,\n\t\ttouchDrag: _propTypes2.default.bool,\n\t\tpullDrag: _propTypes2.default.bool,\n\t\tfreeDrag: _propTypes2.default.bool,\n\n\t\tmargin: _propTypes2.default.number,\n\t\tstagePadding: _propTypes2.default.number,\n\n\t\tmerge: _propTypes2.default.bool,\n\t\tmergeFit: _propTypes2.default.bool,\n\t\tautoWidth: _propTypes2.default.bool,\n\n\t\tstartPosition: _propTypes2.default.number,\n\t\trtl: _propTypes2.default.bool,\n\n\t\tsmartSpeed: _propTypes2.default.number,\n\t\tfluidSpeed: _propTypes2.default.bool,\n\t\tdragEndSpeed: _propTypes2.default.bool,\n\n\t\tresponsive: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.object]),\n\t\tresponsiveRefreshRate: _propTypes2.default.number,\n\t\tresponsiveBaseElement: _propTypes2.default.object,\n\n\t\tfallbackEasing: _propTypes2.default.string,\n\n\t\tinfo: _propTypes2.default.bool,\n\n\t\tnestedItemSelector: _propTypes2.default.bool,\n\t\titemElement: _propTypes2.default.string,\n\t\tstageElement: _propTypes2.default.string,\n\n\t\trefreshClass: _propTypes2.default.string,\n\t\tloadedClass: _propTypes2.default.string,\n\t\tloadingClass: _propTypes2.default.string,\n\t\trtlClass: _propTypes2.default.string,\n\t\tresponsiveClass: _propTypes2.default.string,\n\t\tdragClass: _propTypes2.default.string,\n\t\titemClass: _propTypes2.default.string,\n\t\tstageClass: _propTypes2.default.string,\n\t\tstageOuterClass: _propTypes2.default.string,\n\t\tgrabClass: _propTypes2.default.string,\n\n\t\t// autoRefresh\n\t\tautoRefresh: _propTypes2.default.bool,\n\t\tautoRefreshInterval: _propTypes2.default.number,\n\n\t\t// lazy\n\t\tlazyLoad: _propTypes2.default.bool,\n\n\t\t// autoHeight\n\t\tautoHeight: _propTypes2.default.bool,\n\t\tautoHeightClass: _propTypes2.default.string,\n\n\t\t// video\n\t\tvideo: _propTypes2.default.bool,\n\t\tvideoHeight: _propTypes2.default.bool,\n\t\tvideoWidth: _propTypes2.default.bool,\n\n\t\t// animate\n\t\tanimateOut: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),\n\t\tanimateIn: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),\n\n\t\t// autoplay\n\t\tautoplay: _propTypes2.default.bool,\n\t\tautoplayTimeout: _propTypes2.default.number,\n\t\tautoplayHoverPause: _propTypes2.default.bool,\n\t\tautoplaySpeed: _propTypes2.default.bool,\n\n\t\t// navigation\n\t\tnav: _propTypes2.default.bool,\n\t\tnavText: _propTypes2.default.array,\n\t\tnavSpeed: _propTypes2.default.bool,\n\t\tnavElement: _propTypes2.default.string,\n\t\tnavContainer: _propTypes2.default.bool,\n\t\tnavContainerClass: _propTypes2.default.string,\n\t\tnavClass: _propTypes2.default.array,\n\t\tslideBy: _propTypes2.default.number,\n\t\tdotClass: _propTypes2.default.string,\n\t\tdotsClass: _propTypes2.default.string,\n\t\tdots: _propTypes2.default.bool,\n\t\tdotsEach: _propTypes2.default.bool,\n\t\tdotsData: _propTypes2.default.bool,\n\t\tdotsSpeed: _propTypes2.default.bool,\n\t\tdotsContainer: _propTypes2.default.bool,\n\n\t\t// hash\n\t\tURLhashListener: _propTypes2.default.bool\n\t}),\n\n\tevents: _propTypes2.default.shape({\n\t\t// core\n\t\tonInitialize: _propTypes2.default.func,\n\t\tonInitialized: _propTypes2.default.func,\n\t\tonResize: _propTypes2.default.func,\n\t\tonResized: _propTypes2.default.func,\n\t\tonRefresh: _propTypes2.default.func,\n\t\tonRefreshed: _propTypes2.default.func,\n\t\tonDrag: _propTypes2.default.func,\n\t\tonDragged: _propTypes2.default.func,\n\t\tonTranslate: _propTypes2.default.func,\n\t\tonTranslated: _propTypes2.default.func,\n\t\tonChange: _propTypes2.default.func,\n\t\tonChanged: _propTypes2.default.func,\n\n\t\t// lazy\n\t\tonLoadLazy: _propTypes2.default.func,\n\t\tonLoadedLazy: _propTypes2.default.func,\n\n\t\t// video\n\t\tonStopVideo: _propTypes2.default.func,\n\t\tonPlayVideo: _propTypes2.default.func\n\t})\n};\n\nOwlCarousel.defaultProps = {\n\toptions: {},\n\tevents: {}\n};\n\nexports.default = OwlCarousel;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./components/OwlCarousel.jsx\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./components/OwlCarousel.jsx?");

			/***/
		},
		/* 1 */
		/***/function (module, exports) {

			eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Owl Carousel v2.2.1\n * Copyright 2013-2017 David Deutsch\n * Licensed under  ()\n */\n/**\n * Owl carousel\n * @version 2.1.6\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates a carousel.\n  * @class The Owl Carousel.\n  * @public\n  * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n  * @param {Object} [options] - The options\n  */\n\tfunction Owl(element, options) {\n\n\t\t/**\n   * Current settings for the carousel.\n   * @public\n   */\n\t\tthis.settings = null;\n\n\t\t/**\n   * Current options set by the caller including defaults.\n   * @public\n   */\n\t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n\t\t/**\n   * Plugin element.\n   * @public\n   */\n\t\tthis.$element = $(element);\n\n\t\t/**\n   * Proxied event handlers.\n   * @protected\n   */\n\t\tthis._handlers = {};\n\n\t\t/**\n   * References to the running plugins of this carousel.\n   * @protected\n   */\n\t\tthis._plugins = {};\n\n\t\t/**\n   * Currently suppressed events to prevent them from beeing retriggered.\n   * @protected\n   */\n\t\tthis._supress = {};\n\n\t\t/**\n   * Absolute current position.\n   * @protected\n   */\n\t\tthis._current = null;\n\n\t\t/**\n   * Animation speed in milliseconds.\n   * @protected\n   */\n\t\tthis._speed = null;\n\n\t\t/**\n   * Coordinates of all items in pixel.\n   * @todo The name of this member is missleading.\n   * @protected\n   */\n\t\tthis._coordinates = [];\n\n\t\t/**\n   * Current breakpoint.\n   * @todo Real media queries would be nice.\n   * @protected\n   */\n\t\tthis._breakpoint = null;\n\n\t\t/**\n   * Current width of the plugin element.\n   */\n\t\tthis._width = null;\n\n\t\t/**\n   * All real items.\n   * @protected\n   */\n\t\tthis._items = [];\n\n\t\t/**\n   * All cloned items.\n   * @protected\n   */\n\t\tthis._clones = [];\n\n\t\t/**\n   * Merge values of all items.\n   * @todo Maybe this could be part of a plugin.\n   * @protected\n   */\n\t\tthis._mergers = [];\n\n\t\t/**\n   * Widths of all items.\n   */\n\t\tthis._widths = [];\n\n\t\t/**\n   * Invalidated parts within the update process.\n   * @protected\n   */\n\t\tthis._invalidated = {};\n\n\t\t/**\n   * Ordered list of workers for the update process.\n   * @protected\n   */\n\t\tthis._pipe = [];\n\n\t\t/**\n   * Current state information for the drag operation.\n   * @todo #261\n   * @protected\n   */\n\t\tthis._drag = {\n\t\t\ttime: null,\n\t\t\ttarget: null,\n\t\t\tpointer: null,\n\t\t\tstage: {\n\t\t\t\tstart: null,\n\t\t\t\tcurrent: null\n\t\t\t},\n\t\t\tdirection: null\n\t\t};\n\n\t\t/**\n   * Current state information and their tags.\n   * @type {Object}\n   * @protected\n   */\n\t\tthis._states = {\n\t\t\tcurrent: {},\n\t\t\ttags: {\n\t\t\t\t'initializing': ['busy'],\n\t\t\t\t'animating': ['busy'],\n\t\t\t\t'dragging': ['interacting']\n\t\t\t}\n\t\t};\n\n\t\t$.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {\n\t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n\t\t}, this));\n\n\t\t$.each(Owl.Plugins, $.proxy(function (key, plugin) {\n\t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);\n\t\t}, this));\n\n\t\t$.each(Owl.Workers, $.proxy(function (priority, worker) {\n\t\t\tthis._pipe.push({\n\t\t\t\t'filter': worker.filter,\n\t\t\t\t'run': $.proxy(worker.run, this)\n\t\t\t});\n\t\t}, this));\n\n\t\tthis.setup();\n\t\tthis.initialize();\n\t}\n\n\t/**\n  * Default options for the carousel.\n  * @public\n  */\n\tOwl.Defaults = {\n\t\titems: 3,\n\t\tloop: false,\n\t\tcenter: false,\n\t\trewind: false,\n\n\t\tmouseDrag: true,\n\t\ttouchDrag: true,\n\t\tpullDrag: true,\n\t\tfreeDrag: false,\n\n\t\tmargin: 0,\n\t\tstagePadding: 0,\n\n\t\tmerge: false,\n\t\tmergeFit: true,\n\t\tautoWidth: false,\n\n\t\tstartPosition: 0,\n\t\trtl: false,\n\n\t\tsmartSpeed: 250,\n\t\tfluidSpeed: false,\n\t\tdragEndSpeed: false,\n\n\t\tresponsive: {},\n\t\tresponsiveRefreshRate: 200,\n\t\tresponsiveBaseElement: window,\n\n\t\tfallbackEasing: 'swing',\n\n\t\tinfo: false,\n\n\t\tnestedItemSelector: false,\n\t\titemElement: 'div',\n\t\tstageElement: 'div',\n\n\t\trefreshClass: 'owl-refresh',\n\t\tloadedClass: 'owl-loaded',\n\t\tloadingClass: 'owl-loading',\n\t\trtlClass: 'owl-rtl',\n\t\tresponsiveClass: 'owl-responsive',\n\t\tdragClass: 'owl-drag',\n\t\titemClass: 'owl-item',\n\t\tstageClass: 'owl-stage',\n\t\tstageOuterClass: 'owl-stage-outer',\n\t\tgrabClass: 'owl-grab'\n\t};\n\n\t/**\n  * Enumeration for width.\n  * @public\n  * @readonly\n  * @enum {String}\n  */\n\tOwl.Width = {\n\t\tDefault: 'default',\n\t\tInner: 'inner',\n\t\tOuter: 'outer'\n\t};\n\n\t/**\n  * Enumeration for types.\n  * @public\n  * @readonly\n  * @enum {String}\n  */\n\tOwl.Type = {\n\t\tEvent: 'event',\n\t\tState: 'state'\n\t};\n\n\t/**\n  * Contains all registered plugins.\n  * @public\n  */\n\tOwl.Plugins = {};\n\n\t/**\n  * List of workers involved in the update process.\n  */\n\tOwl.Workers = [{\n\t\tfilter: ['width', 'settings'],\n\t\trun: function run() {\n\t\t\tthis._width = this.$element.width();\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n\t\t}\n\t}, {\n\t\tfilter: ['items', 'settings'],\n\t\trun: function run() {\n\t\t\tthis.$stage.children('.cloned').remove();\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar margin = this.settings.margin || '',\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    rtl = this.settings.rtl,\n\t\t\t    css = {\n\t\t\t\t'width': 'auto',\n\t\t\t\t'margin-left': rtl ? margin : '',\n\t\t\t\t'margin-right': rtl ? '' : margin\n\t\t\t};\n\n\t\t\t!grid && this.$stage.children().css(css);\n\n\t\t\tcache.css = css;\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n\t\t\t    merge = null,\n\t\t\t    iterator = this._items.length,\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    widths = [];\n\n\t\t\tcache.items = {\n\t\t\t\tmerge: false,\n\t\t\t\twidth: width\n\t\t\t};\n\n\t\t\twhile (iterator--) {\n\t\t\t\tmerge = this._mergers[iterator];\n\t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n\t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n\t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n\t\t\t}\n\n\t\t\tthis._widths = widths;\n\t\t}\n\t}, {\n\t\tfilter: ['items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar clones = [],\n\t\t\t    items = this._items,\n\t\t\t    settings = this.settings,\n\n\t\t\t// TODO: Should be computed from number of min width items in stage\n\t\t\tview = Math.max(settings.items * 2, 4),\n\t\t\t    size = Math.ceil(items.length / 2) * 2,\n\t\t\t    repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n\t\t\t    append = '',\n\t\t\t    prepend = '';\n\n\t\t\trepeat /= 2;\n\n\t\t\twhile (repeat--) {\n\t\t\t\t// Switch to only using appended clones\n\t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n\t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n\t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n\t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n\t\t\t}\n\n\t\t\tthis._clones = clones;\n\n\t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n\t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t    size = this._clones.length + this._items.length,\n\t\t\t    iterator = -1,\n\t\t\t    previous = 0,\n\t\t\t    current = 0,\n\t\t\t    coordinates = [];\n\n\t\t\twhile (++iterator < size) {\n\t\t\t\tprevious = coordinates[iterator - 1] || 0;\n\t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n\t\t\t\tcoordinates.push(previous + current * rtl);\n\t\t\t}\n\n\t\t\tthis._coordinates = coordinates;\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar padding = this.settings.stagePadding,\n\t\t\t    coordinates = this._coordinates,\n\t\t\t    css = {\n\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n\t\t\t\t'padding-left': padding || '',\n\t\t\t\t'padding-right': padding || ''\n\t\t\t};\n\n\t\t\tthis.$stage.css(css);\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar iterator = this._coordinates.length,\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    items = this.$stage.children();\n\n\t\t\tif (grid && cache.items.merge) {\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n\t\t\t\t\titems.eq(iterator).css(cache.css);\n\t\t\t\t}\n\t\t\t} else if (grid) {\n\t\t\t\tcache.css.width = cache.items.width;\n\t\t\t\titems.css(cache.css);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tfilter: ['items'],\n\t\trun: function run() {\n\t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n\t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n\t\t\tthis.reset(cache.current);\n\t\t}\n\t}, {\n\t\tfilter: ['position'],\n\t\trun: function run() {\n\t\t\tthis.animate(this.coordinates(this._current));\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'position', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t    padding = this.settings.stagePadding * 2,\n\t\t\t    begin = this.coordinates(this.current()) + padding,\n\t\t\t    end = begin + this.width() * rtl,\n\t\t\t    inner,\n\t\t\t    outer,\n\t\t\t    matches = [],\n\t\t\t    i,\n\t\t\t    n;\n\n\t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n\t\t\t\tinner = this._coordinates[i - 1] || 0;\n\t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n\t\t\t\tif (this.op(inner, '<=', begin) && this.op(inner, '>', end) || this.op(outer, '<', begin) && this.op(outer, '>', end)) {\n\t\t\t\t\tmatches.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$stage.children('.active').removeClass('active');\n\t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n\t\t\tif (this.settings.center) {\n\t\t\t\tthis.$stage.children('.center').removeClass('center');\n\t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n\t\t\t}\n\t\t}\n\t}];\n\n\t/**\n  * Initializes the carousel.\n  * @protected\n  */\n\tOwl.prototype.initialize = function () {\n\t\tthis.enter('initializing');\n\t\tthis.trigger('initialize');\n\n\t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n\t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n\t\t\tvar imgs, nestedSelector, width;\n\t\t\timgs = this.$element.find('img');\n\t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n\t\t\twidth = this.$element.children(nestedSelector).width();\n\n\t\t\tif (imgs.length && width <= 0) {\n\t\t\t\tthis.preloadAutoWidthImages(imgs);\n\t\t\t}\n\t\t}\n\n\t\tthis.$element.addClass(this.options.loadingClass);\n\n\t\t// HACK: DISABLE SCROLLBAR\n\t\tvar overflowVal = $('body').css('overflow');\n\t\t$('body').css({ 'overflow': 'hidden' });\n\n\t\t// create stage\n\t\tthis.$stage = $('<' + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>').wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n\t\t// append stage\n\t\tthis.$element.append(this.$stage.parent());\n\n\t\t// append content\n\t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n\t\t// check visibility\n\t\tif (this.$element.is(':visible')) {\n\t\t\t// update view\n\t\t\tthis.refresh();\n\t\t} else {\n\t\t\t// invalidate width\n\t\t\tthis.invalidate('width');\n\t\t}\n\n\t\t// HACK: RESTORE SCROLLBAR\n\t\t$('body').css({ 'overflow': overflowVal });\n\n\t\tthis.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);\n\n\t\t// register event handlers\n\t\tthis.registerEventHandlers();\n\n\t\tthis.leave('initializing');\n\t\tthis.trigger('initialized');\n\t};\n\n\t/**\n  * Setups the current settings.\n  * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n  * @todo Support for media queries by using `matchMedia` would be nice.\n  * @public\n  */\n\tOwl.prototype.setup = function () {\n\t\tvar viewport = this.viewport(),\n\t\t    overwrites = this.options.responsive,\n\t\t    match = -1,\n\t\t    settings = null;\n\n\t\tif (!overwrites) {\n\t\t\tsettings = $.extend({}, this.options);\n\t\t} else {\n\t\t\t$.each(overwrites, function (breakpoint) {\n\t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n\t\t\t\t\tmatch = Number(breakpoint);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n\t\t\tif (typeof settings.stagePadding === 'function') {\n\t\t\t\tsettings.stagePadding = settings.stagePadding();\n\t\t\t}\n\t\t\tdelete settings.responsive;\n\n\t\t\t// responsive class\n\t\t\tif (settings.responsiveClass) {\n\t\t\t\tthis.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match));\n\t\t\t}\n\t\t}\n\n\t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n\t\tthis._breakpoint = match;\n\t\tthis.settings = settings;\n\t\tthis.invalidate('settings');\n\t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n\t};\n\n\t/**\n  * Updates option logic if necessery.\n  * @protected\n  */\n\tOwl.prototype.optionsLogic = function () {\n\t\tif (this.settings.autoWidth) {\n\t\t\tthis.settings.stagePadding = false;\n\t\t\tthis.settings.merge = false;\n\t\t}\n\t};\n\n\t/**\n  * Prepares an item before add.\n  * @todo Rename event parameter `content` to `item`.\n  * @protected\n  * @returns {jQuery|HTMLElement} - The item container.\n  */\n\tOwl.prototype.prepare = function (item) {\n\t\tvar event = this.trigger('prepare', { content: item });\n\n\t\tif (!event.data) {\n\t\t\tevent.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item);\n\t\t}\n\n\t\tthis.trigger('prepared', { content: event.data });\n\n\t\treturn event.data;\n\t};\n\n\t/**\n  * Updates the view.\n  * @public\n  */\n\tOwl.prototype.update = function () {\n\t\tvar i = 0,\n\t\t    n = this._pipe.length,\n\t\t    filter = $.proxy(function (p) {\n\t\t\treturn this[p];\n\t\t}, this._invalidated),\n\t\t    cache = {};\n\n\t\twhile (i < n) {\n\t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n\t\t\t\tthis._pipe[i].run(cache);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tthis._invalidated = {};\n\n\t\t!this.is('valid') && this.enter('valid');\n\t};\n\n\t/**\n  * Gets the width of the view.\n  * @public\n  * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n  * @returns {Number} - The width of the view in pixel.\n  */\n\tOwl.prototype.width = function (dimension) {\n\t\tdimension = dimension || Owl.Width.Default;\n\t\tswitch (dimension) {\n\t\t\tcase Owl.Width.Inner:\n\t\t\tcase Owl.Width.Outer:\n\t\t\t\treturn this._width;\n\t\t\tdefault:\n\t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n\t\t}\n\t};\n\n\t/**\n  * Refreshes the carousel primarily for adaptive purposes.\n  * @public\n  */\n\tOwl.prototype.refresh = function () {\n\t\tthis.enter('refreshing');\n\t\tthis.trigger('refresh');\n\n\t\tthis.setup();\n\n\t\tthis.optionsLogic();\n\n\t\tthis.$element.addClass(this.options.refreshClass);\n\n\t\tthis.update();\n\n\t\tthis.$element.removeClass(this.options.refreshClass);\n\n\t\tthis.leave('refreshing');\n\t\tthis.trigger('refreshed');\n\t};\n\n\t/**\n  * Checks window `resize` event.\n  * @protected\n  */\n\tOwl.prototype.onThrottledResize = function () {\n\t\twindow.clearTimeout(this.resizeTimer);\n\t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n\t};\n\n\t/**\n  * Checks window `resize` event.\n  * @protected\n  */\n\tOwl.prototype.onResize = function () {\n\t\tif (!this._items.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._width === this.$element.width()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.$element.is(':visible')) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.enter('resizing');\n\n\t\tif (this.trigger('resize').isDefaultPrevented()) {\n\t\t\tthis.leave('resizing');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.invalidate('width');\n\n\t\tthis.refresh();\n\n\t\tthis.leave('resizing');\n\t\tthis.trigger('resized');\n\t};\n\n\t/**\n  * Registers event handlers.\n  * @todo Check `msPointerEnabled`\n  * @todo #261\n  * @protected\n  */\n\tOwl.prototype.registerEventHandlers = function () {\n\t\tif ($.support.transition) {\n\t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n\t\t}\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tif (this.settings.mouseDrag) {\n\t\t\tthis.$element.addClass(this.options.dragClass);\n\t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function () {\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\n\t\tif (this.settings.touchDrag) {\n\t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n\t\t}\n\t};\n\n\t/**\n  * Handles `touchstart` and `mousedown` events.\n  * @todo Horizontal swipe threshold as option\n  * @todo #261\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragStart = function (event) {\n\t\tvar stage = null;\n\n\t\tif (event.which === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ($.support.transform) {\n\t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n\t\t\tstage = {\n\t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n\t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n\t\t\t};\n\t\t} else {\n\t\t\tstage = this.$stage.position();\n\t\t\tstage = {\n\t\t\t\tx: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,\n\t\t\t\ty: stage.top\n\t\t\t};\n\t\t}\n\n\t\tif (this.is('animating')) {\n\t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop();\n\t\t\tthis.invalidate('position');\n\t\t}\n\n\t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n\t\tthis.speed(0);\n\n\t\tthis._drag.time = new Date().getTime();\n\t\tthis._drag.target = $(event.target);\n\t\tthis._drag.stage.start = stage;\n\t\tthis._drag.stage.current = stage;\n\t\tthis._drag.pointer = this.pointer(event);\n\n\t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n\t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {\n\t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n\t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n\t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.enter('dragging');\n\t\t\tthis.trigger('drag');\n\t\t}, this));\n\t};\n\n\t/**\n  * Handles the `touchmove` and `mousemove` events.\n  * @todo #261\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragMove = function (event) {\n\t\tvar minimum = null,\n\t\t    maximum = null,\n\t\t    pull = null,\n\t\t    delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t    stage = this.difference(this._drag.stage.start, delta);\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif (this.settings.loop) {\n\t\t\tminimum = this.coordinates(this.minimum());\n\t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n\t\t\tstage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum;\n\t\t} else {\n\t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n\t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n\t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n\t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n\t\t}\n\n\t\tthis._drag.stage.current = stage;\n\n\t\tthis.animate(stage.x);\n\t};\n\n\t/**\n  * Handles the `touchend` and `mouseup` events.\n  * @todo #261\n  * @todo Threshold for click event\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragEnd = function (event) {\n\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t    stage = this._drag.stage.current,\n\t\t    direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n\t\t$(document).off('.owl.core');\n\n\t\tthis.$element.removeClass(this.options.grabClass);\n\n\t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n\t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n\t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n\t\t\tthis.invalidate('position');\n\t\t\tthis.update();\n\n\t\t\tthis._drag.direction = direction;\n\n\t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n\t\t\t\tthis._drag.target.one('click.owl.core', function () {\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.leave('dragging');\n\t\tthis.trigger('dragged');\n\t};\n\n\t/**\n  * Gets absolute position of the closest item for a coordinate.\n  * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n  * @protected\n  * @param {Number} coordinate - The coordinate in pixel.\n  * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n  * @return {Number} - The absolute position of the closest item.\n  */\n\tOwl.prototype.closest = function (coordinate, direction) {\n\t\tvar position = -1,\n\t\t    pull = 30,\n\t\t    width = this.width(),\n\t\t    coordinates = this.coordinates();\n\n\t\tif (!this.settings.freeDrag) {\n\t\t\t// check closest item\n\t\t\t$.each(coordinates, $.proxy(function (index, value) {\n\t\t\t\t// on a left pull, check on current index\n\t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n\t\t\t\t\tposition = index;\n\t\t\t\t\t// on a right pull, check on previous index\n\t\t\t\t\t// to do so, subtract width from value and set position = index + 1\n\t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t} else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n\t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n\t\t\t\t}\n\t\t\t\treturn position === -1;\n\t\t\t}, this));\n\t\t}\n\n\t\tif (!this.settings.loop) {\n\t\t\t// non loop boundries\n\t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n\t\t\t\tposition = coordinate = this.minimum();\n\t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n\t\t\t\tposition = coordinate = this.maximum();\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Animates the stage.\n  * @todo #270\n  * @public\n  * @param {Number} coordinate - The coordinate in pixels.\n  */\n\tOwl.prototype.animate = function (coordinate) {\n\t\tvar animate = this.speed() > 0;\n\n\t\tthis.is('animating') && this.onTransitionEnd();\n\n\t\tif (animate) {\n\t\t\tthis.enter('animating');\n\t\t\tthis.trigger('translate');\n\t\t}\n\n\t\tif ($.support.transform3d && $.support.transition) {\n\t\t\tthis.$stage.css({\n\t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n\t\t\t\ttransition: this.speed() / 1000 + 's'\n\t\t\t});\n\t\t} else if (animate) {\n\t\t\tthis.$stage.animate({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n\t\t} else {\n\t\t\tthis.$stage.css({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Checks whether the carousel is in a specific state or not.\n  * @param {String} state - The state to check.\n  * @returns {Boolean} - The flag which indicates if the carousel is busy.\n  */\n\tOwl.prototype.is = function (state) {\n\t\treturn this._states.current[state] && this._states.current[state] > 0;\n\t};\n\n\t/**\n  * Sets the absolute position of the current item.\n  * @public\n  * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n  * @returns {Number} - The absolute position of the current item.\n  */\n\tOwl.prototype.current = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._current;\n\t\t}\n\n\t\tif (this._items.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tposition = this.normalize(position);\n\n\t\tif (this._current !== position) {\n\t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n\t\t\tif (event.data !== undefined) {\n\t\t\t\tposition = this.normalize(event.data);\n\t\t\t}\n\n\t\t\tthis._current = position;\n\n\t\t\tthis.invalidate('position');\n\n\t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n\t\t}\n\n\t\treturn this._current;\n\t};\n\n\t/**\n  * Invalidates the given part of the update routine.\n  * @param {String} [part] - The part to invalidate.\n  * @returns {Array.<String>} - The invalidated parts.\n  */\n\tOwl.prototype.invalidate = function (part) {\n\t\tif ($.type(part) === 'string') {\n\t\t\tthis._invalidated[part] = true;\n\t\t\tthis.is('valid') && this.leave('valid');\n\t\t}\n\t\treturn $.map(this._invalidated, function (v, i) {\n\t\t\treturn i;\n\t\t});\n\t};\n\n\t/**\n  * Resets the absolute position of the current item.\n  * @public\n  * @param {Number} position - The absolute position of the new item.\n  */\n\tOwl.prototype.reset = function (position) {\n\t\tposition = this.normalize(position);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._speed = 0;\n\t\tthis._current = position;\n\n\t\tthis.suppress(['translate', 'translated']);\n\n\t\tthis.animate(this.coordinates(position));\n\n\t\tthis.release(['translate', 'translated']);\n\t};\n\n\t/**\n  * Normalizes an absolute or a relative position of an item.\n  * @public\n  * @param {Number} position - The absolute or relative position to normalize.\n  * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n  * @returns {Number} - The normalized position.\n  */\n\tOwl.prototype.normalize = function (position, relative) {\n\t\tvar n = this._items.length,\n\t\t    m = relative ? 0 : this._clones.length;\n\n\t\tif (!this.isNumeric(position) || n < 1) {\n\t\t\tposition = undefined;\n\t\t} else if (position < 0 || position >= n + m) {\n\t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Converts an absolute position of an item into a relative one.\n  * @public\n  * @param {Number} position - The absolute position to convert.\n  * @returns {Number} - The converted position.\n  */\n\tOwl.prototype.relative = function (position) {\n\t\tposition -= this._clones.length / 2;\n\t\treturn this.normalize(position, true);\n\t};\n\n\t/**\n  * Gets the maximum position for the current item.\n  * @public\n  * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n  * @returns {Number}\n  */\n\tOwl.prototype.maximum = function (relative) {\n\t\tvar settings = this.settings,\n\t\t    maximum = this._coordinates.length,\n\t\t    iterator,\n\t\t    reciprocalItemsWidth,\n\t\t    elementWidth;\n\n\t\tif (settings.loop) {\n\t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n\t\t} else if (settings.autoWidth || settings.merge) {\n\t\t\titerator = this._items.length;\n\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n\t\t\telementWidth = this.$element.width();\n\t\t\twhile (iterator--) {\n\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximum = iterator + 1;\n\t\t} else if (settings.center) {\n\t\t\tmaximum = this._items.length - 1;\n\t\t} else {\n\t\t\tmaximum = this._items.length - settings.items;\n\t\t}\n\n\t\tif (relative) {\n\t\t\tmaximum -= this._clones.length / 2;\n\t\t}\n\n\t\treturn Math.max(maximum, 0);\n\t};\n\n\t/**\n  * Gets the minimum position for the current item.\n  * @public\n  * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n  * @returns {Number}\n  */\n\tOwl.prototype.minimum = function (relative) {\n\t\treturn relative ? 0 : this._clones.length / 2;\n\t};\n\n\t/**\n  * Gets an item at the specified relative position.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n  */\n\tOwl.prototype.items = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._items.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._items[position];\n\t};\n\n\t/**\n  * Gets an item at the specified relative position.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n  */\n\tOwl.prototype.mergers = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._mergers.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._mergers[position];\n\t};\n\n\t/**\n  * Gets the absolute positions of clones for an item.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n  */\n\tOwl.prototype.clones = function (position) {\n\t\tvar odd = this._clones.length / 2,\n\t\t    even = odd + this._items.length,\n\t\t    map = function map(index) {\n\t\t\treturn index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2;\n\t\t};\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._clones, function (v, i) {\n\t\t\t\treturn map(i);\n\t\t\t});\n\t\t}\n\n\t\treturn $.map(this._clones, function (v, i) {\n\t\t\treturn v === position ? map(i) : null;\n\t\t});\n\t};\n\n\t/**\n  * Sets the current animation speed.\n  * @public\n  * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n  * @returns {Number} - The current animation speed in milliseconds.\n  */\n\tOwl.prototype.speed = function (speed) {\n\t\tif (speed !== undefined) {\n\t\t\tthis._speed = speed;\n\t\t}\n\n\t\treturn this._speed;\n\t};\n\n\t/**\n  * Gets the coordinate of an item.\n  * @todo The name of this method is missleanding.\n  * @public\n  * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n  * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n  */\n\tOwl.prototype.coordinates = function (position) {\n\t\tvar multiplier = 1,\n\t\t    newPosition = position - 1,\n\t\t    coordinate;\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._coordinates, $.proxy(function (coordinate, index) {\n\t\t\t\treturn this.coordinates(index);\n\t\t\t}, this));\n\t\t}\n\n\t\tif (this.settings.center) {\n\t\t\tif (this.settings.rtl) {\n\t\t\t\tmultiplier = -1;\n\t\t\t\tnewPosition = position + 1;\n\t\t\t}\n\n\t\t\tcoordinate = this._coordinates[position];\n\t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n\t\t} else {\n\t\t\tcoordinate = this._coordinates[newPosition] || 0;\n\t\t}\n\n\t\tcoordinate = Math.ceil(coordinate);\n\n\t\treturn coordinate;\n\t};\n\n\t/**\n  * Calculates the speed for a translation.\n  * @protected\n  * @param {Number} from - The absolute position of the start item.\n  * @param {Number} to - The absolute position of the target item.\n  * @param {Number} [factor=undefined] - The time factor in milliseconds.\n  * @returns {Number} - The time in milliseconds for the translation.\n  */\n\tOwl.prototype.duration = function (from, to, factor) {\n\t\tif (factor === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed);\n\t};\n\n\t/**\n  * Slides to the specified item.\n  * @public\n  * @param {Number} position - The position of the item.\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.to = function (position, speed) {\n\t\tvar current = this.current(),\n\t\t    revert = null,\n\t\t    distance = position - this.relative(current),\n\t\t    direction = (distance > 0) - (distance < 0),\n\t\t    items = this._items.length,\n\t\t    minimum = this.minimum(),\n\t\t    maximum = this.maximum();\n\n\t\tif (this.settings.loop) {\n\t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n\t\t\t\tdistance += direction * -1 * items;\n\t\t\t}\n\n\t\t\tposition = current + distance;\n\t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n\t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n\t\t\t\tcurrent = revert - distance;\n\t\t\t\tposition = revert;\n\t\t\t\tthis.reset(current);\n\t\t\t}\n\t\t} else if (this.settings.rewind) {\n\t\t\tmaximum += 1;\n\t\t\tposition = (position % maximum + maximum) % maximum;\n\t\t} else {\n\t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n\t\t}\n\n\t\tthis.speed(this.duration(current, position, speed));\n\t\tthis.current(position);\n\n\t\tif (this.$element.is(':visible')) {\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\t/**\n  * Slides to the next item.\n  * @public\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.next = function (speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) + 1, speed);\n\t};\n\n\t/**\n  * Slides to the previous item.\n  * @public\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.prev = function (speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) - 1, speed);\n\t};\n\n\t/**\n  * Handles the end of an animation.\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onTransitionEnd = function (event) {\n\n\t\t// if css2 animation then event object is undefined\n\t\tif (event !== undefined) {\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Catch only owl-stage transitionEnd event\n\t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.leave('animating');\n\t\tthis.trigger('translated');\n\t};\n\n\t/**\n  * Gets viewport width.\n  * @protected\n  * @return {Number} - The width in pixel.\n  */\n\tOwl.prototype.viewport = function () {\n\t\tvar width;\n\t\tif (this.options.responsiveBaseElement !== window) {\n\t\t\twidth = $(this.options.responsiveBaseElement).width();\n\t\t} else if (window.innerWidth) {\n\t\t\twidth = window.innerWidth;\n\t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n\t\t\twidth = document.documentElement.clientWidth;\n\t\t} else {\n\t\t\tconsole.warn('Can not detect viewport width.');\n\t\t}\n\t\treturn width;\n\t};\n\n\t/**\n  * Replaces the current content.\n  * @public\n  * @param {HTMLElement|jQuery|String} content - The new content.\n  */\n\tOwl.prototype.replace = function (content) {\n\t\tthis.$stage.empty();\n\t\tthis._items = [];\n\n\t\tif (content) {\n\t\t\tcontent = content instanceof jQuery ? content : $(content);\n\t\t}\n\n\t\tif (this.settings.nestedItemSelector) {\n\t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n\t\t}\n\n\t\tcontent.filter(function () {\n\t\t\treturn this.nodeType === 1;\n\t\t}).each($.proxy(function (index, item) {\n\t\t\titem = this.prepare(item);\n\t\t\tthis.$stage.append(item);\n\t\t\tthis._items.push(item);\n\t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}, this));\n\n\t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n\t\tthis.invalidate('items');\n\t};\n\n\t/**\n  * Adds an item.\n  * @todo Use `item` instead of `content` for the event arguments.\n  * @public\n  * @param {HTMLElement|jQuery|String} content - The item content to add.\n  * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n  */\n\tOwl.prototype.add = function (content, position) {\n\t\tvar current = this.relative(this._current);\n\n\t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n\t\tcontent = content instanceof jQuery ? content : $(content);\n\n\t\tthis.trigger('add', { content: content, position: position });\n\n\t\tcontent = this.prepare(content);\n\n\t\tif (this._items.length === 0 || position === this._items.length) {\n\t\t\tthis._items.length === 0 && this.$stage.append(content);\n\t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n\t\t\tthis._items.push(content);\n\t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t} else {\n\t\t\tthis._items[position].before(content);\n\t\t\tthis._items.splice(position, 0, content);\n\t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}\n\n\t\tthis._items[current] && this.reset(this._items[current].index());\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('added', { content: content, position: position });\n\t};\n\n\t/**\n  * Removes an item by its position.\n  * @todo Use `item` instead of `content` for the event arguments.\n  * @public\n  * @param {Number} position - The relative position of the item to remove.\n  */\n\tOwl.prototype.remove = function (position) {\n\t\tposition = this.normalize(position, true);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n\t\tthis._items[position].remove();\n\t\tthis._items.splice(position, 1);\n\t\tthis._mergers.splice(position, 1);\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('removed', { content: null, position: position });\n\t};\n\n\t/**\n  * Preloads images with auto width.\n  * @todo Replace by a more generic approach\n  * @protected\n  */\n\tOwl.prototype.preloadAutoWidthImages = function (images) {\n\t\timages.each($.proxy(function (i, element) {\n\t\t\tthis.enter('pre-loading');\n\t\t\telement = $(element);\n\t\t\t$(new Image()).one('load', $.proxy(function (e) {\n\t\t\t\telement.attr('src', e.target.src);\n\t\t\t\telement.css('opacity', 1);\n\t\t\t\tthis.leave('pre-loading');\n\t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n\t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n\t\t}, this));\n\t};\n\n\t/**\n  * Destroys the carousel.\n  * @public\n  */\n\tOwl.prototype.destroy = function () {\n\n\t\tthis.$element.off('.owl.core');\n\t\tthis.$stage.off('.owl.core');\n\t\t$(document).off('.owl.core');\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\twindow.clearTimeout(this.resizeTimer);\n\t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tfor (var i in this._plugins) {\n\t\t\tthis._plugins[i].destroy();\n\t\t}\n\n\t\tthis.$stage.children('.cloned').remove();\n\n\t\tthis.$stage.unwrap();\n\t\tthis.$stage.children().contents().unwrap();\n\t\tthis.$stage.children().unwrap();\n\n\t\tthis.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), '')).removeData('owl.carousel');\n\t};\n\n\t/**\n  * Operators to calculate right-to-left and left-to-right.\n  * @protected\n  * @param {Number} [a] - The left side operand.\n  * @param {String} [o] - The operator.\n  * @param {Number} [b] - The right side operand.\n  */\n\tOwl.prototype.op = function (a, o, b) {\n\t\tvar rtl = this.settings.rtl;\n\t\tswitch (o) {\n\t\t\tcase '<':\n\t\t\t\treturn rtl ? a > b : a < b;\n\t\t\tcase '>':\n\t\t\t\treturn rtl ? a < b : a > b;\n\t\t\tcase '>=':\n\t\t\t\treturn rtl ? a <= b : a >= b;\n\t\t\tcase '<=':\n\t\t\t\treturn rtl ? a >= b : a <= b;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n  * Attaches to an internal event.\n  * @protected\n  * @param {HTMLElement} element - The event source.\n  * @param {String} event - The event name.\n  * @param {Function} listener - The event handler to attach.\n  * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n  */\n\tOwl.prototype.on = function (element, event, listener, capture) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, listener, capture);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n  * Detaches from an internal event.\n  * @protected\n  * @param {HTMLElement} element - The event source.\n  * @param {String} event - The event name.\n  * @param {Function} listener - The attached event handler to detach.\n  * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n  */\n\tOwl.prototype.off = function (element, event, listener, capture) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(event, listener, capture);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n  * Triggers a public event.\n  * @todo Remove `status`, `relatedTarget` should be used instead.\n  * @protected\n  * @param {String} name - The event name.\n  * @param {*} [data=null] - The event data.\n  * @param {String} [namespace=carousel] - The event namespace.\n  * @param {String} [state] - The state which is associated with the event.\n  * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n  * @returns {Event} - The event arguments.\n  */\n\tOwl.prototype.trigger = function (name, data, namespace, state, enter) {\n\t\tvar status = {\n\t\t\titem: { count: this._items.length, index: this.current() }\n\t\t},\n\t\t    handler = $.camelCase($.grep(['on', name, namespace], function (v) {\n\t\t\treturn v;\n\t\t}).join('-').toLowerCase()),\n\t\t    event = $.Event([name, 'owl', namespace || 'carousel'].join('.').toLowerCase(), $.extend({ relatedTarget: this }, status, data));\n\n\t\tif (!this._supress[name]) {\n\t\t\t$.each(this._plugins, function (name, plugin) {\n\t\t\t\tif (plugin.onTrigger) {\n\t\t\t\t\tplugin.onTrigger(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.register({ type: Owl.Type.Event, name: name });\n\t\t\tthis.$element.trigger(event);\n\n\t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n\t\t\t\tthis.settings[handler].call(this, event);\n\t\t\t}\n\t\t}\n\n\t\treturn event;\n\t};\n\n\t/**\n  * Enters a state.\n  * @param name - The state name.\n  */\n\tOwl.prototype.enter = function (name) {\n\t\t$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n\t\t\tif (this._states.current[name] === undefined) {\n\t\t\t\tthis._states.current[name] = 0;\n\t\t\t}\n\n\t\t\tthis._states.current[name]++;\n\t\t}, this));\n\t};\n\n\t/**\n  * Leaves a state.\n  * @param name - The state name.\n  */\n\tOwl.prototype.leave = function (name) {\n\t\t$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n\t\t\tthis._states.current[name]--;\n\t\t}, this));\n\t};\n\n\t/**\n  * Registers an event or state.\n  * @public\n  * @param {Object} object - The event or state to register.\n  */\n\tOwl.prototype.register = function (object) {\n\t\tif (object.type === Owl.Type.Event) {\n\t\t\tif (!$.event.special[object.name]) {\n\t\t\t\t$.event.special[object.name] = {};\n\t\t\t}\n\n\t\t\tif (!$.event.special[object.name].owl) {\n\t\t\t\tvar _default = $.event.special[object.name]._default;\n\t\t\t\t$.event.special[object.name]._default = function (e) {\n\t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n\t\t\t\t\t\treturn _default.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n\t\t\t\t};\n\t\t\t\t$.event.special[object.name].owl = true;\n\t\t\t}\n\t\t} else if (object.type === Owl.Type.State) {\n\t\t\tif (!this._states.tags[object.name]) {\n\t\t\t\tthis._states.tags[object.name] = object.tags;\n\t\t\t} else {\n\t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n\t\t\t}\n\n\t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {\n\t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n\t\t\t}, this));\n\t\t}\n\t};\n\n\t/**\n  * Suppresses events.\n  * @protected\n  * @param {Array.<String>} events - The events to suppress.\n  */\n\tOwl.prototype.suppress = function (events) {\n\t\t$.each(events, $.proxy(function (index, event) {\n\t\t\tthis._supress[event] = true;\n\t\t}, this));\n\t};\n\n\t/**\n  * Releases suppressed events.\n  * @protected\n  * @param {Array.<String>} events - The events to release.\n  */\n\tOwl.prototype.release = function (events) {\n\t\t$.each(events, $.proxy(function (index, event) {\n\t\t\tdelete this._supress[event];\n\t\t}, this));\n\t};\n\n\t/**\n  * Gets unified pointer coordinates from event.\n  * @todo #261\n  * @protected\n  * @param {Event} - The `mousedown` or `touchstart` event.\n  * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n  */\n\tOwl.prototype.pointer = function (event) {\n\t\tvar result = { x: null, y: null };\n\n\t\tevent = event.originalEvent || event || window.event;\n\n\t\tevent = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;\n\n\t\tif (event.pageX) {\n\t\t\tresult.x = event.pageX;\n\t\t\tresult.y = event.pageY;\n\t\t} else {\n\t\t\tresult.x = event.clientX;\n\t\t\tresult.y = event.clientY;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n  * Determines if the input is a Number or something that can be coerced to a Number\n  * @protected\n  * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n  * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n  */\n\tOwl.prototype.isNumeric = function (number) {\n\t\treturn !isNaN(parseFloat(number));\n\t};\n\n\t/**\n  * Gets the difference of two vectors.\n  * @todo #261\n  * @protected\n  * @param {Object} - The first vector.\n  * @param {Object} - The second vector.\n  * @returns {Object} - The difference.\n  */\n\tOwl.prototype.difference = function (first, second) {\n\t\treturn {\n\t\t\tx: first.x - second.x,\n\t\t\ty: first.y - second.y\n\t\t};\n\t};\n\n\t/**\n  * The jQuery Plugin for the Owl Carousel\n  * @todo Navigation plugin `next` and `prev`\n  * @public\n  */\n\t$.fn.owlCarousel = function (option) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\treturn this.each(function () {\n\t\t\tvar $this = $(this),\n\t\t\t    data = $this.data('owl.carousel');\n\n\t\t\tif (!data) {\n\t\t\t\tdata = new Owl(this, (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);\n\t\t\t\t$this.data('owl.carousel', data);\n\n\t\t\t\t$.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function (i, event) {\n\t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n\t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {\n\t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n\t\t\t\t\t\t\tthis.suppress([event]);\n\t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n\t\t\t\t\t\t\tthis.release([event]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, data));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n\t\t\t\tdata[option].apply(data, args);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * The constructor for the jQuery Plugin\n  * @public\n  */\n\t$.fn.owlCarousel.Constructor = Owl;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the auto refresh plugin.\n  * @class The Auto Refresh Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar AutoRefresh = function AutoRefresh(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Refresh interval.\n   * @protected\n   * @type {number}\n   */\n\t\tthis._interval = null;\n\n\t\t/**\n   * Whether the element is currently visible or not.\n   * @protected\n   * @type {Boolean}\n   */\n\t\tthis._visible = null;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n\t\t\t\t\tthis.watch();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoRefresh.Defaults = {\n\t\tautoRefresh: true,\n\t\tautoRefreshInterval: 500\n\t};\n\n\t/**\n  * Watches the element.\n  */\n\tAutoRefresh.prototype.watch = function () {\n\t\tif (this._interval) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = this._core.$element.is(':visible');\n\t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n\t};\n\n\t/**\n  * Refreshes the element.\n  */\n\tAutoRefresh.prototype.refresh = function () {\n\t\tif (this._core.$element.is(':visible') === this._visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = !this._visible;\n\n\t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n\t\tthis._visible && this._core.invalidate('width') && this._core.refresh();\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tAutoRefresh.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\twindow.clearInterval(this._interval);\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the lazy plugin.\n  * @class The Lazy Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar Lazy = function Lazy(carousel) {\n\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Already loaded items.\n   * @protected\n   * @type {Array.<jQuery>}\n   */\n\t\tthis._loaded = [];\n\n\t\t/**\n   * Event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (e.property && e.property.name == 'position' || e.type == 'initialized') {\n\t\t\t\t\tvar settings = this._core.settings,\n\t\t\t\t\t    n = settings.center && Math.ceil(settings.items / 2) || settings.items,\n\t\t\t\t\t    i = settings.center && n * -1 || 0,\n\t\t\t\t\t    position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n\t\t\t\t\t    clones = this._core.clones().length,\n\t\t\t\t\t    load = $.proxy(function (i, v) {\n\t\t\t\t\t\tthis.load(v);\n\t\t\t\t\t}, this);\n\n\t\t\t\t\twhile (i++ < n) {\n\t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n\t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set the default options\n\t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n\t\t// register event handler\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tLazy.Defaults = {\n\t\tlazyLoad: false\n\t};\n\n\t/**\n  * Loads all resources of an item at the specified position.\n  * @param {Number} position - The absolute position of the item.\n  * @protected\n  */\n\tLazy.prototype.load = function (position) {\n\t\tvar $item = this._core.$stage.children().eq(position),\n\t\t    $elements = $item && $item.find('.owl-lazy');\n\n\t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements.each($.proxy(function (index, element) {\n\t\t\tvar $element = $(element),\n\t\t\t    image,\n\t\t\t    url = window.devicePixelRatio > 1 && $element.attr('data-src-retina') || $element.attr('data-src');\n\n\t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n\t\t\tif ($element.is('img')) {\n\t\t\t\t$element.one('load.owl.lazy', $.proxy(function () {\n\t\t\t\t\t$element.css('opacity', 1);\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this)).attr('src', url);\n\t\t\t} else {\n\t\t\t\timage = new Image();\n\t\t\t\timage.onload = $.proxy(function () {\n\t\t\t\t\t$element.css({\n\t\t\t\t\t\t'background-image': 'url(\"' + url + '\")',\n\t\t\t\t\t\t'opacity': '1'\n\t\t\t\t\t});\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this);\n\t\t\t\timage.src = url;\n\t\t\t}\n\t\t}, this));\n\n\t\tthis._loaded.push($item.get(0));\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tLazy.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the auto height plugin.\n  * @class The Auto Height Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar AutoHeight = function AutoHeight(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name == 'position') {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'loaded.owl.lazy': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoHeight.Defaults = {\n\t\tautoHeight: false,\n\t\tautoHeightClass: 'owl-height'\n\t};\n\n\t/**\n  * Updates the view.\n  */\n\tAutoHeight.prototype.update = function () {\n\t\tvar start = this._core._current,\n\t\t    end = start + this._core.settings.items,\n\t\t    visible = this._core.$stage.children().toArray().slice(start, end),\n\t\t    heights = [],\n\t\t    maxheight = 0;\n\n\t\t$.each(visible, function (index, item) {\n\t\t\theights.push($(item).height());\n\t\t});\n\n\t\tmaxheight = Math.max.apply(null, heights);\n\n\t\tthis._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);\n\t};\n\n\tAutoHeight.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the video plugin.\n  * @class The Video Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar Video = function Video(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Cache all video URLs.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._videos = {};\n\n\t\t/**\n   * Current playing item.\n   * @protected\n   * @type {jQuery}\n   */\n\t\tthis._playing = null;\n\n\t\t/**\n   * All event handlers.\n   * @todo The cloned content removale is too late\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: ['interacting'] });\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'resize.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.is('resizing')) {\n\t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n\t\t\t\tif ($element.length) {\n\t\t\t\t\t$element.css('display', 'none');\n\t\t\t\t\tthis.fetch($element, $(e.content));\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {\n\t\t\tthis.play(e);\n\t\t}, this));\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tVideo.Defaults = {\n\t\tvideo: false,\n\t\tvideoHeight: false,\n\t\tvideoWidth: false\n\t};\n\n\t/**\n  * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n  * @protected\n  * @param {jQuery} target - The target containing the video data.\n  * @param {jQuery} item - The item containing the video.\n  */\n\tVideo.prototype.fetch = function (target, item) {\n\t\tvar type = function () {\n\t\t\tif (target.attr('data-vimeo-id')) {\n\t\t\t\treturn 'vimeo';\n\t\t\t} else if (target.attr('data-vzaar-id')) {\n\t\t\t\treturn 'vzaar';\n\t\t\t} else {\n\t\t\t\treturn 'youtube';\n\t\t\t}\n\t\t}(),\n\t\t    id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n\t\t    width = target.attr('data-width') || this._core.settings.videoWidth,\n\t\t    height = target.attr('data-height') || this._core.settings.videoHeight,\n\t\t    url = target.attr('href');\n\n\t\tif (url) {\n\n\t\t\t/*\n   \t\tParses the id's out of the following urls (and probably more):\n   \t\thttps://www.youtube.com/watch?v=:id\n   \t\thttps://youtu.be/:id\n   \t\thttps://vimeo.com/:id\n   \t\thttps://vimeo.com/channels/:channel/:id\n   \t\thttps://vimeo.com/groups/:group/videos/:id\n   \t\thttps://app.vzaar.com/videos/:id\n   \t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n   */\n\n\t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n\t\t\tif (id[3].indexOf('youtu') > -1) {\n\t\t\t\ttype = 'youtube';\n\t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n\t\t\t\ttype = 'vimeo';\n\t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n\t\t\t\ttype = 'vzaar';\n\t\t\t} else {\n\t\t\t\tthrow new Error('Video URL not supported.');\n\t\t\t}\n\t\t\tid = id[6];\n\t\t} else {\n\t\t\tthrow new Error('Missing video URL.');\n\t\t}\n\n\t\tthis._videos[url] = {\n\t\t\ttype: type,\n\t\t\tid: id,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\titem.attr('data-video', url);\n\n\t\tthis.thumbnail(target, this._videos[url]);\n\t};\n\n\t/**\n  * Creates video thumbnail.\n  * @protected\n  * @param {jQuery} target - The target containing the video data.\n  * @param {Object} info - The video info object.\n  * @see `fetch`\n  */\n\tVideo.prototype.thumbnail = function (target, video) {\n\t\tvar tnLink,\n\t\t    icon,\n\t\t    path,\n\t\t    dimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n\t\t    customTn = target.find('img'),\n\t\t    srcType = 'src',\n\t\t    lazyClass = '',\n\t\t    settings = this._core.settings,\n\t\t    create = function create(path) {\n\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n\t\t\tif (settings.lazyLoad) {\n\t\t\t\ttnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n\t\t\t} else {\n\t\t\t\ttnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n\t\t\t}\n\t\t\ttarget.after(tnLink);\n\t\t\ttarget.after(icon);\n\t\t};\n\n\t\t// wrap video content into owl-video-wrapper div\n\t\ttarget.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n\t\tif (this._core.settings.lazyLoad) {\n\t\t\tsrcType = 'data-src';\n\t\t\tlazyClass = 'owl-lazy';\n\t\t}\n\n\t\t// custom thumbnail\n\t\tif (customTn.length) {\n\t\t\tcreate(customTn.attr(srcType));\n\t\t\tcustomTn.remove();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (video.type === 'youtube') {\n\t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n\t\t\tcreate(path);\n\t\t} else if (video.type === 'vimeo') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\tpath = data[0].thumbnail_large;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (video.type === 'vzaar') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\tpath = data.framegrab_url;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Stops the current video.\n  * @public\n  */\n\tVideo.prototype.stop = function () {\n\t\tthis._core.trigger('stop', null, 'video');\n\t\tthis._playing.find('.owl-video-frame').remove();\n\t\tthis._playing.removeClass('owl-video-playing');\n\t\tthis._playing = null;\n\t\tthis._core.leave('playing');\n\t\tthis._core.trigger('stopped', null, 'video');\n\t};\n\n\t/**\n  * Starts the current video.\n  * @public\n  * @param {Event} event - The event arguments.\n  */\n\tVideo.prototype.play = function (event) {\n\t\tvar target = $(event.target),\n\t\t    item = target.closest('.' + this._core.settings.itemClass),\n\t\t    video = this._videos[item.attr('data-video')],\n\t\t    width = video.width || '100%',\n\t\t    height = video.height || this._core.$stage.height(),\n\t\t    html;\n\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('playing');\n\t\tthis._core.trigger('play', null, 'video');\n\n\t\titem = this._core.items(this._core.relative(item.index()));\n\n\t\tthis._core.reset(item.index());\n\n\t\tif (video.type === 'youtube') {\n\t\t\thtml = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vimeo') {\n\t\t\thtml = '<iframe src=\"//player.vimeo.com/video/' + video.id + '?autoplay=1\" width=\"' + width + '\" height=\"' + height + '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vzaar') {\n\t\t\thtml = '<iframe frameborder=\"0\"' + 'height=\"' + height + '\"' + 'width=\"' + width + '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' + 'src=\"//view.vzaar.com/' + video.id + '/player?autoplay=true\"></iframe>';\n\t\t}\n\n\t\t$('<div class=\"owl-video-frame\">' + html + '</div>').insertAfter(item.find('.owl-video'));\n\n\t\tthis._playing = item.addClass('owl-video-playing');\n\t};\n\n\t/**\n  * Checks whether an video is currently in full screen mode or not.\n  * @todo Bad style because looks like a readonly method but changes members.\n  * @protected\n  * @returns {Boolean}\n  */\n\tVideo.prototype.isInFullScreen = function () {\n\t\tvar element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;\n\n\t\treturn element && $(element).parent().hasClass('owl-video-frame');\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tVideo.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tthis._core.$element.off('click.owl.video');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the animate plugin.\n  * @class The Navigation Plugin\n  * @param {Owl} scope - The Owl Carousel\n  */\n\tvar Animate = function Animate(scope) {\n\t\tthis.core = scope;\n\t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n\t\tthis.swapping = true;\n\t\tthis.previous = undefined;\n\t\tthis.next = undefined;\n\n\t\tthis.handlers = {\n\t\t\t'change.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.previous = this.core.current();\n\t\t\t\t\tthis.next = e.property.value;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.swapping = e.type == 'translated';\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'translate.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n\t\t\t\t\tthis.swap();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\tthis.core.$element.on(this.handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAnimate.Defaults = {\n\t\tanimateOut: false,\n\t\tanimateIn: false\n\t};\n\n\t/**\n  * Toggles the animation classes whenever an translations starts.\n  * @protected\n  * @returns {Boolean|undefined}\n  */\n\tAnimate.prototype.swap = function () {\n\n\t\tif (this.core.settings.items !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$.support.animation || !$.support.transition) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.core.speed(0);\n\n\t\tvar left,\n\t\t    clear = $.proxy(this.clear, this),\n\t\t    previous = this.core.$stage.children().eq(this.previous),\n\t\t    next = this.core.$stage.children().eq(this.next),\n\t\t    incoming = this.core.settings.animateIn,\n\t\t    outgoing = this.core.settings.animateOut;\n\n\t\tif (this.core.current() === this.previous) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (outgoing) {\n\t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n\t\t\tprevious.one($.support.animation.end, clear).css({ 'left': left + 'px' }).addClass('animated owl-animated-out').addClass(outgoing);\n\t\t}\n\n\t\tif (incoming) {\n\t\t\tnext.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);\n\t\t}\n\t};\n\n\tAnimate.prototype.clear = function (e) {\n\t\t$(e.target).css({ 'left': '' }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);\n\t\tthis.core.onTransitionEnd();\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tAnimate.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the autoplay plugin.\n  * @class The Autoplay Plugin\n  * @param {Owl} scope - The Owl Carousel\n  */\n\tvar Autoplay = function Autoplay(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * The autoplay timeout.\n   * @type {Timeout}\n   */\n\t\tthis._timeout = null;\n\n\t\t/**\n   * Indicates whenever the autoplay is paused.\n   * @type {Boolean}\n   */\n\t\tthis._paused = false;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'settings') {\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t} else if (e.namespace && e.property.name === 'position') {\n\t\t\t\t\t//console.log('play?', e);\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis._setAutoPlayInterval();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'play.owl.autoplay': $.proxy(function (e, t, s) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.play(t, s);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'stop.owl.autoplay': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseover.owl.autoplay': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseleave.owl.autoplay': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchstart.owl.core': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchend.owl.core': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoplay.Defaults = {\n\t\tautoplay: false,\n\t\tautoplayTimeout: 5000,\n\t\tautoplayHoverPause: false,\n\t\tautoplaySpeed: false\n\t};\n\n\t/**\n  * Starts the autoplay.\n  * @public\n  * @param {Number} [timeout] - The interval before the next animation starts.\n  * @param {Number} [speed] - The animation speed for the animations.\n  */\n\tAutoplay.prototype.play = function (timeout, speed) {\n\t\tthis._paused = false;\n\n\t\tif (this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('rotating');\n\n\t\tthis._setAutoPlayInterval();\n\t};\n\n\t/**\n  * Gets a new timeout\n  * @private\n  * @param {Number} [timeout] - The interval before the next animation starts.\n  * @param {Number} [speed] - The animation speed for the animations.\n  * @return {Timeout}\n  */\n\tAutoplay.prototype._getNextTimeout = function (timeout, speed) {\n\t\tif (this._timeout) {\n\t\t\twindow.clearTimeout(this._timeout);\n\t\t}\n\t\treturn window.setTimeout($.proxy(function () {\n\t\t\tif (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n\t\t}, this), timeout || this._core.settings.autoplayTimeout);\n\t};\n\n\t/**\n  * Sets autoplay in motion.\n  * @private\n  */\n\tAutoplay.prototype._setAutoPlayInterval = function () {\n\t\tthis._timeout = this._getNextTimeout();\n\t};\n\n\t/**\n  * Stops the autoplay.\n  * @public\n  */\n\tAutoplay.prototype.stop = function () {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.clearTimeout(this._timeout);\n\t\tthis._core.leave('rotating');\n\t};\n\n\t/**\n  * Stops the autoplay.\n  * @public\n  */\n\tAutoplay.prototype.pause = function () {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._paused = true;\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tAutoplay.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tthis.stop();\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n  * Creates the navigation plugin.\n  * @class The Navigation Plugin\n  * @param {Owl} carousel - The Owl Carousel.\n  */\n\n\tvar Navigation = function Navigation(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Indicates whether the plugin is initialized or not.\n   * @protected\n   * @type {Boolean}\n   */\n\t\tthis._initialized = false;\n\n\t\t/**\n   * The current paging indexes.\n   * @protected\n   * @type {Array}\n   */\n\t\tthis._pages = [];\n\n\t\t/**\n   * All DOM elements of the user interface.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._controls = {};\n\n\t\t/**\n   * Markup for an indicator.\n   * @protected\n   * @type {Array.<String>}\n   */\n\t\tthis._templates = [];\n\n\t\t/**\n   * The carousel element.\n   * @type {jQuery}\n   */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n   * Overridden methods of the carousel.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._overrides = {\n\t\t\tnext: this._core.next,\n\t\t\tprev: this._core.prev,\n\t\t\tto: this._core.to\n\t\t};\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' + $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'added.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'remove.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 1);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.draw();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && !this._initialized) {\n\t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n\t\t\t\t\tthis.initialize();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._initialized) {\n\t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  * @todo Rename `slideBy` to `navBy`\n  */\n\tNavigation.Defaults = {\n\t\tnav: false,\n\t\tnavText: ['prev', 'next'],\n\t\tnavSpeed: false,\n\t\tnavElement: 'div',\n\t\tnavContainer: false,\n\t\tnavContainerClass: 'owl-nav',\n\t\tnavClass: ['owl-prev', 'owl-next'],\n\t\tslideBy: 1,\n\t\tdotClass: 'owl-dot',\n\t\tdotsClass: 'owl-dots',\n\t\tdots: true,\n\t\tdotsEach: false,\n\t\tdotsData: false,\n\t\tdotsSpeed: false,\n\t\tdotsContainer: false\n\t};\n\n\t/**\n  * Initializes the layout of the plugin and extends the carousel.\n  * @protected\n  */\n\tNavigation.prototype.initialize = function () {\n\t\tvar override,\n\t\t    settings = this._core.settings;\n\n\t\t// create DOM structure for relative navigation\n\t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function (e) {\n\t\t\tthis.prev(settings.navSpeed);\n\t\t}, this));\n\t\tthis._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function (e) {\n\t\t\tthis.next(settings.navSpeed);\n\t\t}, this));\n\n\t\t// create DOM structure for absolute navigation\n\t\tif (!settings.dotsData) {\n\t\t\tthis._templates = [$('<div>').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];\n\t\t}\n\n\t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$absolute.on('click', 'div', $.proxy(function (e) {\n\t\t\tvar index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();\n\n\t\t\te.preventDefault();\n\n\t\t\tthis.to(index, settings.dotsSpeed);\n\t\t}, this));\n\n\t\t// override public methods of the carousel\n\t\tfor (override in this._overrides) {\n\t\t\tthis._core[override] = $.proxy(this[override], this);\n\t\t}\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @protected\n  */\n\tNavigation.prototype.destroy = function () {\n\t\tvar handler, control, property, override;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (control in this._controls) {\n\t\t\tthis._controls[control].remove();\n\t\t}\n\t\tfor (override in this.overides) {\n\t\t\tthis._core[override] = this._overrides[override];\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t/**\n  * Updates the internal state.\n  * @protected\n  */\n\tNavigation.prototype.update = function () {\n\t\tvar i,\n\t\t    j,\n\t\t    k,\n\t\t    lower = this._core.clones().length / 2,\n\t\t    upper = lower + this._core.items().length,\n\t\t    maximum = this._core.maximum(true),\n\t\t    settings = this._core.settings,\n\t\t    size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;\n\n\t\tif (settings.slideBy !== 'page') {\n\t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n\t\t}\n\n\t\tif (settings.dots || settings.slideBy == 'page') {\n\t\t\tthis._pages = [];\n\n\t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n\t\t\t\tif (j >= size || j === 0) {\n\t\t\t\t\tthis._pages.push({\n\t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n\t\t\t\t\t\tend: i - lower + size - 1\n\t\t\t\t\t});\n\t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj = 0, ++k;\n\t\t\t\t}\n\t\t\t\tj += this._core.mergers(this._core.relative(i));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Draws the user interface.\n  * @todo The option `dotsData` wont work.\n  * @protected\n  */\n\tNavigation.prototype.draw = function () {\n\t\tvar difference,\n\t\t    settings = this._core.settings,\n\t\t    disabled = this._core.items().length <= settings.items,\n\t\t    index = this._core.relative(this._core.current()),\n\t\t    loop = settings.loop || settings.rewind;\n\n\t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n\t\tif (settings.nav) {\n\t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n\t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n\t\t}\n\n\t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n\t\tif (settings.dots) {\n\t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n\t\t\tif (settings.dotsData && difference !== 0) {\n\t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n\t\t\t} else if (difference > 0) {\n\t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n\t\t\t} else if (difference < 0) {\n\t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n\t\t\t}\n\n\t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n\t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n\t\t}\n\t};\n\n\t/**\n  * Extends event data.\n  * @protected\n  * @param {Event} event - The event object which gets thrown.\n  */\n\tNavigation.prototype.onTrigger = function (event) {\n\t\tvar settings = this._core.settings;\n\n\t\tevent.page = {\n\t\t\tindex: $.inArray(this.current(), this._pages),\n\t\t\tcount: this._pages.length,\n\t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)\n\t\t};\n\t};\n\n\t/**\n  * Gets the current page position of the carousel.\n  * @protected\n  * @returns {Number}\n  */\n\tNavigation.prototype.current = function () {\n\t\tvar current = this._core.relative(this._core.current());\n\t\treturn $.grep(this._pages, $.proxy(function (page, index) {\n\t\t\treturn page.start <= current && page.end >= current;\n\t\t}, this)).pop();\n\t};\n\n\t/**\n  * Gets the current succesor/predecessor position.\n  * @protected\n  * @returns {Number}\n  */\n\tNavigation.prototype.getPosition = function (successor) {\n\t\tvar position,\n\t\t    length,\n\t\t    settings = this._core.settings;\n\n\t\tif (settings.slideBy == 'page') {\n\t\t\tposition = $.inArray(this.current(), this._pages);\n\t\t\tlength = this._pages.length;\n\t\t\tsuccessor ? ++position : --position;\n\t\t\tposition = this._pages[(position % length + length) % length].start;\n\t\t} else {\n\t\t\tposition = this._core.relative(this._core.current());\n\t\t\tlength = this._core.items().length;\n\t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Slides to the next item or page.\n  * @public\n  * @param {Number} [speed=false] - The time in milliseconds for the transition.\n  */\n\tNavigation.prototype.next = function (speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n\t};\n\n\t/**\n  * Slides to the previous item or page.\n  * @public\n  * @param {Number} [speed=false] - The time in milliseconds for the transition.\n  */\n\tNavigation.prototype.prev = function (speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n\t};\n\n\t/**\n  * Slides to the specified item or page.\n  * @public\n  * @param {Number} position - The position of the item or page.\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n  */\n\tNavigation.prototype.to = function (position, speed, standard) {\n\t\tvar length;\n\n\t\tif (!standard && this._pages.length) {\n\t\t\tlength = this._pages.length;\n\t\t\t$.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed);\n\t\t} else {\n\t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n  * Creates the hash plugin.\n  * @class The Hash Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\n\tvar Hash = function Hash(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Hash index for the items.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._hashes = {};\n\n\t\t/**\n   * The carousel element.\n   * @type {jQuery}\n   */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n\t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n\t\t\t\t\tif (!hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._hashes[hash] = e.content;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position') {\n\t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n\t\t\t\t\t    hash = $.map(this._hashes, function (item, hash) {\n\t\t\t\t\t\treturn item === current ? hash : null;\n\t\t\t\t\t}).join();\n\n\t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = hash;\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n\t\t// register the event handlers\n\t\tthis.$element.on(this._handlers);\n\n\t\t// register event listener for hash navigation\n\t\t$(window).on('hashchange.owl.navigation', $.proxy(function (e) {\n\t\t\tvar hash = window.location.hash.substring(1),\n\t\t\t    items = this._core.$stage.children(),\n\t\t\t    position = this._hashes[hash] && items.index(this._hashes[hash]);\n\n\t\t\tif (position === undefined || position === this._core.current()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._core.to(this._core.relative(position), false, true);\n\t\t}, this));\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tHash.Defaults = {\n\t\tURLhashListener: false\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tHash.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\t$(window).off('hashchange.owl.navigation');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.1.0\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\tvar style = $('<support>').get(0).style,\n\t    prefixes = 'Webkit Moz O ms'.split(' '),\n\t    events = {\n\t\ttransition: {\n\t\t\tend: {\n\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\t\t\tMozTransition: 'transitionend',\n\t\t\t\tOTransition: 'oTransitionEnd',\n\t\t\t\ttransition: 'transitionend'\n\t\t\t}\n\t\t},\n\t\tanimation: {\n\t\t\tend: {\n\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n\t\t\t\tMozAnimation: 'animationend',\n\t\t\t\tOAnimation: 'oAnimationEnd',\n\t\t\t\tanimation: 'animationend'\n\t\t\t}\n\t\t}\n\t},\n\t    tests = {\n\t\tcsstransforms: function csstransforms() {\n\t\t\treturn !!test('transform');\n\t\t},\n\t\tcsstransforms3d: function csstransforms3d() {\n\t\t\treturn !!test('perspective');\n\t\t},\n\t\tcsstransitions: function csstransitions() {\n\t\t\treturn !!test('transition');\n\t\t},\n\t\tcssanimations: function cssanimations() {\n\t\t\treturn !!test('animation');\n\t\t}\n\t};\n\n\tfunction test(property, prefixed) {\n\t\tvar result = false,\n\t\t    upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n\t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {\n\t\t\tif (style[property] !== undefined) {\n\t\t\t\tresult = prefixed ? property : true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction prefixed(property) {\n\t\treturn test(property, true);\n\t}\n\n\tif (tests.csstransitions()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transition = new String(prefixed('transition'));\n\t\t$.support.transition.end = events.transition.end[$.support.transition];\n\t}\n\n\tif (tests.cssanimations()) {\n\t\t/* jshint -W053 */\n\t\t$.support.animation = new String(prefixed('animation'));\n\t\t$.support.animation.end = events.animation.end[$.support.animation];\n\t}\n\n\tif (tests.csstransforms()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transform = new String(prefixed('transform'));\n\t\t$.support.transform3d = tests.csstransforms3d();\n\t}\n})(window.Zepto || window.jQuery, window, document);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/owl.carousel.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.js?");

			/***/
		},
		/* 2 */
		/***/function (module, exports, __webpack_require__) {

			eval("exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.id, \"/**\\n * Owl Carousel v2.2.1\\n * Copyright 2013-2017 David Deutsch\\n * Licensed under  ()\\n */\\n/*\\n *  Owl Carousel - Core\\n */\\n.owl-carousel {\\n  display: none;\\n  width: 100%;\\n  -webkit-tap-highlight-color: transparent;\\n  /* position relative and z-index fix webkit rendering fonts issue */\\n  position: relative;\\n  z-index: 1; }\\n  .owl-carousel .owl-stage {\\n    position: relative;\\n    -ms-touch-action: pan-Y;\\n    -moz-backface-visibility: hidden;\\n    /* fix firefox animation glitch */ }\\n  .owl-carousel .owl-stage:after {\\n    content: \\\".\\\";\\n    display: block;\\n    clear: both;\\n    visibility: hidden;\\n    line-height: 0;\\n    height: 0; }\\n  .owl-carousel .owl-stage-outer {\\n    position: relative;\\n    overflow: hidden;\\n    /* fix for flashing background */\\n    -webkit-transform: translate3d(0px, 0px, 0px); }\\n  .owl-carousel .owl-wrapper,\\n  .owl-carousel .owl-item {\\n    -webkit-backface-visibility: hidden;\\n    -moz-backface-visibility: hidden;\\n    -ms-backface-visibility: hidden;\\n    -webkit-transform: translate3d(0, 0, 0);\\n    -moz-transform: translate3d(0, 0, 0);\\n    -ms-transform: translate3d(0, 0, 0); }\\n  .owl-carousel .owl-item {\\n    position: relative;\\n    min-height: 1px;\\n    float: left;\\n    -webkit-backface-visibility: hidden;\\n    -webkit-tap-highlight-color: transparent;\\n    -webkit-touch-callout: none; }\\n  .owl-carousel .owl-item img {\\n    display: block;\\n    width: 100%; }\\n  .owl-carousel .owl-nav.disabled,\\n  .owl-carousel .owl-dots.disabled {\\n    display: none; }\\n  .owl-carousel .owl-nav .owl-prev,\\n  .owl-carousel .owl-nav .owl-next,\\n  .owl-carousel .owl-dot {\\n    cursor: pointer;\\n    cursor: hand;\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel.owl-loaded {\\n    display: block; }\\n  .owl-carousel.owl-loading {\\n    opacity: 0;\\n    display: block; }\\n  .owl-carousel.owl-hidden {\\n    opacity: 0; }\\n  .owl-carousel.owl-refresh .owl-item {\\n    visibility: hidden; }\\n  .owl-carousel.owl-drag .owl-item {\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel.owl-grab {\\n    cursor: move;\\n    cursor: -webkit-grab;\\n    cursor: grab; }\\n  .owl-carousel.owl-rtl {\\n    direction: rtl; }\\n  .owl-carousel.owl-rtl .owl-item {\\n    float: right; }\\n\\n/* No Js */\\n.no-js .owl-carousel {\\n  display: block; }\\n\\n/*\\n *  Owl Carousel - Animate Plugin\\n */\\n.owl-carousel .animated {\\n  -webkit-animation-duration: 1000ms;\\n          animation-duration: 1000ms;\\n  -webkit-animation-fill-mode: both;\\n          animation-fill-mode: both; }\\n\\n.owl-carousel .owl-animated-in {\\n  z-index: 0; }\\n\\n.owl-carousel .owl-animated-out {\\n  z-index: 1; }\\n\\n.owl-carousel .fadeOut {\\n  -webkit-animation-name: fadeOut;\\n          animation-name: fadeOut; }\\n\\n@-webkit-keyframes fadeOut {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n@keyframes fadeOut {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n/*\\n * \\tOwl Carousel - Auto Height Plugin\\n */\\n.owl-height {\\n  transition: height 500ms ease-in-out; }\\n\\n/*\\n * \\tOwl Carousel - Lazy Load Plugin\\n */\\n.owl-carousel .owl-item .owl-lazy {\\n  opacity: 0;\\n  transition: opacity 400ms ease; }\\n\\n.owl-carousel .owl-item img.owl-lazy {\\n  -webkit-transform-style: preserve-3d;\\n          transform-style: preserve-3d; }\\n\\n/*\\n * \\tOwl Carousel - Video Plugin\\n */\\n.owl-carousel .owl-video-wrapper {\\n  position: relative;\\n  height: 100%;\\n  background: #000; }\\n\\n.owl-carousel .owl-video-play-icon {\\n  position: absolute;\\n  height: 80px;\\n  width: 80px;\\n  left: 50%;\\n  top: 50%;\\n  margin-left: -40px;\\n  margin-top: -40px;\\n  /* background: url(\\\"owl.video.play.png\\\") no-repeat; */\\n  cursor: pointer;\\n  z-index: 1;\\n  -webkit-backface-visibility: hidden;\\n  transition: -webkit-transform 100ms ease;\\n  transition: transform 100ms ease;\\n  transition: transform 100ms ease, -webkit-transform 100ms ease; }\\n\\n.owl-carousel .owl-video-play-icon:hover {\\n  -webkit-transform: scale(1.3, 1.3);\\n          transform: scale(1.3, 1.3); }\\n\\n.owl-carousel .owl-video-playing .owl-video-tn,\\n.owl-carousel .owl-video-playing .owl-video-play-icon {\\n  display: none; }\\n\\n.owl-carousel .owl-video-tn {\\n  opacity: 0;\\n  height: 100%;\\n  background-position: center center;\\n  background-repeat: no-repeat;\\n  background-size: contain;\\n  transition: opacity 400ms ease; }\\n\\n.owl-carousel .owl-video-frame {\\n  position: relative;\\n  z-index: 1;\\n  height: 100%;\\n  width: 100%; }\\n\", \"\"]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/postcss-loader!./src/owl.carousel.css\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.css?./~/css-loader!./~/postcss-loader");

			/***/
		},
		/* 3 */
		/***/function (module, exports) {

			eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?");

			/***/
		},
		/* 4 */
		/***/function (module, exports, __webpack_require__) {

			eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(false) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?");

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(2);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!./owl.carousel.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!./owl.carousel.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/owl.carousel.css\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.css?");

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22PropTypes%22,%22commonjs2%22:%22prop-types%22,%22commonjs%22:%22prop-types%22,%22amd%22:%22prop-types%22%7D?");

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?");

			/***/
		},
		/* 8 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"ReactDOM\",\"commonjs2\":\"react-dom\",\"commonjs\":\"react-dom\",\"amd\":\"react-dom\"}\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22ReactDOM%22,%22commonjs2%22:%22react-dom%22,%22commonjs%22:%22react-dom%22,%22amd%22:%22react-dom%22%7D?");

			/***/
		}
		/******/])
	);
});
;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(3);
var invariant = __webpack_require__(5);
var warning = __webpack_require__(7);
var assign = __webpack_require__(4);

var ReactPropTypesSecret = __webpack_require__(9);
var checkPropTypes = __webpack_require__(8);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(3);
var invariant = __webpack_require__(5);
var ReactPropTypesSecret = __webpack_require__(9);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgZjJmYjUzMWIwYzU5NGExOGZlZGQiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9jb21wb25lbnRzL2Jhc2ljaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvY29tcG9uZW50cy9iaW8uanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvdGVjaHNraWxscy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvY29tcG9uZW50cy9za2lsbHNsaXN0LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9jb21wb25lbnRzL2V4cGVyaWVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvZXhwZXJpZW5zZWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvcHJvamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW93bC1jYXJvdXNlbDIvbGliL093bENhcm91c2VsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiYmluZCIsImlzQnVmZmVyIiwidG9TdHJpbmciLCJPYmplY3QiLCJpc0FycmF5IiwidmFsIiwiaXNBcnJheUJ1ZmZlciIsImlzRm9ybURhdGEiLCJGb3JtRGF0YSIsImlzQXJyYXlCdWZmZXJWaWV3IiwicmVzdWx0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNVbmRlZmluZWQiLCJpc09iamVjdCIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzRnVuY3Rpb24iLCJpc1N0cmVhbSIsInBpcGUiLCJpc1VSTFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0Iiwid2luZG93IiwiZG9jdW1lbnQiLCJmb3JFYWNoIiwib2JqIiwiZm4iLCJsIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwiZXh0ZW5kIiwiYSIsImIiLCJ0aGlzQXJnIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJlbXB0eUZ1bmN0aW9uIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJrZXlzIiwiZXJyIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImMiLCJkIiwiZiIsImVycm9yIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwiY2hlY2tEQ0UiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJ1dGlscyIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImhlYWRlcnMiLCJ2YWx1ZSIsImdldERlZmF1bHRBZGFwdGVyIiwiYWRhcHRlciIsIlhNTEh0dHBSZXF1ZXN0IiwiZGVmYXVsdHMiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInBhcnNlIiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsInN0YXR1cyIsImNvbW1vbiIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJtZXRob2QiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJjYW5Vc2VET00iLCJjcmVhdGVFbGVtZW50IiwiRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJjYW5Vc2VXb3JrZXJzIiwiV29ya2VyIiwiY2FuVXNlRXZlbnRMaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjYW5Vc2VWaWV3cG9ydCIsInNjcmVlbiIsImlzSW5Xb3JrZXIiLCJFdmVudExpc3RlbmVyIiwibGlzdGVuIiwiZXZlbnRUeXBlIiwiY2FsbGJhY2siLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJjYXB0dXJlIiwicmVnaXN0ZXJEZWZhdWx0IiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiaXMiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiaXNUZXh0Tm9kZSIsImNvbnRhaW5zTm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwibm9kZSIsImZvY3VzIiwid3JhcCIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJidG9hIiwieGhyQWRhcHRlciIsImNvbmZpZyIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3QiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJ1cmwiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwib3BlbiIsInRvVXBwZXJDYXNlIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1c1RleHQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJjb29raWVzIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwicmVhZCIsInNldFJlcXVlc3RIZWFkZXIiLCJ0b0xvd2VyQ2FzZSIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsInByb21pc2UiLCJ0aGVuIiwib25DYW5jZWxlZCIsImNhbmNlbCIsImFib3J0Iiwic2VuZCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJpc0NhbmNlbCIsIl9fQ0FOQ0VMX18iLCJDYW5jZWwiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsInJlbmRlciIsInF1ZXJ5U2VsZWN0b3IiLCJtIiwicCIsInEiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyIiwiaXNNb3VudGVkIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsInQiLCJwcm9wcyIsImNvbnRleHQiLCJyZWZzIiwidXBkYXRlciIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwidSIsInYiLCJ3IiwiY29uc3RydWN0b3IiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsInVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCIsImNoaWxkcmVuIiwieiIsImN1cnJlbnQiLCJBIiwiQiIsIkMiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsIkQiLCJoIiwiayIsImciLCJkZWZhdWx0UHJvcHMiLCJ0eXBlIiwiX293bmVyIiwiRSIsIkYiLCJpdGVyYXRvciIsIkciLCJIIiwiZXNjYXBlIiwiSSIsIkoiLCJLIiwicG9wIiwia2V5UHJlZml4IiwiZnVuYyIsImNvdW50IiwiTCIsIk0iLCJOIiwibmV4dCIsImRvbmUiLCJPIiwiUCIsIlEiLCJSIiwiQ2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seSIsIkNvbXBvbmVudCIsIlB1cmVDb21wb25lbnQiLCJ1bnN0YWJsZV9Bc3luY0NvbXBvbmVudCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUyIsImRlZmF1bHQiLCJUIiwiX2Fzc2lnbiIsIlJlYWN0VmVyc2lvbiIsImVuYWJsZVJlYWN0RnJhZ21lbnQiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImRpc3BsYXlOYW1lIiwid2FybmluZ0tleSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiY29tcGxldGVTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwibWV0aG9kTmFtZSIsImluZm8iLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImZuTmFtZSIsIkNvbXBvbmVudER1bW15IiwicHVyZUNvbXBvbmVudFByb3RvdHlwZSIsIkFzeW5jQ29tcG9uZW50IiwiYXN5bmNDb21wb25lbnRQcm90b3R5cGUiLCJSRUFDVF9FTEVNRU5UX1RZUEUkMSIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwib3duZXIiLCJlbGVtZW50IiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwibWF0Y2giLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwiUE9PTF9TSVpFIiwidHJhdmVyc2VDb250ZXh0UG9vbCIsImdldFBvb2xlZFRyYXZlcnNlQ29udGV4dCIsIm1hcFJlc3VsdCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInRyYXZlcnNlQ29udGV4dCIsInJlbGVhc2VUcmF2ZXJzZUNvbnRleHQiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsImdldENvbXBvbmVudEtleSIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsImlpIiwiYWRkZW5kdW0iLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJjb21wb25lbnQiLCJpbmRleCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJnZXREaXNwbGF5TmFtZSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUkMSIsIlZBTElEX0ZSQUdNRU5UX1BST1BTIiwiTWFwIiwiSVRFUkFUT1JfU1lNQk9MJDEiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCQxIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJwcm9wVHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImhhcyIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUmVhY3QiLCJGcmFnbWVudCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiYWEiLCJjYSIsImRhIiwiZWEiLCJoYSIsImlhIiwibGEiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGVja2VkIiwiaW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwic3R5bGUiLCJxYSIsInJhIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwic2EiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJoYXNTdHJpbmdCb29sZWFuVmFsdWUiLCJ0YSIsInVhIiwic2xpY2UiLCJ2YSIsIndhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJhbGxvd0Z1bGxTY3JlZW4iLCJhdXRvRm9jdXMiLCJhc3luYyIsImF1dG9QbGF5IiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImZvcm1Ob1ZhbGlkYXRlIiwiaGlkZGVuIiwibG9vcCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub1ZhbGlkYXRlIiwicGxheXNJbmxpbmUiLCJyZWFkT25seSIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb3dzIiwicm93U3BhbiIsInNjb3BlZCIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaXplIiwic3RhcnQiLCJzcGFuIiwic3BlbGxDaGVjayIsInRhYkluZGV4IiwiaXRlbVNjb3BlIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJyZW1vdmVBdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ2YWxpZGl0eSIsImJhZElucHV0Iiwib3duZXJEb2N1bWVudCIsIkJhIiwieGxpbmsiLCJ4bWwiLCJDYSIsImF1dG9SZXZlcnNlIiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsInByZXNlcnZlQWxwaGEiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbExhbmciLCJ4bWxTcGFjZSIsIkRhIiwiRWEiLCJfY2F1Z2h0RXJyb3IiLCJfaGFzQ2F1Z2h0RXJyb3IiLCJfcmV0aHJvd0Vycm9yIiwiX2hhc1JldGhyb3dFcnJvciIsImluamVjdGlvbiIsImluamVjdEVycm9yVXRpbHMiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJIYSIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsImhhc0NhdWdodEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsIklhIiwiSmEiLCJLYSIsIkxhIiwiTWEiLCJleHRyYWN0RXZlbnRzIiwiZXZlbnRUeXBlcyIsIk5hIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJPYSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJQYSIsIlFhIiwiZGVwZW5kZW5jaWVzIiwiUmEiLCJTYSIsIlRhIiwicGx1Z2lucyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiVWEiLCJWYSIsIldhIiwiWGEiLCJjdXJyZW50VGFyZ2V0IiwiWWEiLCJaYSIsIiRhIiwiYWIiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzUGVyc2lzdGVudCIsInJlbGVhc2UiLCJiYiIsImNiIiwiZGIiLCJlYiIsInN0YXRlTm9kZSIsImpiIiwia2IiLCJsYiIsIm1iIiwiZ2V0TGlzdGVuZXIiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJuYiIsIk1hdGgiLCJyYW5kb20iLCJvYiIsInBiIiwidGFnIiwicWIiLCJyYiIsInNiIiwicHJlY2FjaGVGaWJlck5vZGUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJ0YiIsInViIiwiZGlzcGF0Y2hDb25maWciLCJ2YiIsIl90YXJnZXRJbnN0Iiwid2IiLCJ4YiIsInliIiwiemIiLCJBYiIsImFsdGVybmF0ZSIsIkJiIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJDYiIsIkRiIiwiZG9jdW1lbnRFbGVtZW50IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsIkViIiwiRmIiLCJHYiIsIkhiIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJuYXRpdmVFdmVudCIsIkludGVyZmFjZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInJldHVyblZhbHVlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZGVzdHJ1Y3RvciIsImF1Z21lbnRDbGFzcyIsIkliIiwiSmIiLCJldmVudFBvb2wiLCJRYiIsImdldFBvb2xlZCIsIlJiIiwiU2IiLCJUYiIsIlViIiwiVmIiLCJkb2N1bWVudE1vZGUiLCJXYiIsIlhiIiwib3BlcmEiLCJwYXJzZUludCIsIlliIiwiWmIiLCIkYiIsImFjIiwiYmVmb3JlSW5wdXQiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImJjIiwiY2MiLCJrZXlDb2RlIiwiZGMiLCJkZXRhaWwiLCJlYyIsImZjIiwid2hpY2giLCJnYyIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiY2hhciIsImhjIiwiaWMiLCJqYyIsImtjIiwibGMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlIiwibWMiLCJpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50IiwibmMiLCJvYyIsInBjIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicWMiLCJyYyIsInNjIiwidGMiLCJjb2xvciIsImRhdGUiLCJkYXRldGltZSIsImVtYWlsIiwibW9udGgiLCJudW1iZXIiLCJyYW5nZSIsInNlYXJjaCIsInRlbCIsInRpbWUiLCJ3ZWVrIiwidWMiLCJub2RlTmFtZSIsInZjIiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50Iiwibm9kZVR5cGUiLCJ3YyIsImltcGxlbWVudGF0aW9uIiwiaGFzRmVhdHVyZSIsInhjIiwieWMiLCJ6YyIsInNldCIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJfdmFsdWVUcmFja2VyIiwiQWMiLCJCYyIsIkNjIiwiY2hhbmdlIiwiRGMiLCJFYyIsIkZjIiwiR2MiLCJIYyIsIkljIiwiSmMiLCJRYyIsIlJjIiwiU2MiLCJUYyIsIlVjIiwiVmMiLCJXYyIsIl9pc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJfd3JhcHBlclN0YXRlIiwiY29udHJvbGxlZCIsImdldEF0dHJpYnV0ZSIsIlhjIiwidmlldyIsIlljIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIlpjIiwiZ2V0TW9kaWZpZXJTdGF0ZSIsIiRjIiwiYWQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwiYnV0dG9uIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImJkIiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJjZCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZGQiLCJlZCIsImZkIiwiZWZmZWN0VGFnIiwiZ2QiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwiaGQiLCJpZCIsInNpYmxpbmciLCJqZCIsImtkIiwibGQiLCJtZCIsInRhcmdldEluc3QiLCJhbmNlc3RvcnMiLCJjb250YWluZXJJbmZvIiwibmQiLCJ0b3BMZXZlbFR5cGUiLCJvZCIsInBkIiwiVSIsInFkIiwicmQiLCJzZCIsIl9lbmFibGVkIiwiX2hhbmRsZVRvcExldmVsIiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInRkIiwidWQiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJ2ZCIsIndkIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInhkIiwieWQiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQmx1ciIsInRvcENhbmNlbCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ2xvc2UiLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZCIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvZ2dsZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsInpkIiwiQWQiLCJCZCIsIkNkIiwiRGQiLCJmaXJzdENoaWxkIiwiRWQiLCJ0ZXh0Q29udGVudCIsIm9mZnNldCIsIm5leHRTaWJsaW5nIiwiRmQiLCJHZCIsIkhkIiwic2VsZWN0IiwiSWQiLCJKZCIsIktkIiwiTGQiLCJNZCIsInNlbGVjdGlvblN0YXJ0IiwiZW5kIiwic2VsZWN0aW9uRW5kIiwiZ2V0U2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiTmQiLCJvblNlbGVjdCIsIk9kIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlBkIiwiY2xpcGJvYXJkRGF0YSIsIlFkIiwiUmQiLCJjaGFyQ29kZSIsIlNkIiwiRXNjIiwiU3BhY2ViYXIiLCJMZWZ0IiwiVXAiLCJSaWdodCIsIkRvd24iLCJEZWwiLCJXaW4iLCJNZW51IiwiQXBwcyIsIlNjcm9sbCIsIk1velByaW50YWJsZUtleSIsIlRkIiwiVWQiLCJyZXBlYXQiLCJsb2NhbGUiLCJWZCIsImRhdGFUcmFuc2ZlciIsIldkIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlhkIiwiWWQiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlpkIiwiJGQiLCJhZSIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJTZWxlY3RFdmVudFBsdWdpbiIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJiZSIsImNlIiwiViIsIlciLCJTZXQiLCJkZSIsIlgiLCJlZSIsImZlIiwiZ2UiLCJoZSIsImNvbnRleHRUeXBlcyIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dFR5cGVzIiwiaWUiLCJqZSIsImN1cnNvciIsImtlIiwiZ2V0Q2hpbGRDb250ZXh0IiwibGUiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIm1lIiwiWSIsIm1lbW9pemVkU3RhdGUiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkUHJvcHMiLCJwZW5kaW5nUHJvcHMiLCJpbnRlcm5hbENvbnRleHRUYWciLCJsYXN0RWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJuZXh0RWZmZWN0IiwiZXhwaXJhdGlvblRpbWUiLCJuZSIsIm9lIiwicGUiLCJxZSIsInJlIiwiaGFuZGxlciIsInNlIiwidGUiLCJwZW5kaW5nQ2hpbGRyZW4iLCJ1ZSIsInZlIiwid2UiLCJ4ZSIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiaW5qZWN0Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInllIiwiemUiLCJBZSIsImJhc2VTdGF0ZSIsImZpcnN0IiwibGFzdCIsImNhbGxiYWNrTGlzdCIsImhhc0ZvcmNlVXBkYXRlIiwiaXNJbml0aWFsaXplZCIsIkJlIiwiQ2UiLCJEZSIsIktlIiwiaXNSZXBsYWNlIiwiaXNGb3JjZWQiLCJMZSIsIk1lIiwibmV4dENhbGxiYWNrIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsInN0YXRlIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJOZSIsIk9lIiwiUGUiLCJRZSIsIlJlIiwiU2UiLCJUZSIsIlVlIiwiVmUiLCJXZSIsIl9zdHJpbmdSZWYiLCJYZSIsIlllIiwiWmUiLCIkZSIsImFmIiwiYmYiLCJwZW5kaW5nQ29udGV4dCIsInNob3VsZFNldFRleHRDb250ZW50IiwidXNlU3luY1NjaGVkdWxpbmciLCJzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlIiwicHVzaEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250YWluZXIiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiS2IiLCJiZWdpbldvcmsiLCJoeWRyYXRlIiwiYmVnaW5GYWlsZWRXb3JrIiwiY2YiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsInBlcnNpc3RlbmNlIiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJwb3BIb3N0Q29udGV4dCIsImdldEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInBvcEh5ZHJhdGlvblN0YXRlIiwibXV0YXRpb24iLCJjb21wbGV0ZVdvcmsiLCJkZiIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRMaWZlQ3ljbGVzIiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiZWYiLCJmZiIsImdldENoaWxkSG9zdENvbnRleHQiLCJnZXRSb290SG9zdENvbnRleHQiLCJyZXNldEhvc3RDb250YWluZXIiLCJnZiIsImh5ZHJhdGlvbiIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoZiIsIkxiIiwibWEiLCJpc1JlYWR5Rm9yQ29tbWl0IiwidWciLCJ2ZyIsIndnIiwiR2UiLCJIZSIsIkxjIiwieGciLCJNYyIsInpnIiwiQWciLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudFN0YWNrIiwiYmEiLCJGYSIsImZhIiwibmEiLCJuZyIsIm1nIiwiTmMiLCJmYiIsImxnIiwiS2MiLCJnYiIsIkVlIiwiYWRkIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJlcnJvckJvdW5kYXJ5IiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ3aWxsUmV0cnkiLCJCZyIsImphIiwiQ2ciLCJNYiIsIkRnIiwibmV4dFNjaGVkdWxlZFJvb3QiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsIm9hIiwia2EiLCJOYiIsImhiIiwiSWUiLCJKZSIsIkVnIiwicGEiLCJPYiIsImliIiwiT2MiLCJQYiIsIlBjIiwiR2EiLCJmaW5pc2hlZFdvcmsiLCJ0aW1lUmVtYWluaW5nIiwiRmciLCJGZSIsInNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJ5ZyIsInJlc2V0QWZ0ZXJDb21taXQiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwiY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciIsInNjaGVkdWxlV29yayIsImJhdGNoZWRVcGRhdGVzIiwidW5iYXRjaGVkVXBkYXRlcyIsImZsdXNoU3luYyIsImRlZmVycmVkVXBkYXRlcyIsImpmIiwiY3JlYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImtmIiwibGYiLCJtZiIsIm5mIiwicGVyZm9ybWFuY2UiLCJvZiIsInBmIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInFmIiwicmYiLCJzZiIsInRmIiwidWYiLCJ2ZiIsIndmIiwieGYiLCJ5ZiIsInBvc3RNZXNzYWdlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiSW5maW5pdHkiLCJ6ZiIsIkFmIiwiQmYiLCJDZiIsInRlc3QiLCJEZiIsImlzTmFOIiwiRWYiLCJzZXRBdHRyaWJ1dGVOUyIsIkZmIiwiR2YiLCJtaW4iLCJtYXgiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsIkhmIiwiSWYiLCJwYXJzZUZsb2F0IiwiSmYiLCJLZiIsIkxmIiwiTWYiLCJvcHRpb25zIiwiZGVmYXVsdFNlbGVjdGVkIiwiTmYiLCJ3YXNNdWx0aXBsZSIsIk9mIiwiUGYiLCJRZiIsIlJmIiwiU2YiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwiVGYiLCJVZiIsIlZmIiwiV2YiLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwibmFtZXNwYWNlVVJJIiwiWGYiLCJZZiIsImxhc3RDaGlsZCIsIm5vZGVWYWx1ZSIsImV4ZWMiLCJjaGFyQ29kZUF0Iiwic3Vic3RyaW5nIiwiWmYiLCIkZiIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsImFnIiwiY2hhckF0IiwiYmciLCJzZXRQcm9wZXJ0eSIsImNnIiwibWVudWl0ZW0iLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImlucHV0Iiwia2V5Z2VuIiwibGluayIsIm1ldGEiLCJwYXJhbSIsInRyYWNrIiwid2JyIiwiZGciLCJlZyIsImZnIiwiZ2ciLCJoZyIsImlnIiwiamciLCJjcmVhdGVFbGVtZW50TlMiLCJrZyIsImNyZWF0ZVRleHROb2RlIiwib2ciLCJfX2h0bWwiLCJvbkNsaWNrIiwib25jbGljayIsInBnIiwicWciLCJyZyIsInNnIiwidGciLCJzZXRJbml0aWFsUHJvcGVydGllcyIsImRpZmZQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRUZXh0Iiwid2FybkZvclVubWF0Y2hlZFRleHQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JtIiwiR2ciLCJIZyIsIklnIiwiSmciLCJaIiwidGFnTmFtZSIsInJhbmdlQ291bnQiLCJmb2N1c2VkRWxlbSIsInNlbGVjdGlvblJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwic2V0RW5kIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsIktnIiwiX3JlYWN0Um9vdENvbnRhaW5lciIsIkxnIiwiTWciLCJ1bm1vdW50IiwiTmciLCJjcmVhdGVQb3J0YWwiLCJmaW5kRE9NTm9kZSIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiRXZlbnRQcm9wYWdhdG9ycyIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudCIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RE9NRXZlbnRMaXN0ZW5lciIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiT2ciLCJQZyIsImlzTm9kZSIsIk5vZGUiLCJlbXB0eUZ1bmN0aW9uJDEiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwic2hvdWxkU2V0QXR0cmlidXRlIiwiaXNSZXNlcnZlZFByb3AiLCJzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUiLCJnZXRQcm9wZXJ0eUluZm8iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSIsIk5TIiwiQVRUUlMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwib3JpZ2luYWwiLCJyZWFjdE5hbWUiLCJSZWFjdEVycm9yVXRpbHMiLCJpbmplY3RlZEVycm9yVXRpbHMiLCJmdW5jQXJncyIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJkaWRFcnJvciIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsIm9uRXJyb3IiLCJldmVudCIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJsb3dlckNhc2VkTmFtZSIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiaW5qZWN0aW9uJDIiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiSW5qZWN0ZWQiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwic2ltdWxhdGVkIiwibGlzdGVuZXIiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwicGF0aCIsInRyYXZlcnNlRW50ZXJMZWF2ZSIsImFyZ0Zyb20iLCJhcmdUbyIsInBhdGhGcm9tIiwicGF0aFRvIiwiX2FsdGVybmF0ZSIsIl9pIiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJwaGFzZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCIsInBhcmVudEluc3QiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImxlYXZlIiwiZW50ZXIiLCJjb250ZW50S2V5IiwiZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciIsImNvbXBvc2l0aW9uU3RhdGUiLCJpbml0aWFsaXplIiwiZ2V0VGV4dCIsInJlc2V0IiwiZ2V0RGF0YSIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJFVkVOVF9QT09MX1NJWkUiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRXZlbnQiLCJub3JtYWxpemUiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiQ2xhc3MiLCJTdXBlciIsImFkZEV2ZW50UG9vbGluZ1RvIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsInByb3AiLCJnZXRWYWwiLCJhY3Rpb24iLCJ3YXJuaW5nQ29uZGl0aW9uIiwiZ2V0UG9vbGVkRXZlbnQiLCJuYXRpdmVJbnN0IiwiRXZlbnRDb25zdHJ1Y3RvciIsImluc3RhbmNlIiwicmVsZWFzZVBvb2xlZEV2ZW50IiwiU3ludGhldGljRXZlbnQkMSIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiZGlzcGF0Y2hNYXJrZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0IiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kIiwiZ2V0RGF0YUZyb21DdXN0b21FdmVudCIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJmaWJlckhvc3RDb21wb25lbnQiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24iLCJob3N0Q29tcG9uZW50SW1wbCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJpbmplY3Rpb24kMyIsInF1ZXVlZFRhcmdldHMiLCJmaWJlckJhdGNoZWRVcGRhdGVzIiwiYm9va2tlZXBpbmciLCJpc05lc3RpbmdCYXRjaGVkIiwiUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb24iLCJpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzIiwiX2JhdGNoZWRVcGRhdGVzIiwiaW5qZWN0aW9uJDQiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZWxlbSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJ1c2VIYXNGZWF0dXJlIiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwiaXNDaGVja2FibGUiLCJnZXRUcmFja2VyIiwiZGV0YWNoVHJhY2tlciIsImdldFZhbHVlRnJvbU5vZGUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJjdXJyZW50VmFsdWUiLCJ0cmFja2VyIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJsYXN0VmFsdWUiLCJuZXh0VmFsdWUiLCJldmVudFR5cGVzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiVUlFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljTW91c2VFdmVudCIsImV2ZW50VHlwZXMkMiIsIndpbiIsInJlbGF0ZWQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlJlYWN0SW50ZXJuYWxzIiwiTm9FZmZlY3QiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkVyciIsIlJlZiIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsImlzRmliZXJNb3VudGVkSW1wbCIsImlzRmliZXJNb3VudGVkIiwib3duZXJGaWJlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwicGFyZW50QSIsInBhcmVudEIiLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUiLCJjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCIsImZpbmRSb290Q29udGFpbmVyTm9kZSIsImdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsInJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJhbmNlc3RvciIsInJvb3QiLCJoYW5kbGVUb3BMZXZlbCIsImVuYWJsZWQiLCJoYW5kbGVyQmFzZU5hbWUiLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwicHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwidG9wTGV2ZWxUeXBlcyQxIiwiQnJvd3NlckV2ZW50Q29uc3RhbnRzIiwidG9wTGV2ZWxUeXBlcyIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJsaXN0ZW5UbyIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jeSIsImlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJnZXRPZmZzZXRzIiwic2VsZWN0aW9uIiwiZm9jdXNOb2RlJCQxIiwiZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsInNldE9mZnNldHMiLCJvZmZzZXRzIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24iLCJnZXRTZWxlY3Rpb24kMSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImV2ZW50VHlwZXMkMyIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiZXZlbnRUeXBlcyQ0IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsImtub3duSFRNTFRvcExldmVsVHlwZXMiLCJlbmFibGVBc3luY1N1YnRyZWVBUEkiLCJlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NIiwiZW5hYmxlQ3JlYXRlUm9vdCIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIiLCJlbmFibGVOb29wUmVjb25jaWxlciIsImVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJyZXNldCQxIiwiZGVzY3JpYmVGaWJlciIsImdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIiLCJ3b3JrSW5Qcm9ncmVzcyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSIsIlJlYWN0RGVidWdDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtIiwicmVzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50UGhhc2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJsYWJlbHNJbkN1cnJlbnRDb21taXQiLCJmb3JtYXRNYXJrTmFtZSIsIm1hcmtOYW1lIiwiZm9ybWF0TGFiZWwiLCJsYWJlbCIsIndhcm5pbmckJDEiLCJzdWZmaXgiLCJiZWdpbk1hcmsiLCJjbGVhck1hcmsiLCJlbmRNYXJrIiwiZm9ybWF0dGVkTWFya05hbWUiLCJmb3JtYXR0ZWRMYWJlbCIsImdldEZpYmVyTWFya05hbWUiLCJkZWJ1Z0lEIiwiZ2V0RmliZXJMYWJlbCIsImJlZ2luRmliZXJNYXJrIiwiX2RlYnVnSUQiLCJjbGVhckZpYmVyTWFyayIsImVuZEZpYmVyTWFyayIsInNob3VsZElnbm9yZUZpYmVyIiwiY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCIsInBhdXNlVGltZXJzIiwiX2RlYnVnSXNDdXJyZW50bHlUaW1pbmciLCJyZXN1bWVUaW1lcnNSZWN1cnNpdmVseSIsInJlc3VtZVRpbWVycyIsInJlY29yZEVmZmVjdCIsInJlY29yZFNjaGVkdWxlVXBkYXRlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJzdGFydENvbW1pdFRpbWVyIiwiY2xlYXIiLCJzdG9wQ29tbWl0VGltZXIiLCJzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwic3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJoYXNPd25Db250ZXh0IiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJwb3BDb250ZXh0UHJvdmlkZXIiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJyZXNldENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJOb0NvbnRleHQiLCJBc3luY1VwZGF0ZXMiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiZWxlbWVudHMiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY29udGVudCIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiY3JlYXRlRmliZXJGcm9tQ2FsbCIsImNyZWF0ZUZpYmVyRnJvbVJldHVybiIsInJldHVybk5vZGUiLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJjcmVhdGVGaWJlclJvb3QiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJoYXNMb2dnZWRFcnJvciIsImNhdGNoRXJyb3JzIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsInJlbmRlcmVySUQiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3JlYXRlVXBkYXRlUXVldWUiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiX2NhbGxiYWNrTGlzdCIsImNvbW1pdENhbGxiYWNrcyIsIl9jYWxsYmFjayIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Iiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50IiwibWVtb2l6ZVByb3BzIiwibWVtb2l6ZVN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsIm5ld0NvbnRleHQiLCJzaG91bGRVcGRhdGUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50Iiwibm9HZXRJbml0aWFsU3RhdGVPbkVTNiIsImdldEluaXRpYWxTdGF0ZSIsIm5vR2V0RGVmYXVsdFByb3BzT25FUzYiLCJub0luc3RhbmNlUHJvcFR5cGVzIiwibm9JbnN0YW5jZUNvbnRleHRUeXBlcyIsIm5vQ29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwibm9Db21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkVW5tb3VudCIsIm5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwibm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJyZXNldElucHV0UG9pbnRlcnMiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY3RvciIsIm5lZWRzQ29udGV4dCIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJjcmVhdGVQb3J0YWwkMSIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiaXNBcnJheSQxIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwicmV0dXJuRmliZXIiLCJuZXdDaGlsZCIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZENsb25lIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ2FsbCIsInVwZGF0ZVJldHVybiIsInVwZGF0ZVBvcnRhbCIsInVwZGF0ZUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJwb3NzaWJsZU1hcCIsIl9uZXdDaGlsZHJlbiIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ3IiwicmVjb25jaWxlU2luZ2xlQ2FsbCIsInJlY29uY2lsZVNpbmdsZVJldHVybiIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiX2lzTW9ja0Z1bmN0aW9uIiwicmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlIiwibW91bnRDaGlsZEZpYmVyc0luUGxhY2UiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwid2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzIiwiUmVhY3RGaWJlckJlZ2luV29yayIsImhvc3RDb250ZXh0IiwiaHlkcmF0aW9uQ29udGV4dCIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmV4dFByb3BzIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImRlYnVnU291cmNlIiwidXBkYXRlQ2FsbENvbXBvbmVudCIsIm5leHRDYWxsIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiYmFpbG91dE9uTG93UHJpb3JpdHkiLCJuZXh0U3RhdGUiLCJSZWFjdEZpYmVyQ29tcGxldGVXb3JrIiwibWFya1VwZGF0ZSIsImFwcGVuZEFsbFJldHVybnMiLCJyZXR1cm5zIiwibW92ZUNhbGxUb0hhbmRsZXJQaGFzZSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZVBheWxvYWQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjdXJyZW50SG9zdENvbnRleHQiLCJmaWJlclJvb3QiLCJfY3VycmVudEhvc3RDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfaW5zdGFuY2UiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiIsImhhc0NhdWdodEVycm9yJDEiLCJjbGVhckNhdWdodEVycm9yJDEiLCJSZWFjdEZpYmVyQ29tbWl0V29yayIsImNhcHR1cmVFcnJvciIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsInNhZmVseURldGFjaFJlZiIsInJlZkVycm9yIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImN1cnJlbnRSZWYiLCJjb21taXRVbm1vdW50IiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImRldGFjaEZpYmVyIiwiY29tbWl0Q29udGFpbmVyIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiZW1wdHlDaGlsZFNldCIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0Iiwicm9vdEluc3RhbmNlIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsIm5leHRDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsImNhbkh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiaXNFcnJvclJlY292ZXJ5IiwicmVxdWVzdFdvcmsiLCJwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0Iiwic3luY1VwZGF0ZXMiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImlzQ2FsbGJhY2tTY2hlZHVsZWQiLCJpc1JlbmRlcmluZyIsIm5leHRGbHVzaGVkUm9vdCIsIm5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUiLCJkZWFkbGluZURpZEV4cGlyZSIsImhhc1VuaGFuZGxlZEVycm9yIiwidW5oYW5kbGVkRXJyb3IiLCJkZWFkbGluZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiaXNVbmJhdGNoaW5nVXBkYXRlcyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsInBlcmZvcm1Bc3luY1dvcmsiLCJmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCIsImhpZ2hlc3RQcmlvcml0eVdvcmsiLCJoaWdoZXN0UHJpb3JpdHlSb290IiwicHJldmlvdXNTY2hlZHVsZWRSb290IiwicHJldmlvdXNGbHVzaGVkUm9vdCIsImRsIiwibWluRXhwaXJhdGlvblRpbWUiLCJfZXJyb3I0IiwiX2ZpbmlzaGVkV29yayIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQxIiwiX1JlYWN0RmliZXJTY2hlZHVsZXIiLCJzY2hlZHVsZVRvcExldmVsVXBkYXRlIiwiaG9zdEZpYmVyIiwib25Nb3VudENvbnRhaW5lciIsIm9uVW5tb3VudENvbnRhaW5lciIsIm9uVXBkYXRlQ29udGFpbmVyIiwiY29udGFpbmVyRmliZXIiLCJkZXZUb29sc0NvbmZpZyIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDIiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQzIiwicmVhY3RSZWNvbmNpbGVyIiwiaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3ciLCJySUMiLCJmcmFtZUNhbGxiYWNrIiwic2NoZWR1bGVkUklDQ2FsbGJhY2siLCJpc0lkbGVTY2hlZHVsZWQiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiUmVnRXhwIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlV3JhcHBlciIsInZhbHVlQXNOdW1iZXIiLCJwb3N0TW91bnRXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxIiwidXBkYXRlTmFtZWRDb3VzaW5zIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsIm90aGVyTm9kZSIsIm90aGVyUHJvcHMiLCJmbGF0dGVuQ2hpbGRyZW4iLCJ2YWxpZGF0ZVByb3BzIiwicG9zdE1vdW50V3JhcHBlciQxIiwiZ2V0SG9zdFByb3BzJDEiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInVwZGF0ZU9wdGlvbnMiLCJwcm9wVmFsdWUiLCJzZXREZWZhdWx0U2VsZWN0ZWQiLCJzZWxlY3RlZFZhbHVlcyIsInNlbGVjdGVkVmFsdWUiLCJfc2VsZWN0ZWRWYWx1ZSIsIl9pMiIsImdldEhvc3RQcm9wcyQyIiwiaW5pdFdyYXBwZXJTdGF0ZSQxIiwicG9zdE1vdW50V3JhcHBlciQyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImdldEhvc3RQcm9wcyQzIiwiaW5pdFdyYXBwZXJTdGF0ZSQyIiwidXBkYXRlV3JhcHBlciQxIiwibmV3VmFsdWUiLCJwb3N0TW91bnRXcmFwcGVyJDMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMiLCJIVE1MX05BTUVTUEFDRSQxIiwiTUFUSF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiTmFtZXNwYWNlcyIsImdldEludHJpbnNpY05hbWVzcGFjZSIsImdldENoaWxkTmFtZXNwYWNlIiwicGFyZW50TmFtZXNwYWNlIiwiY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsInN2Z05vZGUiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyaW5nIiwibGFzdEluZGV4IiwiZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyIiwic2V0VGV4dENvbnRlbnQiLCJzZXRUZXh0Q29udGVudCQxIiwiaXNVbml0bGVzc051bWJlciIsInByZWZpeEtleSIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNFbXB0eSIsIndhcm5WYWxpZFN0eWxlIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5IiwiaXNGaW5pdGUiLCJ3YXJuVmFsaWRTdHlsZSQxIiwiY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzIiwic3R5bGVzIiwic2VyaWFsaXplZCIsImRlbGltaXRlciIsInN0eWxlTmFtZSIsInN0eWxlVmFsdWUiLCJzZXRWYWx1ZUZvclN0eWxlcyIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJ2b2lkRWxlbWVudFRhZ3MiLCJIVE1MJDEiLCJhc3NlcnRWYWxpZFByb3BzIiwiaXNDdXN0b21Db21wb25lbnQiLCJhcmlhUHJvcGVydGllcyIsIndhcm5lZFByb3BlcnRpZXMiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiYXJpYU5hbWUiLCJjb3JyZWN0TmFtZSIsInN0YW5kYXJkTmFtZSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiZGlkV2FyblZhbHVlTnVsbCIsImdldFN0YWNrQWRkZW5kdW0kMSIsInZhbGlkYXRlUHJvcGVydGllcyQxIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZW5jdHlwZSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlaWdodCIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYW5nIiwibGlzdCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtaW5sZW5ndGgiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicm9sZSIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2Nyb2xsaW5nIiwic2hhcGUiLCJzaXplcyIsInNwZWxsY2hlY2siLCJzcmMiLCJzcmNkb2MiLCJzcmNsYW5nIiwic3Jjc2V0Iiwic3VtbWFyeSIsInRhYmluZGV4IiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3giLCJjeSIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZlY3RvcmVmZmVjdCIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInljaGFubmVsc2VsZWN0b3IiLCJ6b29tYW5kcGFuIiwiZ2V0U3RhY2tBZGRlbmR1bSQyIiwid2FybmVkUHJvcGVydGllcyQxIiwiaGFzT3duUHJvcGVydHkkMSIsIkVWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsImRpZFdhcm5TaGFkeURPTSIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSIsIkFVVE9GT0NVUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiSFRNTF9OQU1FU1BBQ0UiLCJ3YXJuZWRVbmtub3duVGFncyIsImRpYWxvZyIsInZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQiLCJOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgiLCJOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgiLCJub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUiLCJtYXJrdXAiLCJtYXJrdXBTdHJpbmciLCJ3YXJuRm9yVGV4dERpZmZlcmVuY2UiLCJzZXJ2ZXJUZXh0IiwiY2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRDbGllbnRUZXh0Iiwibm9ybWFsaXplZFNlcnZlclRleHQiLCJ3YXJuRm9yUHJvcERpZmZlcmVuY2UiLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZENsaWVudFZhbHVlIiwibm9ybWFsaXplZFNlcnZlclZhbHVlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWVzIiwibmFtZXMiLCJ3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIiLCJub3JtYWxpemVIVE1MIiwidGVzdEVsZW1lbnQiLCJlbnN1cmVMaXN0ZW5pbmdUbyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEb2N1bWVudE9yRnJhZ21lbnQiLCJnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIiLCJtZWRpYUV2ZW50cyIsInRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50Iiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJwcm9wS2V5IiwibmV4dFByb3AiLCJuZXh0SHRtbCIsImNhblNldFRleHRDb250ZW50IiwidXBkYXRlRE9NUHJvcGVydGllcyIsIndhc0N1c3RvbUNvbXBvbmVudFRhZyIsImNyZWF0ZUVsZW1lbnQkMSIsImRpdiIsImNyZWF0ZVRleHROb2RlJDEiLCJzZXRJbml0aWFsUHJvcGVydGllcyQxIiwicmF3UHJvcHMiLCJzaGFkeVJvb3QiLCJkaWZmUHJvcGVydGllcyQxIiwibGFzdFJhd1Byb3BzIiwibmV4dFJhd1Byb3BzIiwibGFzdFByb3BzIiwic3R5bGVVcGRhdGVzIiwibGFzdFN0eWxlIiwibGFzdFByb3AiLCJsYXN0SHRtbCIsInVwZGF0ZVByb3BlcnRpZXMkMSIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSIsImV4dHJhQXR0cmlidXRlTmFtZXMiLCJhdHRyaWJ1dGVzIiwicmF3SHRtbCIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwib3duTmFtZXNwYWNlIiwiZGlmZkh5ZHJhdGVkVGV4dCQxIiwidGV4dE5vZGUiLCJpc0RpZmZlcmVudCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0JDEiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMSIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxIiwiUmVhY3RET01GaWJlckNvbXBvbmVudCIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiIsInZhbGlkYXRlRE9NTmVzdGluZyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvJDEiLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJwYXJlbnRUYWciLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJpbnZhbGlkUGFyZW50T3JBbmNlc3RvciIsImFuY2VzdG9yVGFnIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsInZhbGlkYXRlRE9NTmVzdGluZyQxIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkciLCJldmVudHNFbmFibGVkIiwic2VsZWN0aW9uSW5mb3JtYXRpb24iLCJpc1ZhbGlkQ29udGFpbmVyIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwic2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljIiwicm9vdEVsZW1lbnQiLCJzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50IiwiRE9NUmVuZGVyZXIiLCJ2YWxpZGF0ZWRUYWciLCJfYW5jZXN0b3JJbmZvIiwicGFyZW50SG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dERldiIsIl9uYW1lc3BhY2UiLCJfYW5jZXN0b3JJbmZvMiIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJob3N0Q29udGV4dERldiIsIm93bkFuY2VzdG9ySW5mbyIsImJlZm9yZUNoaWxkIiwid2FybmVkQWJvdXRIeWRyYXRlQVBJIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJob3N0SW5zdGFuY2UiLCJpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0Iiwicm9vdEVsIiwiaGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJzaG91bGRIeWRyYXRlIiwid2FybmVkIiwicm9vdFNpYmxpbmciLCJuZXdSb290IiwiUmVhY3RSb290IiwiUmVhY3RET00iLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImNvbnRhaW5lck5vZGUiLCJyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QiLCJfcm9vdEVsIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJjcmVhdGVSb290IiwiZm91bmREZXZUb29scyIsInVzZXJBZ2VudCIsInByb3RvY29sIiwiUmVhY3RET00kMiIsIlJlYWN0RE9NJDMiLCJyZWFjdERvbSIsImh5cGhlbmF0ZSIsIm1zUGF0dGVybiIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiY2FtZWxpemUiLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJBcHAiLCJsb2FkQ29tbWVudHNGcm9tU2VydmVyIiwicmVzIiwiYmFzaWNpbmZvIiwiYmlvIiwic2tpbGxzIiwiZXhwZXJpZW5jZSIsIkF4aW9zIiwiZGVmYXVsdENvbmZpZyIsImF4aW9zIiwiaW5zdGFuY2VDb25maWciLCJDYW5jZWxUb2tlbiIsImFsbCIsInByb21pc2VzIiwic3ByZWFkIiwiaXNTbG93QnVmZmVyIiwiX2lzQnVmZmVyIiwicmVhZEZsb2F0TEUiLCJJbnRlcmNlcHRvck1hbmFnZXIiLCJkaXNwYXRjaFJlcXVlc3QiLCJpbnRlcmNlcHRvcnMiLCJjaGFpbiIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJ1bnNoaWZ0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJzaGlmdCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImVuY29kZSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJwYXJ0cyIsInNlcmlhbGl6ZSIsInBhcnNlVmFsdWUiLCJ0b0lTT1N0cmluZyIsImlnbm9yZUR1cGxpY2F0ZU9mIiwicGFyc2VkIiwicGFyc2VyIiwibGluZSIsInN1YnN0ciIsInN0YW5kYXJkQnJvd3NlckVudiIsIm1zaWUiLCJ1cmxQYXJzaW5nTm9kZSIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJob3N0IiwiaGFzaCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwicmVxdWVzdFVSTCIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsIm91dHB1dCIsImJsb2NrIiwiaWR4Iiwid3JpdGUiLCJleHBpcmVzIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwidG9HTVRTdHJpbmciLCJkZWNvZGVVUklDb21wb25lbnQiLCJoYW5kbGVycyIsInVzZSIsImVqZWN0IiwiZm9yRWFjaEhhbmRsZXIiLCJ0cmFuc2Zvcm1EYXRhIiwiaXNBYnNvbHV0ZVVSTCIsImNvbWJpbmVVUkxzIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsInRocm93SWZSZXF1ZXN0ZWQiLCJiYXNlVVJMIiwiY2xlYW5IZWFkZXJDb25maWciLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwib25BZGFwdGVyUmVqZWN0aW9uIiwicmVhc29uIiwiZm5zIiwicmVsYXRpdmVVUkwiLCJleGVjdXRvciIsInJlc29sdmVQcm9taXNlIiwicHJvbWlzZUV4ZWN1dG9yIiwiQmFzaWNJbmZvIiwiJCIsInRvb2x0aXAiLCJ0b29sdGlwVGV4dCIsImFkZHJlc3MiLCJCaW8iLCJhYm91dF9tZSIsIlRlY2hTa2lsbHMiLCJza2lsbExpc3QiLCJza2lsbHNfc3RhY2siLCJza2lsbG5hbWUiLCJTa2lsbHNMaXN0Iiwic2tpbGxzSXRlbXMiLCJpdGVtIiwiRXhwZXJpZW5jZSIsImV4cGVyaWVuY2VMaXN0SXRlbSIsIndvcmsiLCJFeHBlcmllbmNlSXRlbSIsImR1dHkiLCJpdGVtZHV0eSIsImNvbXBhbnkiLCJvdmVydmlldyIsImpvYnRpdGxlIiwiUHJvamVjdHMiLCJpdGVtcyIsIm5hdiIsInJld2luZCIsInJlc3BvbnNpdmUiLCJ3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbiIsImZhY3RvcnkiLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXyIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18iLCJtb2R1bGVzIiwiaW5zdGFsbGVkTW9kdWxlcyIsIl9fd2VicGFja19yZXF1aXJlX18iLCJtb2R1bGVJZCIsImxvYWRlZCIsImV2YWwiLCJ3ZWJwYWNrUG9seWZpbGwiLCJkZXByZWNhdGUiLCJwYXRocyIsIkFOT05ZTU9VUyIsIlJlYWN0UHJvcFR5cGVzIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwic3ltYm9sIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJleGFjdCIsImNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIiLCJQcm9wVHlwZUVycm9yIiwiY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIiLCJ2YWxpZGF0ZSIsIm1hbnVhbFByb3BUeXBlQ2FsbENhY2hlIiwibWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQiLCJjaGVja1R5cGUiLCJpc1JlcXVpcmVkIiwicHJvcEZ1bGxOYW1lIiwic2VjcmV0IiwiY2FjaGVLZXkiLCJjaGFpbmVkQ2hlY2tUeXBlIiwiZXhwZWN0ZWRUeXBlIiwicHJvcFR5cGUiLCJnZXRQcm9wVHlwZSIsInByZWNpc2VUeXBlIiwiZ2V0UHJlY2lzZVR5cGUiLCJ0eXBlQ2hlY2tlciIsImV4cGVjdGVkQ2xhc3MiLCJleHBlY3RlZENsYXNzTmFtZSIsImFjdHVhbENsYXNzTmFtZSIsImdldENsYXNzTmFtZSIsImV4cGVjdGVkVmFsdWVzIiwidmFsdWVzU3RyaW5nIiwiYXJyYXlPZlR5cGVDaGVja2VycyIsImNoZWNrZXIiLCJnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmciLCJzaGFwZVR5cGVzIiwiYWxsS2V5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LFdBQU9tQztBQWxCWSxHQUFyQjs7QUFxQkF0RCxpQkFBZXJqRyxjQUFmLEdBQWdDM0QsYUFBaEM7QUFDQWduRyxpQkFBZW9ELFNBQWYsR0FBMkJwRCxjQUEzQjs7QUFFQSxTQUFPQSxjQUFQO0FBQ0QsQ0E1Q0QsQyIsImZpbGUiOiJidW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSAyNCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgZjJmYjUzMWIwYzU5NGExOGZlZGQiLCIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMnKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9pbmRleC5qcyIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYmluZCA9IHJlcXVpcmUoJy4vaGVscGVycy9iaW5kJyk7XG52YXIgaXNCdWZmZXIgPSByZXF1aXJlKCdpcy1idWZmZXInKTtcblxuLypnbG9iYWwgdG9TdHJpbmc6dHJ1ZSovXG5cbi8vIHV0aWxzIGlzIGEgbGlicmFyeSBvZiBnZW5lcmljIGhlbHBlciBmdW5jdGlvbnMgbm9uLXNwZWNpZmljIHRvIGF4aW9zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXkodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEFycmF5QnVmZmVyXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGb3JtRGF0YVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEZvcm1EYXRhLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGb3JtRGF0YSh2YWwpIHtcbiAgcmV0dXJuICh0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnKSAmJiAodmFsIGluc3RhbmNlb2YgRm9ybURhdGEpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgdmlldyBvbiBhbiBBcnJheUJ1ZmZlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xuICB2YXIgcmVzdWx0O1xuICBpZiAoKHR5cGVvZiBBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpICYmIChBcnJheUJ1ZmZlci5pc1ZpZXcpKSB7XG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0ID0gKHZhbCkgJiYgKHZhbC5idWZmZXIpICYmICh2YWwuYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBOdW1iZXJcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIE51bWJlciwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ251bWJlcic7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgdW5kZWZpbmVkXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHZhbHVlIGlzIHVuZGVmaW5lZCwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3VuZGVmaW5lZCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgdHlwZW9mIHZhbCA9PT0gJ29iamVjdCc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eXFxzKi8sICcnKS5yZXBsYWNlKC9cXHMqJC8sICcnKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgd2UncmUgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAqXG4gKiBUaGlzIGFsbG93cyBheGlvcyB0byBydW4gaW4gYSB3ZWIgd29ya2VyLCBhbmQgcmVhY3QtbmF0aXZlLlxuICogQm90aCBlbnZpcm9ubWVudHMgc3VwcG9ydCBYTUxIdHRwUmVxdWVzdCwgYnV0IG5vdCBmdWxseSBzdGFuZGFyZCBnbG9iYWxzLlxuICpcbiAqIHdlYiB3b3JrZXJzOlxuICogIHR5cGVvZiB3aW5kb3cgLT4gdW5kZWZpbmVkXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxuICpcbiAqIHJlYWN0LW5hdGl2ZTpcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXG4gKi9cbmZ1bmN0aW9uIGlzU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIChcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcbiAgKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiBgb2JqYCBpcyBhbiBBcnJheSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cbiAqXG4gKiBJZiAnb2JqJyBpcyBhbiBPYmplY3QgY2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgcGFzc2luZ1xuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IG9iaiBUaGUgb2JqZWN0IHRvIGl0ZXJhdGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxuICovXG5mdW5jdGlvbiBmb3JFYWNoKG9iaiwgZm4pIHtcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXG4gIGlmIChvYmogPT09IG51bGwgfHwgdHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBGb3JjZSBhbiBhcnJheSBpZiBub3QgYWxyZWFkeSBzb21ldGhpbmcgaXRlcmFibGVcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgb2JqID0gW29ial07XG4gIH1cblxuICBpZiAoaXNBcnJheShvYmopKSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgZm4uY2FsbChudWxsLCBvYmpbaV0sIGksIG9iaik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIEl0ZXJhdGUgb3ZlciBvYmplY3Qga2V5c1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSB7XG4gICAgICAgIGZuLmNhbGwobnVsbCwgb2JqW2tleV0sIGtleSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXG4gKiBpbW11dGFibHkgbWVyZ2VzIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2ggb2JqZWN0IGFuZCByZXR1cm5zIHJlc3VsdC5cbiAqXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxuICogdGhlIGFyZ3VtZW50cyBsaXN0IHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcbiAqIGNvbnNvbGUubG9nKHJlc3VsdC5mb28pOyAvLyBvdXRwdXRzIDQ1NlxuICogYGBgXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9iajEgT2JqZWN0IHRvIG1lcmdlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXN1bHQgb2YgYWxsIG1lcmdlIHByb3BlcnRpZXNcbiAqL1xuZnVuY3Rpb24gbWVyZ2UoLyogb2JqMSwgb2JqMiwgb2JqMywgLi4uICovKSB7XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodHlwZW9mIHJlc3VsdFtrZXldID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZShyZXN1bHRba2V5XSwgdmFsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdWx0W2tleV0gPSB2YWw7XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBiZSBleHRlbmRlZFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IHRoaXNBcmcgVGhlIG9iamVjdCB0byBiaW5kIGZ1bmN0aW9uIHRvXG4gKiBAcmV0dXJuIHtPYmplY3R9IFRoZSByZXN1bHRpbmcgdmFsdWUgb2Ygb2JqZWN0IGFcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGEsIGIsIHRoaXNBcmcpIHtcbiAgZm9yRWFjaChiLCBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFba2V5XSA9IGJpbmQodmFsLCB0aGlzQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYVtrZXldID0gdmFsO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBhO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNBcnJheTogaXNBcnJheSxcbiAgaXNBcnJheUJ1ZmZlcjogaXNBcnJheUJ1ZmZlcixcbiAgaXNCdWZmZXI6IGlzQnVmZmVyLFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxuICBpc0FycmF5QnVmZmVyVmlldzogaXNBcnJheUJ1ZmZlclZpZXcsXG4gIGlzU3RyaW5nOiBpc1N0cmluZyxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxuICBpc09iamVjdDogaXNPYmplY3QsXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcbiAgaXNEYXRlOiBpc0RhdGUsXG4gIGlzRmlsZTogaXNGaWxlLFxuICBpc0Jsb2I6IGlzQmxvYixcbiAgaXNGdW5jdGlvbjogaXNGdW5jdGlvbixcbiAgaXNTdHJlYW06IGlzU3RyZWFtLFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXG4gIGlzU3RhbmRhcmRCcm93c2VyRW52OiBpc1N0YW5kYXJkQnJvd3NlckVudixcbiAgZm9yRWFjaDogZm9yRWFjaCxcbiAgbWVyZ2U6IG1lcmdlLFxuICBleHRlbmQ6IGV4dGVuZCxcbiAgdHJpbTogdHJpbVxufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJcInVzZSBzdHJpY3RcIjtcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG5mdW5jdGlvbiBtYWtlRW1wdHlGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXJnO1xuICB9O1xufVxuXG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gYWNjZXB0cyBhbmQgZGlzY2FyZHMgaW5wdXRzOyBpdCBoYXMgbm8gc2lkZSBlZmZlY3RzLiBUaGlzIGlzXG4gKiBwcmltYXJpbHkgdXNlZnVsIGlkaW9tYXRpY2FsbHkgZm9yIG92ZXJyaWRhYmxlIGZ1bmN0aW9uIGVuZHBvaW50cyB3aGljaFxuICogYWx3YXlzIG5lZWQgdG8gYmUgY2FsbGFibGUsIHNpbmNlIEpTIGxhY2tzIGEgbnVsbC1jYWxsIGlkaW9tIGFsYSBDb2NvYS5cbiAqL1xudmFyIGVtcHR5RnVuY3Rpb24gPSBmdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge307XG5cbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMgPSBtYWtlRW1wdHlGdW5jdGlvbjtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKGZhbHNlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlID0gbWFrZUVtcHR5RnVuY3Rpb24odHJ1ZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCA9IG1ha2VFbXB0eUZ1bmN0aW9uKG51bGwpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RoaXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuIGFyZztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlGdW5jdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIi8qXG5vYmplY3QtYXNzaWduXG4oYykgU2luZHJlIFNvcmh1c1xuQGxpY2Vuc2UgTUlUXG4qL1xuXG4ndXNlIHN0cmljdCc7XG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xudmFyIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHM7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xudmFyIHByb3BJc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xuXG5mdW5jdGlvbiB0b09iamVjdCh2YWwpIHtcblx0aWYgKHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHVuZGVmaW5lZCkge1xuXHRcdHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gY2Fubm90IGJlIGNhbGxlZCB3aXRoIG51bGwgb3IgdW5kZWZpbmVkJyk7XG5cdH1cblxuXHRyZXR1cm4gT2JqZWN0KHZhbCk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFVzZU5hdGl2ZSgpIHtcblx0dHJ5IHtcblx0XHRpZiAoIU9iamVjdC5hc3NpZ24pIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBEZXRlY3QgYnVnZ3kgcHJvcGVydHkgZW51bWVyYXRpb24gb3JkZXIgaW4gb2xkZXIgVjggdmVyc2lvbnMuXG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD00MTE4XG5cdFx0dmFyIHRlc3QxID0gbmV3IFN0cmluZygnYWJjJyk7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ldy13cmFwcGVyc1xuXHRcdHRlc3QxWzVdID0gJ2RlJztcblx0XHRpZiAoT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDEpWzBdID09PSAnNScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QyID0ge307XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG5cdFx0XHR0ZXN0MlsnXycgKyBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpXSA9IGk7XG5cdFx0fVxuXHRcdHZhciBvcmRlcjIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MikubWFwKGZ1bmN0aW9uIChuKSB7XG5cdFx0XHRyZXR1cm4gdGVzdDJbbl07XG5cdFx0fSk7XG5cdFx0aWYgKG9yZGVyMi5qb2luKCcnKSAhPT0gJzAxMjM0NTY3ODknKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MyA9IHt9O1xuXHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24gKGxldHRlcikge1xuXHRcdFx0dGVzdDNbbGV0dGVyXSA9IGxldHRlcjtcblx0XHR9KTtcblx0XHRpZiAoT2JqZWN0LmtleXMoT2JqZWN0LmFzc2lnbih7fSwgdGVzdDMpKS5qb2luKCcnKSAhPT1cblx0XHRcdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXHR9IGNhdGNoIChlcnIpIHtcblx0XHQvLyBXZSBkb24ndCBleHBlY3QgYW55IG9mIHRoZSBhYm92ZSB0byB0aHJvdywgYnV0IGJldHRlciB0byBiZSBzYWZlLlxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVzZU5hdGl2ZSgpID8gT2JqZWN0LmFzc2lnbiA6IGZ1bmN0aW9uICh0YXJnZXQsIHNvdXJjZSkge1xuXHR2YXIgZnJvbTtcblx0dmFyIHRvID0gdG9PYmplY3QodGFyZ2V0KTtcblx0dmFyIHN5bWJvbHM7XG5cblx0Zm9yICh2YXIgcyA9IDE7IHMgPCBhcmd1bWVudHMubGVuZ3RoOyBzKyspIHtcblx0XHRmcm9tID0gT2JqZWN0KGFyZ3VtZW50c1tzXSk7XG5cblx0XHRmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuXHRcdFx0aWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuXHRcdFx0XHR0b1trZXldID0gZnJvbVtrZXldO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChnZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcblx0XHRcdHN5bWJvbHMgPSBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZnJvbSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHN5bWJvbHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHByb3BJc0VudW1lcmFibGUuY2FsbChmcm9tLCBzeW1ib2xzW2ldKSkge1xuXHRcdFx0XHRcdHRvW3N5bWJvbHNbaV1dID0gZnJvbVtzeW1ib2xzW2ldXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB0bztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxudmFyIHZhbGlkYXRlRm9ybWF0ID0gZnVuY3Rpb24gdmFsaWRhdGVGb3JtYXQoZm9ybWF0KSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFyaWFudChjb25kaXRpb24sIGZvcm1hdCwgYSwgYiwgYywgZCwgZSwgZikge1xuICB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpO1xuXG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdmFyIGVycm9yO1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ01pbmlmaWVkIGV4Y2VwdGlvbiBvY2N1cnJlZDsgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50ICcgKyAnZm9yIHRoZSBmdWxsIGVycm9yIG1lc3NhZ2UgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFyZ3MgPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICB9KSk7XG4gICAgICBlcnJvci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgIH1cblxuICAgIGVycm9yLmZyYW1lc1RvUG9wID0gMTsgLy8gd2UgZG9uJ3QgY2FyZSBhYm91dCBpbnZhcmlhbnQncyBvd24gZnJhbWVcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlPYmplY3QgPSB7fTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eU9iamVjdCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW1wdHlPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2VtcHR5T2JqZWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTQtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiBwcmludFdhcm5pbmcoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICB3YXJuaW5nID0gZnVuY3Rpb24gd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0LmluZGV4T2YoJ0ZhaWxlZCBDb21wb3NpdGUgcHJvcFR5cGU6ICcpID09PSAwKSB7XG4gICAgICByZXR1cm47IC8vIElnbm9yZSBDb21wb3NpdGVDb21wb25lbnQgcHJvcHR5cGUgY2hlY2suXG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG4gIHZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuICB2YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuICB2YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG59XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgdGhlIHZhbHVlcyBtYXRjaCB3aXRoIHRoZSB0eXBlIHNwZWNzLlxuICogRXJyb3IgbWVzc2FnZXMgYXJlIG1lbW9yaXplZCBhbmQgd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IHR5cGVTcGVjcyBNYXAgb2YgbmFtZSB0byBhIFJlYWN0UHJvcFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSB2YWx1ZXMgUnVudGltZSB2YWx1ZXMgdGhhdCBuZWVkIHRvIGJlIHR5cGUtY2hlY2tlZFxuICogQHBhcmFtIHtzdHJpbmd9IGxvY2F0aW9uIGUuZy4gXCJwcm9wXCIsIFwiY29udGV4dFwiLCBcImNoaWxkIGNvbnRleHRcIlxuICogQHBhcmFtIHtzdHJpbmd9IGNvbXBvbmVudE5hbWUgTmFtZSBvZiB0aGUgY29tcG9uZW50IGZvciBlcnJvciBtZXNzYWdlcy5cbiAqIEBwYXJhbSB7P0Z1bmN0aW9ufSBnZXRTdGFjayBSZXR1cm5zIHRoZSBjb21wb25lbnQgc3RhY2suXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGdldFN0YWNrKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKHR5cGVTcGVjcy5oYXNPd25Qcm9wZXJ0eSh0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvcjtcbiAgICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgICAgLy8gZmFpbCB0aGUgcmVuZGVyIHBoYXNlIHdoZXJlIGl0IGRpZG4ndCBmYWlsIGJlZm9yZS4gU28gd2UgbG9nIGl0LlxuICAgICAgICAvLyBBZnRlciB0aGVzZSBoYXZlIGJlZW4gY2xlYW5lZCB1cCwgd2UnbGwgbGV0IHRoZW0gdGhyb3cuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGludmFyaWFudCh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gPT09ICdmdW5jdGlvbicsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tICcgKyAndGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCVzYC4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSk7XG4gICAgICAgICAgZXJyb3IgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoIWVycm9yIHx8IGVycm9yIGluc3RhbmNlb2YgRXJyb3IsICclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvcik7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgICAgdmFyIHN0YWNrID0gZ2V0U3RhY2sgPyBnZXRTdGFjaygpIDogJyc7XG5cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkICVzIHR5cGU6ICVzJXMnLCBsb2NhdGlvbiwgZXJyb3IubWVzc2FnZSwgc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2hlY2tQcm9wVHlwZXM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVzU2VjcmV0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBjaGVja0RDRSgpIHtcbiAgLyogZ2xvYmFsIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAqL1xuICBpZiAoXG4gICAgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcgfHxcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFICE9PSAnZnVuY3Rpb24nXG4gICkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoaXMgYnJhbmNoIGlzIHVucmVhY2hhYmxlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBvbmx5IGNhbGxlZFxuICAgIC8vIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgY29uZGl0aW9uIGlzIHRydWUgb25seSBpbiBkZXZlbG9wbWVudC5cbiAgICAvLyBUaGVyZWZvcmUgaWYgdGhlIGJyYW5jaCBpcyBzdGlsbCBoZXJlLCBkZWFkIGNvZGUgZWxpbWluYXRpb24gd2Fzbid0XG4gICAgLy8gcHJvcGVybHkgYXBwbGllZC5cbiAgICAvLyBEb24ndCBjaGFuZ2UgdGhlIG1lc3NhZ2UuIFJlYWN0IERldlRvb2xzIHJlbGllcyBvbiBpdC4gQWxzbyBtYWtlIHN1cmVcbiAgICAvLyB0aGlzIG1lc3NhZ2UgZG9lc24ndCBvY2N1ciBlbHNld2hlcmUgaW4gdGhpcyBmdW5jdGlvbiwgb3IgaXQgd2lsbCBjYXVzZVxuICAgIC8vIGEgZmFsc2UgcG9zaXRpdmUuXG4gICAgdGhyb3cgbmV3IEVycm9yKCdeX14nKTtcbiAgfVxuICB0cnkge1xuICAgIC8vIFZlcmlmeSB0aGF0IHRoZSBjb2RlIGFib3ZlIGhhcyBiZWVuIGRlYWQgY29kZSBlbGltaW5hdGVkIChEQ0UnZCkuXG4gICAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmNoZWNrRENFKGNoZWNrRENFKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gRGV2VG9vbHMgc2hvdWxkbid0IGNyYXNoIFJlYWN0LCBubyBtYXR0ZXIgd2hhdC5cbiAgICAvLyBXZSBzaG91bGQgc3RpbGwgcmVwb3J0IGluIGNhc2Ugd2UgYnJlYWsgdGhpcyBjb2RlLlxuICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICAvLyBEQ0UgY2hlY2sgc2hvdWxkIGhhcHBlbiBiZWZvcmUgUmVhY3RET00gYnVuZGxlIGV4ZWN1dGVzIHNvIHRoYXRcbiAgLy8gRGV2VG9vbHMgY2FuIHJlcG9ydCBiYWQgbWluaWZpY2F0aW9uIGR1cmluZyBpbmplY3Rpb24uXG4gIGNoZWNrRENFKCk7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIG5vcm1hbGl6ZUhlYWRlck5hbWUgPSByZXF1aXJlKCcuL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZScpO1xuXG52YXIgREVGQVVMVF9DT05URU5UX1RZUEUgPSB7XG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xufTtcblxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XG4gIGlmICghdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVycykgJiYgdXRpbHMuaXNVbmRlZmluZWQoaGVhZGVyc1snQ29udGVudC1UeXBlJ10pKSB7XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcbiAgdmFyIGFkYXB0ZXI7XG4gIGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL3hocicpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBub2RlIHVzZSBIVFRQIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy9odHRwJyk7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgYWRhcHRlcjogZ2V0RGVmYXVsdEFkYXB0ZXIoKSxcblxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XG4gICAgbm9ybWFsaXplSGVhZGVyTmFtZShoZWFkZXJzLCAnQ29udGVudC1UeXBlJyk7XG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0cmFuc2Zvcm1SZXNwb25zZTogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlc3BvbnNlKGRhdGEpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0cnkge1xuICAgICAgICBkYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHsgLyogSWdub3JlICovIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRpbWVvdXQ6IDAsXG5cbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcbiAgeHNyZkhlYWRlck5hbWU6ICdYLVhTUkYtVE9LRU4nLFxuXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbi8qKlxuICogU2ltcGxlLCBsaWdodHdlaWdodCBtb2R1bGUgYXNzaXN0aW5nIHdpdGggdGhlIGRldGVjdGlvbiBhbmQgY29udGV4dCBvZlxuICogV29ya2VyLiBIZWxwcyBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmNpZXMgYW5kIGFsbG93cyBjb2RlIHRvIHJlYXNvbiBhYm91dFxuICogd2hldGhlciBvciBub3QgdGhleSBhcmUgaW4gYSBXb3JrZXIsIGV2ZW4gaWYgdGhleSBuZXZlciBpbmNsdWRlIHRoZSBtYWluXG4gKiBgUmVhY3RXb3JrZXJgIGRlcGVuZGVuY3kuXG4gKi9cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHtcblxuICBjYW5Vc2VET006IGNhblVzZURPTSxcblxuICBjYW5Vc2VXb3JrZXJzOiB0eXBlb2YgV29ya2VyICE9PSAndW5kZWZpbmVkJyxcblxuICBjYW5Vc2VFdmVudExpc3RlbmVyczogY2FuVXNlRE9NICYmICEhKHdpbmRvdy5hZGRFdmVudExpc3RlbmVyIHx8IHdpbmRvdy5hdHRhY2hFdmVudCksXG5cbiAgY2FuVXNlVmlld3BvcnQ6IGNhblVzZURPTSAmJiAhIXdpbmRvdy5zY3JlZW4sXG5cbiAgaXNJbldvcmtlcjogIWNhblVzZURPTSAvLyBGb3Igbm93LCB0aGlzIGlzIHRydWUgLSBtaWdodCBjaGFuZ2UgaW4gdGhlIGZ1dHVyZS5cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFeGVjdXRpb25FbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJy4vZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFVwc3RyZWFtIHZlcnNpb24gb2YgZXZlbnQgbGlzdGVuZXIuIERvZXMgbm90IHRha2UgaW50byBhY2NvdW50IHNwZWNpZmljXG4gKiBuYXR1cmUgb2YgcGxhdGZvcm0uXG4gKi9cbnZhciBFdmVudExpc3RlbmVyID0ge1xuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBidWJibGUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgbGlzdGVuOiBmdW5jdGlvbiBsaXN0ZW4odGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0YXJnZXQuYXR0YWNoRXZlbnQpIHtcbiAgICAgIHRhcmdldC5hdHRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcbiAgICAgICAgICB0YXJnZXQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogTGlzdGVuIHRvIERPTSBldmVudHMgZHVyaW5nIHRoZSBjYXB0dXJlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGNhcHR1cmU6IGZ1bmN0aW9uIGNhcHR1cmUodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiByZWdpc3RlckRlZmF1bHQoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgZmItd3d3L3R5cGVvZi11bmRlZmluZWQgKi9cblxuLyoqXG4gKiBTYW1lIGFzIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgYnV0IHdyYXBzIGluIGEgdHJ5LWNhdGNoIGJsb2NrLiBJbiBJRSBpdCBpc1xuICogbm90IHNhZmUgdG8gY2FsbCBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGlmIHRoZXJlIGlzIG5vdGhpbmcgZm9jdXNlZC5cbiAqXG4gKiBUaGUgYWN0aXZlRWxlbWVudCB3aWxsIGJlIG51bGwgb25seSBpZiB0aGUgZG9jdW1lbnQgb3IgZG9jdW1lbnQgYm9keSBpcyBub3RcbiAqIHlldCBkZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7P0RPTURvY3VtZW50fSBkb2MgRGVmYXVsdHMgdG8gY3VycmVudCBkb2N1bWVudC5cbiAqIEByZXR1cm4gez9ET01FbGVtZW50fVxuICovXG5mdW5jdGlvbiBnZXRBY3RpdmVFbGVtZW50KGRvYykgLyo/RE9NRWxlbWVudCove1xuICBkb2MgPSBkb2MgfHwgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudCA6IHVuZGVmaW5lZCk7XG4gIGlmICh0eXBlb2YgZG9jID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRvYy5hY3RpdmVFbGVtZW50IHx8IGRvYy5ib2R5O1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvYy5ib2R5O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0QWN0aXZlRWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqIFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gIGlmICh4ID09PSB5KSB7XG4gICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAvLyBBZGRlZCB0aGUgbm9uemVybyB5IGNoZWNrIHRvIG1ha2UgRmxvdyBoYXBweSwgYnV0IGl0IGlzIHJlZHVuZGFudFxuICAgIHJldHVybiB4ICE9PSAwIHx8IHkgIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICB9IGVsc2Uge1xuICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgfVxufVxuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbChvYmpBLCBvYmpCKSB7XG4gIGlmIChpcyhvYmpBLCBvYmpCKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmpBICE9PSAnb2JqZWN0JyB8fCBvYmpBID09PSBudWxsIHx8IHR5cGVvZiBvYmpCICE9PSAnb2JqZWN0JyB8fCBvYmpCID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGtleXNBID0gT2JqZWN0LmtleXMob2JqQSk7XG4gIHZhciBrZXlzQiA9IE9iamVjdC5rZXlzKG9iakIpO1xuXG4gIGlmIChrZXlzQS5sZW5ndGggIT09IGtleXNCLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwob2JqQiwga2V5c0FbaV0pIHx8ICFpcyhvYmpBW2tleXNBW2ldXSwgb2JqQltrZXlzQVtpXV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hhbGxvd0VxdWFsO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxudmFyIGlzVGV4dE5vZGUgPSByZXF1aXJlKCcuL2lzVGV4dE5vZGUnKTtcblxuLyplc2xpbnQtZGlzYWJsZSBuby1iaXR3aXNlICovXG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgZ2l2ZW4gRE9NIG5vZGUgY29udGFpbnMgb3IgaXMgYW5vdGhlciBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlKSB7XG4gIGlmICghb3V0ZXJOb2RlIHx8ICFpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKG91dGVyTm9kZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShpbm5lck5vZGUpKSB7XG4gICAgcmV0dXJuIGNvbnRhaW5zTm9kZShvdXRlck5vZGUsIGlubmVyTm9kZS5wYXJlbnROb2RlKTtcbiAgfSBlbHNlIGlmICgnY29udGFpbnMnIGluIG91dGVyTm9kZSkge1xuICAgIHJldHVybiBvdXRlck5vZGUuY29udGFpbnMoaW5uZXJOb2RlKTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICByZXR1cm4gISEob3V0ZXJOb2RlLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGlubmVyTm9kZSkgJiAxNik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGFpbnNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cblxuZnVuY3Rpb24gZm9jdXNOb2RlKG5vZGUpIHtcbiAgLy8gSUU4IGNhbiB0aHJvdyBcIkNhbid0IG1vdmUgZm9jdXMgdG8gdGhlIGNvbnRyb2wgYmVjYXVzZSBpdCBpcyBpbnZpc2libGUsXG4gIC8vIG5vdCBlbmFibGVkLCBvciBvZiBhIHR5cGUgdGhhdCBkb2VzIG5vdCBhY2NlcHQgdGhlIGZvY3VzLlwiIGZvciBhbGwga2luZHMgb2ZcbiAgLy8gcmVhc29ucyB0aGF0IGFyZSB0b28gZXhwZW5zaXZlIGFuZCBmcmFnaWxlIHRvIHRlc3QuXG4gIHRyeSB7XG4gICAgbm9kZS5mb2N1cygpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZvY3VzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBwYXJzZUhlYWRlcnMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvcGFyc2VIZWFkZXJzJyk7XG52YXIgaXNVUkxTYW1lT3JpZ2luID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbicpO1xudmFyIGNyZWF0ZUVycm9yID0gcmVxdWlyZSgnLi4vY29yZS9jcmVhdGVFcnJvcicpO1xudmFyIGJ0b2EgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmJ0b2EgJiYgd2luZG93LmJ0b2EuYmluZCh3aW5kb3cpKSB8fCByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnRvYScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiBkaXNwYXRjaFhoclJlcXVlc3QocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIHJlcXVlc3REYXRhID0gY29uZmlnLmRhdGE7XG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XG5cbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShyZXF1ZXN0RGF0YSkpIHtcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcbiAgICB9XG5cbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgIHZhciBsb2FkRXZlbnQgPSAnb25yZWFkeXN0YXRlY2hhbmdlJztcbiAgICB2YXIgeERvbWFpbiA9IGZhbHNlO1xuXG4gICAgLy8gRm9yIElFIDgvOSBDT1JTIHN1cHBvcnRcbiAgICAvLyBPbmx5IHN1cHBvcnRzIFBPU1QgYW5kIEdFVCBjYWxscyBhbmQgZG9lc24ndCByZXR1cm5zIHRoZSByZXNwb25zZSBoZWFkZXJzLlxuICAgIC8vIERPTidUIGRvIHRoaXMgZm9yIHRlc3RpbmcgYi9jIFhNTEh0dHBSZXF1ZXN0IGlzIG1vY2tlZCwgbm90IFhEb21haW5SZXF1ZXN0LlxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Rlc3QnICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIHdpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiAhKCd3aXRoQ3JlZGVudGlhbHMnIGluIHJlcXVlc3QpICYmXG4gICAgICAgICFpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpIHtcbiAgICAgIHJlcXVlc3QgPSBuZXcgd2luZG93LlhEb21haW5SZXF1ZXN0KCk7XG4gICAgICBsb2FkRXZlbnQgPSAnb25sb2FkJztcbiAgICAgIHhEb21haW4gPSB0cnVlO1xuICAgICAgcmVxdWVzdC5vbnByb2dyZXNzID0gZnVuY3Rpb24gaGFuZGxlUHJvZ3Jlc3MoKSB7fTtcbiAgICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHt9O1xuICAgIH1cblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgfHwgJyc7XG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xuICAgIH1cblxuICAgIHJlcXVlc3Qub3Blbihjb25maWcubWV0aG9kLnRvVXBwZXJDYXNlKCksIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKSwgdHJ1ZSk7XG5cbiAgICAvLyBTZXQgdGhlIHJlcXVlc3QgdGltZW91dCBpbiBNU1xuICAgIHJlcXVlc3QudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuXG4gICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZVxuICAgIHJlcXVlc3RbbG9hZEV2ZW50XSA9IGZ1bmN0aW9uIGhhbmRsZUxvYWQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QgfHwgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCAmJiAheERvbWFpbikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcbiAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xuICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxuICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhY29uZmlnLnJlc3BvbnNlVHlwZSB8fCBjb25maWcucmVzcG9uc2VUeXBlID09PSAndGV4dCcgPyByZXF1ZXN0LnJlc3BvbnNlVGV4dCA6IHJlcXVlc3QucmVzcG9uc2U7XG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XG4gICAgICAgIGRhdGE6IHJlc3BvbnNlRGF0YSxcbiAgICAgICAgLy8gSUUgc2VuZHMgMTIyMyBpbnN0ZWFkIG9mIDIwNCAoaHR0cHM6Ly9naXRodWIuY29tL2F4aW9zL2F4aW9zL2lzc3Vlcy8yMDEpXG4gICAgICAgIHN0YXR1czogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAyMDQgOiByZXF1ZXN0LnN0YXR1cyxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXMgPT09IDEyMjMgPyAnTm8gQ29udGVudCcgOiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSBsb3cgbGV2ZWwgbmV0d29yayBlcnJvcnNcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcbiAgICAgIC8vIFJlYWwgZXJyb3JzIGFyZSBoaWRkZW4gZnJvbSB1cyBieSB0aGUgYnJvd3NlclxuICAgICAgLy8gb25lcnJvciBzaG91bGQgb25seSBmaXJlIGlmIGl0J3MgYSBuZXR3b3JrIGVycm9yXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XG4gICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge1xuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCcsIGNvbmZpZywgJ0VDT05OQUJPUlRFRCcsXG4gICAgICAgIHJlcXVlc3QpKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfTtcblxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgIC8vIFRoaXMgaXMgb25seSBkb25lIGlmIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50LlxuICAgIC8vIFNwZWNpZmljYWxseSBub3QgaWYgd2UncmUgaW4gYSB3ZWIgd29ya2VyLCBvciByZWFjdC1uYXRpdmUuXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcbiAgICAgIHZhciBjb29raWVzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2Nvb2tpZXMnKTtcblxuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSAmJiBjb25maWcueHNyZkNvb2tpZU5hbWUgP1xuICAgICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcbiAgICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpIHtcbiAgICAgIHJlcXVlc3Qud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBBZGQgcmVzcG9uc2VUeXBlIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gRXhwZWN0ZWQgRE9NRXhjZXB0aW9uIHRocm93biBieSBicm93c2VycyBub3QgY29tcGF0aWJsZSBYTUxIdHRwUmVxdWVzdCBMZXZlbCAyLlxuICAgICAgICAvLyBCdXQsIHRoaXMgY2FuIGJlIHN1cHByZXNzZWQgZm9yICdqc29uJyB0eXBlIGFzIGl0IGNhbiBiZSBwYXJzZWQgYnkgZGVmYXVsdCAndHJhbnNmb3JtUmVzcG9uc2UnIGZ1bmN0aW9uLlxuICAgICAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XG4gICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJlcXVlc3QuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25Eb3dubG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICAvLyBOb3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgdXBsb2FkIGV2ZW50c1xuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcbiAgICAgIHJlcXVlc3QudXBsb2FkLmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcbiAgICAgIC8vIEhhbmRsZSBjYW5jZWxsYXRpb25cbiAgICAgIGNvbmZpZy5jYW5jZWxUb2tlbi5wcm9taXNlLnRoZW4oZnVuY3Rpb24gb25DYW5jZWxlZChjYW5jZWwpIHtcbiAgICAgICAgaWYgKCFyZXF1ZXN0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVxdWVzdC5hYm9ydCgpO1xuICAgICAgICByZWplY3QoY2FuY2VsKTtcbiAgICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXF1ZXN0RGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0NhbmNlbCh2YWx1ZSkge1xuICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX19DQU5DRUxfXyk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIENhbmNlbChtZXNzYWdlKSB7XG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG59XG5cbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgcmV0dXJuICdDYW5jZWwnICsgKHRoaXMubWVzc2FnZSA/ICc6ICcgKyB0aGlzLm1lc3NhZ2UgOiAnJyk7XG59O1xuXG5DYW5jZWwucHJvdG90eXBlLl9fQ0FOQ0VMX18gPSB0cnVlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9ICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmXG4gICAgU3ltYm9sLmZvciAmJlxuICAgIFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSkgfHxcbiAgICAweGVhYzc7XG5cbiAgdmFyIGlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmXG4gICAgICBvYmplY3QgIT09IG51bGwgJiZcbiAgICAgIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9O1xuXG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IGRldmVsb3BtZW50IGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIHZhciB0aHJvd09uRGlyZWN0QWNjZXNzID0gdHJ1ZTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzJykoaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpO1xufSBlbHNlIHtcbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgcHJvZHVjdGlvbiBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zJykoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBSZWFjdERPTSBmcm9tICdyZWFjdC1kb20nO1xuaW1wb3J0IEFwcCBmcm9tICcuL2FwcCc7XG5cblJlYWN0RE9NLnJlbmRlcig8QXBwIHVybD1cImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9hcGkvZGF0YVwiIC8+LCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJykpO1xuLy8gUmVhY3RET00ucmVuZGVyKDxBcHAgdXJsPVwiaHR0cHM6Ly9tYXhnb2x1YmV2LWN2Lmhlcm9rdWFwcC5jb20vYXBpL2RhdGFcIiAvPiwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRhaW5lcicpKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9pbmRleC5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMS4wXG4gKiByZWFjdC5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4ndXNlIHN0cmljdCc7dmFyIG09cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksbj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlPYmplY3RcIikscD1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKTtcbmZ1bmN0aW9uIHEoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxlPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGQ9MDtkPGI7ZCsrKWUrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbZCsxXSk7Yj1FcnJvcihlK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31cbnZhciByPXtpc01vdW50ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKCl7fSxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oKXt9fTtmdW5jdGlvbiB0KGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHJ9dC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD17fTt0LnByb3RvdHlwZS5zZXRTdGF0ZT1mdW5jdGlvbihhLGIpe1wib2JqZWN0XCIhPT10eXBlb2YgYSYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGEmJm51bGwhPWE/cShcIjg1XCIpOnZvaWQgMDt0aGlzLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKHRoaXMsYSxiLFwic2V0U3RhdGVcIil9O3QucHJvdG90eXBlLmZvcmNlVXBkYXRlPWZ1bmN0aW9uKGEpe3RoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcyxhLFwiZm9yY2VVcGRhdGVcIil9O1xuZnVuY3Rpb24gdShhLGIsZSl7dGhpcy5wcm9wcz1hO3RoaXMuY29udGV4dD1iO3RoaXMucmVmcz1uO3RoaXMudXBkYXRlcj1lfHxyfWZ1bmN0aW9uIHYoKXt9di5wcm90b3R5cGU9dC5wcm90b3R5cGU7dmFyIHc9dS5wcm90b3R5cGU9bmV3IHY7dy5jb25zdHJ1Y3Rvcj11O20odyx0LnByb3RvdHlwZSk7dy5pc1B1cmVSZWFjdENvbXBvbmVudD0hMDtmdW5jdGlvbiB4KGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHJ9dmFyIHk9eC5wcm90b3R5cGU9bmV3IHY7eS5jb25zdHJ1Y3Rvcj14O20oeSx0LnByb3RvdHlwZSk7eS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ9ITA7eS5yZW5kZXI9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbn07XG52YXIgej17Y3VycmVudDpudWxsfSxBPU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHksQj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0mJlN5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIil8fDYwMTAzLEM9e2tleTohMCxyZWY6ITAsX19zZWxmOiEwLF9fc291cmNlOiEwfTtcbmZ1bmN0aW9uIEQoYSxiLGUpe3ZhciBkLGM9e30saD1udWxsLGs9bnVsbDtpZihudWxsIT1iKWZvcihkIGluIHZvaWQgMCE9PWIucmVmJiYoaz1iLnJlZiksdm9pZCAwIT09Yi5rZXkmJihoPVwiXCIrYi5rZXkpLGIpQS5jYWxsKGIsZCkmJiFDLmhhc093blByb3BlcnR5KGQpJiYoY1tkXT1iW2RdKTt2YXIgZj1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWYpYy5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxmKXtmb3IodmFyIGc9QXJyYXkoZiksbD0wO2w8ZjtsKyspZ1tsXT1hcmd1bWVudHNbbCsyXTtjLmNoaWxkcmVuPWd9aWYoYSYmYS5kZWZhdWx0UHJvcHMpZm9yKGQgaW4gZj1hLmRlZmF1bHRQcm9wcyxmKXZvaWQgMD09PWNbZF0mJihjW2RdPWZbZF0pO3JldHVybnskJHR5cGVvZjpCLHR5cGU6YSxrZXk6aCxyZWY6ayxwcm9wczpjLF9vd25lcjp6LmN1cnJlbnR9fWZ1bmN0aW9uIEUoYSl7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmYS4kJHR5cGVvZj09PUJ9XG52YXIgRj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IsRz1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0mJlN5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIil8fDYwMTAzLEg9XCJmdW5jdGlvblwiPT09dHlwZW9mIFN5bWJvbCYmU3ltYm9sW1wiZm9yXCJdJiZTeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5wb3J0YWxcIil8fDYwMTA2O2Z1bmN0aW9uIGVzY2FwZShhKXt2YXIgYj17XCJcXHgzZFwiOlwiXFx4M2QwXCIsXCI6XCI6XCJcXHgzZDJcIn07cmV0dXJuXCIkXCIrKFwiXCIrYSkucmVwbGFjZSgvWz06XS9nLGZ1bmN0aW9uKGEpe3JldHVybiBiW2FdfSl9dmFyIEk9L1xcLysvZyxKPVtdO1xuZnVuY3Rpb24gSyhhLGIsZSxkKXtpZihKLmxlbmd0aCl7dmFyIGM9Si5wb3AoKTtjLnJlc3VsdD1hO2Mua2V5UHJlZml4PWI7Yy5mdW5jPWU7Yy5jb250ZXh0PWQ7Yy5jb3VudD0wO3JldHVybiBjfXJldHVybntyZXN1bHQ6YSxrZXlQcmVmaXg6YixmdW5jOmUsY29udGV4dDpkLGNvdW50OjB9fWZ1bmN0aW9uIEwoYSl7YS5yZXN1bHQ9bnVsbDthLmtleVByZWZpeD1udWxsO2EuZnVuYz1udWxsO2EuY29udGV4dD1udWxsO2EuY291bnQ9MDsxMD5KLmxlbmd0aCYmSi5wdXNoKGEpfVxuZnVuY3Rpb24gTShhLGIsZSxkKXt2YXIgYz10eXBlb2YgYTtpZihcInVuZGVmaW5lZFwiPT09Y3x8XCJib29sZWFuXCI9PT1jKWE9bnVsbDtpZihudWxsPT09YXx8XCJzdHJpbmdcIj09PWN8fFwibnVtYmVyXCI9PT1jfHxcIm9iamVjdFwiPT09YyYmYS4kJHR5cGVvZj09PUd8fFwib2JqZWN0XCI9PT1jJiZhLiQkdHlwZW9mPT09SClyZXR1cm4gZShkLGEsXCJcIj09PWI/XCIuXCIrTihhLDApOmIpLDE7dmFyIGg9MDtiPVwiXCI9PT1iP1wiLlwiOmIrXCI6XCI7aWYoQXJyYXkuaXNBcnJheShhKSlmb3IodmFyIGs9MDtrPGEubGVuZ3RoO2srKyl7Yz1hW2tdO3ZhciBmPWIrTihjLGspO2grPU0oYyxmLGUsZCl9ZWxzZSBpZihmPUYmJmFbRl18fGFbXCJAQGl0ZXJhdG9yXCJdLFwiZnVuY3Rpb25cIj09PXR5cGVvZiBmKWZvcihhPWYuY2FsbChhKSxrPTA7IShjPWEubmV4dCgpKS5kb25lOyljPWMudmFsdWUsZj1iK04oYyxrKyspLGgrPU0oYyxmLGUsZCk7ZWxzZVwib2JqZWN0XCI9PT1jJiYoZT1cIlwiK2EscShcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PVxuZT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGEpLmpvaW4oXCIsIFwiKStcIn1cIjplLFwiXCIpKTtyZXR1cm4gaH1mdW5jdGlvbiBOKGEsYil7cmV0dXJuXCJvYmplY3RcIj09PXR5cGVvZiBhJiZudWxsIT09YSYmbnVsbCE9YS5rZXk/ZXNjYXBlKGEua2V5KTpiLnRvU3RyaW5nKDM2KX1mdW5jdGlvbiBPKGEsYil7YS5mdW5jLmNhbGwoYS5jb250ZXh0LGIsYS5jb3VudCsrKX1cbmZ1bmN0aW9uIFAoYSxiLGUpe3ZhciBkPWEucmVzdWx0LGM9YS5rZXlQcmVmaXg7YT1hLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspO0FycmF5LmlzQXJyYXkoYSk/UShhLGQsZSxwLnRoYXRSZXR1cm5zQXJndW1lbnQpOm51bGwhPWEmJihFKGEpJiYoYj1jKyghYS5rZXl8fGImJmIua2V5PT09YS5rZXk/XCJcIjooXCJcIithLmtleSkucmVwbGFjZShJLFwiJFxceDI2L1wiKStcIi9cIikrZSxhPXskJHR5cGVvZjpCLHR5cGU6YS50eXBlLGtleTpiLHJlZjphLnJlZixwcm9wczphLnByb3BzLF9vd25lcjphLl9vd25lcn0pLGQucHVzaChhKSl9ZnVuY3Rpb24gUShhLGIsZSxkLGMpe3ZhciBoPVwiXCI7bnVsbCE9ZSYmKGg9KFwiXCIrZSkucmVwbGFjZShJLFwiJFxceDI2L1wiKStcIi9cIik7Yj1LKGIsaCxkLGMpO251bGw9PWF8fE0oYSxcIlwiLFAsYik7TChiKX1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0mJlN5bWJvbFtcImZvclwiXShcInJlYWN0LmZyYWdtZW50XCIpO1xudmFyIFI9e0NoaWxkcmVuOnttYXA6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7dmFyIGQ9W107UShhLGQsbnVsbCxiLGUpO3JldHVybiBkfSxmb3JFYWNoOmZ1bmN0aW9uKGEsYixlKXtpZihudWxsPT1hKXJldHVybiBhO2I9SyhudWxsLG51bGwsYixlKTtudWxsPT1hfHxNKGEsXCJcIixPLGIpO0woYil9LGNvdW50OmZ1bmN0aW9uKGEpe3JldHVybiBudWxsPT1hPzA6TShhLFwiXCIscC50aGF0UmV0dXJuc051bGwsbnVsbCl9LHRvQXJyYXk6ZnVuY3Rpb24oYSl7dmFyIGI9W107UShhLGIsbnVsbCxwLnRoYXRSZXR1cm5zQXJndW1lbnQpO3JldHVybiBifSxvbmx5OmZ1bmN0aW9uKGEpe0UoYSk/dm9pZCAwOnEoXCIxNDNcIik7cmV0dXJuIGF9fSxDb21wb25lbnQ6dCxQdXJlQ29tcG9uZW50OnUsdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6eCxjcmVhdGVFbGVtZW50OkQsY2xvbmVFbGVtZW50OmZ1bmN0aW9uKGEsYixlKXt2YXIgZD1tKHt9LGEucHJvcHMpLGM9YS5rZXksaD1hLnJlZixcbms9YS5fb3duZXI7aWYobnVsbCE9Yil7dm9pZCAwIT09Yi5yZWYmJihoPWIucmVmLGs9ei5jdXJyZW50KTt2b2lkIDAhPT1iLmtleSYmKGM9XCJcIitiLmtleSk7aWYoYS50eXBlJiZhLnR5cGUuZGVmYXVsdFByb3BzKXZhciBmPWEudHlwZS5kZWZhdWx0UHJvcHM7Zm9yKGcgaW4gYilBLmNhbGwoYixnKSYmIUMuaGFzT3duUHJvcGVydHkoZykmJihkW2ddPXZvaWQgMD09PWJbZ10mJnZvaWQgMCE9PWY/ZltnXTpiW2ddKX12YXIgZz1hcmd1bWVudHMubGVuZ3RoLTI7aWYoMT09PWcpZC5jaGlsZHJlbj1lO2Vsc2UgaWYoMTxnKXtmPUFycmF5KGcpO2Zvcih2YXIgbD0wO2w8ZztsKyspZltsXT1hcmd1bWVudHNbbCsyXTtkLmNoaWxkcmVuPWZ9cmV0dXJueyQkdHlwZW9mOkIsdHlwZTphLnR5cGUsa2V5OmMscmVmOmgscHJvcHM6ZCxfb3duZXI6a319LGNyZWF0ZUZhY3Rvcnk6ZnVuY3Rpb24oYSl7dmFyIGI9RC5iaW5kKG51bGwsYSk7Yi50eXBlPWE7cmV0dXJuIGJ9LGlzVmFsaWRFbGVtZW50OkUsXG52ZXJzaW9uOlwiMTYuMS4wXCIsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e1JlYWN0Q3VycmVudE93bmVyOnosYXNzaWduOm19fSxTPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6Un0pLFQ9UyYmUnx8Uzttb2R1bGUuZXhwb3J0cz1UW1wiZGVmYXVsdFwiXT9UW1wiZGVmYXVsdFwiXTpUO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMS4wXG4gKiByZWFjdC5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjEuMCc7XG5cbi8qKlxuICogV0FSTklORzogRE8gTk9UIG1hbnVhbGx5IHJlcXVpcmUgdGhpcyBtb2R1bGUuXG4gKiBUaGlzIGlzIGEgcmVwbGFjZW1lbnQgZm9yIGBpbnZhcmlhbnQoLi4uKWAgdXNlZCBieSB0aGUgZXJyb3IgY29kZSBzeXN0ZW1cbiAqIGFuZCB3aWxsIF9vbmx5XyBiZSByZXF1aXJlZCBieSB0aGUgY29ycmVzcG9uZGluZyBiYWJlbCBwYXNzLlxuICogSXQgYWx3YXlzIHRocm93cy5cbiAqL1xuXG4vLyBFeHBvcnRzIFJlYWN0LkZyYWdtZW50XG52YXIgZW5hYmxlUmVhY3RGcmFnbWVudCA9IGZhbHNlO1xuLy8gRXhwb3J0cyBSZWFjdERPTS5jcmVhdGVSb290XG5cblxuXG4vLyBNdXRhdGluZyBtb2RlIChSZWFjdCBET00sIFJlYWN0IEFSVCwgUmVhY3QgTmF0aXZlKTpcblxuLy8gRXhwZXJpbWVudGFsIG5vb3AgbW9kZSAoY3VycmVudGx5IHVudXNlZCk6XG5cbi8vIEV4cGVyaW1lbnRhbCBwZXJzaXN0ZW50IG1vZGUgKENTKTpcblxuXG4vLyBPbmx5IHVzZWQgaW4gd3d3IGJ1aWxkcy5cblxuLyoqXG4gKiBGb3JrZWQgZnJvbSBmYmpzL3dhcm5pbmc6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmJqcy9ibG9iL2U2NmJhMjBhZDViZTQzM2ViNTQ0MjNmMmIwOTdkODI5MzI0ZDlkZTYvcGFja2FnZXMvZmJqcy9zcmMvX19mb3Jrc19fL3dhcm5pbmcuanNcbiAqXG4gKiBPbmx5IGNoYW5nZSBpcyB3ZSB1c2UgY29uc29sZS53YXJuIGluc3RlYWQgb2YgY29uc29sZS5lcnJvcixcbiAqIGFuZCBkbyBub3RoaW5nIHdoZW4gJ2NvbnNvbGUnIGlzIG5vdCBzdXBwb3J0ZWQuXG4gKiBUaGlzIHJlYWxseSBzaW1wbGlmaWVzIHRoZSBjb2RlLlxuICogLS0tXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uICgpIHt9O1xuXG57XG4gIHZhciBwcmludFdhcm5pbmcgPSBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgKyBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIGxvd1ByaW9yaXR5V2FybmluZyA9IGZ1bmN0aW9uIChjb25kaXRpb24sIGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdgd2FybmluZyhjb25kaXRpb24sIGZvcm1hdCwgLi4uYXJncylgIHJlcXVpcmVzIGEgd2FybmluZyAnICsgJ21lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4yID4gMiA/IF9sZW4yIC0gMiA6IDApLCBfa2V5MiA9IDI7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgYXJnc1tfa2V5MiAtIDJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nLmFwcGx5KHVuZGVmaW5lZCwgW2Zvcm1hdF0uY29uY2F0KGFyZ3MpKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmckMSA9IGxvd1ByaW9yaXR5V2FybmluZztcblxudmFyIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudCA9IHt9O1xuXG5mdW5jdGlvbiB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgY2FsbGVyTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3I7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBjb25zdHJ1Y3RvciAmJiAoY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgY29uc3RydWN0b3IubmFtZSkgfHwgJ1JlYWN0Q2xhc3MnO1xuICAgIHZhciB3YXJuaW5nS2V5ID0gY29tcG9uZW50TmFtZSArICcuJyArIGNhbGxlck5hbWU7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFt3YXJuaW5nS2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyBjb21wb25lbnQuICcgKyAnVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgJXMoKSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiAnICsgJ1RoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgdGhlIGFic3RyYWN0IEFQSSBmb3IgYW4gdXBkYXRlIHF1ZXVlLlxuICovXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSB7XG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICAgKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICAgKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAgICpcbiAgICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICAgKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdmb3JjZVVwZGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhbGwgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgb3IgYHNldFN0YXRlYCB0byBtdXRhdGUgc3RhdGUuXG4gICAqIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAgICpcbiAgICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAgICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb21wbGV0ZVN0YXRlIE5leHQgc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gY2FsbGVyTmFtZSBuYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ3JlcGxhY2VTdGF0ZScpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gVGhpcyBvbmx5IGV4aXN0cyBiZWNhdXNlIF9wZW5kaW5nU3RhdGUgaXNcbiAgICogaW50ZXJuYWwuIFRoaXMgcHJvdmlkZXMgYSBtZXJnaW5nIHN0cmF0ZWd5IHRoYXQgaXMgbm90IGF2YWlsYWJsZSB0byBkZWVwXG4gICAqIHByb3BlcnRpZXMgd2hpY2ggaXMgY29uZnVzaW5nLiBUT0RPOiBFeHBvc2UgcGVuZGluZ1N0YXRlIG9yIGRvbid0IHVzZSBpdFxuICAgKiBkdXJpbmcgdGhlIG1lcmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggc3RhdGUuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgY29tcG9uZW50IGlzIHVwZGF0ZWQuXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gTmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfVxufTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5Db21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQgPSB7fTtcblxuLyoqXG4gKiBTZXRzIGEgc3Vic2V0IG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIHRvIG11dGF0ZVxuICogc3RhdGUuIFlvdSBzaG91bGQgdHJlYXQgYHRoaXMuc3RhdGVgIGFzIGltbXV0YWJsZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICogYWNjZXNzaW5nIGB0aGlzLnN0YXRlYCBhZnRlciBjYWxsaW5nIHRoaXMgbWV0aG9kIG1heSByZXR1cm4gdGhlIG9sZCB2YWx1ZS5cbiAqXG4gKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBjYWxscyB0byBgc2V0U3RhdGVgIHdpbGwgcnVuIHN5bmNocm9ub3VzbHksXG4gKiBhcyB0aGV5IG1heSBldmVudHVhbGx5IGJlIGJhdGNoZWQgdG9nZXRoZXIuICBZb3UgY2FuIHByb3ZpZGUgYW4gb3B0aW9uYWxcbiAqIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHRoZSBjYWxsIHRvIHNldFN0YXRlIGlzIGFjdHVhbGx5XG4gKiBjb21wbGV0ZWQuXG4gKlxuICogV2hlbiBhIGZ1bmN0aW9uIGlzIHByb3ZpZGVkIHRvIHNldFN0YXRlLCBpdCB3aWxsIGJlIGNhbGxlZCBhdCBzb21lIHBvaW50IGluXG4gKiB0aGUgZnV0dXJlIChub3Qgc3luY2hyb25vdXNseSkuIEl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHVwIHRvIGRhdGVcbiAqIGNvbXBvbmVudCBhcmd1bWVudHMgKHN0YXRlLCBwcm9wcywgY29udGV4dCkuIFRoZXNlIHZhbHVlcyBjYW4gYmUgZGlmZmVyZW50XG4gKiBmcm9tIHRoaXMuKiBiZWNhdXNlIHlvdXIgZnVuY3Rpb24gbWF5IGJlIGNhbGxlZCBhZnRlciByZWNlaXZlUHJvcHMgYnV0IGJlZm9yZVxuICogc2hvdWxkQ29tcG9uZW50VXBkYXRlLCBhbmQgdGhpcyBuZXcgc3RhdGUsIHByb3BzLCBhbmQgY29udGV4dCB3aWxsIG5vdCB5ZXQgYmVcbiAqIGFzc2lnbmVkIHRvIHRoaXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R8ZnVuY3Rpb259IHBhcnRpYWxTdGF0ZSBOZXh0IHBhcnRpYWwgc3RhdGUgb3IgZnVuY3Rpb24gdG9cbiAqICAgICAgICBwcm9kdWNlIG5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBjdXJyZW50IHN0YXRlLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cbkNvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogdGFrZXMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcyB0byB1cGRhdGUgb3IgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiB2b2lkIDA7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcywgcGFydGlhbFN0YXRlLCBjYWxsYmFjaywgJ3NldFN0YXRlJyk7XG59O1xuXG4vKipcbiAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICpcbiAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICpcbiAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gKlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciB1cGRhdGUgaXMgY29tcGxldGUuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMsIGNhbGxiYWNrLCAnZm9yY2VVcGRhdGUnKTtcbn07XG5cbi8qKlxuICogRGVwcmVjYXRlZCBBUElzLiBUaGVzZSBBUElzIHVzZWQgdG8gZXhpc3Qgb24gY2xhc3NpYyBSZWFjdCBjbGFzc2VzIGJ1dCBzaW5jZVxuICogd2Ugd291bGQgbGlrZSB0byBkZXByZWNhdGUgdGhlbSwgd2UncmUgbm90IGdvaW5nIHRvIG1vdmUgdGhlbSBvdmVyIHRvIHRoaXNcbiAqIG1vZGVybiBiYXNlIGNsYXNzLiBJbnN0ZWFkLCB3ZSBkZWZpbmUgYSBnZXR0ZXIgdGhhdCB3YXJucyBpZiBpdCdzIGFjY2Vzc2VkLlxuICovXG57XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVN0YXRlOiBbJ3JlcGxhY2VTdGF0ZScsICdSZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIHNldFN0YXRlIGluc3RlYWQgKHNlZSAnICsgJ2h0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMzIzNikuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbXBvbmVudC5wcm90b3R5cGUsIG1ldGhvZE5hbWUsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICBsb3dQcmlvcml0eVdhcm5pbmckMShmYWxzZSwgJyVzKC4uLikgaXMgZGVwcmVjYXRlZCBpbiBwbGFpbiBKYXZhU2NyaXB0IFJlYWN0IGNsYXNzZXMuICVzJywgaW5mb1swXSwgaW5mb1sxXSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUHVyZUNvbXBvbmVudChwcm9wcywgY29udGV4dCwgdXBkYXRlcikge1xuICAvLyBEdXBsaWNhdGVkIGZyb20gQ29tcG9uZW50LlxuICB0aGlzLnByb3BzID0gcHJvcHM7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMucmVmcyA9IGVtcHR5T2JqZWN0O1xuICAvLyBXZSBpbml0aWFsaXplIHRoZSBkZWZhdWx0IHVwZGF0ZXIgYnV0IHRoZSByZWFsIG9uZSBnZXRzIGluamVjdGVkIGJ5IHRoZVxuICAvLyByZW5kZXJlci5cbiAgdGhpcy51cGRhdGVyID0gdXBkYXRlciB8fCBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcbn1cblxuZnVuY3Rpb24gQ29tcG9uZW50RHVtbXkoKSB7fVxuQ29tcG9uZW50RHVtbXkucHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbnZhciBwdXJlQ29tcG9uZW50UHJvdG90eXBlID0gUHVyZUNvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbnB1cmVDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBQdXJlQ29tcG9uZW50O1xuLy8gQXZvaWQgYW4gZXh0cmEgcHJvdG90eXBlIGp1bXAgZm9yIHRoZXNlIG1ldGhvZHMuXG5fYXNzaWduKHB1cmVDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCA9IHRydWU7XG5cbmZ1bmN0aW9uIEFzeW5jQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG52YXIgYXN5bmNDb21wb25lbnRQcm90b3R5cGUgPSBBc3luY0NvbXBvbmVudC5wcm90b3R5cGUgPSBuZXcgQ29tcG9uZW50RHVtbXkoKTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQXN5bmNDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24oYXN5bmNDb21wb25lbnRQcm90b3R5cGUsIENvbXBvbmVudC5wcm90b3R5cGUpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcbmFzeW5jQ29tcG9uZW50UHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucHJvcHMuY2hpbGRyZW47XG59O1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIEB0eXBlIHtSZWFjdENvbXBvbmVudH1cbiAgICovXG4gIGN1cnJlbnQ6IG51bGxcbn07XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudCB0eXBlLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFJDEgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcblxudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBrZXk6IHRydWUsXG4gIHJlZjogdHJ1ZSxcbiAgX19zZWxmOiB0cnVlLFxuICBfX3NvdXJjZTogdHJ1ZVxufTtcblxudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG4gICAgICBpZiAoZ2V0dGVyICYmIGdldHRlci5pc1JlYWN0V2FybmluZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5rZXkgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vZmIubWUvcmVhY3Qtc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgfVxuICB9O1xuICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgbm8gaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUkMSxcblxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcblxuICAgIC8vIFJlY29yZCB0aGUgY29tcG9uZW50IHJlc3BvbnNpYmxlIGZvciBjcmVhdGluZyB0aGlzIGVsZW1lbnQuXG4gICAgX293bmVyOiBvd25lclxuICB9O1xuXG4gIHtcbiAgICAvLyBUaGUgdmFsaWRhdGlvbiBmbGFnIGlzIGN1cnJlbnRseSBtdXRhdGl2ZS4gV2UgcHV0IGl0IG9uXG4gICAgLy8gYW4gZXh0ZXJuYWwgYmFja2luZyBzdG9yZSBzbyB0aGF0IHdlIGNhbiBmcmVlemUgdGhlIHdob2xlIG9iamVjdC5cbiAgICAvLyBUaGlzIGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgV2Vha01hcCBvbmNlIHRoZXkgYXJlIGltcGxlbWVudGVkIGluXG4gICAgLy8gY29tbW9ubHkgdXNlZCBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMuXG4gICAgZWxlbWVudC5fc3RvcmUgPSB7fTtcblxuICAgIC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pO1xuICAgIC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTtcbiAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcbiAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50LnByb3BzKTtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVsZW1lbnQ7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCBvZiB0aGUgZ2l2ZW4gdHlwZS5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY3JlYXRlZWxlbWVudFxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIHNlbGYgPSBjb25maWcuX19zZWxmID09PSB1bmRlZmluZWQgPyBudWxsIDogY29uZmlnLl9fc2VsZjtcbiAgICBzb3VyY2UgPSBjb25maWcuX19zb3VyY2UgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zb3VyY2U7XG4gICAgLy8gUmVtYWluaW5nIHByb3BlcnRpZXMgYXJlIGFkZGVkIHRvIGEgbmV3IHByb3BzIG9iamVjdFxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAge1xuICAgICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShjaGlsZEFycmF5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gIGlmICh0eXBlICYmIHR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuICAgIGZvciAocHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAge1xuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICBpZiAodHlwZW9mIHByb3BzLiQkdHlwZW9mID09PSAndW5kZWZpbmVkJyB8fCBwcm9wcy4kJHR5cGVvZiAhPT0gUkVBQ1RfRUxFTUVOVF9UWVBFJDEpIHtcbiAgICAgICAgdmFyIGRpc3BsYXlOYW1lID0gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgPyB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCAnVW5rbm93bicgOiB0eXBlO1xuICAgICAgICBpZiAoa2V5KSB7XG4gICAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVmKSB7XG4gICAgICAgICAgZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYSBmdW5jdGlvbiB0aGF0IHByb2R1Y2VzIFJlYWN0RWxlbWVudHMgb2YgYSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVmYWN0b3J5XG4gKi9cblxuXG5mdW5jdGlvbiBjbG9uZUFuZFJlcGxhY2VLZXkob2xkRWxlbWVudCwgbmV3S2V5KSB7XG4gIHZhciBuZXdFbGVtZW50ID0gUmVhY3RFbGVtZW50KG9sZEVsZW1lbnQudHlwZSwgbmV3S2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgb2xkRWxlbWVudC5wcm9wcyk7XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbi8qKlxuICogQ2xvbmUgYW5kIHJldHVybiBhIG5ldyBSZWFjdEVsZW1lbnQgdXNpbmcgZWxlbWVudCBhcyB0aGUgc3RhcnRpbmcgcG9pbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2Nsb25lZWxlbWVudFxuICovXG5mdW5jdGlvbiBjbG9uZUVsZW1lbnQoZWxlbWVudCwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gT3JpZ2luYWwgcHJvcHMgYXJlIGNvcGllZFxuICB2YXIgcHJvcHMgPSBfYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIC8vIFNpbGVudGx5IHN0ZWFsIHRoZSByZWYgZnJvbSB0aGUgcGFyZW50LlxuICAgICAgcmVmID0gY29uZmlnLnJlZjtcbiAgICAgIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICB9XG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIGtleSA9ICcnICsgY29uZmlnLmtleTtcbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBvdmVycmlkZSBleGlzdGluZyBwcm9wc1xuICAgIHZhciBkZWZhdWx0UHJvcHM7XG4gICAgaWYgKGVsZW1lbnQudHlwZSAmJiBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzKSB7XG4gICAgICBkZWZhdWx0UHJvcHMgPSBlbGVtZW50LnR5cGUuZGVmYXVsdFByb3BzO1xuICAgIH1cbiAgICBmb3IgKHByb3BOYW1lIGluIGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBwcm9wTmFtZSkgJiYgIVJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBpZiAoY29uZmlnW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkICYmIGRlZmF1bHRQcm9wcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzXG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2hpbGRyZW4gY2FuIGJlIG1vcmUgdGhhbiBvbmUgYXJndW1lbnQsIGFuZCB0aG9zZSBhcmUgdHJhbnNmZXJyZWQgb250b1xuICAvLyB0aGUgbmV3bHkgYWxsb2NhdGVkIHByb3BzIG9iamVjdC5cbiAgdmFyIGNoaWxkcmVuTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCAtIDI7XG4gIGlmIChjaGlsZHJlbkxlbmd0aCA9PT0gMSkge1xuICAgIHByb3BzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIH0gZWxzZSBpZiAoY2hpbGRyZW5MZW5ndGggPiAxKSB7XG4gICAgdmFyIGNoaWxkQXJyYXkgPSBBcnJheShjaGlsZHJlbkxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbkxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZEFycmF5W2ldID0gYXJndW1lbnRzW2kgKyAyXTtcbiAgICB9XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZEFycmF5O1xuICB9XG5cbiAgcmV0dXJuIFJlYWN0RWxlbWVudChlbGVtZW50LnR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcyk7XG59XG5cbi8qKlxuICogVmVyaWZpZXMgdGhlIG9iamVjdCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjaXN2YWxpZGVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGBvYmplY3RgIGlzIGEgdmFsaWQgY29tcG9uZW50LlxuICogQGZpbmFsXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFJDE7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0ge307XG5cbntcbiAgLy8gQ29tcG9uZW50IHRoYXQgaXMgYmVpbmcgd29ya2VkIG9uXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcblxuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGltcGwgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjaztcbiAgICBpZiAoaW1wbCkge1xuICAgICAgcmV0dXJuIGltcGwoKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG59XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZWxlbWVudCcpIHx8IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSB8fCAweGVhY2E7XG52YXIgU0VQQVJBVE9SID0gJy4nO1xudmFyIFNVQlNFUEFSQVRPUiA9ICc6JztcblxuLyoqXG4gKiBFc2NhcGUgYW5kIHdyYXAga2V5IHNvIGl0IGlzIHNhZmUgdG8gdXNlIGFzIGEgcmVhY3RpZFxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgdG8gYmUgZXNjYXBlZC5cbiAqIEByZXR1cm4ge3N0cmluZ30gdGhlIGVzY2FwZWQga2V5LlxuICovXG5mdW5jdGlvbiBlc2NhcGUoa2V5KSB7XG4gIHZhciBlc2NhcGVSZWdleCA9IC9bPTpdL2c7XG4gIHZhciBlc2NhcGVyTG9va3VwID0ge1xuICAgICc9JzogJz0wJyxcbiAgICAnOic6ICc9MidcbiAgfTtcbiAgdmFyIGVzY2FwZWRTdHJpbmcgPSAoJycgKyBrZXkpLnJlcGxhY2UoZXNjYXBlUmVnZXgsIGZ1bmN0aW9uIChtYXRjaCkge1xuICAgIHJldHVybiBlc2NhcGVyTG9va3VwW21hdGNoXTtcbiAgfSk7XG5cbiAgcmV0dXJuICckJyArIGVzY2FwZWRTdHJpbmc7XG59XG5cbi8qKlxuICogVE9ETzogVGVzdCB0aGF0IGEgc2luZ2xlIGNoaWxkIGFuZCBhbiBhcnJheSB3aXRoIG9uZSBpdGVtIGhhdmUgdGhlIHNhbWUga2V5XG4gKiBwYXR0ZXJuLlxuICovXG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbnZhciB1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCA9IC9cXC8rL2c7XG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgJyQmLycpO1xufVxuXG52YXIgUE9PTF9TSVpFID0gMTA7XG52YXIgdHJhdmVyc2VDb250ZXh0UG9vbCA9IFtdO1xuZnVuY3Rpb24gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KG1hcFJlc3VsdCwga2V5UHJlZml4LCBtYXBGdW5jdGlvbiwgbWFwQ29udGV4dCkge1xuICBpZiAodHJhdmVyc2VDb250ZXh0UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gdHJhdmVyc2VDb250ZXh0UG9vbC5wb3AoKTtcbiAgICB0cmF2ZXJzZUNvbnRleHQucmVzdWx0ID0gbWFwUmVzdWx0O1xuICAgIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBrZXlQcmVmaXg7XG4gICAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG1hcENvbnRleHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgICByZXR1cm4gdHJhdmVyc2VDb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB7XG4gICAgICByZXN1bHQ6IG1hcFJlc3VsdCxcbiAgICAgIGtleVByZWZpeDoga2V5UHJlZml4LFxuICAgICAgZnVuYzogbWFwRnVuY3Rpb24sXG4gICAgICBjb250ZXh0OiBtYXBDb250ZXh0LFxuICAgICAgY291bnQ6IDBcbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KSB7XG4gIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQua2V5UHJlZml4ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmZ1bmMgPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb3VudCA9IDA7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCA8IFBPT0xfU0laRSkge1xuICAgIHRyYXZlcnNlQ29udGV4dFBvb2wucHVzaCh0cmF2ZXJzZUNvbnRleHQpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fFxuICAvLyBUaGUgZm9sbG93aW5nIGlzIGlubGluZWQgZnJvbSBSZWFjdEVsZW1lbnQuIFRoaXMgbWVhbnMgd2UgY2FuIG9wdGltaXplXG4gIC8vIHNvbWUgY2hlY2tzLiBSZWFjdCBGaWJlciBhbHNvIGlubGluZXMgdGhpcyBsb2dpYyBmb3Igc2ltaWxhciBwdXJwb3Nlcy5cbiAgdHlwZSA9PT0gJ29iamVjdCcgJiYgY2hpbGRyZW4uJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfUE9SVEFMX1RZUEUpIHtcbiAgICBjYWxsYmFjayh0cmF2ZXJzZUNvbnRleHQsIGNoaWxkcmVuLFxuICAgIC8vIElmIGl0J3MgdGhlIG9ubHkgY2hpbGQsIHRyZWF0IHRoZSBuYW1lIGFzIGlmIGl0IHdhcyB3cmFwcGVkIGluIGFuIGFycmF5XG4gICAgLy8gc28gdGhhdCBpdCdzIGNvbnNpc3RlbnQgaWYgdGhlIG51bWJlciBvZiBjaGlsZHJlbiBncm93cy5cbiAgICBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkcmVuLCAwKSA6IG5hbWVTb0Zhcik7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICB2YXIgY2hpbGQ7XG4gIHZhciBuZXh0TmFtZTtcbiAgdmFyIHN1YnRyZWVDb3VudCA9IDA7IC8vIENvdW50IG9mIGNoaWxkcmVuIGZvdW5kIGluIHRoZSBjdXJyZW50IHN1YnRyZWUuXG4gIHZhciBuZXh0TmFtZVByZWZpeCA9IG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgOiBuYW1lU29GYXIgKyBTVUJTRVBBUkFUT1I7XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgY2hpbGQgPSBjaGlsZHJlbltpXTtcbiAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGkpO1xuICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBpdGVyYXRvckZuID0gSVRFUkFUT1JfU1lNQk9MICYmIGNoaWxkcmVuW0lURVJBVE9SX1NZTUJPTF0gfHwgY2hpbGRyZW5bRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAge1xuICAgICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gPT09IGNoaWxkcmVuLmVudHJpZXMpIHtcbiAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIHVuc3VwcG9ydGVkIGFuZCB3aWxsIGxpa2VseSB5aWVsZCAnICsgJ3VuZXhwZWN0ZWQgcmVzdWx0cy4gQ29udmVydCBpdCB0byBhIHNlcXVlbmNlL2l0ZXJhYmxlIG9mIGtleWVkICcgKyAnUmVhY3RFbGVtZW50cyBpbnN0ZWFkLiVzJywgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChjaGlsZHJlbik7XG4gICAgICB2YXIgc3RlcDtcbiAgICAgIHZhciBpaSA9IDA7XG4gICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgIGNoaWxkID0gc3RlcC52YWx1ZTtcbiAgICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaWkrKyk7XG4gICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgICAge1xuICAgICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gJycgKyBjaGlsZHJlbjtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgY2hpbGRyZW5TdHJpbmcgPT09ICdbb2JqZWN0IE9iamVjdF0nID8gJ29iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjaGlsZHJlbikuam9pbignLCAnKSArICd9JyA6IGNoaWxkcmVuU3RyaW5nLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN1YnRyZWVDb3VudDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLCBidXRcbiAqIG1pZ2h0IGFsc28gYmUgc3BlY2lmaWVkIHRocm91Z2ggYXR0cmlidXRlczpcbiAqXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMuY2hpbGRyZW4sIC4uLilgXG4gKiAtIGB0cmF2ZXJzZUFsbENoaWxkcmVuKHRoaXMucHJvcHMubGVmdFBhbmVsQ2hpbGRyZW4sIC4uLilgXG4gKlxuICogVGhlIGB0cmF2ZXJzZUNvbnRleHRgIGlzIGFuIG9wdGlvbmFsIGFyZ3VtZW50IHRoYXQgaXMgcGFzc2VkIHRocm91Z2ggdGhlXG4gKiBlbnRpcmUgdHJhdmVyc2FsLiBJdCBjYW4gYmUgdXNlZCB0byBzdG9yZSBhY2N1bXVsYXRpb25zIG9yIGFueXRoaW5nIGVsc2UgdGhhdFxuICogdGhlIGNhbGxiYWNrIG1pZ2h0IGZpbmQgcmVsZXZhbnQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBvYmplY3QuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgVG8gaW52b2tlIHVwb24gdHJhdmVyc2luZyBlYWNoIGNoaWxkLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgZm9yIHRyYXZlcnNhbC5cbiAqIEByZXR1cm4geyFudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4gaW4gdGhpcyBzdWJ0cmVlLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sICcnLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhIGtleSBzdHJpbmcgdGhhdCBpZGVudGlmaWVzIGEgY29tcG9uZW50IHdpdGhpbiBhIHNldC5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbXBvbmVudCBBIGNvbXBvbmVudCB0aGF0IGNvdWxkIGNvbnRhaW4gYSBtYW51YWwga2V5LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IHRoYXQgaXMgdXNlZCBpZiBhIG1hbnVhbCBrZXkgaXMgbm90IHByb3ZpZGVkLlxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRDb21wb25lbnRLZXkoY29tcG9uZW50LCBpbmRleCkge1xuICAvLyBEbyBzb21lIHR5cGVjaGVja2luZyBoZXJlIHNpbmNlIHdlIGNhbGwgdGhpcyBibGluZGx5LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGRvbid0IGJsb2NrIHBvdGVudGlhbCBmdXR1cmUgRVMgQVBJcy5cbiAgaWYgKHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnICYmIGNvbXBvbmVudCAhPT0gbnVsbCAmJiBjb21wb25lbnQua2V5ICE9IG51bGwpIHtcbiAgICAvLyBFeHBsaWNpdCBrZXlcbiAgICByZXR1cm4gZXNjYXBlKGNvbXBvbmVudC5rZXkpO1xuICB9XG4gIC8vIEltcGxpY2l0IGtleSBkZXRlcm1pbmVkIGJ5IHRoZSBpbmRleCBpbiB0aGUgc2V0XG4gIHJldHVybiBpbmRleC50b1N0cmluZygzNik7XG59XG5cbmZ1bmN0aW9uIGZvckVhY2hTaW5nbGVDaGlsZChib29rS2VlcGluZywgY2hpbGQsIG5hbWUpIHtcbiAgdmFyIGZ1bmMgPSBib29rS2VlcGluZy5mdW5jLFxuICAgICAgY29udGV4dCA9IGJvb2tLZWVwaW5nLmNvbnRleHQ7XG5cbiAgZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbn1cblxuLyoqXG4gKiBJdGVyYXRlcyB0aHJvdWdoIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmZvcmVhY2hcbiAqXG4gKiBUaGUgcHJvdmlkZWQgZm9yRWFjaEZ1bmMoY2hpbGQsIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZm9yRWFjaEZ1bmNcbiAqIEBwYXJhbSB7Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCBmb3IgZm9yRWFjaENvbnRleHQuXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciB0cmF2ZXJzZUNvbnRleHQgPSBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobnVsbCwgbnVsbCwgZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICByZWxlYXNlVHJhdmVyc2VDb250ZXh0KHRyYXZlcnNlQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQoYm9va0tlZXBpbmcsIGNoaWxkLCBjaGlsZEtleSkge1xuICB2YXIgcmVzdWx0ID0gYm9va0tlZXBpbmcucmVzdWx0LFxuICAgICAga2V5UHJlZml4ID0gYm9va0tlZXBpbmcua2V5UHJlZml4LFxuICAgICAgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChpc1ZhbGlkRWxlbWVudChtYXBwZWRDaGlsZCkpIHtcbiAgICAgIG1hcHBlZENoaWxkID0gY2xvbmVBbmRSZXBsYWNlS2V5KG1hcHBlZENoaWxkLFxuICAgICAgLy8gS2VlcCBib3RoIHRoZSAobWFwcGVkKSBhbmQgb2xkIGtleXMgaWYgdGhleSBkaWZmZXIsIGp1c3QgYXNcbiAgICAgIC8vIHRyYXZlcnNlQWxsQ2hpbGRyZW4gdXNlZCB0byBkbyBmb3Igb2JqZWN0cyBhcyBjaGlsZHJlblxuICAgICAga2V5UHJlZml4ICsgKG1hcHBlZENoaWxkLmtleSAmJiAoIWNoaWxkIHx8IGNoaWxkLmtleSAhPT0gbWFwcGVkQ2hpbGQua2V5KSA/IGVzY2FwZVVzZXJQcm92aWRlZEtleShtYXBwZWRDaGlsZC5rZXkpICsgJy8nIDogJycpICsgY2hpbGRLZXkpO1xuICAgIH1cbiAgICByZXN1bHQucHVzaChtYXBwZWRDaGlsZCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgYXJyYXksIHByZWZpeCwgZnVuYywgY29udGV4dCkge1xuICB2YXIgZXNjYXBlZFByZWZpeCA9ICcnO1xuICBpZiAocHJlZml4ICE9IG51bGwpIHtcbiAgICBlc2NhcGVkUHJlZml4ID0gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHByZWZpeCkgKyAnLyc7XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChhcnJheSwgZXNjYXBlZFByZWZpeCwgZnVuYywgY29udGV4dCk7XG4gIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIG1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuLyoqXG4gKiBNYXBzIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXMgYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm1hcFxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi5jb3VudFxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuLlxuICovXG5mdW5jdGlvbiBjb3VudENoaWxkcmVuKGNoaWxkcmVuLCBjb250ZXh0KSB7XG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCwgbnVsbCk7XG59XG5cbi8qKlxuICogRmxhdHRlbiBhIGNoaWxkcmVuIG9iamVjdCAodHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gKSBhbmRcbiAqIHJldHVybiBhbiBhcnJheSB3aXRoIGFwcHJvcHJpYXRlbHkgcmUta2V5ZWQgY2hpbGRyZW4uXG4gKlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNyZWFjdC5jaGlsZHJlbi50b2FycmF5XG4gKi9cbmZ1bmN0aW9uIHRvQXJyYXkoY2hpbGRyZW4pIHtcbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgY2hpbGQgaW4gYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuIGFuZCB2ZXJpZmllcyB0aGF0IHRoZXJlXG4gKiBpcyBvbmx5IG9uZSBjaGlsZCBpbiB0aGUgY29sbGVjdGlvbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLm9ubHlcbiAqXG4gKiBUaGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzXG4gKiBwYXNzZWQgd2l0aG91dCBhIHdyYXBwZXIsIGJ1dCB0aGUgcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0b1xuICogYWJzdHJhY3QgYXdheSB0aGUgcGFydGljdWxhciBzdHJ1Y3R1cmUgb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0RWxlbWVudH0gVGhlIGZpcnN0IGFuZCBvbmx5IGBSZWFjdEVsZW1lbnRgIGNvbnRhaW5lZCBpbiB0aGVcbiAqIHN0cnVjdHVyZS5cbiAqL1xuZnVuY3Rpb24gb25seUNoaWxkKGNoaWxkcmVuKSB7XG4gICFpc1ZhbGlkRWxlbWVudChjaGlsZHJlbikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdC5DaGlsZHJlbi5vbmx5IGV4cGVjdGVkIHRvIHJlY2VpdmUgYSBzaW5nbGUgUmVhY3QgZWxlbWVudCBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxue1xuICB2YXIgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gIHZhciBnZXREaXNwbGF5TmFtZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcjZW1wdHknO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVsZW1lbnQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBlbGVtZW50ID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuICcjdGV4dCc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgICB9IGVsc2UgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSQxKSB7XG4gICAgICByZXR1cm4gJ1JlYWN0LkZyYWdtZW50JztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGVsZW1lbnQudHlwZS5kaXNwbGF5TmFtZSB8fCBlbGVtZW50LnR5cGUubmFtZSB8fCAnVW5rbm93bic7XG4gICAgfVxuICB9O1xuXG4gIHZhciBnZXRTdGFja0FkZGVuZHVtID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGFjayA9ICcnO1xuICAgIGlmIChjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXREaXNwbGF5TmFtZShjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCk7XG4gICAgICB2YXIgb3duZXIgPSBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudC5fb3duZXI7XG4gICAgICBzdGFjayArPSBkZXNjcmliZUNvbXBvbmVudEZyYW1lKG5hbWUsIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9zb3VyY2UsIG93bmVyICYmIGdldENvbXBvbmVudE5hbWUob3duZXIpKTtcbiAgICB9XG4gICAgc3RhY2sgKz0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBSRUFDVF9GUkFHTUVOVF9UWVBFJDEgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSB8fCAweGVhY2I7XG5cbiAgdmFyIFZBTElEX0ZSQUdNRU5UX1BST1BTID0gbmV3IE1hcChbWydjaGlsZHJlbicsIHRydWVdLCBbJ2tleScsIHRydWVdXSk7XG59XG5cbnZhciBJVEVSQVRPUl9TWU1CT0wkMSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MJDEgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKGVsZW1lbnRQcm9wcykge1xuICBpZiAoZWxlbWVudFByb3BzICE9PSBudWxsICYmIGVsZW1lbnRQcm9wcyAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnRQcm9wcy5fX3NvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIHNvdXJjZSA9IGVsZW1lbnRQcm9wcy5fX3NvdXJjZTtcbiAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB5b3VyIGNvZGUgYXQgJyArIGZpbGVOYW1lICsgJzonICsgbGluZU51bWJlciArICcuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gKiB1cGRhdGVzLlxuICovXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gIGlmICghaW5mbykge1xuICAgIHZhciBwYXJlbnROYW1lID0gdHlwZW9mIHBhcmVudFR5cGUgPT09ICdzdHJpbmcnID8gcGFyZW50VHlwZSA6IHBhcmVudFR5cGUuZGlzcGxheU5hbWUgfHwgcGFyZW50VHlwZS5uYW1lO1xuICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICBpbmZvID0gJ1xcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPCcgKyBwYXJlbnROYW1lICsgJz4uJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluZm87XG59XG5cbi8qKlxuICogV2FybiBpZiB0aGUgZWxlbWVudCBkb2Vzbid0IGhhdmUgYW4gZXhwbGljaXQga2V5IGFzc2lnbmVkIHRvIGl0LlxuICogVGhpcyBlbGVtZW50IGlzIGluIGFuIGFycmF5LiBUaGUgYXJyYXkgY291bGQgZ3JvdyBhbmQgc2hyaW5rIG9yIGJlXG4gKiByZW9yZGVyZWQuIEFsbCBjaGlsZHJlbiB0aGF0IGhhdmVuJ3QgYWxyZWFkeSBiZWVuIHZhbGlkYXRlZCBhcmUgcmVxdWlyZWQgdG9cbiAqIGhhdmUgYSBcImtleVwiIHByb3BlcnR5IGFzc2lnbmVkIHRvIGl0LiBFcnJvciBzdGF0dXNlcyBhcmUgY2FjaGVkIHNvIGEgd2FybmluZ1xuICogd2lsbCBvbmx5IGJlIHNob3duIG9uY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudCBFbGVtZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG4gIHZhciBjaGlsZE93bmVyID0gJyc7XG4gIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgY2hpbGRPd25lciA9ICcgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gJyArIGdldENvbXBvbmVudE5hbWUoZWxlbWVudC5fb3duZXIpICsgJy4nO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBlbGVtZW50O1xuICB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJXMnLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgLy8gVGhpcyBlbGVtZW50IHdhcyBwYXNzZWQgaW4gYSB2YWxpZCBsb2NhdGlvbi5cbiAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IElURVJBVE9SX1NZTUJPTCQxICYmIG5vZGVbSVRFUkFUT1JfU1lNQk9MJDFdIHx8IG5vZGVbRkFVWF9JVEVSQVRPUl9TWU1CT0wkMV07XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgIGlmIChpdGVyYXRvckZuICE9PSBub2RlLmVudHJpZXMpIHtcbiAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShzdGVwLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICB2YXIgcHJvcFR5cGVzID0gY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzO1xuXG4gIGlmIChwcm9wVHlwZXMpIHtcbiAgICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0pO1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGNvbXBvbmVudENsYXNzLmdldERlZmF1bHRQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICB9XG59XG5cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZnJhZ21lbnQ7XG5cbiAgdmFyIF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlO1xuICB2YXIgX2RpZEl0ZXJhdG9yRXJyb3IgPSBmYWxzZTtcbiAgdmFyIF9pdGVyYXRvckVycm9yID0gdW5kZWZpbmVkO1xuXG4gIHRyeSB7XG4gICAgZm9yICh2YXIgX2l0ZXJhdG9yID0gT2JqZWN0LmtleXMoZnJhZ21lbnQucHJvcHMpW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3N0ZXA7ICEoX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IChfc3RlcCA9IF9pdGVyYXRvci5uZXh0KCkpLmRvbmUpOyBfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gdHJ1ZSkge1xuICAgICAgdmFyIGtleSA9IF9zdGVwLnZhbHVlO1xuXG4gICAgICBpZiAoIVZBTElEX0ZSQUdNRU5UX1BST1BTLmhhcyhrZXkpKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJXMnLCBrZXksIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgX2RpZEl0ZXJhdG9yRXJyb3IgPSB0cnVlO1xuICAgIF9pdGVyYXRvckVycm9yID0gZXJyO1xuICB9IGZpbmFsbHkge1xuICAgIHRyeSB7XG4gICAgICBpZiAoIV9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gJiYgX2l0ZXJhdG9yWydyZXR1cm4nXSkge1xuICAgICAgICBfaXRlcmF0b3JbJ3JldHVybiddKCk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChfZGlkSXRlcmF0b3JFcnJvcikge1xuICAgICAgICB0aHJvdyBfaXRlcmF0b3JFcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAoZnJhZ21lbnQucmVmICE9PSBudWxsKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXR0cmlidXRlIGByZWZgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuJXMnLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG5cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnIHx8IHR5cGVvZiB0eXBlID09PSAnbnVtYmVyJztcbiAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cbiAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLlwiO1xuICAgIH1cblxuICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0ocHJvcHMpO1xuICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgfVxuXG4gICAgaW5mbyArPSBnZXRTdGFja0FkZGVuZHVtKCkgfHwgJyc7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QuY3JlYXRlRWxlbWVudDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlID09IG51bGwgPyB0eXBlIDogdHlwZW9mIHR5cGUsIGluZm8pO1xuICB9XG5cbiAgdmFyIGVsZW1lbnQgPSBjcmVhdGVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgLy8gVE9ETzogRHJvcCB0aGlzIHdoZW4gdGhlc2UgYXJlIG5vIGxvbmdlciBhbGxvd2VkIGFzIHRoZSB0eXBlIGFyZ3VtZW50LlxuICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICAvLyBTa2lwIGtleSB3YXJuaW5nIGlmIHRoZSB0eXBlIGlzbid0IHZhbGlkIHNpbmNlIG91ciBrZXkgdmFsaWRhdGlvbiBsb2dpY1xuICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gIC8vIFdlIGRvbid0IHdhbnQgZXhjZXB0aW9uIGJlaGF2aW9yIHRvIGRpZmZlciBiZXR3ZWVuIGRldiBhbmQgcHJvZC5cbiAgLy8gKFJlbmRlcmluZyB3aWxsIHRocm93IHdpdGggYSBoZWxwZnVsIG1lc3NhZ2UgYW5kIGFzIHNvb24gYXMgdGhlIHR5cGUgaXNcbiAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICBpZiAodmFsaWRUeXBlKSB7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3ltYm9sJyAmJiB0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFJDEpIHtcbiAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uKHR5cGUpIHtcbiAgdmFyIHZhbGlkYXRlZEZhY3RvcnkgPSBjcmVhdGVFbGVtZW50V2l0aFZhbGlkYXRpb24uYmluZChudWxsLCB0eXBlKTtcbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIHZhbGlkYXRlZEZhY3RvcnkudHlwZSA9IHR5cGU7XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWxpZGF0ZWRGYWN0b3J5LCAndHlwZScsIHtcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnRmFjdG9yeS50eXBlIGlzIGRlcHJlY2F0ZWQuIEFjY2VzcyB0aGUgY2xhc3MgZGlyZWN0bHkgJyArICdiZWZvcmUgcGFzc2luZyBpdCB0byBjcmVhdGVGYWN0b3J5LicpO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3R5cGUnLCB7XG4gICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHZhbGlkYXRlZEZhY3Rvcnk7XG59XG5cbmZ1bmN0aW9uIGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uKGVsZW1lbnQsIHByb3BzLCBjaGlsZHJlbikge1xuICB2YXIgbmV3RWxlbWVudCA9IGNsb25lRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgbmV3RWxlbWVudC50eXBlKTtcbiAgfVxuICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59XG5cbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50JykgfHwgMHhlYWNiO1xuXG52YXIgUmVhY3QgPSB7XG4gIENoaWxkcmVuOiB7XG4gICAgbWFwOiBtYXBDaGlsZHJlbixcbiAgICBmb3JFYWNoOiBmb3JFYWNoQ2hpbGRyZW4sXG4gICAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gICAgdG9BcnJheTogdG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IENvbXBvbmVudCxcbiAgUHVyZUNvbXBvbmVudDogUHVyZUNvbXBvbmVudCxcbiAgdW5zdGFibGVfQXN5bmNDb21wb25lbnQ6IEFzeW5jQ29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY2xvbmVFbGVtZW50OiBjbG9uZUVsZW1lbnRXaXRoVmFsaWRhdGlvbixcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeVdpdGhWYWxpZGF0aW9uLFxuICBpc1ZhbGlkRWxlbWVudDogaXNWYWxpZEVsZW1lbnQsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgUmVhY3RDdXJyZW50T3duZXI6IFJlYWN0Q3VycmVudE93bmVyLFxuICAgIC8vIFVzZWQgYnkgcmVuZGVyZXJzIHRvIGF2b2lkIGJ1bmRsaW5nIG9iamVjdC1hc3NpZ24gdHdpY2UgaW4gVU1EIGJ1bmRsZXM6XG4gICAgYXNzaWduOiBfYXNzaWduXG4gIH1cbn07XG5cbmlmIChlbmFibGVSZWFjdEZyYWdtZW50KSB7XG4gIFJlYWN0LkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbn1cblxue1xuICBfYXNzaWduKFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELCB7XG4gICAgLy8gVGhlc2Ugc2hvdWxkIG5vdCBiZSBpbmNsdWRlZCBpbiBwcm9kdWN0aW9uLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWU6IFJlYWN0RGVidWdDdXJyZW50RnJhbWUsXG4gICAgLy8gU2hpbSBmb3IgUmVhY3QgRE9NIDE2LjAuMCB3aGljaCBzdGlsbCBkZXN0cnVjdHVyZWQgKGJ1dCBub3QgdXNlZCkgdGhpcy5cbiAgICAvLyBUT0RPOiByZW1vdmUgaW4gUmVhY3QgMTcuMC5cbiAgICBSZWFjdENvbXBvbmVudFRyZWVIb29rOiB7fVxuICB9KTtcbn1cblxuXG5cbnZhciBSZWFjdCQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0XG59KTtcblxudmFyIFJlYWN0JDMgPSAoIFJlYWN0JDIgJiYgUmVhY3QgKSB8fCBSZWFjdCQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdCA9IFJlYWN0JDNbJ2RlZmF1bHQnXSA/IFJlYWN0JDNbJ2RlZmF1bHQnXSA6IFJlYWN0JDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3Q7XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LmRldmVsb3BtZW50LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xLjBcbiAqIHJlYWN0LWRvbS5wcm9kdWN0aW9uLm1pbi5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG4vKlxuIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuKi9cbid1c2Ugc3RyaWN0Jzt2YXIgYWE9cmVxdWlyZShcInJlYWN0XCIpLG09cmVxdWlyZShcImZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50XCIpLEE9cmVxdWlyZShcIm9iamVjdC1hc3NpZ25cIiksQj1yZXF1aXJlKFwiZmJqcy9saWIvZW1wdHlGdW5jdGlvblwiKSxjYT1yZXF1aXJlKFwiZmJqcy9saWIvRXZlbnRMaXN0ZW5lclwiKSxkYT1yZXF1aXJlKFwiZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudFwiKSxlYT1yZXF1aXJlKFwiZmJqcy9saWIvc2hhbGxvd0VxdWFsXCIpLGhhPXJlcXVpcmUoXCJmYmpzL2xpYi9jb250YWluc05vZGVcIiksaWE9cmVxdWlyZShcImZianMvbGliL2ZvY3VzTm9kZVwiKSxDPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKTtcbmZ1bmN0aW9uIEQoYSl7Zm9yKHZhciBiPWFyZ3VtZW50cy5sZW5ndGgtMSxjPVwiTWluaWZpZWQgUmVhY3QgZXJyb3IgI1wiK2ErXCI7IHZpc2l0IGh0dHA6Ly9mYWNlYm9vay5naXRodWIuaW8vcmVhY3QvZG9jcy9lcnJvci1kZWNvZGVyLmh0bWw/aW52YXJpYW50XFx4M2RcIithLGQ9MDtkPGI7ZCsrKWMrPVwiXFx4MjZhcmdzW11cXHgzZFwiK2VuY29kZVVSSUNvbXBvbmVudChhcmd1bWVudHNbZCsxXSk7Yj1FcnJvcihjK1wiIGZvciB0aGUgZnVsbCBtZXNzYWdlIG9yIHVzZSB0aGUgbm9uLW1pbmlmaWVkIGRldiBlbnZpcm9ubWVudCBmb3IgZnVsbCBlcnJvcnMgYW5kIGFkZGl0aW9uYWwgaGVscGZ1bCB3YXJuaW5ncy5cIik7Yi5uYW1lPVwiSW52YXJpYW50IFZpb2xhdGlvblwiO2IuZnJhbWVzVG9Qb3A9MTt0aHJvdyBiO31hYT92b2lkIDA6RChcIjIyN1wiKTtcbnZhciBsYT17Y2hpbGRyZW46ITAsZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6ITAsZGVmYXVsdFZhbHVlOiEwLGRlZmF1bHRDaGVja2VkOiEwLGlubmVySFRNTDohMCxzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6ITAsc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nOiEwLHN0eWxlOiEwfTtmdW5jdGlvbiBxYShhLGIpe3JldHVybihhJmIpPT09Yn1cbnZhciByYT17TVVTVF9VU0VfUFJPUEVSVFk6MSxIQVNfQk9PTEVBTl9WQUxVRTo0LEhBU19OVU1FUklDX1ZBTFVFOjgsSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6MjQsSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTozMixIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6NjQsaW5qZWN0RE9NUHJvcGVydHlDb25maWc6ZnVuY3Rpb24oYSl7dmFyIGI9cmEsYz1hLlByb3BlcnRpZXN8fHt9LGQ9YS5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzfHx7fSxlPWEuRE9NQXR0cmlidXRlTmFtZXN8fHt9O2E9YS5ET01NdXRhdGlvbk1ldGhvZHN8fHt9O2Zvcih2YXIgZiBpbiBjKXtzYS5oYXNPd25Qcm9wZXJ0eShmKT9EKFwiNDhcIixmKTp2b2lkIDA7dmFyIGc9Zi50b0xvd2VyQ2FzZSgpLGs9Y1tmXTtnPXthdHRyaWJ1dGVOYW1lOmcsYXR0cmlidXRlTmFtZXNwYWNlOm51bGwscHJvcGVydHlOYW1lOmYsbXV0YXRpb25NZXRob2Q6bnVsbCxtdXN0VXNlUHJvcGVydHk6cWEoayxiLk1VU1RfVVNFX1BST1BFUlRZKSxcbmhhc0Jvb2xlYW5WYWx1ZTpxYShrLGIuSEFTX0JPT0xFQU5fVkFMVUUpLGhhc051bWVyaWNWYWx1ZTpxYShrLGIuSEFTX05VTUVSSUNfVkFMVUUpLGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOnFhKGssYi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpxYShrLGIuSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksaGFzU3RyaW5nQm9vbGVhblZhbHVlOnFhKGssYi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpfTsxPj1nLmhhc0Jvb2xlYW5WYWx1ZStnLmhhc051bWVyaWNWYWx1ZStnLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU/dm9pZCAwOkQoXCI1MFwiLGYpO2UuaGFzT3duUHJvcGVydHkoZikmJihnLmF0dHJpYnV0ZU5hbWU9ZVtmXSk7ZC5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZXNwYWNlPWRbZl0pO2EuaGFzT3duUHJvcGVydHkoZikmJihnLm11dGF0aW9uTWV0aG9kPWFbZl0pO3NhW2ZdPWd9fX0sc2E9e307XG5mdW5jdGlvbiB0YShhLGIpe2lmKGxhLmhhc093blByb3BlcnR5KGEpfHwyPGEubGVuZ3RoJiYoXCJvXCI9PT1hWzBdfHxcIk9cIj09PWFbMF0pJiYoXCJuXCI9PT1hWzFdfHxcIk5cIj09PWFbMV0pKXJldHVybiExO2lmKG51bGw9PT1iKXJldHVybiEwO3N3aXRjaCh0eXBlb2YgYil7Y2FzZSBcImJvb2xlYW5cIjpyZXR1cm4gbGEuaGFzT3duUHJvcGVydHkoYSk/YT0hMDooYj11YShhKSk/YT1iLmhhc0Jvb2xlYW5WYWx1ZXx8Yi5oYXNTdHJpbmdCb29sZWFuVmFsdWV8fGIuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTooYT1hLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCw1KSxhPVwiZGF0YS1cIj09PWF8fFwiYXJpYS1cIj09PWEpLGE7Y2FzZSBcInVuZGVmaW5lZFwiOmNhc2UgXCJudW1iZXJcIjpjYXNlIFwic3RyaW5nXCI6Y2FzZSBcIm9iamVjdFwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIHVhKGEpe3JldHVybiBzYS5oYXNPd25Qcm9wZXJ0eShhKT9zYVthXTpudWxsfVxudmFyIHZhPXJhLHdhPXZhLk1VU1RfVVNFX1BST1BFUlRZLEg9dmEuSEFTX0JPT0xFQU5fVkFMVUUseGE9dmEuSEFTX05VTUVSSUNfVkFMVUUseWE9dmEuSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsemE9dmEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLEFhPXtQcm9wZXJ0aWVzOnthbGxvd0Z1bGxTY3JlZW46SCxhdXRvRm9jdXM6emEsYXN5bmM6SCxhdXRvUGxheTpILGNhcHR1cmU6SCxjaGVja2VkOndhfEgsY29sczp5YSxjb250ZW50RWRpdGFibGU6emEsY29udHJvbHM6SCxcImRlZmF1bHRcIjpILGRlZmVyOkgsZGlzYWJsZWQ6SCxkb3dubG9hZDp2YS5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFLGRyYWdnYWJsZTp6YSxmb3JtTm9WYWxpZGF0ZTpILGhpZGRlbjpILGxvb3A6SCxtdWx0aXBsZTp3YXxILG11dGVkOndhfEgsbm9WYWxpZGF0ZTpILG9wZW46SCxwbGF5c0lubGluZTpILHJlYWRPbmx5OkgscmVxdWlyZWQ6SCxyZXZlcnNlZDpILHJvd3M6eWEscm93U3Bhbjp4YSxcbnNjb3BlZDpILHNlYW1sZXNzOkgsc2VsZWN0ZWQ6d2F8SCxzaXplOnlhLHN0YXJ0OnhhLHNwYW46eWEsc3BlbGxDaGVjazp6YSxzdHlsZTowLHRhYkluZGV4OjAsaXRlbVNjb3BlOkgsYWNjZXB0Q2hhcnNldDowLGNsYXNzTmFtZTowLGh0bWxGb3I6MCxodHRwRXF1aXY6MCx2YWx1ZTp6YX0sRE9NQXR0cmlidXRlTmFtZXM6e2FjY2VwdENoYXJzZXQ6XCJhY2NlcHQtY2hhcnNldFwiLGNsYXNzTmFtZTpcImNsYXNzXCIsaHRtbEZvcjpcImZvclwiLGh0dHBFcXVpdjpcImh0dHAtZXF1aXZcIn0sRE9NTXV0YXRpb25NZXRob2RzOnt2YWx1ZTpmdW5jdGlvbihhLGIpe2lmKG51bGw9PWIpcmV0dXJuIGEucmVtb3ZlQXR0cmlidXRlKFwidmFsdWVcIik7XCJudW1iZXJcIiE9PWEudHlwZXx8ITE9PT1hLmhhc0F0dHJpYnV0ZShcInZhbHVlXCIpP2Euc2V0QXR0cmlidXRlKFwidmFsdWVcIixcIlwiK2IpOmEudmFsaWRpdHkmJiFhLnZhbGlkaXR5LmJhZElucHV0JiZhLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCE9PWEmJlxuYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYil9fX0sQmE9dmEuSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLEs9e3hsaW5rOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGlua1wiLHhtbDpcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwifSxDYT17UHJvcGVydGllczp7YXV0b1JldmVyc2U6QmEsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpCYSxwcmVzZXJ2ZUFscGhhOkJhfSxET01BdHRyaWJ1dGVOYW1lczp7YXV0b1JldmVyc2U6XCJhdXRvUmV2ZXJzZVwiLGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6XCJleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkXCIscHJlc2VydmVBbHBoYTpcInByZXNlcnZlQWxwaGFcIn0sRE9NQXR0cmlidXRlTmFtZXNwYWNlczp7eGxpbmtBY3R1YXRlOksueGxpbmsseGxpbmtBcmNyb2xlOksueGxpbmsseGxpbmtIcmVmOksueGxpbmsseGxpbmtSb2xlOksueGxpbmsseGxpbmtTaG93OksueGxpbmsseGxpbmtUaXRsZTpLLnhsaW5rLHhsaW5rVHlwZTpLLnhsaW5rLFxueG1sQmFzZTpLLnhtbCx4bWxMYW5nOksueG1sLHhtbFNwYWNlOksueG1sfX0sRGE9L1tcXC1cXDpdKFthLXpdKS9nO2Z1bmN0aW9uIEVhKGEpe3JldHVybiBhWzFdLnRvVXBwZXJDYXNlKCl9XG5cImFjY2VudC1oZWlnaHQgYWxpZ25tZW50LWJhc2VsaW5lIGFyYWJpYy1mb3JtIGJhc2VsaW5lLXNoaWZ0IGNhcC1oZWlnaHQgY2xpcC1wYXRoIGNsaXAtcnVsZSBjb2xvci1pbnRlcnBvbGF0aW9uIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycyBjb2xvci1wcm9maWxlIGNvbG9yLXJlbmRlcmluZyBkb21pbmFudC1iYXNlbGluZSBlbmFibGUtYmFja2dyb3VuZCBmaWxsLW9wYWNpdHkgZmlsbC1ydWxlIGZsb29kLWNvbG9yIGZsb29kLW9wYWNpdHkgZm9udC1mYW1pbHkgZm9udC1zaXplIGZvbnQtc2l6ZS1hZGp1c3QgZm9udC1zdHJldGNoIGZvbnQtc3R5bGUgZm9udC12YXJpYW50IGZvbnQtd2VpZ2h0IGdseXBoLW5hbWUgZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCBnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCBob3Jpei1hZHYteCBob3Jpei1vcmlnaW4teCBpbWFnZS1yZW5kZXJpbmcgbGV0dGVyLXNwYWNpbmcgbGlnaHRpbmctY29sb3IgbWFya2VyLWVuZCBtYXJrZXItbWlkIG1hcmtlci1zdGFydCBvdmVybGluZS1wb3NpdGlvbiBvdmVybGluZS10aGlja25lc3MgcGFpbnQtb3JkZXIgcGFub3NlLTEgcG9pbnRlci1ldmVudHMgcmVuZGVyaW5nLWludGVudCBzaGFwZS1yZW5kZXJpbmcgc3RvcC1jb2xvciBzdG9wLW9wYWNpdHkgc3RyaWtldGhyb3VnaC1wb3NpdGlvbiBzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcyBzdHJva2UtZGFzaGFycmF5IHN0cm9rZS1kYXNob2Zmc2V0IHN0cm9rZS1saW5lY2FwIHN0cm9rZS1saW5lam9pbiBzdHJva2UtbWl0ZXJsaW1pdCBzdHJva2Utb3BhY2l0eSBzdHJva2Utd2lkdGggdGV4dC1hbmNob3IgdGV4dC1kZWNvcmF0aW9uIHRleHQtcmVuZGVyaW5nIHVuZGVybGluZS1wb3NpdGlvbiB1bmRlcmxpbmUtdGhpY2tuZXNzIHVuaWNvZGUtYmlkaSB1bmljb2RlLXJhbmdlIHVuaXRzLXBlci1lbSB2LWFscGhhYmV0aWMgdi1oYW5naW5nIHYtaWRlb2dyYXBoaWMgdi1tYXRoZW1hdGljYWwgdmVjdG9yLWVmZmVjdCB2ZXJ0LWFkdi15IHZlcnQtb3JpZ2luLXggdmVydC1vcmlnaW4teSB3b3JkLXNwYWNpbmcgd3JpdGluZy1tb2RlIHgtaGVpZ2h0IHhsaW5rOmFjdHVhdGUgeGxpbms6YXJjcm9sZSB4bGluazpocmVmIHhsaW5rOnJvbGUgeGxpbms6c2hvdyB4bGluazp0aXRsZSB4bGluazp0eXBlIHhtbDpiYXNlIHhtbG5zOnhsaW5rIHhtbDpsYW5nIHhtbDpzcGFjZVwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWEucmVwbGFjZShEYSxcbkVhKTtDYS5Qcm9wZXJ0aWVzW2JdPTA7Q2EuRE9NQXR0cmlidXRlTmFtZXNbYl09YX0pO3ZhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKEFhKTt2YS5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhDYSk7XG52YXIgTj17X2NhdWdodEVycm9yOm51bGwsX2hhc0NhdWdodEVycm9yOiExLF9yZXRocm93RXJyb3I6bnVsbCxfaGFzUmV0aHJvd0Vycm9yOiExLGluamVjdGlvbjp7aW5qZWN0RXJyb3JVdGlsczpmdW5jdGlvbihhKXtcImZ1bmN0aW9uXCIhPT10eXBlb2YgYS5pbnZva2VHdWFyZGVkQ2FsbGJhY2s/RChcIjE5N1wiKTp2b2lkIDA7SGE9YS5pbnZva2VHdWFyZGVkQ2FsbGJhY2t9fSxpbnZva2VHdWFyZGVkQ2FsbGJhY2s6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGgpe0hhLmFwcGx5KE4sYXJndW1lbnRzKX0saW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGcsayxoKXtOLmludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseSh0aGlzLGFyZ3VtZW50cyk7aWYoTi5oYXNDYXVnaHRFcnJvcigpKXt2YXIgcj1OLmNsZWFyQ2F1Z2h0RXJyb3IoKTtOLl9oYXNSZXRocm93RXJyb3J8fChOLl9oYXNSZXRocm93RXJyb3I9ITAsTi5fcmV0aHJvd0Vycm9yPVxucil9fSxyZXRocm93Q2F1Z2h0RXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gSWEuYXBwbHkoTixhcmd1bWVudHMpfSxoYXNDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBOLl9oYXNDYXVnaHRFcnJvcn0sY2xlYXJDYXVnaHRFcnJvcjpmdW5jdGlvbigpe2lmKE4uX2hhc0NhdWdodEVycm9yKXt2YXIgYT1OLl9jYXVnaHRFcnJvcjtOLl9jYXVnaHRFcnJvcj1udWxsO04uX2hhc0NhdWdodEVycm9yPSExO3JldHVybiBhfUQoXCIxOThcIil9fTtmdW5jdGlvbiBIYShhLGIsYyxkLGUsZixnLGssaCl7Ti5faGFzQ2F1Z2h0RXJyb3I9ITE7Ti5fY2F1Z2h0RXJyb3I9bnVsbDt2YXIgcj1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMyk7dHJ5e2IuYXBwbHkoYyxyKX1jYXRjaChuKXtOLl9jYXVnaHRFcnJvcj1uLE4uX2hhc0NhdWdodEVycm9yPSEwfX1cbmZ1bmN0aW9uIElhKCl7aWYoTi5faGFzUmV0aHJvd0Vycm9yKXt2YXIgYT1OLl9yZXRocm93RXJyb3I7Ti5fcmV0aHJvd0Vycm9yPW51bGw7Ti5faGFzUmV0aHJvd0Vycm9yPSExO3Rocm93IGE7fX12YXIgSmE9bnVsbCxLYT17fTtcbmZ1bmN0aW9uIExhKCl7aWYoSmEpZm9yKHZhciBhIGluIEthKXt2YXIgYj1LYVthXSxjPUphLmluZGV4T2YoYSk7LTE8Yz92b2lkIDA6RChcIjk2XCIsYSk7aWYoIU1hW2NdKXtiLmV4dHJhY3RFdmVudHM/dm9pZCAwOkQoXCI5N1wiLGEpO01hW2NdPWI7Yz1iLmV2ZW50VHlwZXM7Zm9yKHZhciBkIGluIGMpe3ZhciBlPXZvaWQgMDt2YXIgZj1jW2RdLGc9YixrPWQ7TmEuaGFzT3duUHJvcGVydHkoayk/RChcIjk5XCIsayk6dm9pZCAwO05hW2tdPWY7dmFyIGg9Zi5waGFzZWRSZWdpc3RyYXRpb25OYW1lcztpZihoKXtmb3IoZSBpbiBoKWguaGFzT3duUHJvcGVydHkoZSkmJk9hKGhbZV0sZyxrKTtlPSEwfWVsc2UgZi5yZWdpc3RyYXRpb25OYW1lPyhPYShmLnJlZ2lzdHJhdGlvbk5hbWUsZyxrKSxlPSEwKTplPSExO2U/dm9pZCAwOkQoXCI5OFwiLGQsYSl9fX19XG5mdW5jdGlvbiBPYShhLGIsYyl7UGFbYV0/RChcIjEwMFwiLGEpOnZvaWQgMDtQYVthXT1iO1FhW2FdPWIuZXZlbnRUeXBlc1tjXS5kZXBlbmRlbmNpZXN9dmFyIE1hPVtdLE5hPXt9LFBhPXt9LFFhPXt9O2Z1bmN0aW9uIFJhKGEpe0phP0QoXCIxMDFcIik6dm9pZCAwO0phPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEpO0xhKCl9ZnVuY3Rpb24gU2EoYSl7dmFyIGI9ITEsYztmb3IoYyBpbiBhKWlmKGEuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPWFbY107S2EuaGFzT3duUHJvcGVydHkoYykmJkthW2NdPT09ZHx8KEthW2NdP0QoXCIxMDJcIixjKTp2b2lkIDAsS2FbY109ZCxiPSEwKX1iJiZMYSgpfVxudmFyIFRhPU9iamVjdC5mcmVlemUoe3BsdWdpbnM6TWEsZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOk5hLHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOlBhLHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6UWEscG9zc2libGVSZWdpc3RyYXRpb25OYW1lczpudWxsLGluamVjdEV2ZW50UGx1Z2luT3JkZXI6UmEsaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOlNhfSksVWE9bnVsbCxWYT1udWxsLFdhPW51bGw7ZnVuY3Rpb24gWGEoYSxiLGMsZCl7Yj1hLnR5cGV8fFwidW5rbm93bi1ldmVudFwiO2EuY3VycmVudFRhcmdldD1XYShkKTtOLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcihiLGMsdm9pZCAwLGEpO2EuY3VycmVudFRhcmdldD1udWxsfVxuZnVuY3Rpb24gWWEoYSxiKXtudWxsPT1iP0QoXCIzMFwiKTp2b2lkIDA7aWYobnVsbD09YSlyZXR1cm4gYjtpZihBcnJheS5pc0FycmF5KGEpKXtpZihBcnJheS5pc0FycmF5KGIpKXJldHVybiBhLnB1c2guYXBwbHkoYSxiKSxhO2EucHVzaChiKTtyZXR1cm4gYX1yZXR1cm4gQXJyYXkuaXNBcnJheShiKT9bYV0uY29uY2F0KGIpOlthLGJdfWZ1bmN0aW9uIFphKGEsYixjKXtBcnJheS5pc0FycmF5KGEpP2EuZm9yRWFjaChiLGMpOmEmJmIuY2FsbChjLGEpfXZhciAkYT1udWxsO1xuZnVuY3Rpb24gYWIoYSxiKXtpZihhKXt2YXIgYz1hLl9kaXNwYXRjaExpc3RlbmVycyxkPWEuX2Rpc3BhdGNoSW5zdGFuY2VzO2lmKEFycmF5LmlzQXJyYXkoYykpZm9yKHZhciBlPTA7ZTxjLmxlbmd0aCYmIWEuaXNQcm9wYWdhdGlvblN0b3BwZWQoKTtlKyspWGEoYSxiLGNbZV0sZFtlXSk7ZWxzZSBjJiZYYShhLGIsYyxkKTthLl9kaXNwYXRjaExpc3RlbmVycz1udWxsO2EuX2Rpc3BhdGNoSW5zdGFuY2VzPW51bGw7YS5pc1BlcnNpc3RlbnQoKXx8YS5jb25zdHJ1Y3Rvci5yZWxlYXNlKGEpfX1mdW5jdGlvbiBiYihhKXtyZXR1cm4gYWIoYSwhMCl9ZnVuY3Rpb24gY2IoYSl7cmV0dXJuIGFiKGEsITEpfXZhciBkYj17aW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpSYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6U2F9O1xuZnVuY3Rpb24gZWIoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtpZighYylyZXR1cm4gbnVsbDt2YXIgZD1VYShjKTtpZighZClyZXR1cm4gbnVsbDtjPWRbYl07YTpzd2l0Y2goYil7Y2FzZSBcIm9uQ2xpY2tcIjpjYXNlIFwib25DbGlja0NhcHR1cmVcIjpjYXNlIFwib25Eb3VibGVDbGlja1wiOmNhc2UgXCJvbkRvdWJsZUNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlRG93blwiOmNhc2UgXCJvbk1vdXNlRG93bkNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZU1vdmVcIjpjYXNlIFwib25Nb3VzZU1vdmVDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VVcFwiOmNhc2UgXCJvbk1vdXNlVXBDYXB0dXJlXCI6KGQ9IWQuZGlzYWJsZWQpfHwoYT1hLnR5cGUsZD0hKFwiYnV0dG9uXCI9PT1hfHxcImlucHV0XCI9PT1hfHxcInNlbGVjdFwiPT09YXx8XCJ0ZXh0YXJlYVwiPT09YSkpO2E9IWQ7YnJlYWsgYTtkZWZhdWx0OmE9ITF9aWYoYSlyZXR1cm4gbnVsbDtjJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYz9EKFwiMjMxXCIsYix0eXBlb2YgYyk6dm9pZCAwO1xucmV0dXJuIGN9ZnVuY3Rpb24gamIoYSxiLGMsZCl7Zm9yKHZhciBlLGY9MDtmPE1hLmxlbmd0aDtmKyspe3ZhciBnPU1hW2ZdO2cmJihnPWcuZXh0cmFjdEV2ZW50cyhhLGIsYyxkKSkmJihlPVlhKGUsZykpfXJldHVybiBlfWZ1bmN0aW9uIGtiKGEpe2EmJigkYT1ZYSgkYSxhKSl9ZnVuY3Rpb24gbGIoYSl7dmFyIGI9JGE7JGE9bnVsbDthP1phKGIsYmIpOlphKGIsY2IpOyRhP0QoXCI5NVwiKTp2b2lkIDA7Ti5yZXRocm93Q2F1Z2h0RXJyb3IoKX12YXIgbWI9T2JqZWN0LmZyZWV6ZSh7aW5qZWN0aW9uOmRiLGdldExpc3RlbmVyOmViLGV4dHJhY3RFdmVudHM6amIsZW5xdWV1ZUV2ZW50czprYixwcm9jZXNzRXZlbnRRdWV1ZTpsYn0pLG5iPU1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpLE89XCJfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSRcIituYixvYj1cIl9fcmVhY3RFdmVudEhhbmRsZXJzJFwiK25iO1xuZnVuY3Rpb24gcGIoYSl7aWYoYVtPXSlyZXR1cm4gYVtPXTtmb3IodmFyIGI9W107IWFbT107KWlmKGIucHVzaChhKSxhLnBhcmVudE5vZGUpYT1hLnBhcmVudE5vZGU7ZWxzZSByZXR1cm4gbnVsbDt2YXIgYz12b2lkIDAsZD1hW09dO2lmKDU9PT1kLnRhZ3x8Nj09PWQudGFnKXJldHVybiBkO2Zvcig7YSYmKGQ9YVtPXSk7YT1iLnBvcCgpKWM9ZDtyZXR1cm4gY31mdW5jdGlvbiBxYihhKXtpZig1PT09YS50YWd8fDY9PT1hLnRhZylyZXR1cm4gYS5zdGF0ZU5vZGU7RChcIjMzXCIpfWZ1bmN0aW9uIHJiKGEpe3JldHVybiBhW29iXXx8bnVsbH1cbnZhciBzYj1PYmplY3QuZnJlZXplKHtwcmVjYWNoZUZpYmVyTm9kZTpmdW5jdGlvbihhLGIpe2JbT109YX0sZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGU6cGIsZ2V0SW5zdGFuY2VGcm9tTm9kZTpmdW5jdGlvbihhKXthPWFbT107cmV0dXJuIWF8fDUhPT1hLnRhZyYmNiE9PWEudGFnP251bGw6YX0sZ2V0Tm9kZUZyb21JbnN0YW5jZTpxYixnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOnJiLHVwZGF0ZUZpYmVyUHJvcHM6ZnVuY3Rpb24oYSxiKXthW29iXT1ifX0pO2Z1bmN0aW9uIFEoYSl7ZG8gYT1hW1wicmV0dXJuXCJdO3doaWxlKGEmJjUhPT1hLnRhZyk7cmV0dXJuIGE/YTpudWxsfWZ1bmN0aW9uIHRiKGEsYixjKXtmb3IodmFyIGQ9W107YTspZC5wdXNoKGEpLGE9UShhKTtmb3IoYT1kLmxlbmd0aDswPGEtLTspYihkW2FdLFwiY2FwdHVyZWRcIixjKTtmb3IoYT0wO2E8ZC5sZW5ndGg7YSsrKWIoZFthXSxcImJ1YmJsZWRcIixjKX1cbmZ1bmN0aW9uIHViKGEsYixjKXtpZihiPWViKGEsYy5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1tiXSkpYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9WWEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9WWEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSl9ZnVuY3Rpb24gdmIoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcyYmdGIoYS5fdGFyZ2V0SW5zdCx1YixhKX1mdW5jdGlvbiB3YihhKXtpZihhJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzKXt2YXIgYj1hLl90YXJnZXRJbnN0O2I9Yj9RKGIpOm51bGw7dGIoYix1YixhKX19XG5mdW5jdGlvbiB4YihhLGIsYyl7YSYmYyYmYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiYoYj1lYihhLGMuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkpJiYoYy5fZGlzcGF0Y2hMaXN0ZW5lcnM9WWEoYy5fZGlzcGF0Y2hMaXN0ZW5lcnMsYiksYy5fZGlzcGF0Y2hJbnN0YW5jZXM9WWEoYy5fZGlzcGF0Y2hJbnN0YW5jZXMsYSkpfWZ1bmN0aW9uIHliKGEpe2EmJmEuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSYmeGIoYS5fdGFyZ2V0SW5zdCxudWxsLGEpfWZ1bmN0aW9uIHpiKGEpe1phKGEsdmIpfVxuZnVuY3Rpb24gQWIoYSxiLGMsZCl7aWYoYyYmZClhOnt2YXIgZT1jO2Zvcih2YXIgZj1kLGc9MCxrPWU7aztrPVEoaykpZysrO2s9MDtmb3IodmFyIGg9ZjtoO2g9UShoKSlrKys7Zm9yKDswPGctazspZT1RKGUpLGctLTtmb3IoOzA8ay1nOylmPVEoZiksay0tO2Zvcig7Zy0tOyl7aWYoZT09PWZ8fGU9PT1mLmFsdGVybmF0ZSlicmVhayBhO2U9UShlKTtmPVEoZil9ZT1udWxsfWVsc2UgZT1udWxsO2Y9ZTtmb3IoZT1bXTtjJiZjIT09Zjspe2c9Yy5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2UucHVzaChjKTtjPVEoYyl9Zm9yKGM9W107ZCYmZCE9PWY7KXtnPWQuYWx0ZXJuYXRlO2lmKG51bGwhPT1nJiZnPT09ZilicmVhaztjLnB1c2goZCk7ZD1RKGQpfWZvcihkPTA7ZDxlLmxlbmd0aDtkKyspeGIoZVtkXSxcImJ1YmJsZWRcIixhKTtmb3IoYT1jLmxlbmd0aDswPGEtLTspeGIoY1thXSxcImNhcHR1cmVkXCIsYil9XG52YXIgQmI9T2JqZWN0LmZyZWV6ZSh7YWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlczp6YixhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDpmdW5jdGlvbihhKXtaYShhLHdiKX0sYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOkFiLGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOmZ1bmN0aW9uKGEpe1phKGEseWIpfX0pLENiPW51bGw7ZnVuY3Rpb24gRGIoKXshQ2ImJm0uY2FuVXNlRE9NJiYoQ2I9XCJ0ZXh0Q29udGVudFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50P1widGV4dENvbnRlbnRcIjpcImlubmVyVGV4dFwiKTtyZXR1cm4gQ2J9dmFyIFI9e19yb290Om51bGwsX3N0YXJ0VGV4dDpudWxsLF9mYWxsYmFja1RleHQ6bnVsbH07XG5mdW5jdGlvbiBFYigpe2lmKFIuX2ZhbGxiYWNrVGV4dClyZXR1cm4gUi5fZmFsbGJhY2tUZXh0O3ZhciBhLGI9Ui5fc3RhcnRUZXh0LGM9Yi5sZW5ndGgsZCxlPUZiKCksZj1lLmxlbmd0aDtmb3IoYT0wO2E8YyYmYlthXT09PWVbYV07YSsrKTt2YXIgZz1jLWE7Zm9yKGQ9MTtkPD1nJiZiW2MtZF09PT1lW2YtZF07ZCsrKTtSLl9mYWxsYmFja1RleHQ9ZS5zbGljZShhLDE8ZD8xLWQ6dm9pZCAwKTtyZXR1cm4gUi5fZmFsbGJhY2tUZXh0fWZ1bmN0aW9uIEZiKCl7cmV0dXJuXCJ2YWx1ZVwiaW4gUi5fcm9vdD9SLl9yb290LnZhbHVlOlIuX3Jvb3RbRGIoKV19XG52YXIgR2I9XCJkaXNwYXRjaENvbmZpZyBfdGFyZ2V0SW5zdCBuYXRpdmVFdmVudCBpc0RlZmF1bHRQcmV2ZW50ZWQgaXNQcm9wYWdhdGlvblN0b3BwZWQgX2Rpc3BhdGNoTGlzdGVuZXJzIF9kaXNwYXRjaEluc3RhbmNlc1wiLnNwbGl0KFwiIFwiKSxIYj17dHlwZTpudWxsLHRhcmdldDpudWxsLGN1cnJlbnRUYXJnZXQ6Qi50aGF0UmV0dXJuc051bGwsZXZlbnRQaGFzZTpudWxsLGJ1YmJsZXM6bnVsbCxjYW5jZWxhYmxlOm51bGwsdGltZVN0YW1wOmZ1bmN0aW9uKGEpe3JldHVybiBhLnRpbWVTdGFtcHx8RGF0ZS5ub3coKX0sZGVmYXVsdFByZXZlbnRlZDpudWxsLGlzVHJ1c3RlZDpudWxsfTtcbmZ1bmN0aW9uIFMoYSxiLGMsZCl7dGhpcy5kaXNwYXRjaENvbmZpZz1hO3RoaXMuX3RhcmdldEluc3Q9Yjt0aGlzLm5hdGl2ZUV2ZW50PWM7YT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtmb3IodmFyIGUgaW4gYSlhLmhhc093blByb3BlcnR5KGUpJiYoKGI9YVtlXSk/dGhpc1tlXT1iKGMpOlwidGFyZ2V0XCI9PT1lP3RoaXMudGFyZ2V0PWQ6dGhpc1tlXT1jW2VdKTt0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD0obnVsbCE9Yy5kZWZhdWx0UHJldmVudGVkP2MuZGVmYXVsdFByZXZlbnRlZDohMT09PWMucmV0dXJuVmFsdWUpP0IudGhhdFJldHVybnNUcnVlOkIudGhhdFJldHVybnNGYWxzZTt0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUIudGhhdFJldHVybnNGYWxzZTtyZXR1cm4gdGhpc31cbkEoUy5wcm90b3R5cGUse3ByZXZlbnREZWZhdWx0OmZ1bmN0aW9uKCl7dGhpcy5kZWZhdWx0UHJldmVudGVkPSEwO3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEucHJldmVudERlZmF1bHQ/YS5wcmV2ZW50RGVmYXVsdCgpOlwidW5rbm93blwiIT09dHlwZW9mIGEucmV0dXJuVmFsdWUmJihhLnJldHVyblZhbHVlPSExKSx0aGlzLmlzRGVmYXVsdFByZXZlbnRlZD1CLnRoYXRSZXR1cm5zVHJ1ZSl9LHN0b3BQcm9wYWdhdGlvbjpmdW5jdGlvbigpe3ZhciBhPXRoaXMubmF0aXZlRXZlbnQ7YSYmKGEuc3RvcFByb3BhZ2F0aW9uP2Euc3RvcFByb3BhZ2F0aW9uKCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5jYW5jZWxCdWJibGUmJihhLmNhbmNlbEJ1YmJsZT0hMCksdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZD1CLnRoYXRSZXR1cm5zVHJ1ZSl9LHBlcnNpc3Q6ZnVuY3Rpb24oKXt0aGlzLmlzUGVyc2lzdGVudD1CLnRoYXRSZXR1cm5zVHJ1ZX0saXNQZXJzaXN0ZW50OkIudGhhdFJldHVybnNGYWxzZSxcbmRlc3RydWN0b3I6ZnVuY3Rpb24oKXt2YXIgYT10aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZSxiO2ZvcihiIGluIGEpdGhpc1tiXT1udWxsO2ZvcihhPTA7YTxHYi5sZW5ndGg7YSsrKXRoaXNbR2JbYV1dPW51bGx9fSk7Uy5JbnRlcmZhY2U9SGI7Uy5hdWdtZW50Q2xhc3M9ZnVuY3Rpb24oYSxiKXtmdW5jdGlvbiBjKCl7fWMucHJvdG90eXBlPXRoaXMucHJvdG90eXBlO3ZhciBkPW5ldyBjO0EoZCxhLnByb3RvdHlwZSk7YS5wcm90b3R5cGU9ZDthLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1hO2EuSW50ZXJmYWNlPUEoe30sdGhpcy5JbnRlcmZhY2UsYik7YS5hdWdtZW50Q2xhc3M9dGhpcy5hdWdtZW50Q2xhc3M7SWIoYSl9O0liKFMpO2Z1bmN0aW9uIEpiKGEsYixjLGQpe2lmKHRoaXMuZXZlbnRQb29sLmxlbmd0aCl7dmFyIGU9dGhpcy5ldmVudFBvb2wucG9wKCk7dGhpcy5jYWxsKGUsYSxiLGMsZCk7cmV0dXJuIGV9cmV0dXJuIG5ldyB0aGlzKGEsYixjLGQpfVxuZnVuY3Rpb24gUWIoYSl7YSBpbnN0YW5jZW9mIHRoaXM/dm9pZCAwOkQoXCIyMjNcIik7YS5kZXN0cnVjdG9yKCk7MTA+dGhpcy5ldmVudFBvb2wubGVuZ3RoJiZ0aGlzLmV2ZW50UG9vbC5wdXNoKGEpfWZ1bmN0aW9uIEliKGEpe2EuZXZlbnRQb29sPVtdO2EuZ2V0UG9vbGVkPUpiO2EucmVsZWFzZT1RYn1mdW5jdGlvbiBSYihhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9Uy5hdWdtZW50Q2xhc3MoUmIse2RhdGE6bnVsbH0pO2Z1bmN0aW9uIFNiKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1TLmF1Z21lbnRDbGFzcyhTYix7ZGF0YTpudWxsfSk7dmFyIFRiPVs5LDEzLDI3LDMyXSxVYj1tLmNhblVzZURPTSYmXCJDb21wb3NpdGlvbkV2ZW50XCJpbiB3aW5kb3csVmI9bnVsbDttLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYoVmI9ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKTt2YXIgV2I7XG5pZihXYj1tLmNhblVzZURPTSYmXCJUZXh0RXZlbnRcImluIHdpbmRvdyYmIVZiKXt2YXIgWGI9d2luZG93Lm9wZXJhO1diPSEoXCJvYmplY3RcIj09PXR5cGVvZiBYYiYmXCJmdW5jdGlvblwiPT09dHlwZW9mIFhiLnZlcnNpb24mJjEyPj1wYXJzZUludChYYi52ZXJzaW9uKCksMTApKX1cbnZhciBZYj1XYixaYj1tLmNhblVzZURPTSYmKCFVYnx8VmImJjg8VmImJjExPj1WYiksJGI9U3RyaW5nLmZyb21DaGFyQ29kZSgzMiksYWM9e2JlZm9yZUlucHV0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQmVmb3JlSW5wdXRcIixjYXB0dXJlZDpcIm9uQmVmb3JlSW5wdXRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbXCJ0b3BDb21wb3NpdGlvbkVuZFwiLFwidG9wS2V5UHJlc3NcIixcInRvcFRleHRJbnB1dFwiLFwidG9wUGFzdGVcIl19LGNvbXBvc2l0aW9uRW5kOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25FbmRcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25FbmQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uU3RhcnQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvblN0YXJ0XCIsXG5jYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvblN0YXJ0IHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfSxjb21wb3NpdGlvblVwZGF0ZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlXCIsY2FwdHVyZWQ6XCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uVXBkYXRlIHRvcEtleURvd24gdG9wS2V5UHJlc3MgdG9wS2V5VXAgdG9wTW91c2VEb3duXCIuc3BsaXQoXCIgXCIpfX0sYmM9ITE7XG5mdW5jdGlvbiBjYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4tMSE9PVRiLmluZGV4T2YoYi5rZXlDb2RlKTtjYXNlIFwidG9wS2V5RG93blwiOnJldHVybiAyMjkhPT1iLmtleUNvZGU7Y2FzZSBcInRvcEtleVByZXNzXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BCbHVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gZGMoYSl7YT1hLmRldGFpbDtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJlwiZGF0YVwiaW4gYT9hLmRhdGE6bnVsbH12YXIgZWM9ITE7ZnVuY3Rpb24gZmMoYSxiKXtzd2l0Y2goYSl7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuIGRjKGIpO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDMyIT09Yi53aGljaClyZXR1cm4gbnVsbDtiYz0hMDtyZXR1cm4gJGI7Y2FzZSBcInRvcFRleHRJbnB1dFwiOnJldHVybiBhPWIuZGF0YSxhPT09JGImJmJjP251bGw6YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbmZ1bmN0aW9uIGdjKGEsYil7aWYoZWMpcmV0dXJuXCJ0b3BDb21wb3NpdGlvbkVuZFwiPT09YXx8IVViJiZjYyhhLGIpPyhhPUViKCksUi5fcm9vdD1udWxsLFIuX3N0YXJ0VGV4dD1udWxsLFIuX2ZhbGxiYWNrVGV4dD1udWxsLGVjPSExLGEpOm51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BQYXN0ZVwiOnJldHVybiBudWxsO2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKCEoYi5jdHJsS2V5fHxiLmFsdEtleXx8Yi5tZXRhS2V5KXx8Yi5jdHJsS2V5JiZiLmFsdEtleSl7aWYoYi5jaGFyJiYxPGIuY2hhci5sZW5ndGgpcmV0dXJuIGIuY2hhcjtpZihiLndoaWNoKXJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIud2hpY2gpfXJldHVybiBudWxsO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOnJldHVybiBaYj9udWxsOmIuZGF0YTtkZWZhdWx0OnJldHVybiBudWxsfX1cbnZhciBoYz17ZXZlbnRUeXBlczphYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlO2lmKFViKWI6e3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25TdGFydFwiOnZhciBmPWFjLmNvbXBvc2l0aW9uU3RhcnQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpmPWFjLmNvbXBvc2l0aW9uRW5kO2JyZWFrIGI7Y2FzZSBcInRvcENvbXBvc2l0aW9uVXBkYXRlXCI6Zj1hYy5jb21wb3NpdGlvblVwZGF0ZTticmVhayBifWY9dm9pZCAwfWVsc2UgZWM/Y2MoYSxjKSYmKGY9YWMuY29tcG9zaXRpb25FbmQpOlwidG9wS2V5RG93blwiPT09YSYmMjI5PT09Yy5rZXlDb2RlJiYoZj1hYy5jb21wb3NpdGlvblN0YXJ0KTtmPyhaYiYmKGVjfHxmIT09YWMuY29tcG9zaXRpb25TdGFydD9mPT09YWMuY29tcG9zaXRpb25FbmQmJmVjJiYoZT1FYigpKTooUi5fcm9vdD1kLFIuX3N0YXJ0VGV4dD1GYigpLGVjPSEwKSksZj1SYi5nZXRQb29sZWQoZixiLGMsZCksZT9mLmRhdGE9XG5lOihlPWRjKGMpLG51bGwhPT1lJiYoZi5kYXRhPWUpKSx6YihmKSxlPWYpOmU9bnVsbDsoYT1ZYj9mYyhhLGMpOmdjKGEsYykpPyhiPVNiLmdldFBvb2xlZChhYy5iZWZvcmVJbnB1dCxiLGMsZCksYi5kYXRhPWEsemIoYikpOmI9bnVsbDtyZXR1cm5bZSxiXX19LGljPW51bGwsamM9bnVsbCxrYz1udWxsO2Z1bmN0aW9uIGxjKGEpe2lmKGE9VmEoYSkpe2ljJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgaWMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZT92b2lkIDA6RChcIjE5NFwiKTt2YXIgYj1VYShhLnN0YXRlTm9kZSk7aWMucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShhLnN0YXRlTm9kZSxhLnR5cGUsYil9fXZhciBtYz17aW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudDpmdW5jdGlvbihhKXtpYz1hfX07ZnVuY3Rpb24gbmMoYSl7amM/a2M/a2MucHVzaChhKTprYz1bYV06amM9YX1cbmZ1bmN0aW9uIG9jKCl7aWYoamMpe3ZhciBhPWpjLGI9a2M7a2M9amM9bnVsbDtsYyhhKTtpZihiKWZvcihhPTA7YTxiLmxlbmd0aDthKyspbGMoYlthXSl9fXZhciBwYz1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246bWMsZW5xdWV1ZVN0YXRlUmVzdG9yZTpuYyxyZXN0b3JlU3RhdGVJZk5lZWRlZDpvY30pO2Z1bmN0aW9uIHFjKGEsYil7cmV0dXJuIGEoYil9dmFyIHJjPSExO2Z1bmN0aW9uIHNjKGEsYil7aWYocmMpcmV0dXJuIHFjKGEsYik7cmM9ITA7dHJ5e3JldHVybiBxYyhhLGIpfWZpbmFsbHl7cmM9ITEsb2MoKX19dmFyIHRjPXtjb2xvcjohMCxkYXRlOiEwLGRhdGV0aW1lOiEwLFwiZGF0ZXRpbWUtbG9jYWxcIjohMCxlbWFpbDohMCxtb250aDohMCxudW1iZXI6ITAscGFzc3dvcmQ6ITAscmFuZ2U6ITAsc2VhcmNoOiEwLHRlbDohMCx0ZXh0OiEwLHRpbWU6ITAsdXJsOiEwLHdlZWs6ITB9O1xuZnVuY3Rpb24gdWMoYSl7dmFyIGI9YSYmYS5ub2RlTmFtZSYmYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO3JldHVyblwiaW5wdXRcIj09PWI/ISF0Y1thLnR5cGVdOlwidGV4dGFyZWFcIj09PWI/ITA6ITF9ZnVuY3Rpb24gdmMoYSl7YT1hLnRhcmdldHx8YS5zcmNFbGVtZW50fHx3aW5kb3c7YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCYmKGE9YS5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCk7cmV0dXJuIDM9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZTphfXZhciB3YzttLmNhblVzZURPTSYmKHdjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uJiZkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlJiYhMCE9PWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJcIixcIlwiKSk7XG5mdW5jdGlvbiB4YyhhLGIpe2lmKCFtLmNhblVzZURPTXx8YiYmIShcImFkZEV2ZW50TGlzdGVuZXJcImluIGRvY3VtZW50KSlyZXR1cm4hMTtiPVwib25cIithO3ZhciBjPWIgaW4gZG9jdW1lbnQ7Y3x8KGM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxjLnNldEF0dHJpYnV0ZShiLFwicmV0dXJuO1wiKSxjPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBjW2JdKTshYyYmd2MmJlwid2hlZWxcIj09PWEmJihjPWRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoXCJFdmVudHMud2hlZWxcIixcIjMuMFwiKSk7cmV0dXJuIGN9ZnVuY3Rpb24geWMoYSl7dmFyIGI9YS50eXBlO3JldHVybihhPWEubm9kZU5hbWUpJiZcImlucHV0XCI9PT1hLnRvTG93ZXJDYXNlKCkmJihcImNoZWNrYm94XCI9PT1ifHxcInJhZGlvXCI9PT1iKX1cbmZ1bmN0aW9uIHpjKGEpe3ZhciBiPXljKGEpP1wiY2hlY2tlZFwiOlwidmFsdWVcIixjPU9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsYiksZD1cIlwiK2FbYl07aWYoIWEuaGFzT3duUHJvcGVydHkoYikmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLmdldCYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuc2V0KXJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoYSxiLHtlbnVtZXJhYmxlOmMuZW51bWVyYWJsZSxjb25maWd1cmFibGU6ITAsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIGMuZ2V0LmNhbGwodGhpcyl9LHNldDpmdW5jdGlvbihhKXtkPVwiXCIrYTtjLnNldC5jYWxsKHRoaXMsYSl9fSkse2dldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIGR9LHNldFZhbHVlOmZ1bmN0aW9uKGEpe2Q9XCJcIithfSxzdG9wVHJhY2tpbmc6ZnVuY3Rpb24oKXthLl92YWx1ZVRyYWNrZXI9bnVsbDtkZWxldGUgYVtiXX19fVxuZnVuY3Rpb24gQWMoYSl7YS5fdmFsdWVUcmFja2VyfHwoYS5fdmFsdWVUcmFja2VyPXpjKGEpKX1mdW5jdGlvbiBCYyhhKXtpZighYSlyZXR1cm4hMTt2YXIgYj1hLl92YWx1ZVRyYWNrZXI7aWYoIWIpcmV0dXJuITA7dmFyIGM9Yi5nZXRWYWx1ZSgpO3ZhciBkPVwiXCI7YSYmKGQ9eWMoYSk/YS5jaGVja2VkP1widHJ1ZVwiOlwiZmFsc2VcIjphLnZhbHVlKTthPWQ7cmV0dXJuIGEhPT1jPyhiLnNldFZhbHVlKGEpLCEwKTohMX12YXIgQ2M9e2NoYW5nZTp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNoYW5nZVwiLGNhcHR1cmVkOlwib25DaGFuZ2VDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ2hhbmdlIHRvcENsaWNrIHRvcEZvY3VzIHRvcElucHV0IHRvcEtleURvd24gdG9wS2V5VXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX07XG5mdW5jdGlvbiBEYyhhLGIsYyl7YT1TLmdldFBvb2xlZChDYy5jaGFuZ2UsYSxiLGMpO2EudHlwZT1cImNoYW5nZVwiO25jKGMpO3piKGEpO3JldHVybiBhfXZhciBFYz1udWxsLEZjPW51bGw7ZnVuY3Rpb24gR2MoYSl7a2IoYSk7bGIoITEpfWZ1bmN0aW9uIEhjKGEpe3ZhciBiPXFiKGEpO2lmKEJjKGIpKXJldHVybiBhfWZ1bmN0aW9uIEljKGEsYil7aWYoXCJ0b3BDaGFuZ2VcIj09PWEpcmV0dXJuIGJ9dmFyIEpjPSExO20uY2FuVXNlRE9NJiYoSmM9eGMoXCJpbnB1dFwiKSYmKCFkb2N1bWVudC5kb2N1bWVudE1vZGV8fDk8ZG9jdW1lbnQuZG9jdW1lbnRNb2RlKSk7ZnVuY3Rpb24gUWMoKXtFYyYmKEVjLmRldGFjaEV2ZW50KFwib25wcm9wZXJ0eWNoYW5nZVwiLFJjKSxGYz1FYz1udWxsKX1mdW5jdGlvbiBSYyhhKXtcInZhbHVlXCI9PT1hLnByb3BlcnR5TmFtZSYmSGMoRmMpJiYoYT1EYyhGYyxhLHZjKGEpKSxzYyhHYyxhKSl9XG5mdW5jdGlvbiBTYyhhLGIsYyl7XCJ0b3BGb2N1c1wiPT09YT8oUWMoKSxFYz1iLEZjPWMsRWMuYXR0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsUmMpKTpcInRvcEJsdXJcIj09PWEmJlFjKCl9ZnVuY3Rpb24gVGMoYSl7aWYoXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIj09PWF8fFwidG9wS2V5VXBcIj09PWF8fFwidG9wS2V5RG93blwiPT09YSlyZXR1cm4gSGMoRmMpfWZ1bmN0aW9uIFVjKGEsYil7aWYoXCJ0b3BDbGlja1wiPT09YSlyZXR1cm4gSGMoYil9ZnVuY3Rpb24gVmMoYSxiKXtpZihcInRvcElucHV0XCI9PT1hfHxcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gSGMoYil9XG52YXIgV2M9e2V2ZW50VHlwZXM6Q2MsX2lzSW5wdXRFdmVudFN1cHBvcnRlZDpKYyxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWI/cWIoYik6d2luZG93LGY9ZS5ub2RlTmFtZSYmZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO2lmKFwic2VsZWN0XCI9PT1mfHxcImlucHV0XCI9PT1mJiZcImZpbGVcIj09PWUudHlwZSl2YXIgZz1JYztlbHNlIGlmKHVjKGUpKWlmKEpjKWc9VmM7ZWxzZXtnPVRjO3ZhciBrPVNjfWVsc2UgZj1lLm5vZGVOYW1lLCFmfHxcImlucHV0XCIhPT1mLnRvTG93ZXJDYXNlKCl8fFwiY2hlY2tib3hcIiE9PWUudHlwZSYmXCJyYWRpb1wiIT09ZS50eXBlfHwoZz1VYyk7aWYoZyYmKGc9ZyhhLGIpKSlyZXR1cm4gRGMoZyxjLGQpO2smJmsoYSxlLGIpO1widG9wQmx1clwiPT09YSYmbnVsbCE9YiYmKGE9Yi5fd3JhcHBlclN0YXRlfHxlLl93cmFwcGVyU3RhdGUpJiZhLmNvbnRyb2xsZWQmJlwibnVtYmVyXCI9PT1lLnR5cGUmJihhPVwiXCIrZS52YWx1ZSxlLmdldEF0dHJpYnV0ZShcInZhbHVlXCIpIT09XG5hJiZlLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYSkpfX07ZnVuY3Rpb24gWGMoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVMuYXVnbWVudENsYXNzKFhjLHt2aWV3Om51bGwsZGV0YWlsOm51bGx9KTt2YXIgWWM9e0FsdDpcImFsdEtleVwiLENvbnRyb2w6XCJjdHJsS2V5XCIsTWV0YTpcIm1ldGFLZXlcIixTaGlmdDpcInNoaWZ0S2V5XCJ9O2Z1bmN0aW9uIFpjKGEpe3ZhciBiPXRoaXMubmF0aXZlRXZlbnQ7cmV0dXJuIGIuZ2V0TW9kaWZpZXJTdGF0ZT9iLmdldE1vZGlmaWVyU3RhdGUoYSk6KGE9WWNbYV0pPyEhYlthXTohMX1mdW5jdGlvbiAkYygpe3JldHVybiBaY31mdW5jdGlvbiBhZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9XG5YYy5hdWdtZW50Q2xhc3MoYWQse3NjcmVlblg6bnVsbCxzY3JlZW5ZOm51bGwsY2xpZW50WDpudWxsLGNsaWVudFk6bnVsbCxwYWdlWDpudWxsLHBhZ2VZOm51bGwsY3RybEtleTpudWxsLHNoaWZ0S2V5Om51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6JGMsYnV0dG9uOm51bGwsYnV0dG9uczpudWxsLHJlbGF0ZWRUYXJnZXQ6ZnVuY3Rpb24oYSl7cmV0dXJuIGEucmVsYXRlZFRhcmdldHx8KGEuZnJvbUVsZW1lbnQ9PT1hLnNyY0VsZW1lbnQ/YS50b0VsZW1lbnQ6YS5mcm9tRWxlbWVudCl9fSk7XG52YXIgYmQ9e21vdXNlRW50ZXI6e3JlZ2lzdHJhdGlvbk5hbWU6XCJvbk1vdXNlRW50ZXJcIixkZXBlbmRlbmNpZXM6W1widG9wTW91c2VPdXRcIixcInRvcE1vdXNlT3ZlclwiXX0sbW91c2VMZWF2ZTp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VMZWF2ZVwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfX0sY2Q9e2V2ZW50VHlwZXM6YmQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXtpZihcInRvcE1vdXNlT3ZlclwiPT09YSYmKGMucmVsYXRlZFRhcmdldHx8Yy5mcm9tRWxlbWVudCl8fFwidG9wTW91c2VPdXRcIiE9PWEmJlwidG9wTW91c2VPdmVyXCIhPT1hKXJldHVybiBudWxsO3ZhciBlPWQud2luZG93PT09ZD9kOihlPWQub3duZXJEb2N1bWVudCk/ZS5kZWZhdWx0Vmlld3x8ZS5wYXJlbnRXaW5kb3c6d2luZG93O1widG9wTW91c2VPdXRcIj09PWE/KGE9YixiPShiPWMucmVsYXRlZFRhcmdldHx8Yy50b0VsZW1lbnQpP3BiKGIpOm51bGwpOmE9bnVsbDtpZihhPT09XG5iKXJldHVybiBudWxsO3ZhciBmPW51bGw9PWE/ZTpxYihhKTtlPW51bGw9PWI/ZTpxYihiKTt2YXIgZz1hZC5nZXRQb29sZWQoYmQubW91c2VMZWF2ZSxhLGMsZCk7Zy50eXBlPVwibW91c2VsZWF2ZVwiO2cudGFyZ2V0PWY7Zy5yZWxhdGVkVGFyZ2V0PWU7Yz1hZC5nZXRQb29sZWQoYmQubW91c2VFbnRlcixiLGMsZCk7Yy50eXBlPVwibW91c2VlbnRlclwiO2MudGFyZ2V0PWU7Yy5yZWxhdGVkVGFyZ2V0PWY7QWIoZyxjLGEsYik7cmV0dXJuW2csY119fSxkZD1hYS5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRC5SZWFjdEN1cnJlbnRPd25lcjtmdW5jdGlvbiBlZChhKXthPWEudHlwZTtyZXR1cm5cInN0cmluZ1wiPT09dHlwZW9mIGE/YTpcImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hLmRpc3BsYXlOYW1lfHxhLm5hbWU6bnVsbH1cbmZ1bmN0aW9uIGZkKGEpe3ZhciBiPWE7aWYoYS5hbHRlcm5hdGUpZm9yKDtiW1wicmV0dXJuXCJdOyliPWJbXCJyZXR1cm5cIl07ZWxzZXtpZigwIT09KGIuZWZmZWN0VGFnJjIpKXJldHVybiAxO2Zvcig7YltcInJldHVyblwiXTspaWYoYj1iW1wicmV0dXJuXCJdLDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDF9cmV0dXJuIDM9PT1iLnRhZz8yOjN9ZnVuY3Rpb24gZ2QoYSl7cmV0dXJuKGE9YS5fcmVhY3RJbnRlcm5hbEZpYmVyKT8yPT09ZmQoYSk6ITF9ZnVuY3Rpb24gaGQoYSl7MiE9PWZkKGEpP0QoXCIxODhcIik6dm9pZCAwfVxuZnVuY3Rpb24gaWQoYSl7dmFyIGI9YS5hbHRlcm5hdGU7aWYoIWIpcmV0dXJuIGI9ZmQoYSksMz09PWI/RChcIjE4OFwiKTp2b2lkIDAsMT09PWI/bnVsbDphO2Zvcih2YXIgYz1hLGQ9Yjs7KXt2YXIgZT1jW1wicmV0dXJuXCJdLGY9ZT9lLmFsdGVybmF0ZTpudWxsO2lmKCFlfHwhZilicmVhaztpZihlLmNoaWxkPT09Zi5jaGlsZCl7Zm9yKHZhciBnPWUuY2hpbGQ7Zzspe2lmKGc9PT1jKXJldHVybiBoZChlKSxhO2lmKGc9PT1kKXJldHVybiBoZChlKSxiO2c9Zy5zaWJsaW5nfUQoXCIxODhcIil9aWYoY1tcInJldHVyblwiXSE9PWRbXCJyZXR1cm5cIl0pYz1lLGQ9ZjtlbHNle2c9ITE7Zm9yKHZhciBrPWUuY2hpbGQ7azspe2lmKGs9PT1jKXtnPSEwO2M9ZTtkPWY7YnJlYWt9aWYoaz09PWQpe2c9ITA7ZD1lO2M9ZjticmVha31rPWsuc2libGluZ31pZighZyl7Zm9yKGs9Zi5jaGlsZDtrOyl7aWYoaz09PWMpe2c9ITA7Yz1mO2Q9ZTticmVha31pZihrPT09ZCl7Zz0hMDtkPWY7Yz1lO2JyZWFrfWs9ay5zaWJsaW5nfWc/XG52b2lkIDA6RChcIjE4OVwiKX19Yy5hbHRlcm5hdGUhPT1kP0QoXCIxOTBcIik6dm9pZCAwfTMhPT1jLnRhZz9EKFwiMTg4XCIpOnZvaWQgMDtyZXR1cm4gYy5zdGF0ZU5vZGUuY3VycmVudD09PWM/YTpifWZ1bmN0aW9uIGpkKGEpe2E9aWQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9XG5mdW5jdGlvbiBrZChhKXthPWlkKGEpO2lmKCFhKXJldHVybiBudWxsO2Zvcih2YXIgYj1hOzspe2lmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKXJldHVybiBiO2lmKGIuY2hpbGQmJjQhPT1iLnRhZyliLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkO2Vsc2V7aWYoYj09PWEpYnJlYWs7Zm9yKDshYi5zaWJsaW5nOyl7aWYoIWJbXCJyZXR1cm5cIl18fGJbXCJyZXR1cm5cIl09PT1hKXJldHVybiBudWxsO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319cmV0dXJuIG51bGx9dmFyIGxkPVtdO1xuZnVuY3Rpb24gbWQoYSl7dmFyIGI9YS50YXJnZXRJbnN0O2Rve2lmKCFiKXthLmFuY2VzdG9ycy5wdXNoKGIpO2JyZWFrfXZhciBjO2ZvcihjPWI7Y1tcInJldHVyblwiXTspYz1jW1wicmV0dXJuXCJdO2M9MyE9PWMudGFnP251bGw6Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztpZighYylicmVhazthLmFuY2VzdG9ycy5wdXNoKGIpO2I9cGIoYyl9d2hpbGUoYik7Zm9yKGM9MDtjPGEuYW5jZXN0b3JzLmxlbmd0aDtjKyspYj1hLmFuY2VzdG9yc1tjXSxuZChhLnRvcExldmVsVHlwZSxiLGEubmF0aXZlRXZlbnQsdmMoYS5uYXRpdmVFdmVudCkpfXZhciBvZD0hMCxuZD12b2lkIDA7ZnVuY3Rpb24gcGQoYSl7b2Q9ISFhfWZ1bmN0aW9uIFUoYSxiLGMpe3JldHVybiBjP2NhLmxpc3RlbihjLGIscWQuYmluZChudWxsLGEpKTpudWxsfWZ1bmN0aW9uIHJkKGEsYixjKXtyZXR1cm4gYz9jYS5jYXB0dXJlKGMsYixxZC5iaW5kKG51bGwsYSkpOm51bGx9XG5mdW5jdGlvbiBxZChhLGIpe2lmKG9kKXt2YXIgYz12YyhiKTtjPXBiKGMpO251bGw9PT1jfHxcIm51bWJlclwiIT09dHlwZW9mIGMudGFnfHwyPT09ZmQoYyl8fChjPW51bGwpO2lmKGxkLmxlbmd0aCl7dmFyIGQ9bGQucG9wKCk7ZC50b3BMZXZlbFR5cGU9YTtkLm5hdGl2ZUV2ZW50PWI7ZC50YXJnZXRJbnN0PWM7YT1kfWVsc2UgYT17dG9wTGV2ZWxUeXBlOmEsbmF0aXZlRXZlbnQ6Yix0YXJnZXRJbnN0OmMsYW5jZXN0b3JzOltdfTt0cnl7c2MobWQsYSl9ZmluYWxseXthLnRvcExldmVsVHlwZT1udWxsLGEubmF0aXZlRXZlbnQ9bnVsbCxhLnRhcmdldEluc3Q9bnVsbCxhLmFuY2VzdG9ycy5sZW5ndGg9MCwxMD5sZC5sZW5ndGgmJmxkLnB1c2goYSl9fX1cbnZhciBzZD1PYmplY3QuZnJlZXplKHtnZXQgX2VuYWJsZWQoKXtyZXR1cm4gb2R9LGdldCBfaGFuZGxlVG9wTGV2ZWwoKXtyZXR1cm4gbmR9LHNldEhhbmRsZVRvcExldmVsOmZ1bmN0aW9uKGEpe25kPWF9LHNldEVuYWJsZWQ6cGQsaXNFbmFibGVkOmZ1bmN0aW9uKCl7cmV0dXJuIG9kfSx0cmFwQnViYmxlZEV2ZW50OlUsdHJhcENhcHR1cmVkRXZlbnQ6cmQsZGlzcGF0Y2hFdmVudDpxZH0pO2Z1bmN0aW9uIHRkKGEsYil7dmFyIGM9e307Y1thLnRvTG93ZXJDYXNlKCldPWIudG9Mb3dlckNhc2UoKTtjW1wiV2Via2l0XCIrYV09XCJ3ZWJraXRcIitiO2NbXCJNb3pcIithXT1cIm1velwiK2I7Y1tcIm1zXCIrYV09XCJNU1wiK2I7Y1tcIk9cIithXT1cIm9cIitiLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGN9XG52YXIgdWQ9e2FuaW1hdGlvbmVuZDp0ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uRW5kXCIpLGFuaW1hdGlvbml0ZXJhdGlvbjp0ZChcIkFuaW1hdGlvblwiLFwiQW5pbWF0aW9uSXRlcmF0aW9uXCIpLGFuaW1hdGlvbnN0YXJ0OnRkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25TdGFydFwiKSx0cmFuc2l0aW9uZW5kOnRkKFwiVHJhbnNpdGlvblwiLFwiVHJhbnNpdGlvbkVuZFwiKX0sdmQ9e30sd2Q9e307bS5jYW5Vc2VET00mJih3ZD1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLnN0eWxlLFwiQW5pbWF0aW9uRXZlbnRcImluIHdpbmRvd3x8KGRlbGV0ZSB1ZC5hbmltYXRpb25lbmQuYW5pbWF0aW9uLGRlbGV0ZSB1ZC5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uLGRlbGV0ZSB1ZC5hbmltYXRpb25zdGFydC5hbmltYXRpb24pLFwiVHJhbnNpdGlvbkV2ZW50XCJpbiB3aW5kb3d8fGRlbGV0ZSB1ZC50cmFuc2l0aW9uZW5kLnRyYW5zaXRpb24pO1xuZnVuY3Rpb24geGQoYSl7aWYodmRbYV0pcmV0dXJuIHZkW2FdO2lmKCF1ZFthXSlyZXR1cm4gYTt2YXIgYj11ZFthXSxjO2ZvcihjIGluIGIpaWYoYi5oYXNPd25Qcm9wZXJ0eShjKSYmYyBpbiB3ZClyZXR1cm4gdmRbYV09YltjXTtyZXR1cm5cIlwifVxudmFyIHlkPXt0b3BBYm9ydDpcImFib3J0XCIsdG9wQW5pbWF0aW9uRW5kOnhkKFwiYW5pbWF0aW9uZW5kXCIpfHxcImFuaW1hdGlvbmVuZFwiLHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjp4ZChcImFuaW1hdGlvbml0ZXJhdGlvblwiKXx8XCJhbmltYXRpb25pdGVyYXRpb25cIix0b3BBbmltYXRpb25TdGFydDp4ZChcImFuaW1hdGlvbnN0YXJ0XCIpfHxcImFuaW1hdGlvbnN0YXJ0XCIsdG9wQmx1cjpcImJsdXJcIix0b3BDYW5jZWw6XCJjYW5jZWxcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BDaGFuZ2U6XCJjaGFuZ2VcIix0b3BDbGljazpcImNsaWNrXCIsdG9wQ2xvc2U6XCJjbG9zZVwiLHRvcENvbXBvc2l0aW9uRW5kOlwiY29tcG9zaXRpb25lbmRcIix0b3BDb21wb3NpdGlvblN0YXJ0OlwiY29tcG9zaXRpb25zdGFydFwiLHRvcENvbXBvc2l0aW9uVXBkYXRlOlwiY29tcG9zaXRpb251cGRhdGVcIix0b3BDb250ZXh0TWVudTpcImNvbnRleHRtZW51XCIsdG9wQ29weTpcImNvcHlcIixcbnRvcEN1dDpcImN1dFwiLHRvcERvdWJsZUNsaWNrOlwiZGJsY2xpY2tcIix0b3BEcmFnOlwiZHJhZ1wiLHRvcERyYWdFbmQ6XCJkcmFnZW5kXCIsdG9wRHJhZ0VudGVyOlwiZHJhZ2VudGVyXCIsdG9wRHJhZ0V4aXQ6XCJkcmFnZXhpdFwiLHRvcERyYWdMZWF2ZTpcImRyYWdsZWF2ZVwiLHRvcERyYWdPdmVyOlwiZHJhZ292ZXJcIix0b3BEcmFnU3RhcnQ6XCJkcmFnc3RhcnRcIix0b3BEcm9wOlwiZHJvcFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wRm9jdXM6XCJmb2N1c1wiLHRvcElucHV0OlwiaW5wdXRcIix0b3BLZXlEb3duOlwia2V5ZG93blwiLHRvcEtleVByZXNzOlwia2V5cHJlc3NcIix0b3BLZXlVcDpcImtleXVwXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkOlwibG9hZFwiLHRvcExvYWRlZE1ldGFkYXRhOlwibG9hZGVkbWV0YWRhdGFcIix0b3BMb2FkU3RhcnQ6XCJsb2Fkc3RhcnRcIixcbnRvcE1vdXNlRG93bjpcIm1vdXNlZG93blwiLHRvcE1vdXNlTW92ZTpcIm1vdXNlbW92ZVwiLHRvcE1vdXNlT3V0OlwibW91c2VvdXRcIix0b3BNb3VzZU92ZXI6XCJtb3VzZW92ZXJcIix0b3BNb3VzZVVwOlwibW91c2V1cFwiLHRvcFBhc3RlOlwicGFzdGVcIix0b3BQYXVzZTpcInBhdXNlXCIsdG9wUGxheTpcInBsYXlcIix0b3BQbGF5aW5nOlwicGxheWluZ1wiLHRvcFByb2dyZXNzOlwicHJvZ3Jlc3NcIix0b3BSYXRlQ2hhbmdlOlwicmF0ZWNoYW5nZVwiLHRvcFNjcm9sbDpcInNjcm9sbFwiLHRvcFNlZWtlZDpcInNlZWtlZFwiLHRvcFNlZWtpbmc6XCJzZWVraW5nXCIsdG9wU2VsZWN0aW9uQ2hhbmdlOlwic2VsZWN0aW9uY2hhbmdlXCIsdG9wU3RhbGxlZDpcInN0YWxsZWRcIix0b3BTdXNwZW5kOlwic3VzcGVuZFwiLHRvcFRleHRJbnB1dDpcInRleHRJbnB1dFwiLHRvcFRpbWVVcGRhdGU6XCJ0aW1ldXBkYXRlXCIsdG9wVG9nZ2xlOlwidG9nZ2xlXCIsdG9wVG91Y2hDYW5jZWw6XCJ0b3VjaGNhbmNlbFwiLHRvcFRvdWNoRW5kOlwidG91Y2hlbmRcIix0b3BUb3VjaE1vdmU6XCJ0b3VjaG1vdmVcIixcbnRvcFRvdWNoU3RhcnQ6XCJ0b3VjaHN0YXJ0XCIsdG9wVHJhbnNpdGlvbkVuZDp4ZChcInRyYW5zaXRpb25lbmRcIil8fFwidHJhbnNpdGlvbmVuZFwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLHRvcFdhaXRpbmc6XCJ3YWl0aW5nXCIsdG9wV2hlZWw6XCJ3aGVlbFwifSx6ZD17fSxBZD0wLEJkPVwiX3JlYWN0TGlzdGVuZXJzSURcIisoXCJcIitNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtmdW5jdGlvbiBDZChhKXtPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYSxCZCl8fChhW0JkXT1BZCsrLHpkW2FbQmRdXT17fSk7cmV0dXJuIHpkW2FbQmRdXX1mdW5jdGlvbiBEZChhKXtmb3IoO2EmJmEuZmlyc3RDaGlsZDspYT1hLmZpcnN0Q2hpbGQ7cmV0dXJuIGF9XG5mdW5jdGlvbiBFZChhLGIpe3ZhciBjPURkKGEpO2E9MDtmb3IodmFyIGQ7Yzspe2lmKDM9PT1jLm5vZGVUeXBlKXtkPWErYy50ZXh0Q29udGVudC5sZW5ndGg7aWYoYTw9YiYmZD49YilyZXR1cm57bm9kZTpjLG9mZnNldDpiLWF9O2E9ZH1hOntmb3IoO2M7KXtpZihjLm5leHRTaWJsaW5nKXtjPWMubmV4dFNpYmxpbmc7YnJlYWsgYX1jPWMucGFyZW50Tm9kZX1jPXZvaWQgMH1jPURkKGMpfX1mdW5jdGlvbiBGZChhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIGImJihcImlucHV0XCI9PT1iJiZcInRleHRcIj09PWEudHlwZXx8XCJ0ZXh0YXJlYVwiPT09Ynx8XCJ0cnVlXCI9PT1hLmNvbnRlbnRFZGl0YWJsZSl9XG52YXIgR2Q9bS5jYW5Vc2VET00mJlwiZG9jdW1lbnRNb2RlXCJpbiBkb2N1bWVudCYmMTE+PWRvY3VtZW50LmRvY3VtZW50TW9kZSxIZD17c2VsZWN0OntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uU2VsZWN0XCIsY2FwdHVyZWQ6XCJvblNlbGVjdENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb250ZXh0TWVudSB0b3BGb2N1cyB0b3BLZXlEb3duIHRvcEtleVVwIHRvcE1vdXNlRG93biB0b3BNb3VzZVVwIHRvcFNlbGVjdGlvbkNoYW5nZVwiLnNwbGl0KFwiIFwiKX19LElkPW51bGwsSmQ9bnVsbCxLZD1udWxsLExkPSExO1xuZnVuY3Rpb24gTWQoYSxiKXtpZihMZHx8bnVsbD09SWR8fElkIT09ZGEoKSlyZXR1cm4gbnVsbDt2YXIgYz1JZDtcInNlbGVjdGlvblN0YXJ0XCJpbiBjJiZGZChjKT9jPXtzdGFydDpjLnNlbGVjdGlvblN0YXJ0LGVuZDpjLnNlbGVjdGlvbkVuZH06d2luZG93LmdldFNlbGVjdGlvbj8oYz13aW5kb3cuZ2V0U2VsZWN0aW9uKCksYz17YW5jaG9yTm9kZTpjLmFuY2hvck5vZGUsYW5jaG9yT2Zmc2V0OmMuYW5jaG9yT2Zmc2V0LGZvY3VzTm9kZTpjLmZvY3VzTm9kZSxmb2N1c09mZnNldDpjLmZvY3VzT2Zmc2V0fSk6Yz12b2lkIDA7cmV0dXJuIEtkJiZlYShLZCxjKT9udWxsOihLZD1jLGE9Uy5nZXRQb29sZWQoSGQuc2VsZWN0LEpkLGEsYiksYS50eXBlPVwic2VsZWN0XCIsYS50YXJnZXQ9SWQsemIoYSksYSl9XG52YXIgTmQ9e2V2ZW50VHlwZXM6SGQsZXh0cmFjdEV2ZW50czpmdW5jdGlvbihhLGIsYyxkKXt2YXIgZT1kLndpbmRvdz09PWQ/ZC5kb2N1bWVudDo5PT09ZC5ub2RlVHlwZT9kOmQub3duZXJEb2N1bWVudCxmO2lmKCEoZj0hZSkpe2E6e2U9Q2QoZSk7Zj1RYS5vblNlbGVjdDtmb3IodmFyIGc9MDtnPGYubGVuZ3RoO2crKyl7dmFyIGs9ZltnXTtpZighZS5oYXNPd25Qcm9wZXJ0eShrKXx8IWVba10pe2U9ITE7YnJlYWsgYX19ZT0hMH1mPSFlfWlmKGYpcmV0dXJuIG51bGw7ZT1iP3FiKGIpOndpbmRvdztzd2l0Y2goYSl7Y2FzZSBcInRvcEZvY3VzXCI6aWYodWMoZSl8fFwidHJ1ZVwiPT09ZS5jb250ZW50RWRpdGFibGUpSWQ9ZSxKZD1iLEtkPW51bGw7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpLZD1KZD1JZD1udWxsO2JyZWFrO2Nhc2UgXCJ0b3BNb3VzZURvd25cIjpMZD0hMDticmVhaztjYXNlIFwidG9wQ29udGV4dE1lbnVcIjpjYXNlIFwidG9wTW91c2VVcFwiOnJldHVybiBMZD0hMSxNZChjLGQpO2Nhc2UgXCJ0b3BTZWxlY3Rpb25DaGFuZ2VcIjppZihHZClicmVhaztcbmNhc2UgXCJ0b3BLZXlEb3duXCI6Y2FzZSBcInRvcEtleVVwXCI6cmV0dXJuIE1kKGMsZCl9cmV0dXJuIG51bGx9fTtmdW5jdGlvbiBPZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9Uy5hdWdtZW50Q2xhc3MoT2Qse2FuaW1hdGlvbk5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO2Z1bmN0aW9uIFBkKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1TLmF1Z21lbnRDbGFzcyhQZCx7Y2xpcGJvYXJkRGF0YTpmdW5jdGlvbihhKXtyZXR1cm5cImNsaXBib2FyZERhdGFcImluIGE/YS5jbGlwYm9hcmREYXRhOndpbmRvdy5jbGlwYm9hcmREYXRhfX0pO2Z1bmN0aW9uIFFkKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1YYy5hdWdtZW50Q2xhc3MoUWQse3JlbGF0ZWRUYXJnZXQ6bnVsbH0pO1xuZnVuY3Rpb24gUmQoYSl7dmFyIGI9YS5rZXlDb2RlO1wiY2hhckNvZGVcImluIGE/KGE9YS5jaGFyQ29kZSwwPT09YSYmMTM9PT1iJiYoYT0xMykpOmE9YjtyZXR1cm4gMzI8PWF8fDEzPT09YT9hOjB9XG52YXIgU2Q9e0VzYzpcIkVzY2FwZVwiLFNwYWNlYmFyOlwiIFwiLExlZnQ6XCJBcnJvd0xlZnRcIixVcDpcIkFycm93VXBcIixSaWdodDpcIkFycm93UmlnaHRcIixEb3duOlwiQXJyb3dEb3duXCIsRGVsOlwiRGVsZXRlXCIsV2luOlwiT1NcIixNZW51OlwiQ29udGV4dE1lbnVcIixBcHBzOlwiQ29udGV4dE1lbnVcIixTY3JvbGw6XCJTY3JvbGxMb2NrXCIsTW96UHJpbnRhYmxlS2V5OlwiVW5pZGVudGlmaWVkXCJ9LFRkPXs4OlwiQmFja3NwYWNlXCIsOTpcIlRhYlwiLDEyOlwiQ2xlYXJcIiwxMzpcIkVudGVyXCIsMTY6XCJTaGlmdFwiLDE3OlwiQ29udHJvbFwiLDE4OlwiQWx0XCIsMTk6XCJQYXVzZVwiLDIwOlwiQ2Fwc0xvY2tcIiwyNzpcIkVzY2FwZVwiLDMyOlwiIFwiLDMzOlwiUGFnZVVwXCIsMzQ6XCJQYWdlRG93blwiLDM1OlwiRW5kXCIsMzY6XCJIb21lXCIsMzc6XCJBcnJvd0xlZnRcIiwzODpcIkFycm93VXBcIiwzOTpcIkFycm93UmlnaHRcIiw0MDpcIkFycm93RG93blwiLDQ1OlwiSW5zZXJ0XCIsNDY6XCJEZWxldGVcIiwxMTI6XCJGMVwiLDExMzpcIkYyXCIsMTE0OlwiRjNcIiwxMTU6XCJGNFwiLFxuMTE2OlwiRjVcIiwxMTc6XCJGNlwiLDExODpcIkY3XCIsMTE5OlwiRjhcIiwxMjA6XCJGOVwiLDEyMTpcIkYxMFwiLDEyMjpcIkYxMVwiLDEyMzpcIkYxMlwiLDE0NDpcIk51bUxvY2tcIiwxNDU6XCJTY3JvbGxMb2NrXCIsMjI0OlwiTWV0YVwifTtmdW5jdGlvbiBVZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9XG5YYy5hdWdtZW50Q2xhc3MoVWQse2tleTpmdW5jdGlvbihhKXtpZihhLmtleSl7dmFyIGI9U2RbYS5rZXldfHxhLmtleTtpZihcIlVuaWRlbnRpZmllZFwiIT09YilyZXR1cm4gYn1yZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/KGE9UmQoYSksMTM9PT1hP1wiRW50ZXJcIjpTdHJpbmcuZnJvbUNoYXJDb2RlKGEpKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP1RkW2Eua2V5Q29kZV18fFwiVW5pZGVudGlmaWVkXCI6XCJcIn0sbG9jYXRpb246bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwscmVwZWF0Om51bGwsbG9jYWxlOm51bGwsZ2V0TW9kaWZpZXJTdGF0ZTokYyxjaGFyQ29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1hLnR5cGU/UmQoYSk6MH0sa2V5Q29kZTpmdW5jdGlvbihhKXtyZXR1cm5cImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfSx3aGljaDpmdW5jdGlvbihhKXtyZXR1cm5cImtleXByZXNzXCI9PT1cbmEudHlwZT9SZChhKTpcImtleWRvd25cIj09PWEudHlwZXx8XCJrZXl1cFwiPT09YS50eXBlP2Eua2V5Q29kZTowfX0pO2Z1bmN0aW9uIFZkKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1hZC5hdWdtZW50Q2xhc3MoVmQse2RhdGFUcmFuc2ZlcjpudWxsfSk7ZnVuY3Rpb24gV2QoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVhjLmF1Z21lbnRDbGFzcyhXZCx7dG91Y2hlczpudWxsLHRhcmdldFRvdWNoZXM6bnVsbCxjaGFuZ2VkVG91Y2hlczpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxnZXRNb2RpZmllclN0YXRlOiRjfSk7ZnVuY3Rpb24gWGQoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVMuYXVnbWVudENsYXNzKFhkLHtwcm9wZXJ0eU5hbWU6bnVsbCxlbGFwc2VkVGltZTpudWxsLHBzZXVkb0VsZW1lbnQ6bnVsbH0pO1xuZnVuY3Rpb24gWWQoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfWFkLmF1Z21lbnRDbGFzcyhZZCx7ZGVsdGFYOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFYXCJpbiBhP2EuZGVsdGFYOlwid2hlZWxEZWx0YVhcImluIGE/LWEud2hlZWxEZWx0YVg6MH0sZGVsdGFZOmZ1bmN0aW9uKGEpe3JldHVyblwiZGVsdGFZXCJpbiBhP2EuZGVsdGFZOlwid2hlZWxEZWx0YVlcImluIGE/LWEud2hlZWxEZWx0YVk6XCJ3aGVlbERlbHRhXCJpbiBhPy1hLndoZWVsRGVsdGE6MH0sZGVsdGFaOm51bGwsZGVsdGFNb2RlOm51bGx9KTt2YXIgWmQ9e30sJGQ9e307XG5cImFib3J0IGFuaW1hdGlvbkVuZCBhbmltYXRpb25JdGVyYXRpb24gYW5pbWF0aW9uU3RhcnQgYmx1ciBjYW5jZWwgY2FuUGxheSBjYW5QbGF5VGhyb3VnaCBjbGljayBjbG9zZSBjb250ZXh0TWVudSBjb3B5IGN1dCBkb3VibGVDbGljayBkcmFnIGRyYWdFbmQgZHJhZ0VudGVyIGRyYWdFeGl0IGRyYWdMZWF2ZSBkcmFnT3ZlciBkcmFnU3RhcnQgZHJvcCBkdXJhdGlvbkNoYW5nZSBlbXB0aWVkIGVuY3J5cHRlZCBlbmRlZCBlcnJvciBmb2N1cyBpbnB1dCBpbnZhbGlkIGtleURvd24ga2V5UHJlc3Mga2V5VXAgbG9hZCBsb2FkZWREYXRhIGxvYWRlZE1ldGFkYXRhIGxvYWRTdGFydCBtb3VzZURvd24gbW91c2VNb3ZlIG1vdXNlT3V0IG1vdXNlT3ZlciBtb3VzZVVwIHBhc3RlIHBhdXNlIHBsYXkgcGxheWluZyBwcm9ncmVzcyByYXRlQ2hhbmdlIHJlc2V0IHNjcm9sbCBzZWVrZWQgc2Vla2luZyBzdGFsbGVkIHN1Ym1pdCBzdXNwZW5kIHRpbWVVcGRhdGUgdG9nZ2xlIHRvdWNoQ2FuY2VsIHRvdWNoRW5kIHRvdWNoTW92ZSB0b3VjaFN0YXJ0IHRyYW5zaXRpb25FbmQgdm9sdW1lQ2hhbmdlIHdhaXRpbmcgd2hlZWxcIi5zcGxpdChcIiBcIikuZm9yRWFjaChmdW5jdGlvbihhKXt2YXIgYj1hWzBdLnRvVXBwZXJDYXNlKCkrXG5hLnNsaWNlKDEpLGM9XCJvblwiK2I7Yj1cInRvcFwiK2I7Yz17cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6YyxjYXB0dXJlZDpjK1wiQ2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6W2JdfTtaZFthXT1jOyRkW2JdPWN9KTtcbnZhciBhZT17ZXZlbnRUeXBlczpaZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPSRkW2FdO2lmKCFlKXJldHVybiBudWxsO3N3aXRjaChhKXtjYXNlIFwidG9wS2V5UHJlc3NcIjppZigwPT09UmQoYykpcmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjphPVVkO2JyZWFrO2Nhc2UgXCJ0b3BCbHVyXCI6Y2FzZSBcInRvcEZvY3VzXCI6YT1RZDticmVhaztjYXNlIFwidG9wQ2xpY2tcIjppZigyPT09Yy5idXR0b24pcmV0dXJuIG51bGw7Y2FzZSBcInRvcERvdWJsZUNsaWNrXCI6Y2FzZSBcInRvcE1vdXNlRG93blwiOmNhc2UgXCJ0b3BNb3VzZU1vdmVcIjpjYXNlIFwidG9wTW91c2VVcFwiOmNhc2UgXCJ0b3BNb3VzZU91dFwiOmNhc2UgXCJ0b3BNb3VzZU92ZXJcIjpjYXNlIFwidG9wQ29udGV4dE1lbnVcIjphPWFkO2JyZWFrO2Nhc2UgXCJ0b3BEcmFnXCI6Y2FzZSBcInRvcERyYWdFbmRcIjpjYXNlIFwidG9wRHJhZ0VudGVyXCI6Y2FzZSBcInRvcERyYWdFeGl0XCI6Y2FzZSBcInRvcERyYWdMZWF2ZVwiOmNhc2UgXCJ0b3BEcmFnT3ZlclwiOmNhc2UgXCJ0b3BEcmFnU3RhcnRcIjpjYXNlIFwidG9wRHJvcFwiOmE9XG5WZDticmVhaztjYXNlIFwidG9wVG91Y2hDYW5jZWxcIjpjYXNlIFwidG9wVG91Y2hFbmRcIjpjYXNlIFwidG9wVG91Y2hNb3ZlXCI6Y2FzZSBcInRvcFRvdWNoU3RhcnRcIjphPVdkO2JyZWFrO2Nhc2UgXCJ0b3BBbmltYXRpb25FbmRcIjpjYXNlIFwidG9wQW5pbWF0aW9uSXRlcmF0aW9uXCI6Y2FzZSBcInRvcEFuaW1hdGlvblN0YXJ0XCI6YT1PZDticmVhaztjYXNlIFwidG9wVHJhbnNpdGlvbkVuZFwiOmE9WGQ7YnJlYWs7Y2FzZSBcInRvcFNjcm9sbFwiOmE9WGM7YnJlYWs7Y2FzZSBcInRvcFdoZWVsXCI6YT1ZZDticmVhaztjYXNlIFwidG9wQ29weVwiOmNhc2UgXCJ0b3BDdXRcIjpjYXNlIFwidG9wUGFzdGVcIjphPVBkO2JyZWFrO2RlZmF1bHQ6YT1TfWI9YS5nZXRQb29sZWQoZSxiLGMsZCk7emIoYik7cmV0dXJuIGJ9fTtuZD1mdW5jdGlvbihhLGIsYyxkKXthPWpiKGEsYixjLGQpO2tiKGEpO2xiKCExKX07ZGIuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihcIlJlc3BvbmRlckV2ZW50UGx1Z2luIFNpbXBsZUV2ZW50UGx1Z2luIFRhcEV2ZW50UGx1Z2luIEVudGVyTGVhdmVFdmVudFBsdWdpbiBDaGFuZ2VFdmVudFBsdWdpbiBTZWxlY3RFdmVudFBsdWdpbiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXCIuc3BsaXQoXCIgXCIpKTtcblVhPXNiLmdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU7VmE9c2IuZ2V0SW5zdGFuY2VGcm9tTm9kZTtXYT1zYi5nZXROb2RlRnJvbUluc3RhbmNlO2RiLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7U2ltcGxlRXZlbnRQbHVnaW46YWUsRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOmNkLENoYW5nZUV2ZW50UGx1Z2luOldjLFNlbGVjdEV2ZW50UGx1Z2luOk5kLEJlZm9yZUlucHV0RXZlbnRQbHVnaW46aGN9KTt2YXIgYmU9W10sY2U9LTE7ZnVuY3Rpb24gVihhKXswPmNlfHwoYS5jdXJyZW50PWJlW2NlXSxiZVtjZV09bnVsbCxjZS0tKX1mdW5jdGlvbiBXKGEsYil7Y2UrKztiZVtjZV09YS5jdXJyZW50O2EuY3VycmVudD1ifW5ldyBTZXQ7dmFyIGRlPXtjdXJyZW50OkN9LFg9e2N1cnJlbnQ6ITF9LGVlPUM7ZnVuY3Rpb24gZmUoYSl7cmV0dXJuIGdlKGEpP2VlOmRlLmN1cnJlbnR9XG5mdW5jdGlvbiBoZShhLGIpe3ZhciBjPWEudHlwZS5jb250ZXh0VHlwZXM7aWYoIWMpcmV0dXJuIEM7dmFyIGQ9YS5zdGF0ZU5vZGU7aWYoZCYmZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PT09YilyZXR1cm4gZC5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dDt2YXIgZT17fSxmO2ZvcihmIGluIGMpZVtmXT1iW2ZdO2QmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1iLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9ZSk7cmV0dXJuIGV9ZnVuY3Rpb24gZ2UoYSl7cmV0dXJuIDI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzfWZ1bmN0aW9uIGllKGEpe2dlKGEpJiYoVihYLGEpLFYoZGUsYSkpfVxuZnVuY3Rpb24gamUoYSxiLGMpe251bGwhPWRlLmN1cnNvcj9EKFwiMTY4XCIpOnZvaWQgMDtXKGRlLGIsYSk7VyhYLGMsYSl9ZnVuY3Rpb24ga2UoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZSxkPWEudHlwZS5jaGlsZENvbnRleHRUeXBlcztpZihcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5nZXRDaGlsZENvbnRleHQpcmV0dXJuIGI7Yz1jLmdldENoaWxkQ29udGV4dCgpO2Zvcih2YXIgZSBpbiBjKWUgaW4gZD92b2lkIDA6RChcIjEwOFwiLGVkKGEpfHxcIlVua25vd25cIixlKTtyZXR1cm4gQSh7fSxiLGMpfWZ1bmN0aW9uIGxlKGEpe2lmKCFnZShhKSlyZXR1cm4hMTt2YXIgYj1hLnN0YXRlTm9kZTtiPWImJmIuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHR8fEM7ZWU9ZGUuY3VycmVudDtXKGRlLGIsYSk7VyhYLFguY3VycmVudCxhKTtyZXR1cm4hMH1cbmZ1bmN0aW9uIG1lKGEsYil7dmFyIGM9YS5zdGF0ZU5vZGU7Yz92b2lkIDA6RChcIjE2OVwiKTtpZihiKXt2YXIgZD1rZShhLGVlKTtjLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0PWQ7VihYLGEpO1YoZGUsYSk7VyhkZSxkLGEpfWVsc2UgVihYLGEpO1coWCxiLGEpfVxuZnVuY3Rpb24gWShhLGIsYyl7dGhpcy50YWc9YTt0aGlzLmtleT1iO3RoaXMuc3RhdGVOb2RlPXRoaXMudHlwZT1udWxsO3RoaXMuc2libGluZz10aGlzLmNoaWxkPXRoaXNbXCJyZXR1cm5cIl09bnVsbDt0aGlzLmluZGV4PTA7dGhpcy5tZW1vaXplZFN0YXRlPXRoaXMudXBkYXRlUXVldWU9dGhpcy5tZW1vaXplZFByb3BzPXRoaXMucGVuZGluZ1Byb3BzPXRoaXMucmVmPW51bGw7dGhpcy5pbnRlcm5hbENvbnRleHRUYWc9Yzt0aGlzLmVmZmVjdFRhZz0wO3RoaXMubGFzdEVmZmVjdD10aGlzLmZpcnN0RWZmZWN0PXRoaXMubmV4dEVmZmVjdD1udWxsO3RoaXMuZXhwaXJhdGlvblRpbWU9MDt0aGlzLmFsdGVybmF0ZT1udWxsfVxuZnVuY3Rpb24gbmUoYSxiLGMpe3ZhciBkPWEuYWx0ZXJuYXRlO251bGw9PT1kPyhkPW5ldyBZKGEudGFnLGEua2V5LGEuaW50ZXJuYWxDb250ZXh0VGFnKSxkLnR5cGU9YS50eXBlLGQuc3RhdGVOb2RlPWEuc3RhdGVOb2RlLGQuYWx0ZXJuYXRlPWEsYS5hbHRlcm5hdGU9ZCk6KGQuZWZmZWN0VGFnPTAsZC5uZXh0RWZmZWN0PW51bGwsZC5maXJzdEVmZmVjdD1udWxsLGQubGFzdEVmZmVjdD1udWxsKTtkLmV4cGlyYXRpb25UaW1lPWM7ZC5wZW5kaW5nUHJvcHM9YjtkLmNoaWxkPWEuY2hpbGQ7ZC5tZW1vaXplZFByb3BzPWEubWVtb2l6ZWRQcm9wcztkLm1lbW9pemVkU3RhdGU9YS5tZW1vaXplZFN0YXRlO2QudXBkYXRlUXVldWU9YS51cGRhdGVRdWV1ZTtkLnNpYmxpbmc9YS5zaWJsaW5nO2QuaW5kZXg9YS5pbmRleDtkLnJlZj1hLnJlZjtyZXR1cm4gZH1cbmZ1bmN0aW9uIG9lKGEsYixjKXt2YXIgZD12b2lkIDAsZT1hLnR5cGUsZj1hLmtleTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZT8oZD1lLnByb3RvdHlwZSYmZS5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudD9uZXcgWSgyLGYsYik6bmV3IFkoMCxmLGIpLGQudHlwZT1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOlwic3RyaW5nXCI9PT10eXBlb2YgZT8oZD1uZXcgWSg1LGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZSYmXCJudW1iZXJcIj09PXR5cGVvZiBlLnRhZz8oZD1lLGQucGVuZGluZ1Byb3BzPWEucHJvcHMpOkQoXCIxMzBcIixudWxsPT1lP2U6dHlwZW9mIGUsXCJcIik7ZC5leHBpcmF0aW9uVGltZT1jO3JldHVybiBkfWZ1bmN0aW9uIHBlKGEsYixjLGQpe2I9bmV3IFkoMTAsZCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1cbmZ1bmN0aW9uIHFlKGEsYixjKXtiPW5ldyBZKDYsbnVsbCxiKTtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiByZShhLGIsYyl7Yj1uZXcgWSg3LGEua2V5LGIpO2IudHlwZT1hLmhhbmRsZXI7Yi5wZW5kaW5nUHJvcHM9YTtiLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGJ9ZnVuY3Rpb24gc2UoYSxiLGMpe2E9bmV3IFkoOSxudWxsLGIpO2EuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYX1mdW5jdGlvbiB0ZShhLGIsYyl7Yj1uZXcgWSg0LGEua2V5LGIpO2IucGVuZGluZ1Byb3BzPWEuY2hpbGRyZW58fFtdO2IuZXhwaXJhdGlvblRpbWU9YztiLnN0YXRlTm9kZT17Y29udGFpbmVySW5mbzphLmNvbnRhaW5lckluZm8scGVuZGluZ0NoaWxkcmVuOm51bGwsaW1wbGVtZW50YXRpb246YS5pbXBsZW1lbnRhdGlvbn07cmV0dXJuIGJ9dmFyIHVlPW51bGwsdmU9bnVsbDtcbmZ1bmN0aW9uIHdlKGEpe3JldHVybiBmdW5jdGlvbihiKXt0cnl7cmV0dXJuIGEoYil9Y2F0Y2goYyl7fX19ZnVuY3Rpb24geGUoYSl7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18pcmV0dXJuITE7dmFyIGI9X19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO2lmKGIuaXNEaXNhYmxlZHx8IWIuc3VwcG9ydHNGaWJlcilyZXR1cm4hMDt0cnl7dmFyIGM9Yi5pbmplY3QoYSk7dWU9d2UoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclJvb3QoYyxhKX0pO3ZlPXdlKGZ1bmN0aW9uKGEpe3JldHVybiBiLm9uQ29tbWl0RmliZXJVbm1vdW50KGMsYSl9KX1jYXRjaChkKXt9cmV0dXJuITB9ZnVuY3Rpb24geWUoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIHVlJiZ1ZShhKX1mdW5jdGlvbiB6ZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdmUmJnZlKGEpfVxuZnVuY3Rpb24gQWUoYSl7cmV0dXJue2Jhc2VTdGF0ZTphLGV4cGlyYXRpb25UaW1lOjAsZmlyc3Q6bnVsbCxsYXN0Om51bGwsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITEsaXNJbml0aWFsaXplZDohMX19ZnVuY3Rpb24gQmUoYSxiKXtudWxsPT09YS5sYXN0P2EuZmlyc3Q9YS5sYXN0PWI6KGEubGFzdC5uZXh0PWIsYS5sYXN0PWIpO2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIuZXhwaXJhdGlvblRpbWUpYS5leHBpcmF0aW9uVGltZT1iLmV4cGlyYXRpb25UaW1lfVxuZnVuY3Rpb24gQ2UoYSxiKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEudXBkYXRlUXVldWU7bnVsbD09PWQmJihkPWEudXBkYXRlUXVldWU9QWUobnVsbCkpO251bGwhPT1jPyhhPWMudXBkYXRlUXVldWUsbnVsbD09PWEmJihhPWMudXBkYXRlUXVldWU9QWUobnVsbCkpKTphPW51bGw7YT1hIT09ZD9hOm51bGw7bnVsbD09PWE/QmUoZCxiKTpudWxsPT09ZC5sYXN0fHxudWxsPT09YS5sYXN0PyhCZShkLGIpLEJlKGEsYikpOihCZShkLGIpLGEubGFzdD1iKX1mdW5jdGlvbiBEZShhLGIsYyxkKXthPWEucGFydGlhbFN0YXRlO3JldHVyblwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuY2FsbChiLGMsZCk6YX1cbmZ1bmN0aW9uIEtlKGEsYixjLGQsZSxmKXtudWxsIT09YSYmYS51cGRhdGVRdWV1ZT09PWMmJihjPWIudXBkYXRlUXVldWU9e2Jhc2VTdGF0ZTpjLmJhc2VTdGF0ZSxleHBpcmF0aW9uVGltZTpjLmV4cGlyYXRpb25UaW1lLGZpcnN0OmMuZmlyc3QsbGFzdDpjLmxhc3QsaXNJbml0aWFsaXplZDpjLmlzSW5pdGlhbGl6ZWQsY2FsbGJhY2tMaXN0Om51bGwsaGFzRm9yY2VVcGRhdGU6ITF9KTtjLmV4cGlyYXRpb25UaW1lPTA7Yy5pc0luaXRpYWxpemVkP2E9Yy5iYXNlU3RhdGU6KGE9Yy5iYXNlU3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuaXNJbml0aWFsaXplZD0hMCk7Zm9yKHZhciBnPSEwLGs9Yy5maXJzdCxoPSExO251bGwhPT1rOyl7dmFyIHI9ay5leHBpcmF0aW9uVGltZTtpZihyPmYpe3ZhciBuPWMuZXhwaXJhdGlvblRpbWU7aWYoMD09PW58fG4+ciljLmV4cGlyYXRpb25UaW1lPXI7aHx8KGg9ITAsYy5iYXNlU3RhdGU9YSl9ZWxzZXtofHwoYy5maXJzdD1rLm5leHQsbnVsbD09PVxuYy5maXJzdCYmKGMubGFzdD1udWxsKSk7aWYoay5pc1JlcGxhY2UpYT1EZShrLGQsYSxlKSxnPSEwO2Vsc2UgaWYocj1EZShrLGQsYSxlKSlhPWc/QSh7fSxhLHIpOkEoYSxyKSxnPSExO2suaXNGb3JjZWQmJihjLmhhc0ZvcmNlVXBkYXRlPSEwKTtudWxsIT09ay5jYWxsYmFjayYmKHI9Yy5jYWxsYmFja0xpc3QsbnVsbD09PXImJihyPWMuY2FsbGJhY2tMaXN0PVtdKSxyLnB1c2goaykpfWs9ay5uZXh0fW51bGwhPT1jLmNhbGxiYWNrTGlzdD9iLmVmZmVjdFRhZ3w9MzI6bnVsbCE9PWMuZmlyc3R8fGMuaGFzRm9yY2VVcGRhdGV8fChiLnVwZGF0ZVF1ZXVlPW51bGwpO2h8fChjLmJhc2VTdGF0ZT1hKTtyZXR1cm4gYX1cbmZ1bmN0aW9uIExlKGEsYil7dmFyIGM9YS5jYWxsYmFja0xpc3Q7aWYobnVsbCE9PWMpZm9yKGEuY2FsbGJhY2tMaXN0PW51bGwsYT0wO2E8Yy5sZW5ndGg7YSsrKXt2YXIgZD1jW2FdLGU9ZC5jYWxsYmFjaztkLmNhbGxiYWNrPW51bGw7XCJmdW5jdGlvblwiIT09dHlwZW9mIGU/RChcIjE5MVwiLGUpOnZvaWQgMDtlLmNhbGwoYil9fVxuZnVuY3Rpb24gTWUoYSxiLGMsZCl7ZnVuY3Rpb24gZShhLGIpe2IudXBkYXRlcj1mO2Euc3RhdGVOb2RlPWI7Yi5fcmVhY3RJbnRlcm5hbEZpYmVyPWF9dmFyIGY9e2lzTW91bnRlZDpnZCxlbnF1ZXVlU2V0U3RhdGU6ZnVuY3Rpb24oYyxkLGUpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2U9dm9pZCAwPT09ZT9udWxsOmU7dmFyIGc9YihjKTtDZShjLHtleHBpcmF0aW9uVGltZTpnLHBhcnRpYWxTdGF0ZTpkLGNhbGxiYWNrOmUsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiExLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxnKX0sZW5xdWV1ZVJlcGxhY2VTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZj1iKGMpO0NlKGMse2V4cGlyYXRpb25UaW1lOmYscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITAsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7XG5hKGMsZil9LGVucXVldWVGb3JjZVVwZGF0ZTpmdW5jdGlvbihjLGQpe2M9Yy5fcmVhY3RJbnRlcm5hbEZpYmVyO2Q9dm9pZCAwPT09ZD9udWxsOmQ7dmFyIGU9YihjKTtDZShjLHtleHBpcmF0aW9uVGltZTplLHBhcnRpYWxTdGF0ZTpudWxsLGNhbGxiYWNrOmQsaXNSZXBsYWNlOiExLGlzRm9yY2VkOiEwLG5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2EoYyxlKX19O3JldHVybnthZG9wdENsYXNzSW5zdGFuY2U6ZSxjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsYil7dmFyIGM9YS50eXBlLGQ9ZmUoYSksZj0yPT09YS50YWcmJm51bGwhPWEudHlwZS5jb250ZXh0VHlwZXMsZz1mP2hlKGEsZCk6QztiPW5ldyBjKGIsZyk7ZShhLGIpO2YmJihhPWEuc3RhdGVOb2RlLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dD1kLGEuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ9Zyk7cmV0dXJuIGJ9LG1vdW50Q2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLFxuYil7dmFyIGM9YS5hbHRlcm5hdGUsZD1hLnN0YXRlTm9kZSxlPWQuc3RhdGV8fG51bGwsZz1hLnBlbmRpbmdQcm9wcztnP3ZvaWQgMDpEKFwiMTU4XCIpO3ZhciBrPWZlKGEpO2QucHJvcHM9ZztkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZT1lO2QucmVmcz1DO2QuY29udGV4dD1oZShhLGspO251bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCYmKGEuaW50ZXJuYWxDb250ZXh0VGFnfD0xKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsTW91bnQmJihlPWQuc3RhdGUsZC5jb21wb25lbnRXaWxsTW91bnQoKSxlIT09ZC5zdGF0ZSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGQsZC5zdGF0ZSxudWxsKSxlPWEudXBkYXRlUXVldWUsbnVsbCE9PWUmJihkLnN0YXRlPUtlKGMsYSxlLGQsZyxiKSkpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudERpZE1vdW50JiYoYS5lZmZlY3RUYWd8PVxuNCl9LHVwZGF0ZUNsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGUpe3ZhciBnPWIuc3RhdGVOb2RlO2cucHJvcHM9Yi5tZW1vaXplZFByb3BzO2cuc3RhdGU9Yi5tZW1vaXplZFN0YXRlO3ZhciBrPWIubWVtb2l6ZWRQcm9wcyxoPWIucGVuZGluZ1Byb3BzO2h8fChoPWssbnVsbD09aD9EKFwiMTU5XCIpOnZvaWQgMCk7dmFyIHU9Zy5jb250ZXh0LHg9ZmUoYik7eD1oZShiLHgpO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHN8fGs9PT1oJiZ1PT09eHx8KHU9Zy5zdGF0ZSxnLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoaCx4KSxnLnN0YXRlIT09dSYmZi5lbnF1ZXVlUmVwbGFjZVN0YXRlKGcsZy5zdGF0ZSxudWxsKSk7dT1iLm1lbW9pemVkU3RhdGU7ZT1udWxsIT09Yi51cGRhdGVRdWV1ZT9LZShhLGIsYi51cGRhdGVRdWV1ZSxnLGgsZSk6dTtpZighKGshPT1ofHx1IT09ZXx8WC5jdXJyZW50fHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkpcmV0dXJuXCJmdW5jdGlvblwiIT09XG50eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fGs9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksITE7dmFyIEY9aDtpZihudWxsPT09a3x8bnVsbCE9PWIudXBkYXRlUXVldWUmJmIudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpRj0hMDtlbHNle3ZhciBMPWIuc3RhdGVOb2RlLEc9Yi50eXBlO0Y9XCJmdW5jdGlvblwiPT09dHlwZW9mIEwuc2hvdWxkQ29tcG9uZW50VXBkYXRlP0wuc2hvdWxkQ29tcG9uZW50VXBkYXRlKEYsZSx4KTpHLnByb3RvdHlwZSYmRy5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQ/IWVhKGssRil8fCFlYSh1LGUpOiEwfUY/KFwiZnVuY3Rpb25cIj09PXR5cGVvZiBnLmNvbXBvbmVudFdpbGxVcGRhdGUmJmcuY29tcG9uZW50V2lsbFVwZGF0ZShoLGUseCksXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlJiYoYi5lZmZlY3RUYWd8PTQpKTooXCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50RGlkVXBkYXRlfHxcbms9PT1hLm1lbW9pemVkUHJvcHMmJnU9PT1hLm1lbW9pemVkU3RhdGV8fChiLmVmZmVjdFRhZ3w9NCksYyhiLGgpLGQoYixlKSk7Zy5wcm9wcz1oO2cuc3RhdGU9ZTtnLmNvbnRleHQ9eDtyZXR1cm4gRn19fXZhciBOZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0mJlN5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKXx8NjAxMDY7ZnVuY3Rpb24gT2UoYSxiLGMpe3ZhciBkPTM8YXJndW1lbnRzLmxlbmd0aCYmdm9pZCAwIT09YXJndW1lbnRzWzNdP2FyZ3VtZW50c1szXTpudWxsO3JldHVybnskJHR5cGVvZjpOZSxrZXk6bnVsbD09ZD9udWxsOlwiXCIrZCxjaGlsZHJlbjphLGNvbnRhaW5lckluZm86YixpbXBsZW1lbnRhdGlvbjpjfX12YXIgUGU9QXJyYXkuaXNBcnJheSxRZT1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2wuaXRlcmF0b3IsUmUsU2UsVGUsVWU7XG5cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0/KFJlPVN5bWJvbFtcImZvclwiXShcInJlYWN0LmVsZW1lbnRcIiksU2U9U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuY2FsbFwiKSxUZT1TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5yZXR1cm5cIiksVWU9U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIikpOihSZT02MDEwMyxTZT02MDEwNCxUZT02MDEwNSxVZT02MDEwNyk7ZnVuY3Rpb24gVmUoYSl7aWYobnVsbD09PWF8fFwidW5kZWZpbmVkXCI9PT10eXBlb2YgYSlyZXR1cm4gbnVsbDthPVFlJiZhW1FlXXx8YVtcIkBAaXRlcmF0b3JcIl07cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YTpudWxsfVxuZnVuY3Rpb24gV2UoYSxiKXt2YXIgYz1iLnJlZjtpZihudWxsIT09YyYmXCJmdW5jdGlvblwiIT09dHlwZW9mIGMpe2lmKGIuX293bmVyKXtiPWIuX293bmVyO3ZhciBkPXZvaWQgMDtiJiYoMiE9PWIudGFnP0QoXCIxMTBcIik6dm9pZCAwLGQ9Yi5zdGF0ZU5vZGUpO2Q/dm9pZCAwOkQoXCIxNDdcIixjKTt2YXIgZT1cIlwiK2M7aWYobnVsbCE9PWEmJm51bGwhPT1hLnJlZiYmYS5yZWYuX3N0cmluZ1JlZj09PWUpcmV0dXJuIGEucmVmO2E9ZnVuY3Rpb24oYSl7dmFyIGI9ZC5yZWZzPT09Qz9kLnJlZnM9e306ZC5yZWZzO251bGw9PT1hP2RlbGV0ZSBiW2VdOmJbZV09YX07YS5fc3RyaW5nUmVmPWU7cmV0dXJuIGF9XCJzdHJpbmdcIiE9PXR5cGVvZiBjP0QoXCIxNDhcIik6dm9pZCAwO2IuX293bmVyP3ZvaWQgMDpEKFwiMTQ5XCIsYyl9cmV0dXJuIGN9XG5mdW5jdGlvbiBYZShhLGIpe1widGV4dGFyZWFcIiE9PWEudHlwZSYmRChcIjMxXCIsXCJbb2JqZWN0IE9iamVjdF1cIj09PU9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChiKT9cIm9iamVjdCB3aXRoIGtleXMge1wiK09iamVjdC5rZXlzKGIpLmpvaW4oXCIsIFwiKStcIn1cIjpiLFwiXCIpfVxuZnVuY3Rpb24gWWUoYSxiKXtmdW5jdGlvbiBjKGMsZCl7aWYoYil7aWYoIWEpe2lmKG51bGw9PT1kLmFsdGVybmF0ZSlyZXR1cm47ZD1kLmFsdGVybmF0ZX12YXIgcD1jLmxhc3RFZmZlY3Q7bnVsbCE9PXA/KHAubmV4dEVmZmVjdD1kLGMubGFzdEVmZmVjdD1kKTpjLmZpcnN0RWZmZWN0PWMubGFzdEVmZmVjdD1kO2QubmV4dEVmZmVjdD1udWxsO2QuZWZmZWN0VGFnPTh9fWZ1bmN0aW9uIGQoYSxkKXtpZighYilyZXR1cm4gbnVsbDtmb3IoO251bGwhPT1kOyljKGEsZCksZD1kLnNpYmxpbmc7cmV0dXJuIG51bGx9ZnVuY3Rpb24gZShhLGIpe2ZvcihhPW5ldyBNYXA7bnVsbCE9PWI7KW51bGwhPT1iLmtleT9hLnNldChiLmtleSxiKTphLnNldChiLmluZGV4LGIpLGI9Yi5zaWJsaW5nO3JldHVybiBhfWZ1bmN0aW9uIGYoYixjLGQpe2lmKGEpcmV0dXJuIGI9bmUoYixjLGQpLGIuaW5kZXg9MCxiLnNpYmxpbmc9bnVsbCxiO2IuZXhwaXJhdGlvblRpbWU9ZDtiLmVmZmVjdFRhZz0wO2IuaW5kZXg9XG4wO2Iuc2libGluZz1udWxsO2IucGVuZGluZ1Byb3BzPWM7cmV0dXJuIGJ9ZnVuY3Rpb24gZyhhLGMsZCl7YS5pbmRleD1kO2lmKCFiKXJldHVybiBjO2Q9YS5hbHRlcm5hdGU7aWYobnVsbCE9PWQpcmV0dXJuIGQ9ZC5pbmRleCxkPGM/KGEuZWZmZWN0VGFnPTIsYyk6ZDthLmVmZmVjdFRhZz0yO3JldHVybiBjfWZ1bmN0aW9uIGsoYSl7YiYmbnVsbD09PWEuYWx0ZXJuYXRlJiYoYS5lZmZlY3RUYWc9Mik7cmV0dXJuIGF9ZnVuY3Rpb24gaChhLGIsYyxkKXtpZihudWxsPT09Ynx8NiE9PWIudGFnKXJldHVybiBiPXFlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1mKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gcihhLGIsYyxkKXtpZihudWxsIT09YiYmYi50eXBlPT09Yy50eXBlKXJldHVybiBkPWYoYixjLnByb3BzLGQpLGQucmVmPVdlKGIsYyksZFtcInJldHVyblwiXT1hLGQ7ZD1vZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQpO1xuZC5yZWY9V2UoYixjKTtkW1wicmV0dXJuXCJdPWE7cmV0dXJuIGR9ZnVuY3Rpb24gbihhLGIsYyxkKXtpZihudWxsPT09Ynx8NyE9PWIudGFnKXJldHVybiBiPXJlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYltcInJldHVyblwiXT1hLGI7Yj1mKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24geShhLGIsYyxkKXtpZihudWxsPT09Ynx8OSE9PWIudGFnKXJldHVybiBiPXNlKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCksYi50eXBlPWMudmFsdWUsYltcInJldHVyblwiXT1hLGI7Yj1mKGIsbnVsbCxkKTtiLnR5cGU9Yy52YWx1ZTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gdShhLGIsYyxkKXtpZihudWxsPT09Ynx8NCE9PWIudGFnfHxiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvIT09Yy5jb250YWluZXJJbmZvfHxiLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiE9PWMuaW1wbGVtZW50YXRpb24pcmV0dXJuIGI9dGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxcbmQpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZihiLGMuY2hpbGRyZW58fFtdLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB4KGEsYixjLGQsZSl7aWYobnVsbD09PWJ8fDEwIT09Yi50YWcpcmV0dXJuIGI9cGUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkLGUpLGJbXCJyZXR1cm5cIl09YSxiO2I9ZihiLGMsZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIEYoYSxiLGMpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKXJldHVybiBiPXFlKFwiXCIrYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtpZihcIm9iamVjdFwiPT09dHlwZW9mIGImJm51bGwhPT1iKXtzd2l0Y2goYi4kJHR5cGVvZil7Y2FzZSBSZTppZihiLnR5cGU9PT1VZSlyZXR1cm4gYj1wZShiLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsYi5rZXkpLGJbXCJyZXR1cm5cIl09YSxiO2M9b2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKTtcbmMucmVmPVdlKG51bGwsYik7Y1tcInJldHVyblwiXT1hO3JldHVybiBjO2Nhc2UgU2U6cmV0dXJuIGI9cmUoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxiW1wicmV0dXJuXCJdPWEsYjtjYXNlIFRlOnJldHVybiBjPXNlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYy50eXBlPWIudmFsdWUsY1tcInJldHVyblwiXT1hLGM7Y2FzZSBOZTpyZXR1cm4gYj10ZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxifWlmKFBlKGIpfHxWZShiKSlyZXR1cm4gYj1wZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMsbnVsbCksYltcInJldHVyblwiXT1hLGI7WGUoYSxiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBMKGEsYixjLGQpe3ZhciBlPW51bGwhPT1iP2Iua2V5Om51bGw7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBjfHxcIm51bWJlclwiPT09dHlwZW9mIGMpcmV0dXJuIG51bGwhPT1lP251bGw6aChhLGIsXCJcIitjLGQpO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYyYmbnVsbCE9PWMpe3N3aXRjaChjLiQkdHlwZW9mKXtjYXNlIFJlOnJldHVybiBjLmtleT09PVxuZT9jLnR5cGU9PT1VZT94KGEsYixjLnByb3BzLmNoaWxkcmVuLGQsZSk6cihhLGIsYyxkKTpudWxsO2Nhc2UgU2U6cmV0dXJuIGMua2V5PT09ZT9uKGEsYixjLGQpOm51bGw7Y2FzZSBUZTpyZXR1cm4gbnVsbD09PWU/eShhLGIsYyxkKTpudWxsO2Nhc2UgTmU6cmV0dXJuIGMua2V5PT09ZT91KGEsYixjLGQpOm51bGx9aWYoUGUoYyl8fFZlKGMpKXJldHVybiBudWxsIT09ZT9udWxsOngoYSxiLGMsZCxudWxsKTtYZShhLGMpfXJldHVybiBudWxsfWZ1bmN0aW9uIEcoYSxiLGMsZCxlKXtpZihcInN0cmluZ1wiPT09dHlwZW9mIGR8fFwibnVtYmVyXCI9PT10eXBlb2YgZClyZXR1cm4gYT1hLmdldChjKXx8bnVsbCxoKGIsYSxcIlwiK2QsZSk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBkJiZudWxsIT09ZCl7c3dpdGNoKGQuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLGQudHlwZT09PVVlP3goYixhLGQucHJvcHMuY2hpbGRyZW4sZSxkLmtleSk6XG5yKGIsYSxkLGUpO2Nhc2UgU2U6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLG4oYixhLGQsZSk7Y2FzZSBUZTpyZXR1cm4gYT1hLmdldChjKXx8bnVsbCx5KGIsYSxkLGUpO2Nhc2UgTmU6cmV0dXJuIGE9YS5nZXQobnVsbD09PWQua2V5P2M6ZC5rZXkpfHxudWxsLHUoYixhLGQsZSl9aWYoUGUoZCl8fFZlKGQpKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHgoYixhLGQsZSxudWxsKTtYZShiLGQpfXJldHVybiBudWxsfWZ1bmN0aW9uIFQoYSxmLHYsayl7Zm9yKHZhciBwPW51bGwsej1udWxsLGw9ZixoPWY9MCx0PW51bGw7bnVsbCE9PWwmJmg8di5sZW5ndGg7aCsrKXtsLmluZGV4Pmg/KHQ9bCxsPW51bGwpOnQ9bC5zaWJsaW5nO3ZhciB3PUwoYSxsLHZbaF0sayk7aWYobnVsbD09PXcpe251bGw9PT1sJiYobD10KTticmVha31iJiZsJiZudWxsPT09dy5hbHRlcm5hdGUmJmMoYSxsKTtmPWcodyxmLGgpO251bGw9PT16P3A9dzp6LnNpYmxpbmc9dzt6PXc7XG5sPXR9aWYoaD09PXYubGVuZ3RoKXJldHVybiBkKGEsbCkscDtpZihudWxsPT09bCl7Zm9yKDtoPHYubGVuZ3RoO2grKylpZihsPUYoYSx2W2hdLGspKWY9ZyhsLGYsaCksbnVsbD09PXo/cD1sOnouc2libGluZz1sLHo9bDtyZXR1cm4gcH1mb3IobD1lKGEsbCk7aDx2Lmxlbmd0aDtoKyspaWYodD1HKGwsYSxoLHZbaF0saykpe2lmKGImJm51bGwhPT10LmFsdGVybmF0ZSlsW1wiZGVsZXRlXCJdKG51bGw9PT10LmtleT9oOnQua2V5KTtmPWcodCxmLGgpO251bGw9PT16P3A9dDp6LnNpYmxpbmc9dDt6PXR9YiYmbC5mb3JFYWNoKGZ1bmN0aW9uKGIpe3JldHVybiBjKGEsYil9KTtyZXR1cm4gcH1mdW5jdGlvbiBJKGEsZix2LGspe3ZhciBwPVZlKHYpO1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBwP0QoXCIxNTBcIik6dm9pZCAwO3Y9cC5jYWxsKHYpO251bGw9PXY/RChcIjE1MVwiKTp2b2lkIDA7Zm9yKHZhciBoPXA9bnVsbCxsPWYsej1mPTAsdD1udWxsLHc9di5uZXh0KCk7bnVsbCE9PWwmJiF3LmRvbmU7eisrLFxudz12Lm5leHQoKSl7bC5pbmRleD56Pyh0PWwsbD1udWxsKTp0PWwuc2libGluZzt2YXIgbj1MKGEsbCx3LnZhbHVlLGspO2lmKG51bGw9PT1uKXtsfHwobD10KTticmVha31iJiZsJiZudWxsPT09bi5hbHRlcm5hdGUmJmMoYSxsKTtmPWcobixmLHopO251bGw9PT1oP3A9bjpoLnNpYmxpbmc9bjtoPW47bD10fWlmKHcuZG9uZSlyZXR1cm4gZChhLGwpLHA7aWYobnVsbD09PWwpe2Zvcig7IXcuZG9uZTt6Kyssdz12Lm5leHQoKSl3PUYoYSx3LnZhbHVlLGspLG51bGwhPT13JiYoZj1nKHcsZix6KSxudWxsPT09aD9wPXc6aC5zaWJsaW5nPXcsaD13KTtyZXR1cm4gcH1mb3IobD1lKGEsbCk7IXcuZG9uZTt6Kyssdz12Lm5leHQoKSlpZih3PUcobCxhLHosdy52YWx1ZSxrKSxudWxsIT09dyl7aWYoYiYmbnVsbCE9PXcuYWx0ZXJuYXRlKWxbXCJkZWxldGVcIl0obnVsbD09PXcua2V5P3o6dy5rZXkpO2Y9Zyh3LGYseik7bnVsbD09PWg/cD13Omguc2libGluZz13O2g9d31iJiZsLmZvckVhY2goZnVuY3Rpb24oYil7cmV0dXJuIGMoYSxcbmIpfSk7cmV0dXJuIHB9cmV0dXJuIGZ1bmN0aW9uKGEsYixlLGcpe3ZhciBoPVwib2JqZWN0XCI9PT10eXBlb2YgZSYmbnVsbCE9PWU7aWYoaClzd2l0Y2goZS4kJHR5cGVvZil7Y2FzZSBSZTphOnt2YXIgdj1lLmtleTtmb3IoaD1iO251bGwhPT1oOyl7aWYoaC5rZXk9PT12KWlmKDEwPT09aC50YWc/ZS50eXBlPT09VWU6aC50eXBlPT09ZS50eXBlKXtkKGEsaC5zaWJsaW5nKTtiPWYoaCxlLnR5cGU9PT1VZT9lLnByb3BzLmNoaWxkcmVuOmUucHJvcHMsZyk7Yi5yZWY9V2UoaCxlKTtiW1wicmV0dXJuXCJdPWE7YT1iO2JyZWFrIGF9ZWxzZXtkKGEsaCk7YnJlYWt9ZWxzZSBjKGEsaCk7aD1oLnNpYmxpbmd9ZS50eXBlPT09VWU/KGU9cGUoZS5wcm9wcy5jaGlsZHJlbixhLmludGVybmFsQ29udGV4dFRhZyxnLGUua2V5KSxlW1wicmV0dXJuXCJdPWEsYT1lKTooZz1vZShlLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcpLGcucmVmPVdlKGIsZSksZ1tcInJldHVyblwiXT1hLGE9Zyl9cmV0dXJuIGsoYSk7XG5jYXNlIFNlOmE6e2ZvcihoPWUua2V5O251bGwhPT1iOyl7aWYoYi5rZXk9PT1oKWlmKDc9PT1iLnRhZyl7ZChhLGIuc2libGluZyk7ZT1mKGIsZSxnKTtlW1wicmV0dXJuXCJdPWE7YT1lO2JyZWFrIGF9ZWxzZXtkKGEsYik7YnJlYWt9ZWxzZSBjKGEsYik7Yj1iLnNpYmxpbmd9ZT1yZShlLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcpO2VbXCJyZXR1cm5cIl09YTthPWV9cmV0dXJuIGsoYSk7Y2FzZSBUZTphOntpZihudWxsIT09YilpZig5PT09Yi50YWcpe2QoYSxiLnNpYmxpbmcpO2I9ZihiLG51bGwsZyk7Yi50eXBlPWUudmFsdWU7YltcInJldHVyblwiXT1hO2E9YjticmVhayBhfWVsc2UgZChhLGIpO2I9c2UoZSxhLmludGVybmFsQ29udGV4dFRhZyxnKTtiLnR5cGU9ZS52YWx1ZTtiW1wicmV0dXJuXCJdPWE7YT1ifXJldHVybiBrKGEpO2Nhc2UgTmU6YTp7Zm9yKGg9ZS5rZXk7bnVsbCE9PWI7KXtpZihiLmtleT09PWgpaWYoND09PWIudGFnJiZiLnN0YXRlTm9kZS5jb250YWluZXJJbmZvPT09ZS5jb250YWluZXJJbmZvJiZcbmIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uPT09ZS5pbXBsZW1lbnRhdGlvbil7ZChhLGIuc2libGluZyk7ZT1mKGIsZS5jaGlsZHJlbnx8W10sZyk7ZVtcInJldHVyblwiXT1hO2E9ZTticmVhayBhfWVsc2V7ZChhLGIpO2JyZWFrfWVsc2UgYyhhLGIpO2I9Yi5zaWJsaW5nfWU9dGUoZSxhLmludGVybmFsQ29udGV4dFRhZyxnKTtlW1wicmV0dXJuXCJdPWE7YT1lfXJldHVybiBrKGEpfWlmKFwic3RyaW5nXCI9PT10eXBlb2YgZXx8XCJudW1iZXJcIj09PXR5cGVvZiBlKXJldHVybiBlPVwiXCIrZSxudWxsIT09YiYmNj09PWIudGFnPyhkKGEsYi5zaWJsaW5nKSxlPWYoYixlLGcpKTooZChhLGIpLGU9cWUoZSxhLmludGVybmFsQ29udGV4dFRhZyxnKSksZVtcInJldHVyblwiXT1hLGE9ZSxrKGEpO2lmKFBlKGUpKXJldHVybiBUKGEsYixlLGcpO2lmKFZlKGUpKXJldHVybiBJKGEsYixlLGcpO2gmJlhlKGEsZSk7aWYoXCJ1bmRlZmluZWRcIj09PXR5cGVvZiBlKXN3aXRjaChhLnRhZyl7Y2FzZSAyOmNhc2UgMTplPVxuYS50eXBlLEQoXCIxNTJcIixlLmRpc3BsYXlOYW1lfHxlLm5hbWV8fFwiQ29tcG9uZW50XCIpfXJldHVybiBkKGEsYil9fXZhciBaZT1ZZSghMCwhMCksJGU9WWUoITEsITApLGFmPVllKCExLCExKTtcbmZ1bmN0aW9uIGJmKGEsYixjLGQsZSl7ZnVuY3Rpb24gZihhLGIsYyl7ZyhhLGIsYyxiLmV4cGlyYXRpb25UaW1lKX1mdW5jdGlvbiBnKGEsYixjLGQpe2IuY2hpbGQ9bnVsbD09PWE/YWYoYixiLmNoaWxkLGMsZCk6YS5jaGlsZD09PWIuY2hpbGQ/WmUoYixiLmNoaWxkLGMsZCk6JGUoYixiLmNoaWxkLGMsZCl9ZnVuY3Rpb24gayhhLGIpe3ZhciBjPWIucmVmO251bGw9PT1jfHxhJiZhLnJlZj09PWN8fChiLmVmZmVjdFRhZ3w9MTI4KX1mdW5jdGlvbiBoKGEsYixjLGQpe2soYSxiKTtpZighYylyZXR1cm4gZCYmbWUoYiwhMSksbihhLGIpO2M9Yi5zdGF0ZU5vZGU7ZGQuY3VycmVudD1iO3ZhciBlPWMucmVuZGVyKCk7Yi5lZmZlY3RUYWd8PTE7ZihhLGIsZSk7Yi5tZW1vaXplZFN0YXRlPWMuc3RhdGU7Yi5tZW1vaXplZFByb3BzPWMucHJvcHM7ZCYmbWUoYiwhMCk7cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24gcihhKXt2YXIgYj1hLnN0YXRlTm9kZTtiLnBlbmRpbmdDb250ZXh0P2plKGEsXG5iLnBlbmRpbmdDb250ZXh0LGIucGVuZGluZ0NvbnRleHQhPT1iLmNvbnRleHQpOmIuY29udGV4dCYmamUoYSxiLmNvbnRleHQsITEpO0coYSxiLmNvbnRhaW5lckluZm8pfWZ1bmN0aW9uIG4oYSxiKXtudWxsIT09YSYmYi5jaGlsZCE9PWEuY2hpbGQ/RChcIjE1M1wiKTp2b2lkIDA7aWYobnVsbCE9PWIuY2hpbGQpe2E9Yi5jaGlsZDt2YXIgYz1uZShhLGEucGVuZGluZ1Byb3BzLGEuZXhwaXJhdGlvblRpbWUpO2IuY2hpbGQ9Yztmb3IoY1tcInJldHVyblwiXT1iO251bGwhPT1hLnNpYmxpbmc7KWE9YS5zaWJsaW5nLGM9Yy5zaWJsaW5nPW5lKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSksY1tcInJldHVyblwiXT1iO2Muc2libGluZz1udWxsfXJldHVybiBiLmNoaWxkfWZ1bmN0aW9uIHkoYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMzpyKGIpO2JyZWFrO2Nhc2UgMjpsZShiKTticmVhaztjYXNlIDQ6RyhiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pfXJldHVybiBudWxsfXZhciB1PVxuYS5zaG91bGRTZXRUZXh0Q29udGVudCx4PWEudXNlU3luY1NjaGVkdWxpbmcsRj1hLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUsTD1iLnB1c2hIb3N0Q29udGV4dCxHPWIucHVzaEhvc3RDb250YWluZXIsVD1jLmVudGVySHlkcmF0aW9uU3RhdGUsST1jLnJlc2V0SHlkcmF0aW9uU3RhdGUsej1jLnRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlO2E9TWUoZCxlLGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFByb3BzPWJ9LGZ1bmN0aW9uKGEsYil7YS5tZW1vaXplZFN0YXRlPWJ9KTt2YXIgcD1hLmFkb3B0Q2xhc3NJbnN0YW5jZSx2PWEuY29uc3RydWN0Q2xhc3NJbnN0YW5jZSx0PWEubW91bnRDbGFzc0luc3RhbmNlLEtiPWEudXBkYXRlQ2xhc3NJbnN0YW5jZTtyZXR1cm57YmVnaW5Xb3JrOmZ1bmN0aW9uKGEsYixjKXtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB5KGEsYik7c3dpdGNoKGIudGFnKXtjYXNlIDA6bnVsbCE9PWE/XG5EKFwiMTU1XCIpOnZvaWQgMDt2YXIgZD1iLnR5cGUsZT1iLnBlbmRpbmdQcm9wcyxnPWZlKGIpO2c9aGUoYixnKTtkPWQoZSxnKTtiLmVmZmVjdFRhZ3w9MTtcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5yZW5kZXI/KGIudGFnPTIsZT1sZShiKSxwKGIsZCksdChiLGMpLGI9aChhLGIsITAsZSkpOihiLnRhZz0xLGYoYSxiLGQpLGIubWVtb2l6ZWRQcm9wcz1lLGI9Yi5jaGlsZCk7cmV0dXJuIGI7Y2FzZSAxOmE6e2U9Yi50eXBlO2M9Yi5wZW5kaW5nUHJvcHM7ZD1iLm1lbW9pemVkUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1kKTtlbHNlIGlmKG51bGw9PT1jfHxkPT09Yyl7Yj1uKGEsYik7YnJlYWsgYX1kPWZlKGIpO2Q9aGUoYixkKTtlPWUoYyxkKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7Y2FzZSAyOnJldHVybiBlPWxlKGIpLGQ9dm9pZCAwLG51bGw9PT1cbmE/Yi5zdGF0ZU5vZGU/RChcIjE1M1wiKToodihiLGIucGVuZGluZ1Byb3BzKSx0KGIsYyksZD0hMCk6ZD1LYihhLGIsYyksaChhLGIsZCxlKTtjYXNlIDM6cmV0dXJuIHIoYiksZT1iLnVwZGF0ZVF1ZXVlLG51bGwhPT1lPyhkPWIubWVtb2l6ZWRTdGF0ZSxlPUtlKGEsYixlLG51bGwsbnVsbCxjKSxkPT09ZT8oSSgpLGI9bihhLGIpKTooZD1lLmVsZW1lbnQsZz1iLnN0YXRlTm9kZSwobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKSYmZy5oeWRyYXRlJiZUKGIpPyhiLmVmZmVjdFRhZ3w9MixiLmNoaWxkPWFmKGIsYi5jaGlsZCxkLGMpKTooSSgpLGYoYSxiLGQpKSxiLm1lbW9pemVkU3RhdGU9ZSxiPWIuY2hpbGQpKTooSSgpLGI9bihhLGIpKSxiO2Nhc2UgNTpMKGIpO251bGw9PT1hJiZ6KGIpO2U9Yi50eXBlO3ZhciBsPWIubWVtb2l6ZWRQcm9wcztkPWIucGVuZGluZ1Byb3BzO251bGw9PT1kJiYoZD1sLG51bGw9PT1kP0QoXCIxNTRcIik6dm9pZCAwKTtnPW51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbm51bGw7WC5jdXJyZW50fHxudWxsIT09ZCYmbCE9PWQ/KGw9ZC5jaGlsZHJlbix1KGUsZCk/bD1udWxsOmcmJnUoZSxnKSYmKGIuZWZmZWN0VGFnfD0xNiksayhhLGIpLDIxNDc0ODM2NDchPT1jJiYheCYmRihlLGQpPyhiLmV4cGlyYXRpb25UaW1lPTIxNDc0ODM2NDcsYj1udWxsKTooZihhLGIsbCksYi5tZW1vaXplZFByb3BzPWQsYj1iLmNoaWxkKSk6Yj1uKGEsYik7cmV0dXJuIGI7Y2FzZSA2OnJldHVybiBudWxsPT09YSYmeihiKSxhPWIucGVuZGluZ1Byb3BzLG51bGw9PT1hJiYoYT1iLm1lbW9pemVkUHJvcHMpLGIubWVtb2l6ZWRQcm9wcz1hLG51bGw7Y2FzZSA4OmIudGFnPTc7Y2FzZSA3OmU9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09PWU/RChcIjE1NFwiKTp2b2lkIDApO2Vsc2UgaWYobnVsbD09PWV8fGIubWVtb2l6ZWRQcm9wcz09PWUpZT1iLm1lbW9pemVkUHJvcHM7ZD1lLmNoaWxkcmVuO2Iuc3RhdGVOb2RlPVxubnVsbD09PWE/YWYoYixiLnN0YXRlTm9kZSxkLGMpOmEuY2hpbGQ9PT1iLmNoaWxkP1plKGIsYi5zdGF0ZU5vZGUsZCxjKTokZShiLGIuc3RhdGVOb2RlLGQsYyk7Yi5tZW1vaXplZFByb3BzPWU7cmV0dXJuIGIuc3RhdGVOb2RlO2Nhc2UgOTpyZXR1cm4gbnVsbDtjYXNlIDQ6YTp7RyhiLGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO2U9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1lJiYoZT1hJiZhLm1lbW9pemVkUHJvcHMsbnVsbD09ZT9EKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSl7Yj1uKGEsYik7YnJlYWsgYX1udWxsPT09YT9iLmNoaWxkPSRlKGIsYi5jaGlsZCxlLGMpOmYoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1lO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDEwOmE6e2M9Yi5wZW5kaW5nUHJvcHM7aWYoWC5jdXJyZW50KW51bGw9PT1jJiYoYz1iLm1lbW9pemVkUHJvcHMpO2Vsc2UgaWYobnVsbD09PWN8fFxuYi5tZW1vaXplZFByb3BzPT09Yyl7Yj1uKGEsYik7YnJlYWsgYX1mKGEsYixjKTtiLm1lbW9pemVkUHJvcHM9YztiPWIuY2hpbGR9cmV0dXJuIGI7ZGVmYXVsdDpEKFwiMTU2XCIpfX0sYmVnaW5GYWlsZWRXb3JrOmZ1bmN0aW9uKGEsYixjKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpsZShiKTticmVhaztjYXNlIDM6cihiKTticmVhaztkZWZhdWx0OkQoXCIxNTdcIil9Yi5lZmZlY3RUYWd8PTY0O251bGw9PT1hP2IuY2hpbGQ9bnVsbDpiLmNoaWxkIT09YS5jaGlsZCYmKGIuY2hpbGQ9YS5jaGlsZCk7aWYoMD09PWIuZXhwaXJhdGlvblRpbWV8fGIuZXhwaXJhdGlvblRpbWU+YylyZXR1cm4geShhLGIpO2IuZmlyc3RFZmZlY3Q9bnVsbDtiLmxhc3RFZmZlY3Q9bnVsbDtnKGEsYixudWxsLGMpOzI9PT1iLnRhZyYmKGE9Yi5zdGF0ZU5vZGUsYi5tZW1vaXplZFByb3BzPWEucHJvcHMsYi5tZW1vaXplZFN0YXRlPWEuc3RhdGUpO3JldHVybiBiLmNoaWxkfX19XG5mdW5jdGlvbiBjZihhLGIsYyl7ZnVuY3Rpb24gZChhKXthLmVmZmVjdFRhZ3w9NH12YXIgZT1hLmNyZWF0ZUluc3RhbmNlLGY9YS5jcmVhdGVUZXh0SW5zdGFuY2UsZz1hLmFwcGVuZEluaXRpYWxDaGlsZCxrPWEuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4saD1hLnByZXBhcmVVcGRhdGUscj1hLnBlcnNpc3RlbmNlLG49Yi5nZXRSb290SG9zdENvbnRhaW5lcix5PWIucG9wSG9zdENvbnRleHQsdT1iLmdldEhvc3RDb250ZXh0LHg9Yi5wb3BIb3N0Q29udGFpbmVyLEY9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLEw9Yy5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxHPWMucG9wSHlkcmF0aW9uU3RhdGUsVD12b2lkIDAsST12b2lkIDAsej12b2lkIDA7YS5tdXRhdGlvbj8oVD1mdW5jdGlvbigpe30sST1mdW5jdGlvbihhLGIsYyl7KGIudXBkYXRlUXVldWU9YykmJmQoYil9LHo9ZnVuY3Rpb24oYSxiLGMsZSl7YyE9PWUmJmQoYil9KTpyP0QoXCIyMzVcIik6RChcIjIzNlwiKTtcbnJldHVybntjb21wbGV0ZVdvcms6ZnVuY3Rpb24oYSxiLGMpe3ZhciBwPWIucGVuZGluZ1Byb3BzO2lmKG51bGw9PT1wKXA9Yi5tZW1vaXplZFByb3BzO2Vsc2UgaWYoMjE0NzQ4MzY0NyE9PWIuZXhwaXJhdGlvblRpbWV8fDIxNDc0ODM2NDc9PT1jKWIucGVuZGluZ1Byb3BzPW51bGw7c3dpdGNoKGIudGFnKXtjYXNlIDE6cmV0dXJuIG51bGw7Y2FzZSAyOnJldHVybiBpZShiKSxudWxsO2Nhc2UgMzp4KGIpO1YoWCxiKTtWKGRlLGIpO3A9Yi5zdGF0ZU5vZGU7cC5wZW5kaW5nQ29udGV4dCYmKHAuY29udGV4dD1wLnBlbmRpbmdDb250ZXh0LHAucGVuZGluZ0NvbnRleHQ9bnVsbCk7aWYobnVsbD09PWF8fG51bGw9PT1hLmNoaWxkKUcoYiksYi5lZmZlY3RUYWcmPS0zO1QoYik7cmV0dXJuIG51bGw7Y2FzZSA1OnkoYik7Yz1uKCk7dmFyIHY9Yi50eXBlO2lmKG51bGwhPT1hJiZudWxsIT1iLnN0YXRlTm9kZSl7dmFyIGw9YS5tZW1vaXplZFByb3BzLHQ9Yi5zdGF0ZU5vZGUscj11KCk7dD1cbmgodCx2LGwscCxjLHIpO0koYSxiLHQsdixsLHAsYyk7YS5yZWYhPT1iLnJlZiYmKGIuZWZmZWN0VGFnfD0xMjgpfWVsc2V7aWYoIXApcmV0dXJuIG51bGw9PT1iLnN0YXRlTm9kZT9EKFwiMTY2XCIpOnZvaWQgMCxudWxsO2E9dSgpO2lmKEcoYikpRihiLGMsYSkmJmQoYik7ZWxzZXthPWUodixwLGMsYSxiKTthOmZvcihsPWIuY2hpbGQ7bnVsbCE9PWw7KXtpZig1PT09bC50YWd8fDY9PT1sLnRhZylnKGEsbC5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWwudGFnJiZudWxsIT09bC5jaGlsZCl7bC5jaGlsZFtcInJldHVyblwiXT1sO2w9bC5jaGlsZDtjb250aW51ZX1pZihsPT09YilicmVhaztmb3IoO251bGw9PT1sLnNpYmxpbmc7KXtpZihudWxsPT09bFtcInJldHVyblwiXXx8bFtcInJldHVyblwiXT09PWIpYnJlYWsgYTtsPWxbXCJyZXR1cm5cIl19bC5zaWJsaW5nW1wicmV0dXJuXCJdPWxbXCJyZXR1cm5cIl07bD1sLnNpYmxpbmd9ayhhLHYscCxjKSYmZChiKTtiLnN0YXRlTm9kZT1hfW51bGwhPT1iLnJlZiYmXG4oYi5lZmZlY3RUYWd8PTEyOCl9cmV0dXJuIG51bGw7Y2FzZSA2OmlmKGEmJm51bGwhPWIuc3RhdGVOb2RlKXooYSxiLGEubWVtb2l6ZWRQcm9wcyxwKTtlbHNle2lmKFwic3RyaW5nXCIhPT10eXBlb2YgcClyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0QoXCIxNjZcIik6dm9pZCAwLG51bGw7YT1uKCk7Yz11KCk7RyhiKT9MKGIpJiZkKGIpOmIuc3RhdGVOb2RlPWYocCxhLGMsYil9cmV0dXJuIG51bGw7Y2FzZSA3OihwPWIubWVtb2l6ZWRQcm9wcyk/dm9pZCAwOkQoXCIxNjVcIik7Yi50YWc9ODt2PVtdO2E6Zm9yKChsPWIuc3RhdGVOb2RlKSYmKGxbXCJyZXR1cm5cIl09Yik7bnVsbCE9PWw7KXtpZig1PT09bC50YWd8fDY9PT1sLnRhZ3x8ND09PWwudGFnKUQoXCIyNDdcIik7ZWxzZSBpZig5PT09bC50YWcpdi5wdXNoKGwudHlwZSk7ZWxzZSBpZihudWxsIT09bC5jaGlsZCl7bC5jaGlsZFtcInJldHVyblwiXT1sO2w9bC5jaGlsZDtjb250aW51ZX1mb3IoO251bGw9PT1sLnNpYmxpbmc7KXtpZihudWxsPT09XG5sW1wicmV0dXJuXCJdfHxsW1wicmV0dXJuXCJdPT09YilicmVhayBhO2w9bFtcInJldHVyblwiXX1sLnNpYmxpbmdbXCJyZXR1cm5cIl09bFtcInJldHVyblwiXTtsPWwuc2libGluZ31sPXAuaGFuZGxlcjtwPWwocC5wcm9wcyx2KTtiLmNoaWxkPVplKGIsbnVsbCE9PWE/YS5jaGlsZDpudWxsLHAsYyk7cmV0dXJuIGIuY2hpbGQ7Y2FzZSA4OnJldHVybiBiLnRhZz03LG51bGw7Y2FzZSA5OnJldHVybiBudWxsO2Nhc2UgMTA6cmV0dXJuIG51bGw7Y2FzZSA0OnJldHVybiB4KGIpLFQoYiksbnVsbDtjYXNlIDA6RChcIjE2N1wiKTtkZWZhdWx0OkQoXCIxNTZcIil9fX19XG5mdW5jdGlvbiBkZihhLGIpe2Z1bmN0aW9uIGMoYSl7dmFyIGM9YS5yZWY7aWYobnVsbCE9PWMpdHJ5e2MobnVsbCl9Y2F0Y2godil7YihhLHYpfX1mdW5jdGlvbiBkKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiB6ZSYmemUoYSk7c3dpdGNoKGEudGFnKXtjYXNlIDI6YyhhKTt2YXIgZD1hLnN0YXRlTm9kZTtpZihcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5jb21wb25lbnRXaWxsVW5tb3VudCl0cnl7ZC5wcm9wcz1hLm1lbW9pemVkUHJvcHMsZC5zdGF0ZT1hLm1lbW9pemVkU3RhdGUsZC5jb21wb25lbnRXaWxsVW5tb3VudCgpfWNhdGNoKHYpe2IoYSx2KX1icmVhaztjYXNlIDU6YyhhKTticmVhaztjYXNlIDc6ZShhLnN0YXRlTm9kZSk7YnJlYWs7Y2FzZSA0OmgmJmcoYSl9fWZ1bmN0aW9uIGUoYSl7Zm9yKHZhciBiPWE7OylpZihkKGIpLG51bGw9PT1iLmNoaWxkfHxoJiY0PT09Yi50YWcpe2lmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxcbmJbXCJyZXR1cm5cIl09PT1hKXJldHVybjtiPWJbXCJyZXR1cm5cIl19Yi5zaWJsaW5nW1wicmV0dXJuXCJdPWJbXCJyZXR1cm5cIl07Yj1iLnNpYmxpbmd9ZWxzZSBiLmNoaWxkW1wicmV0dXJuXCJdPWIsYj1iLmNoaWxkfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIDU9PT1hLnRhZ3x8Mz09PWEudGFnfHw0PT09YS50YWd9ZnVuY3Rpb24gZyhhKXtmb3IodmFyIGI9YSxjPSExLGY9dm9pZCAwLGc9dm9pZCAwOzspe2lmKCFjKXtjPWJbXCJyZXR1cm5cIl07YTpmb3IoOzspe251bGw9PT1jP0QoXCIxNjBcIik6dm9pZCAwO3N3aXRjaChjLnRhZyl7Y2FzZSA1OmY9Yy5zdGF0ZU5vZGU7Zz0hMTticmVhayBhO2Nhc2UgMzpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhO2Nhc2UgNDpmPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87Zz0hMDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jPSEwfWlmKDU9PT1iLnRhZ3x8Nj09PWIudGFnKWUoYiksZz9JKGYsYi5zdGF0ZU5vZGUpOlQoZixiLnN0YXRlTm9kZSk7XG5lbHNlIGlmKDQ9PT1iLnRhZz9mPWIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm86ZChiKSxudWxsIT09Yi5jaGlsZCl7Yi5jaGlsZFtcInJldHVyblwiXT1iO2I9Yi5jaGlsZDtjb250aW51ZX1pZihiPT09YSlicmVhaztmb3IoO251bGw9PT1iLnNpYmxpbmc7KXtpZihudWxsPT09YltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXTs0PT09Yi50YWcmJihjPSExKX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ319dmFyIGs9YS5nZXRQdWJsaWNJbnN0YW5jZSxoPWEubXV0YXRpb247YT1hLnBlcnNpc3RlbmNlO2h8fChhP0QoXCIyMzVcIik6RChcIjIzNlwiKSk7dmFyIHI9aC5jb21taXRNb3VudCxuPWguY29tbWl0VXBkYXRlLHk9aC5yZXNldFRleHRDb250ZW50LHU9aC5jb21taXRUZXh0VXBkYXRlLHg9aC5hcHBlbmRDaGlsZCxGPWguYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixMPWguaW5zZXJ0QmVmb3JlLEc9aC5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZSxcblQ9aC5yZW1vdmVDaGlsZCxJPWgucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO3JldHVybntjb21taXRSZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe3koYS5zdGF0ZU5vZGUpfSxjb21taXRQbGFjZW1lbnQ6ZnVuY3Rpb24oYSl7YTp7Zm9yKHZhciBiPWFbXCJyZXR1cm5cIl07bnVsbCE9PWI7KXtpZihmKGIpKXt2YXIgYz1iO2JyZWFrIGF9Yj1iW1wicmV0dXJuXCJdfUQoXCIxNjBcIik7Yz12b2lkIDB9dmFyIGQ9Yj12b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Yj1jLnN0YXRlTm9kZTtkPSExO2JyZWFrO2Nhc2UgMzpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztjYXNlIDQ6Yj1jLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2Q9ITA7YnJlYWs7ZGVmYXVsdDpEKFwiMTYxXCIpfWMuZWZmZWN0VGFnJjE2JiYoeShiKSxjLmVmZmVjdFRhZyY9LTE3KTthOmI6Zm9yKGM9YTs7KXtmb3IoO251bGw9PT1jLnNpYmxpbmc7KXtpZihudWxsPT09Y1tcInJldHVyblwiXXx8ZihjW1wicmV0dXJuXCJdKSl7Yz1cbm51bGw7YnJlYWsgYX1jPWNbXCJyZXR1cm5cIl19Yy5zaWJsaW5nW1wicmV0dXJuXCJdPWNbXCJyZXR1cm5cIl07Zm9yKGM9Yy5zaWJsaW5nOzUhPT1jLnRhZyYmNiE9PWMudGFnOyl7aWYoYy5lZmZlY3RUYWcmMiljb250aW51ZSBiO2lmKG51bGw9PT1jLmNoaWxkfHw0PT09Yy50YWcpY29udGludWUgYjtlbHNlIGMuY2hpbGRbXCJyZXR1cm5cIl09YyxjPWMuY2hpbGR9aWYoIShjLmVmZmVjdFRhZyYyKSl7Yz1jLnN0YXRlTm9kZTticmVhayBhfX1mb3IodmFyIGU9YTs7KXtpZig1PT09ZS50YWd8fDY9PT1lLnRhZyljP2Q/RyhiLGUuc3RhdGVOb2RlLGMpOkwoYixlLnN0YXRlTm9kZSxjKTpkP0YoYixlLnN0YXRlTm9kZSk6eChiLGUuc3RhdGVOb2RlKTtlbHNlIGlmKDQhPT1lLnRhZyYmbnVsbCE9PWUuY2hpbGQpe2UuY2hpbGRbXCJyZXR1cm5cIl09ZTtlPWUuY2hpbGQ7Y29udGludWV9aWYoZT09PWEpYnJlYWs7Zm9yKDtudWxsPT09ZS5zaWJsaW5nOyl7aWYobnVsbD09PWVbXCJyZXR1cm5cIl18fGVbXCJyZXR1cm5cIl09PT1cbmEpcmV0dXJuO2U9ZVtcInJldHVyblwiXX1lLnNpYmxpbmdbXCJyZXR1cm5cIl09ZVtcInJldHVyblwiXTtlPWUuc2libGluZ319LGNvbW1pdERlbGV0aW9uOmZ1bmN0aW9uKGEpe2coYSk7YVtcInJldHVyblwiXT1udWxsO2EuY2hpbGQ9bnVsbDthLmFsdGVybmF0ZSYmKGEuYWx0ZXJuYXRlLmNoaWxkPW51bGwsYS5hbHRlcm5hdGVbXCJyZXR1cm5cIl09bnVsbCl9LGNvbW1pdFdvcms6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjpicmVhaztjYXNlIDU6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYobnVsbCE9Yyl7dmFyIGQ9Yi5tZW1vaXplZFByb3BzO2E9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOmQ7dmFyIGU9Yi50eXBlLGY9Yi51cGRhdGVRdWV1ZTtiLnVwZGF0ZVF1ZXVlPW51bGw7bnVsbCE9PWYmJm4oYyxmLGUsYSxkLGIpfWJyZWFrO2Nhc2UgNjpudWxsPT09Yi5zdGF0ZU5vZGU/RChcIjE2MlwiKTp2b2lkIDA7Yz1iLm1lbW9pemVkUHJvcHM7dShiLnN0YXRlTm9kZSxudWxsIT09YT9hLm1lbW9pemVkUHJvcHM6XG5jLGMpO2JyZWFrO2Nhc2UgMzpicmVhaztkZWZhdWx0OkQoXCIxNjNcIil9fSxjb21taXRMaWZlQ3ljbGVzOmZ1bmN0aW9uKGEsYil7c3dpdGNoKGIudGFnKXtjYXNlIDI6dmFyIGM9Yi5zdGF0ZU5vZGU7aWYoYi5lZmZlY3RUYWcmNClpZihudWxsPT09YSljLnByb3BzPWIubWVtb2l6ZWRQcm9wcyxjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZSxjLmNvbXBvbmVudERpZE1vdW50KCk7ZWxzZXt2YXIgZD1hLm1lbW9pemVkUHJvcHM7YT1hLm1lbW9pemVkU3RhdGU7Yy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Yy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7Yy5jb21wb25lbnREaWRVcGRhdGUoZCxhKX1iPWIudXBkYXRlUXVldWU7bnVsbCE9PWImJkxlKGIsYyk7YnJlYWs7Y2FzZSAzOmM9Yi51cGRhdGVRdWV1ZTtudWxsIT09YyYmTGUoYyxudWxsIT09Yi5jaGlsZD9iLmNoaWxkLnN0YXRlTm9kZTpudWxsKTticmVhaztjYXNlIDU6Yz1iLnN0YXRlTm9kZTtudWxsPT09YSYmYi5lZmZlY3RUYWcmNCYmcihjLFxuYi50eXBlLGIubWVtb2l6ZWRQcm9wcyxiKTticmVhaztjYXNlIDY6YnJlYWs7Y2FzZSA0OmJyZWFrO2RlZmF1bHQ6RChcIjE2M1wiKX19LGNvbW1pdEF0dGFjaFJlZjpmdW5jdGlvbihhKXt2YXIgYj1hLnJlZjtpZihudWxsIT09Yil7dmFyIGM9YS5zdGF0ZU5vZGU7c3dpdGNoKGEudGFnKXtjYXNlIDU6YihrKGMpKTticmVhaztkZWZhdWx0OmIoYyl9fX0sY29tbWl0RGV0YWNoUmVmOmZ1bmN0aW9uKGEpe2E9YS5yZWY7bnVsbCE9PWEmJmEobnVsbCl9fX12YXIgZWY9e307XG5mdW5jdGlvbiBmZihhKXtmdW5jdGlvbiBiKGEpe2E9PT1lZj9EKFwiMTc0XCIpOnZvaWQgMDtyZXR1cm4gYX12YXIgYz1hLmdldENoaWxkSG9zdENvbnRleHQsZD1hLmdldFJvb3RIb3N0Q29udGV4dCxlPXtjdXJyZW50OmVmfSxmPXtjdXJyZW50OmVmfSxnPXtjdXJyZW50OmVmfTtyZXR1cm57Z2V0SG9zdENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gYihlLmN1cnJlbnQpfSxnZXRSb290SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe3JldHVybiBiKGcuY3VycmVudCl9LHBvcEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSl7VihlLGEpO1YoZixhKTtWKGcsYSl9LHBvcEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe2YuY3VycmVudD09PWEmJihWKGUsYSksVihmLGEpKX0scHVzaEhvc3RDb250YWluZXI6ZnVuY3Rpb24oYSxiKXtXKGcsYixhKTtiPWQoYik7VyhmLGEsYSk7VyhlLGIsYSl9LHB1c2hIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgZD1iKGcuY3VycmVudCksaz1iKGUuY3VycmVudCk7XG5kPWMoayxhLnR5cGUsZCk7ayE9PWQmJihXKGYsYSxhKSxXKGUsZCxhKSl9LHJlc2V0SG9zdENvbnRhaW5lcjpmdW5jdGlvbigpe2UuY3VycmVudD1lZjtnLmN1cnJlbnQ9ZWZ9fX1cbmZ1bmN0aW9uIGdmKGEpe2Z1bmN0aW9uIGIoYSxiKXt2YXIgYz1uZXcgWSg1LG51bGwsMCk7Yy50eXBlPVwiREVMRVRFRFwiO2Muc3RhdGVOb2RlPWI7Y1tcInJldHVyblwiXT1hO2MuZWZmZWN0VGFnPTg7bnVsbCE9PWEubGFzdEVmZmVjdD8oYS5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YyxhLmxhc3RFZmZlY3Q9Yyk6YS5maXJzdEVmZmVjdD1hLmxhc3RFZmZlY3Q9Y31mdW5jdGlvbiBjKGEsYil7c3dpdGNoKGEudGFnKXtjYXNlIDU6cmV0dXJuIGYoYixhLnR5cGUsYS5wZW5kaW5nUHJvcHMpO2Nhc2UgNjpyZXR1cm4gZyhiLGEucGVuZGluZ1Byb3BzKTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBkKGEpe2ZvcihhPWFbXCJyZXR1cm5cIl07bnVsbCE9PWEmJjUhPT1hLnRhZyYmMyE9PWEudGFnOylhPWFbXCJyZXR1cm5cIl07eT1hfXZhciBlPWEuc2hvdWxkU2V0VGV4dENvbnRlbnQ7YT1hLmh5ZHJhdGlvbjtpZighYSlyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfSxcbnJlc2V0SHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oKXt9LHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKCl7RChcIjE3NVwiKX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXtEKFwiMTc2XCIpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3JldHVybiExfX07dmFyIGY9YS5jYW5IeWRyYXRlSW5zdGFuY2UsZz1hLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2Usaz1hLmdldE5leHRIeWRyYXRhYmxlU2libGluZyxoPWEuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQscj1hLmh5ZHJhdGVJbnN0YW5jZSxuPWEuaHlkcmF0ZVRleHRJbnN0YW5jZSx5PW51bGwsdT1udWxsLHg9ITE7cmV0dXJue2VudGVySHlkcmF0aW9uU3RhdGU6ZnVuY3Rpb24oYSl7dT1oKGEuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO3k9YTtyZXR1cm4geD0hMH0scmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe3U9XG55PW51bGw7eD0hMX0sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oYSl7aWYoeCl7dmFyIGQ9dTtpZihkKXtpZighYyhhLGQpKXtkPWsoZCk7aWYoIWR8fCFjKGEsZCkpe2EuZWZmZWN0VGFnfD0yO3g9ITE7eT1hO3JldHVybn1iKHksdSl9YS5zdGF0ZU5vZGU9ZDt5PWE7dT1oKGQpfWVsc2UgYS5lZmZlY3RUYWd8PTIseD0hMSx5PWF9fSxwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXtiPXIoYS5zdGF0ZU5vZGUsYS50eXBlLGEubWVtb2l6ZWRQcm9wcyxiLGMsYSk7YS51cGRhdGVRdWV1ZT1iO3JldHVybiBudWxsIT09Yj8hMDohMX0scHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIG4oYS5zdGF0ZU5vZGUsYS5tZW1vaXplZFByb3BzLGEpfSxwb3BIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXtpZihhIT09eSlyZXR1cm4hMTtpZigheClyZXR1cm4gZChhKSx4PSEwLCExO3ZhciBjPVxuYS50eXBlO2lmKDUhPT1hLnRhZ3x8XCJoZWFkXCIhPT1jJiZcImJvZHlcIiE9PWMmJiFlKGMsYS5tZW1vaXplZFByb3BzKSlmb3IoYz11O2M7KWIoYSxjKSxjPWsoYyk7ZChhKTt1PXk/ayhhLnN0YXRlTm9kZSk6bnVsbDtyZXR1cm4hMH19fVxuZnVuY3Rpb24gaGYoYSl7ZnVuY3Rpb24gYihhKXtMYj1tYT0hMDt2YXIgYj1hLnN0YXRlTm9kZTtiLmN1cnJlbnQ9PT1hP0QoXCIxNzdcIik6dm9pZCAwO2IuaXNSZWFkeUZvckNvbW1pdD0hMTtkZC5jdXJyZW50PW51bGw7aWYoMTxhLmVmZmVjdFRhZylpZihudWxsIT09YS5sYXN0RWZmZWN0KXthLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1hO3ZhciBjPWEuZmlyc3RFZmZlY3R9ZWxzZSBjPWE7ZWxzZSBjPWEuZmlyc3RFZmZlY3Q7dWcoKTtmb3IocT1jO251bGwhPT1xOyl7dmFyIGQ9ITEsZT12b2lkIDA7dHJ5e2Zvcig7bnVsbCE9PXE7KXt2YXIgZj1xLmVmZmVjdFRhZztmJjE2JiZ2ZyhxKTtpZihmJjEyOCl7dmFyIGc9cS5hbHRlcm5hdGU7bnVsbCE9PWcmJndnKGcpfXN3aXRjaChmJi0yNDIpe2Nhc2UgMjpHZShxKTtxLmVmZmVjdFRhZyY9LTM7YnJlYWs7Y2FzZSA2OkdlKHEpO3EuZWZmZWN0VGFnJj0tMztIZShxLmFsdGVybmF0ZSxxKTticmVhaztjYXNlIDQ6SGUocS5hbHRlcm5hdGUsXG5xKTticmVhaztjYXNlIDg6TGM9ITAseGcocSksTGM9ITF9cT1xLm5leHRFZmZlY3R9fWNhdGNoKE1jKXtkPSEwLGU9TWN9ZCYmKG51bGw9PT1xP0QoXCIxNzhcIik6dm9pZCAwLGsocSxlKSxudWxsIT09cSYmKHE9cS5uZXh0RWZmZWN0KSl9eWcoKTtiLmN1cnJlbnQ9YTtmb3IocT1jO251bGwhPT1xOyl7Yz0hMTtkPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09cTspe3ZhciBoPXEuZWZmZWN0VGFnO2gmMzYmJnpnKHEuYWx0ZXJuYXRlLHEpO2gmMTI4JiZBZyhxKTtpZihoJjY0KXN3aXRjaChlPXEsZj12b2lkIDAsbnVsbCE9PVAmJihmPVAuZ2V0KGUpLFBbXCJkZWxldGVcIl0oZSksbnVsbD09ZiYmbnVsbCE9PWUuYWx0ZXJuYXRlJiYoZT1lLmFsdGVybmF0ZSxmPVAuZ2V0KGUpLFBbXCJkZWxldGVcIl0oZSkpKSxudWxsPT1mP0QoXCIxODRcIik6dm9pZCAwLGUudGFnKXtjYXNlIDI6ZS5zdGF0ZU5vZGUuY29tcG9uZW50RGlkQ2F0Y2goZi5lcnJvcix7Y29tcG9uZW50U3RhY2s6Zi5jb21wb25lbnRTdGFja30pO1xuYnJlYWs7Y2FzZSAzOm51bGw9PT1iYSYmKGJhPWYuZXJyb3IpO2JyZWFrO2RlZmF1bHQ6RChcIjE1N1wiKX12YXIgRmE9cS5uZXh0RWZmZWN0O3EubmV4dEVmZmVjdD1udWxsO3E9RmF9fWNhdGNoKE1jKXtjPSEwLGQ9TWN9YyYmKG51bGw9PT1xP0QoXCIxNzhcIik6dm9pZCAwLGsocSxkKSxudWxsIT09cSYmKHE9cS5uZXh0RWZmZWN0KSl9bWE9TGI9ITE7XCJmdW5jdGlvblwiPT09dHlwZW9mIHllJiZ5ZShhLnN0YXRlTm9kZSk7ZmEmJihmYS5mb3JFYWNoKEYpLGZhPW51bGwpO251bGwhPT1iYSYmKGE9YmEsYmE9bnVsbCx2KGEpKTtiPWIuY3VycmVudC5leHBpcmF0aW9uVGltZTswPT09YiYmKG5hPVA9bnVsbCk7cmV0dXJuIGJ9ZnVuY3Rpb24gYyhhKXtmb3IoOzspe3ZhciBiPW5nKGEuYWx0ZXJuYXRlLGEsSiksYz1hW1wicmV0dXJuXCJdLGQ9YS5zaWJsaW5nO3ZhciBlPWE7aWYoMjE0NzQ4MzY0Nz09PUp8fDIxNDc0ODM2NDchPT1lLmV4cGlyYXRpb25UaW1lKXtpZigyIT09ZS50YWcmJjMhPT1cbmUudGFnKXZhciBmPTA7ZWxzZSBmPWUudXBkYXRlUXVldWUsZj1udWxsPT09Zj8wOmYuZXhwaXJhdGlvblRpbWU7Zm9yKHZhciBnPWUuY2hpbGQ7bnVsbCE9PWc7KTAhPT1nLmV4cGlyYXRpb25UaW1lJiYoMD09PWZ8fGY+Zy5leHBpcmF0aW9uVGltZSkmJihmPWcuZXhwaXJhdGlvblRpbWUpLGc9Zy5zaWJsaW5nO2UuZXhwaXJhdGlvblRpbWU9Zn1pZihudWxsIT09YilyZXR1cm4gYjtudWxsIT09YyYmKG51bGw9PT1jLmZpcnN0RWZmZWN0JiYoYy5maXJzdEVmZmVjdD1hLmZpcnN0RWZmZWN0KSxudWxsIT09YS5sYXN0RWZmZWN0JiYobnVsbCE9PWMubGFzdEVmZmVjdCYmKGMubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLGMubGFzdEVmZmVjdD1hLmxhc3RFZmZlY3QpLDE8YS5lZmZlY3RUYWcmJihudWxsIT09Yy5sYXN0RWZmZWN0P2MubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE6Yy5maXJzdEVmZmVjdD1hLGMubGFzdEVmZmVjdD1hKSk7aWYobnVsbCE9PWQpcmV0dXJuIGQ7XG5pZihudWxsIT09YylhPWM7ZWxzZXthLnN0YXRlTm9kZS5pc1JlYWR5Rm9yQ29tbWl0PSEwO2JyZWFrfX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBkKGEpe3ZhciBiPXcoYS5hbHRlcm5hdGUsYSxKKTtudWxsPT09YiYmKGI9YyhhKSk7ZGQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGUoYSl7dmFyIGI9bWcoYS5hbHRlcm5hdGUsYSxKKTtudWxsPT09YiYmKGI9YyhhKSk7ZGQuY3VycmVudD1udWxsO3JldHVybiBifWZ1bmN0aW9uIGYoYSl7aWYobnVsbCE9PVApe2lmKCEoMD09PUp8fEo+YSkpaWYoSjw9TmMpZm9yKDtudWxsIT09RTspRT1oKEUpP2UoRSk6ZChFKTtlbHNlIGZvcig7bnVsbCE9PUUmJiFwKCk7KUU9aChFKT9lKEUpOmQoRSl9ZWxzZSBpZighKDA9PT1KfHxKPmEpKWlmKEo8PU5jKWZvcig7bnVsbCE9PUU7KUU9ZChFKTtlbHNlIGZvcig7bnVsbCE9PUUmJiFwKCk7KUU9ZChFKX1mdW5jdGlvbiBnKGEsYil7bWE/RChcIjI0M1wiKTp2b2lkIDA7bWE9ITA7YS5pc1JlYWR5Rm9yQ29tbWl0PVxuITE7aWYoYSE9PWZifHxiIT09Snx8bnVsbD09PUUpe2Zvcig7LTE8Y2U7KWJlW2NlXT1udWxsLGNlLS07ZWU9QztkZS5jdXJyZW50PUM7WC5jdXJyZW50PSExO2xnKCk7ZmI9YTtKPWI7RT1uZShmYi5jdXJyZW50LG51bGwsYil9dmFyIGM9ITEsZD1udWxsO3RyeXtmKGIpfWNhdGNoKEtjKXtjPSEwLGQ9S2N9Zm9yKDtjOyl7aWYoZ2Ipe2JhPWQ7YnJlYWt9dmFyIGc9RTtpZihudWxsPT09ZylnYj0hMDtlbHNle3ZhciBoPWsoZyxkKTtudWxsPT09aD9EKFwiMTgzXCIpOnZvaWQgMDtpZighZ2Ipe3RyeXtjPWg7ZD1iO2ZvcihoPWM7bnVsbCE9PWc7KXtzd2l0Y2goZy50YWcpe2Nhc2UgMjppZShnKTticmVhaztjYXNlIDU6bChnKTticmVhaztjYXNlIDM6RWUoZyk7YnJlYWs7Y2FzZSA0OkVlKGcpfWlmKGc9PT1ofHxnLmFsdGVybmF0ZT09PWgpYnJlYWs7Zz1nW1wicmV0dXJuXCJdfUU9ZShjKTtmKGQpfWNhdGNoKEtjKXtjPSEwO2Q9S2M7Y29udGludWV9YnJlYWt9fX1iPWJhO2diPW1hPSExO1xuYmE9bnVsbDtudWxsIT09YiYmdihiKTtyZXR1cm4gYS5pc1JlYWR5Rm9yQ29tbWl0P2EuY3VycmVudC5hbHRlcm5hdGU6bnVsbH1mdW5jdGlvbiBrKGEsYil7dmFyIGM9ZGQuY3VycmVudD1udWxsLGQ9ITEsZT0hMSxmPW51bGw7aWYoMz09PWEudGFnKWM9YSxyKGEpJiYoZ2I9ITApO2Vsc2UgZm9yKHZhciBnPWFbXCJyZXR1cm5cIl07bnVsbCE9PWcmJm51bGw9PT1jOyl7Mj09PWcudGFnP1wiZnVuY3Rpb25cIj09PXR5cGVvZiBnLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaCYmKGQ9ITAsZj1lZChnKSxjPWcsZT0hMCk6Mz09PWcudGFnJiYoYz1nKTtpZihyKGcpKXtpZihMY3x8bnVsbCE9PWZhJiYoZmEuaGFzKGcpfHxudWxsIT09Zy5hbHRlcm5hdGUmJmZhLmhhcyhnLmFsdGVybmF0ZSkpKXJldHVybiBudWxsO2M9bnVsbDtlPSExfWc9Z1tcInJldHVyblwiXX1pZihudWxsIT09Yyl7bnVsbD09PW5hJiYobmE9bmV3IFNldCk7bmEuYWRkKGMpO3ZhciBoPVwiXCI7Zz1hO2Rve2E6c3dpdGNoKGcudGFnKXtjYXNlIDA6Y2FzZSAxOmNhc2UgMjpjYXNlIDU6dmFyIGs9XG5nLl9kZWJ1Z093bmVyLGw9Zy5fZGVidWdTb3VyY2U7dmFyIEZhPWVkKGcpO3ZhciBuPW51bGw7ayYmKG49ZWQoaykpO2s9bDtGYT1cIlxcbiAgICBpbiBcIisoRmF8fFwiVW5rbm93blwiKSsoaz9cIiAoYXQgXCIray5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLFwiXCIpK1wiOlwiK2subGluZU51bWJlcitcIilcIjpuP1wiIChjcmVhdGVkIGJ5IFwiK24rXCIpXCI6XCJcIik7YnJlYWsgYTtkZWZhdWx0OkZhPVwiXCJ9aCs9RmE7Zz1nW1wicmV0dXJuXCJdfXdoaWxlKGcpO2c9aDthPWVkKGEpO251bGw9PT1QJiYoUD1uZXcgTWFwKTtiPXtjb21wb25lbnROYW1lOmEsY29tcG9uZW50U3RhY2s6ZyxlcnJvcjpiLGVycm9yQm91bmRhcnk6ZD9jLnN0YXRlTm9kZTpudWxsLGVycm9yQm91bmRhcnlGb3VuZDpkLGVycm9yQm91bmRhcnlOYW1lOmYsd2lsbFJldHJ5OmV9O1Auc2V0KGMsYik7dHJ5e2NvbnNvbGUuZXJyb3IoYi5lcnJvcil9Y2F0Y2goQmcpe2NvbnNvbGUuZXJyb3IoQmcpfUxiPyhudWxsPT09ZmEmJihmYT1uZXcgU2V0KSxcbmZhLmFkZChjKSk6RihjKTtyZXR1cm4gY31udWxsPT09YmEmJihiYT1iKTtyZXR1cm4gbnVsbH1mdW5jdGlvbiBoKGEpe3JldHVybiBudWxsIT09UCYmKFAuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJlAuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gcihhKXtyZXR1cm4gbnVsbCE9PW5hJiYobmEuaGFzKGEpfHxudWxsIT09YS5hbHRlcm5hdGUmJm5hLmhhcyhhLmFsdGVybmF0ZSkpfWZ1bmN0aW9uIG4oKXtyZXR1cm4gMjAqKCgoTCgpKzEwMCkvMjB8MCkrMSl9ZnVuY3Rpb24geShhKXtyZXR1cm4gMCE9PWphP2phOm1hP0xiPzE6SjohQ2d8fGEuaW50ZXJuYWxDb250ZXh0VGFnJjE/bigpOjF9ZnVuY3Rpb24gdShhLGIpe3JldHVybiB4KGEsYiwhMSl9ZnVuY3Rpb24geChhLGIpe2Zvcig7bnVsbCE9PWE7KXtpZigwPT09YS5leHBpcmF0aW9uVGltZXx8YS5leHBpcmF0aW9uVGltZT5iKWEuZXhwaXJhdGlvblRpbWU9YjtudWxsIT09YS5hbHRlcm5hdGUmJigwPT09YS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWV8fFxuYS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWU+YikmJihhLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT1iKTtpZihudWxsPT09YVtcInJldHVyblwiXSlpZigzPT09YS50YWcpe3ZhciBjPWEuc3RhdGVOb2RlOyFtYSYmYz09PWZiJiZiPD1KJiYoRT1mYj1udWxsLEo9MCk7dmFyIGQ9YjtNYj5EZyYmRChcIjE4NVwiKTtpZihudWxsPT09Yy5uZXh0U2NoZWR1bGVkUm9vdCljLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWQsbnVsbD09PU0/KG9hPU09YyxjLm5leHRTY2hlZHVsZWRSb290PWMpOihNPU0ubmV4dFNjaGVkdWxlZFJvb3Q9YyxNLm5leHRTY2hlZHVsZWRSb290PW9hKTtlbHNle3ZhciBlPWMucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWV8fGQ8ZSljLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWR9R2F8fChrYT9OYiYmeihjLDEpOjE9PT1kP0koMSxudWxsKTpoYnx8KGhiPSEwLEllKFQpKSl9ZWxzZSBicmVhazthPWFbXCJyZXR1cm5cIl19fWZ1bmN0aW9uIEYoYSl7eChhLDEsXG4hMCl9ZnVuY3Rpb24gTCgpe3JldHVybiBOYz0oKEplKCktRWcpLzEwfDApKzJ9ZnVuY3Rpb24gRygpe3ZhciBhPTAsYj1udWxsO2lmKG51bGwhPT1NKWZvcih2YXIgYz1NLGQ9b2E7bnVsbCE9PWQ7KXt2YXIgZT1kLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO2lmKDA9PT1lKXtudWxsPT09Y3x8bnVsbD09PU0/RChcIjI0NFwiKTp2b2lkIDA7aWYoZD09PWQubmV4dFNjaGVkdWxlZFJvb3Qpe29hPU09ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgaWYoZD09PW9hKW9hPWU9ZC5uZXh0U2NoZWR1bGVkUm9vdCxNLm5leHRTY2hlZHVsZWRSb290PWUsZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2Vsc2UgaWYoZD09PU0pe009YztNLm5leHRTY2hlZHVsZWRSb290PW9hO2QubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDticmVha31lbHNlIGMubmV4dFNjaGVkdWxlZFJvb3Q9ZC5uZXh0U2NoZWR1bGVkUm9vdCxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZD1jLm5leHRTY2hlZHVsZWRSb290fWVsc2V7aWYoMD09PVxuYXx8ZTxhKWE9ZSxiPWQ7aWYoZD09PU0pYnJlYWs7Yz1kO2Q9ZC5uZXh0U2NoZWR1bGVkUm9vdH19Yz1wYTtudWxsIT09YyYmYz09PWI/TWIrKzpNYj0wO3BhPWI7T2I9YX1mdW5jdGlvbiBUKGEpe0koMCxhKX1mdW5jdGlvbiBJKGEsYil7aWI9Yjtmb3IoRygpO251bGwhPT1wYSYmMCE9PU9iJiYoMD09PWF8fE9iPD1hKSYmIU9jOyl6KHBhLE9iKSxHKCk7bnVsbCE9PWliJiYoaGI9ITEpO251bGw9PT1wYXx8aGJ8fChoYj0hMCxJZShUKSk7aWI9bnVsbDtPYz0hMTtNYj0wO2lmKFBiKXRocm93IGE9UGMsUGM9bnVsbCxQYj0hMSxhO31mdW5jdGlvbiB6KGEsYyl7R2E/RChcIjI0NVwiKTp2b2lkIDA7R2E9ITA7aWYoYzw9TCgpKXt2YXIgZD1hLmZpbmlzaGVkV29yaztudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYoYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1cbmIoZCkpKX1lbHNlIGQ9YS5maW5pc2hlZFdvcmssbnVsbCE9PWQ/KGEuZmluaXNoZWRXb3JrPW51bGwsYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKTooYS5maW5pc2hlZFdvcms9bnVsbCxkPWcoYSxjKSxudWxsIT09ZCYmKHAoKT9hLmZpbmlzaGVkV29yaz1kOmEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSkpO0dhPSExfWZ1bmN0aW9uIHAoKXtyZXR1cm4gbnVsbD09PWlifHxpYi50aW1lUmVtYWluaW5nKCk+Rmc/ITE6T2M9ITB9ZnVuY3Rpb24gdihhKXtudWxsPT09cGE/RChcIjI0NlwiKTp2b2lkIDA7cGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9MDtQYnx8KFBiPSEwLFBjPWEpfXZhciB0PWZmKGEpLEtiPWdmKGEpLEVlPXQucG9wSG9zdENvbnRhaW5lcixsPXQucG9wSG9zdENvbnRleHQsbGc9dC5yZXNldEhvc3RDb250YWluZXIsRmU9YmYoYSx0LEtiLHUseSksdz1GZS5iZWdpbldvcmssbWc9RmUuYmVnaW5GYWlsZWRXb3JrLG5nPWNmKGEsdCxLYikuY29tcGxldGVXb3JrO1xudD1kZihhLGspO3ZhciB2Zz10LmNvbW1pdFJlc2V0VGV4dENvbnRlbnQsR2U9dC5jb21taXRQbGFjZW1lbnQseGc9dC5jb21taXREZWxldGlvbixIZT10LmNvbW1pdFdvcmssemc9dC5jb21taXRMaWZlQ3ljbGVzLEFnPXQuY29tbWl0QXR0YWNoUmVmLHdnPXQuY29tbWl0RGV0YWNoUmVmLEplPWEubm93LEllPWEuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLENnPWEudXNlU3luY1NjaGVkdWxpbmcsdWc9YS5wcmVwYXJlRm9yQ29tbWl0LHlnPWEucmVzZXRBZnRlckNvbW1pdCxFZz1KZSgpLE5jPTIsamE9MCxtYT0hMSxFPW51bGwsZmI9bnVsbCxKPTAscT1udWxsLFA9bnVsbCxuYT1udWxsLGZhPW51bGwsYmE9bnVsbCxnYj0hMSxMYj0hMSxMYz0hMSxvYT1udWxsLE09bnVsbCxoYj0hMSxHYT0hMSxwYT1udWxsLE9iPTAsT2M9ITEsUGI9ITEsUGM9bnVsbCxpYj1udWxsLGthPSExLE5iPSExLERnPTFFMyxNYj0wLEZnPTE7cmV0dXJue2NvbXB1dGVBc3luY0V4cGlyYXRpb246bixjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOnksXG5zY2hlZHVsZVdvcms6dSxiYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhLGIpe3ZhciBjPWthO2thPSEwO3RyeXtyZXR1cm4gYShiKX1maW5hbGx5eyhrYT1jKXx8R2F8fEkoMSxudWxsKX19LHVuYmF0Y2hlZFVwZGF0ZXM6ZnVuY3Rpb24oYSl7aWYoa2EmJiFOYil7TmI9ITA7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtOYj0hMX19cmV0dXJuIGEoKX0sZmx1c2hTeW5jOmZ1bmN0aW9uKGEpe3ZhciBiPWthO2thPSEwO3RyeXthOnt2YXIgYz1qYTtqYT0xO3RyeXt2YXIgZD1hKCk7YnJlYWsgYX1maW5hbGx5e2phPWN9ZD12b2lkIDB9cmV0dXJuIGR9ZmluYWxseXtrYT1iLEdhP0QoXCIxODdcIik6dm9pZCAwLEkoMSxudWxsKX19LGRlZmVycmVkVXBkYXRlczpmdW5jdGlvbihhKXt2YXIgYj1qYTtqYT1uKCk7dHJ5e3JldHVybiBhKCl9ZmluYWxseXtqYT1ifX19fVxuZnVuY3Rpb24gamYoYSl7ZnVuY3Rpb24gYihhKXthPWpkKGEpO3JldHVybiBudWxsPT09YT9udWxsOmEuc3RhdGVOb2RlfXZhciBjPWEuZ2V0UHVibGljSW5zdGFuY2U7YT1oZihhKTt2YXIgZD1hLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sZT1hLmNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsZj1hLnNjaGVkdWxlV29yaztyZXR1cm57Y3JlYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7dmFyIGM9bmV3IFkoMyxudWxsLDApO2E9e2N1cnJlbnQ6Yyxjb250YWluZXJJbmZvOmEscGVuZGluZ0NoaWxkcmVuOm51bGwscmVtYWluaW5nRXhwaXJhdGlvblRpbWU6MCxpc1JlYWR5Rm9yQ29tbWl0OiExLGZpbmlzaGVkV29yazpudWxsLGNvbnRleHQ6bnVsbCxwZW5kaW5nQ29udGV4dDpudWxsLGh5ZHJhdGU6YixuZXh0U2NoZWR1bGVkUm9vdDpudWxsfTtyZXR1cm4gYy5zdGF0ZU5vZGU9YX0sdXBkYXRlQ29udGFpbmVyOmZ1bmN0aW9uKGEsYixjLHIpe3ZhciBnPWIuY3VycmVudDtpZihjKXtjPVxuYy5fcmVhY3RJbnRlcm5hbEZpYmVyO3ZhciBoO2I6ezI9PT1mZChjKSYmMj09PWMudGFnP3ZvaWQgMDpEKFwiMTcwXCIpO2ZvcihoPWM7MyE9PWgudGFnOyl7aWYoZ2UoaCkpe2g9aC5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7YnJlYWsgYn0oaD1oW1wicmV0dXJuXCJdKT92b2lkIDA6RChcIjE3MVwiKX1oPWguc3RhdGVOb2RlLmNvbnRleHR9Yz1nZShjKT9rZShjLGgpOmh9ZWxzZSBjPUM7bnVsbD09PWIuY29udGV4dD9iLmNvbnRleHQ9YzpiLnBlbmRpbmdDb250ZXh0PWM7Yj1yO2I9dm9pZCAwPT09Yj9udWxsOmI7cj1udWxsIT1hJiZudWxsIT1hLnR5cGUmJm51bGwhPWEudHlwZS5wcm90b3R5cGUmJiEwPT09YS50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQ/ZCgpOmUoZyk7Q2UoZyx7ZXhwaXJhdGlvblRpbWU6cixwYXJ0aWFsU3RhdGU6e2VsZW1lbnQ6YX0sY2FsbGJhY2s6Yixpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsXG5uZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtmKGcscil9LGJhdGNoZWRVcGRhdGVzOmEuYmF0Y2hlZFVwZGF0ZXMsdW5iYXRjaGVkVXBkYXRlczphLnVuYmF0Y2hlZFVwZGF0ZXMsZGVmZXJyZWRVcGRhdGVzOmEuZGVmZXJyZWRVcGRhdGVzLGZsdXNoU3luYzphLmZsdXNoU3luYyxnZXRQdWJsaWNSb290SW5zdGFuY2U6ZnVuY3Rpb24oYSl7YT1hLmN1cnJlbnQ7aWYoIWEuY2hpbGQpcmV0dXJuIG51bGw7c3dpdGNoKGEuY2hpbGQudGFnKXtjYXNlIDU6cmV0dXJuIGMoYS5jaGlsZC5zdGF0ZU5vZGUpO2RlZmF1bHQ6cmV0dXJuIGEuY2hpbGQuc3RhdGVOb2RlfX0sZmluZEhvc3RJbnN0YW5jZTpiLGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzOmZ1bmN0aW9uKGEpe2E9a2QoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9LGluamVjdEludG9EZXZUb29sczpmdW5jdGlvbihhKXt2YXIgYz1hLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO3JldHVybiB4ZShBKHt9LFxuYSx7ZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6ZnVuY3Rpb24oYSl7cmV0dXJuIGIoYSl9LGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBjP2MoYSk6bnVsbH19KSl9fX12YXIga2Y9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpqZn0pLGxmPWtmJiZqZnx8a2YsbWY9bGZbXCJkZWZhdWx0XCJdP2xmW1wiZGVmYXVsdFwiXTpsZixuZj1cIm9iamVjdFwiPT09dHlwZW9mIHBlcmZvcm1hbmNlJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgcGVyZm9ybWFuY2Uubm93LG9mPXZvaWQgMDtvZj1uZj9mdW5jdGlvbigpe3JldHVybiBwZXJmb3JtYW5jZS5ub3coKX06ZnVuY3Rpb24oKXtyZXR1cm4gRGF0ZS5ub3coKX07dmFyIHBmPXZvaWQgMDtcbmlmKG0uY2FuVXNlRE9NKWlmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrKXt2YXIgcWY9bnVsbCxyZj0hMSxzZj0hMSx0Zj0wLHVmPTMzLHZmPTMzLHdmO3dmPW5mP3t0aW1lUmVtYWluaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRmLXBlcmZvcm1hbmNlLm5vdygpfX06e3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGYtRGF0ZS5ub3coKX19O3ZhciB4Zj1cIl9fcmVhY3RJZGxlQ2FsbGJhY2skXCIrTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7d2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsZnVuY3Rpb24oYSl7YS5zb3VyY2U9PT13aW5kb3cmJmEuZGF0YT09PXhmJiYocmY9ITEsYT1xZixxZj1udWxsLG51bGwhPT1hJiZhKHdmKSl9LCExKTt2YXIgeWY9ZnVuY3Rpb24oYSl7c2Y9ITE7dmFyIGI9YS10Zit2ZjtiPHZmJiZ1Zjx2Zj8oOD5iJiYoYj04KSx2Zj1iPHVmP3VmOmIpOnVmPWI7dGY9YSt2ZjtyZnx8KHJmPSEwLFxud2luZG93LnBvc3RNZXNzYWdlKHhmLFwiKlwiKSl9O3BmPWZ1bmN0aW9uKGEpe3FmPWE7c2Z8fChzZj0hMCxyZXF1ZXN0QW5pbWF0aW9uRnJhbWUoeWYpKTtyZXR1cm4gMH19ZWxzZSBwZj1yZXF1ZXN0SWRsZUNhbGxiYWNrO2Vsc2UgcGY9ZnVuY3Rpb24oYSl7c2V0VGltZW91dChmdW5jdGlvbigpe2Eoe3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gSW5maW5pdHl9fSl9KTtyZXR1cm4gMH07XG52YXIgemY9L15bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdWzpBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKiQvLEFmPXt9LEJmPXt9O2Z1bmN0aW9uIENmKGEpe2lmKEJmLmhhc093blByb3BlcnR5KGEpKXJldHVybiEwO2lmKEFmLmhhc093blByb3BlcnR5KGEpKXJldHVybiExO2lmKHpmLnRlc3QoYSkpcmV0dXJuIEJmW2FdPSEwO0FmW2FdPSEwO3JldHVybiExfVxuZnVuY3Rpb24gRGYoYSxiLGMpe3ZhciBkPXVhKGIpO2lmKGQmJnRhKGIsYykpe3ZhciBlPWQubXV0YXRpb25NZXRob2Q7ZT9lKGEsYyk6bnVsbD09Y3x8ZC5oYXNCb29sZWFuVmFsdWUmJiFjfHxkLmhhc051bWVyaWNWYWx1ZSYmaXNOYU4oYyl8fGQuaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUmJjE+Y3x8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMT09PWM/RWYoYSxiKTpkLm11c3RVc2VQcm9wZXJ0eT9hW2QucHJvcGVydHlOYW1lXT1jOihiPWQuYXR0cmlidXRlTmFtZSwoZT1kLmF0dHJpYnV0ZU5hbWVzcGFjZSk/YS5zZXRBdHRyaWJ1dGVOUyhlLGIsXCJcIitjKTpkLmhhc0Jvb2xlYW5WYWx1ZXx8ZC5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlJiYhMD09PWM/YS5zZXRBdHRyaWJ1dGUoYixcIlwiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWVsc2UgRmYoYSxiLHRhKGIsYyk/YzpudWxsKX1cbmZ1bmN0aW9uIEZmKGEsYixjKXtDZihiKSYmKG51bGw9PWM/YS5yZW1vdmVBdHRyaWJ1dGUoYik6YS5zZXRBdHRyaWJ1dGUoYixcIlwiK2MpKX1mdW5jdGlvbiBFZihhLGIpe3ZhciBjPXVhKGIpO2M/KGI9Yy5tdXRhdGlvbk1ldGhvZCk/YihhLHZvaWQgMCk6Yy5tdXN0VXNlUHJvcGVydHk/YVtjLnByb3BlcnR5TmFtZV09Yy5oYXNCb29sZWFuVmFsdWU/ITE6XCJcIjphLnJlbW92ZUF0dHJpYnV0ZShjLmF0dHJpYnV0ZU5hbWUpOmEucmVtb3ZlQXR0cmlidXRlKGIpfVxuZnVuY3Rpb24gR2YoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9Yi5jaGVja2VkO3JldHVybiBBKHt0eXBlOnZvaWQgMCxzdGVwOnZvaWQgMCxtaW46dm9pZCAwLG1heDp2b2lkIDB9LGIse2RlZmF1bHRDaGVja2VkOnZvaWQgMCxkZWZhdWx0VmFsdWU6dm9pZCAwLHZhbHVlOm51bGwhPWM/YzphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLGNoZWNrZWQ6bnVsbCE9ZD9kOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZH0pfWZ1bmN0aW9uIEhmKGEsYil7dmFyIGM9Yi5kZWZhdWx0VmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsQ2hlY2tlZDpudWxsIT1iLmNoZWNrZWQ/Yi5jaGVja2VkOmIuZGVmYXVsdENoZWNrZWQsaW5pdGlhbFZhbHVlOm51bGwhPWIudmFsdWU/Yi52YWx1ZTpjLGNvbnRyb2xsZWQ6XCJjaGVja2JveFwiPT09Yi50eXBlfHxcInJhZGlvXCI9PT1iLnR5cGU/bnVsbCE9Yi5jaGVja2VkOm51bGwhPWIudmFsdWV9fVxuZnVuY3Rpb24gSWYoYSxiKXt2YXIgYz1iLmNoZWNrZWQ7bnVsbCE9YyYmRGYoYSxcImNoZWNrZWRcIixjfHwhMSk7Yz1iLnZhbHVlO2lmKG51bGwhPWMpaWYoMD09PWMmJlwiXCI9PT1hLnZhbHVlKWEudmFsdWU9XCIwXCI7ZWxzZSBpZihcIm51bWJlclwiPT09Yi50eXBlKXtpZihiPXBhcnNlRmxvYXQoYS52YWx1ZSl8fDAsYyE9Ynx8Yz09YiYmYS52YWx1ZSE9YylhLnZhbHVlPVwiXCIrY31lbHNlIGEudmFsdWUhPT1cIlwiK2MmJihhLnZhbHVlPVwiXCIrYyk7ZWxzZSBudWxsPT1iLnZhbHVlJiZudWxsIT1iLmRlZmF1bHRWYWx1ZSYmYS5kZWZhdWx0VmFsdWUhPT1cIlwiK2IuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9XCJcIitiLmRlZmF1bHRWYWx1ZSksbnVsbD09Yi5jaGVja2VkJiZudWxsIT1iLmRlZmF1bHRDaGVja2VkJiYoYS5kZWZhdWx0Q2hlY2tlZD0hIWIuZGVmYXVsdENoZWNrZWQpfVxuZnVuY3Rpb24gSmYoYSxiKXtzd2l0Y2goYi50eXBlKXtjYXNlIFwic3VibWl0XCI6Y2FzZSBcInJlc2V0XCI6YnJlYWs7Y2FzZSBcImNvbG9yXCI6Y2FzZSBcImRhdGVcIjpjYXNlIFwiZGF0ZXRpbWVcIjpjYXNlIFwiZGF0ZXRpbWUtbG9jYWxcIjpjYXNlIFwibW9udGhcIjpjYXNlIFwidGltZVwiOmNhc2UgXCJ3ZWVrXCI6YS52YWx1ZT1cIlwiO2EudmFsdWU9YS5kZWZhdWx0VmFsdWU7YnJlYWs7ZGVmYXVsdDphLnZhbHVlPWEudmFsdWV9Yj1hLm5hbWU7XCJcIiE9PWImJihhLm5hbWU9XCJcIik7YS5kZWZhdWx0Q2hlY2tlZD0hYS5kZWZhdWx0Q2hlY2tlZDthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO1wiXCIhPT1iJiYoYS5uYW1lPWIpfWZ1bmN0aW9uIEtmKGEpe3ZhciBiPVwiXCI7YWEuQ2hpbGRyZW4uZm9yRWFjaChhLGZ1bmN0aW9uKGEpe251bGw9PWF8fFwic3RyaW5nXCIhPT10eXBlb2YgYSYmXCJudW1iZXJcIiE9PXR5cGVvZiBhfHwoYis9YSl9KTtyZXR1cm4gYn1cbmZ1bmN0aW9uIExmKGEsYil7YT1BKHtjaGlsZHJlbjp2b2lkIDB9LGIpO2lmKGI9S2YoYi5jaGlsZHJlbikpYS5jaGlsZHJlbj1iO3JldHVybiBhfWZ1bmN0aW9uIE1mKGEsYixjLGQpe2E9YS5vcHRpb25zO2lmKGIpe2I9e307Zm9yKHZhciBlPTA7ZTxjLmxlbmd0aDtlKyspYltcIiRcIitjW2VdXT0hMDtmb3IoYz0wO2M8YS5sZW5ndGg7YysrKWU9Yi5oYXNPd25Qcm9wZXJ0eShcIiRcIithW2NdLnZhbHVlKSxhW2NdLnNlbGVjdGVkIT09ZSYmKGFbY10uc2VsZWN0ZWQ9ZSksZSYmZCYmKGFbY10uZGVmYXVsdFNlbGVjdGVkPSEwKX1lbHNle2M9XCJcIitjO2I9bnVsbDtmb3IoZT0wO2U8YS5sZW5ndGg7ZSsrKXtpZihhW2VdLnZhbHVlPT09Yyl7YVtlXS5zZWxlY3RlZD0hMDtkJiYoYVtlXS5kZWZhdWx0U2VsZWN0ZWQ9ITApO3JldHVybn1udWxsIT09Ynx8YVtlXS5kaXNhYmxlZHx8KGI9YVtlXSl9bnVsbCE9PWImJihiLnNlbGVjdGVkPSEwKX19XG5mdW5jdGlvbiBOZihhLGIpe3ZhciBjPWIudmFsdWU7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6bnVsbCE9Yz9jOmIuZGVmYXVsdFZhbHVlLHdhc011bHRpcGxlOiEhYi5tdWx0aXBsZX19ZnVuY3Rpb24gT2YoYSxiKXtudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0QoXCI5MVwiKTp2b2lkIDA7cmV0dXJuIEEoe30sYix7dmFsdWU6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsY2hpbGRyZW46XCJcIithLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlfSl9ZnVuY3Rpb24gUGYoYSxiKXt2YXIgYz1iLnZhbHVlLGQ9YztudWxsPT1jJiYoYz1iLmRlZmF1bHRWYWx1ZSxiPWIuY2hpbGRyZW4sbnVsbCE9YiYmKG51bGwhPWM/RChcIjkyXCIpOnZvaWQgMCxBcnJheS5pc0FycmF5KGIpJiYoMT49Yi5sZW5ndGg/dm9pZCAwOkQoXCI5M1wiKSxiPWJbMF0pLGM9XCJcIitiKSxudWxsPT1jJiYoYz1cIlwiKSxkPWMpO2EuX3dyYXBwZXJTdGF0ZT17aW5pdGlhbFZhbHVlOlwiXCIrZH19XG5mdW5jdGlvbiBRZihhLGIpe3ZhciBjPWIudmFsdWU7bnVsbCE9YyYmKGM9XCJcIitjLGMhPT1hLnZhbHVlJiYoYS52YWx1ZT1jKSxudWxsPT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWMpKTtudWxsIT1iLmRlZmF1bHRWYWx1ZSYmKGEuZGVmYXVsdFZhbHVlPWIuZGVmYXVsdFZhbHVlKX1mdW5jdGlvbiBSZihhKXt2YXIgYj1hLnRleHRDb250ZW50O2I9PT1hLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlJiYoYS52YWx1ZT1iKX12YXIgU2Y9e2h0bWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCIsbWF0aG1sOlwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiLHN2ZzpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJ9O1xuZnVuY3Rpb24gVGYoYSl7c3dpdGNoKGEpe2Nhc2UgXCJzdmdcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI7Y2FzZSBcIm1hdGhcIjpyZXR1cm5cImh0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUxcIjtkZWZhdWx0OnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwifX1mdW5jdGlvbiBVZihhLGIpe3JldHVybiBudWxsPT1hfHxcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIj09PWE/VGYoYik6XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPT09YSYmXCJmb3JlaWduT2JqZWN0XCI9PT1iP1wiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiOmF9XG52YXIgVmY9dm9pZCAwLFdmPWZ1bmN0aW9uKGEpe3JldHVyblwidW5kZWZpbmVkXCIhPT10eXBlb2YgTVNBcHAmJk1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uP2Z1bmN0aW9uKGIsYyxkLGUpe01TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uKCl7cmV0dXJuIGEoYixjLGQsZSl9KX06YX0oZnVuY3Rpb24oYSxiKXtpZihhLm5hbWVzcGFjZVVSSSE9PVNmLnN2Z3x8XCJpbm5lckhUTUxcImluIGEpYS5pbm5lckhUTUw9YjtlbHNle1ZmPVZmfHxkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1ZmLmlubmVySFRNTD1cIlxceDNjc3ZnXFx4M2VcIitiK1wiXFx4M2Mvc3ZnXFx4M2VcIjtmb3IoYj1WZi5maXJzdENoaWxkO2EuZmlyc3RDaGlsZDspYS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpO2Zvcig7Yi5maXJzdENoaWxkOylhLmFwcGVuZENoaWxkKGIuZmlyc3RDaGlsZCl9fSksWGY9L1tcIicmPD5dLztcbmZ1bmN0aW9uIFlmKGEsYil7aWYoYil7dmFyIGM9YS5maXJzdENoaWxkO2lmKGMmJmM9PT1hLmxhc3RDaGlsZCYmMz09PWMubm9kZVR5cGUpe2Mubm9kZVZhbHVlPWI7cmV0dXJufX1hLnRleHRDb250ZW50PWJ9XG5tLmNhblVzZURPTSYmKFwidGV4dENvbnRlbnRcImluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudHx8KFlmPWZ1bmN0aW9uKGEsYil7aWYoMz09PWEubm9kZVR5cGUpYS5ub2RlVmFsdWU9YjtlbHNle2lmKFwiYm9vbGVhblwiPT09dHlwZW9mIGJ8fFwibnVtYmVyXCI9PT10eXBlb2YgYiliPVwiXCIrYjtlbHNle2I9XCJcIitiO3ZhciBjPVhmLmV4ZWMoYik7aWYoYyl7dmFyIGQ9XCJcIixlLGY9MDtmb3IoZT1jLmluZGV4O2U8Yi5sZW5ndGg7ZSsrKXtzd2l0Y2goYi5jaGFyQ29kZUF0KGUpKXtjYXNlIDM0OmM9XCJcXHgyNnF1b3Q7XCI7YnJlYWs7Y2FzZSAzODpjPVwiXFx4MjZhbXA7XCI7YnJlYWs7Y2FzZSAzOTpjPVwiXFx4MjYjeDI3O1wiO2JyZWFrO2Nhc2UgNjA6Yz1cIlxceDI2bHQ7XCI7YnJlYWs7Y2FzZSA2MjpjPVwiXFx4MjZndDtcIjticmVhaztkZWZhdWx0OmNvbnRpbnVlfWYhPT1lJiYoZCs9Yi5zdWJzdHJpbmcoZixlKSk7Zj1lKzE7ZCs9Y31iPWYhPT1lP2QrYi5zdWJzdHJpbmcoZixlKTpkfX1XZihhLGIpfX0pKTtcbnZhciBaZj1ZZiwkZj17YW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ITAsYm9yZGVySW1hZ2VPdXRzZXQ6ITAsYm9yZGVySW1hZ2VTbGljZTohMCxib3JkZXJJbWFnZVdpZHRoOiEwLGJveEZsZXg6ITAsYm94RmxleEdyb3VwOiEwLGJveE9yZGluYWxHcm91cDohMCxjb2x1bW5Db3VudDohMCxjb2x1bW5zOiEwLGZsZXg6ITAsZmxleEdyb3c6ITAsZmxleFBvc2l0aXZlOiEwLGZsZXhTaHJpbms6ITAsZmxleE5lZ2F0aXZlOiEwLGZsZXhPcmRlcjohMCxncmlkUm93OiEwLGdyaWRSb3dFbmQ6ITAsZ3JpZFJvd1NwYW46ITAsZ3JpZFJvd1N0YXJ0OiEwLGdyaWRDb2x1bW46ITAsZ3JpZENvbHVtbkVuZDohMCxncmlkQ29sdW1uU3BhbjohMCxncmlkQ29sdW1uU3RhcnQ6ITAsZm9udFdlaWdodDohMCxsaW5lQ2xhbXA6ITAsbGluZUhlaWdodDohMCxvcGFjaXR5OiEwLG9yZGVyOiEwLG9ycGhhbnM6ITAsdGFiU2l6ZTohMCx3aWRvd3M6ITAsekluZGV4OiEwLHpvb206ITAsZmlsbE9wYWNpdHk6ITAsXG5mbG9vZE9wYWNpdHk6ITAsc3RvcE9wYWNpdHk6ITAsc3Ryb2tlRGFzaGFycmF5OiEwLHN0cm9rZURhc2hvZmZzZXQ6ITAsc3Ryb2tlTWl0ZXJsaW1pdDohMCxzdHJva2VPcGFjaXR5OiEwLHN0cm9rZVdpZHRoOiEwfSxhZz1bXCJXZWJraXRcIixcIm1zXCIsXCJNb3pcIixcIk9cIl07T2JqZWN0LmtleXMoJGYpLmZvckVhY2goZnVuY3Rpb24oYSl7YWcuZm9yRWFjaChmdW5jdGlvbihiKXtiPWIrYS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSthLnN1YnN0cmluZygxKTskZltiXT0kZlthXX0pfSk7XG5mdW5jdGlvbiBiZyhhLGIpe2E9YS5zdHlsZTtmb3IodmFyIGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpKXt2YXIgZD0wPT09Yy5pbmRleE9mKFwiLS1cIik7dmFyIGU9Yzt2YXIgZj1iW2NdO2U9bnVsbD09Znx8XCJib29sZWFuXCI9PT10eXBlb2YgZnx8XCJcIj09PWY/XCJcIjpkfHxcIm51bWJlclwiIT09dHlwZW9mIGZ8fDA9PT1mfHwkZi5oYXNPd25Qcm9wZXJ0eShlKSYmJGZbZV0/KFwiXCIrZikudHJpbSgpOmYrXCJweFwiO1wiZmxvYXRcIj09PWMmJihjPVwiY3NzRmxvYXRcIik7ZD9hLnNldFByb3BlcnR5KGMsZSk6YVtjXT1lfX12YXIgY2c9QSh7bWVudWl0ZW06ITB9LHthcmVhOiEwLGJhc2U6ITAsYnI6ITAsY29sOiEwLGVtYmVkOiEwLGhyOiEwLGltZzohMCxpbnB1dDohMCxrZXlnZW46ITAsbGluazohMCxtZXRhOiEwLHBhcmFtOiEwLHNvdXJjZTohMCx0cmFjazohMCx3YnI6ITB9KTtcbmZ1bmN0aW9uIGRnKGEsYixjKXtiJiYoY2dbYV0mJihudWxsIT1iLmNoaWxkcmVufHxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MP0QoXCIxMzdcIixhLGMoKSk6dm9pZCAwKSxudWxsIT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiYobnVsbCE9Yi5jaGlsZHJlbj9EKFwiNjBcIik6dm9pZCAwLFwib2JqZWN0XCI9PT10eXBlb2YgYi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJfX2h0bWxcImluIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/dm9pZCAwOkQoXCI2MVwiKSksbnVsbCE9Yi5zdHlsZSYmXCJvYmplY3RcIiE9PXR5cGVvZiBiLnN0eWxlP0QoXCI2MlwiLGMoKSk6dm9pZCAwKX1cbmZ1bmN0aW9uIGVnKGEsYil7aWYoLTE9PT1hLmluZGV4T2YoXCItXCIpKXJldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYi5pcztzd2l0Y2goYSl7Y2FzZSBcImFubm90YXRpb24teG1sXCI6Y2FzZSBcImNvbG9yLXByb2ZpbGVcIjpjYXNlIFwiZm9udC1mYWNlXCI6Y2FzZSBcImZvbnQtZmFjZS1zcmNcIjpjYXNlIFwiZm9udC1mYWNlLXVyaVwiOmNhc2UgXCJmb250LWZhY2UtZm9ybWF0XCI6Y2FzZSBcImZvbnQtZmFjZS1uYW1lXCI6Y2FzZSBcIm1pc3NpbmctZ2x5cGhcIjpyZXR1cm4hMTtkZWZhdWx0OnJldHVybiEwfX12YXIgZmc9U2YuaHRtbCxnZz1CLnRoYXRSZXR1cm5zKFwiXCIpO1xuZnVuY3Rpb24gaGcoYSxiKXthPTk9PT1hLm5vZGVUeXBlfHwxMT09PWEubm9kZVR5cGU/YTphLm93bmVyRG9jdW1lbnQ7dmFyIGM9Q2QoYSk7Yj1RYVtiXTtmb3IodmFyIGQ9MDtkPGIubGVuZ3RoO2QrKyl7dmFyIGU9YltkXTtjLmhhc093blByb3BlcnR5KGUpJiZjW2VdfHwoXCJ0b3BXaGVlbFwiPT09ZT94YyhcIndoZWVsXCIpP1UoXCJ0b3BXaGVlbFwiLFwid2hlZWxcIixhKTp4YyhcIm1vdXNld2hlZWxcIik/VShcInRvcFdoZWVsXCIsXCJtb3VzZXdoZWVsXCIsYSk6VShcInRvcFdoZWVsXCIsXCJET01Nb3VzZVNjcm9sbFwiLGEpOlwidG9wU2Nyb2xsXCI9PT1lP3JkKFwidG9wU2Nyb2xsXCIsXCJzY3JvbGxcIixhKTpcInRvcEZvY3VzXCI9PT1lfHxcInRvcEJsdXJcIj09PWU/KHJkKFwidG9wRm9jdXNcIixcImZvY3VzXCIsYSkscmQoXCJ0b3BCbHVyXCIsXCJibHVyXCIsYSksYy50b3BCbHVyPSEwLGMudG9wRm9jdXM9ITApOlwidG9wQ2FuY2VsXCI9PT1lPyh4YyhcImNhbmNlbFwiLCEwKSYmcmQoXCJ0b3BDYW5jZWxcIixcImNhbmNlbFwiLGEpLGMudG9wQ2FuY2VsPVxuITApOlwidG9wQ2xvc2VcIj09PWU/KHhjKFwiY2xvc2VcIiwhMCkmJnJkKFwidG9wQ2xvc2VcIixcImNsb3NlXCIsYSksYy50b3BDbG9zZT0hMCk6eWQuaGFzT3duUHJvcGVydHkoZSkmJlUoZSx5ZFtlXSxhKSxjW2VdPSEwKX19XG52YXIgaWc9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BDYW5QbGF5OlwiY2FucGxheVwiLHRvcENhblBsYXlUaHJvdWdoOlwiY2FucGxheXRocm91Z2hcIix0b3BEdXJhdGlvbkNoYW5nZTpcImR1cmF0aW9uY2hhbmdlXCIsdG9wRW1wdGllZDpcImVtcHRpZWRcIix0b3BFbmNyeXB0ZWQ6XCJlbmNyeXB0ZWRcIix0b3BFbmRlZDpcImVuZGVkXCIsdG9wRXJyb3I6XCJlcnJvclwiLHRvcExvYWRlZERhdGE6XCJsb2FkZWRkYXRhXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BWb2x1bWVDaGFuZ2U6XCJ2b2x1bWVjaGFuZ2VcIixcbnRvcFdhaXRpbmc6XCJ3YWl0aW5nXCJ9O2Z1bmN0aW9uIGpnKGEsYixjLGQpe2M9OT09PWMubm9kZVR5cGU/YzpjLm93bmVyRG9jdW1lbnQ7ZD09PWZnJiYoZD1UZihhKSk7ZD09PWZnP1wic2NyaXB0XCI9PT1hPyhhPWMuY3JlYXRlRWxlbWVudChcImRpdlwiKSxhLmlubmVySFRNTD1cIlxceDNjc2NyaXB0XFx4M2VcXHgzYy9zY3JpcHRcXHgzZVwiLGE9YS5yZW1vdmVDaGlsZChhLmZpcnN0Q2hpbGQpKTphPVwic3RyaW5nXCI9PT10eXBlb2YgYi5pcz9jLmNyZWF0ZUVsZW1lbnQoYSx7aXM6Yi5pc30pOmMuY3JlYXRlRWxlbWVudChhKTphPWMuY3JlYXRlRWxlbWVudE5TKGQsYSk7cmV0dXJuIGF9ZnVuY3Rpb24ga2coYSxiKXtyZXR1cm4oOT09PWIubm9kZVR5cGU/YjpiLm93bmVyRG9jdW1lbnQpLmNyZWF0ZVRleHROb2RlKGEpfVxuZnVuY3Rpb24gb2coYSxiLGMsZCl7dmFyIGU9ZWcoYixjKTtzd2l0Y2goYil7Y2FzZSBcImlmcmFtZVwiOmNhc2UgXCJvYmplY3RcIjpVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO3ZhciBmPWM7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKGYgaW4gaWcpaWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixpZ1tmXSxhKTtmPWM7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImltZ1wiOmNhc2UgXCJpbWFnZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTtVKFwidG9wTG9hZFwiLFwibG9hZFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTtmPWM7YnJlYWs7Y2FzZSBcImlucHV0XCI6SGYoYSxjKTtmPUdmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtcbmhnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwib3B0aW9uXCI6Zj1MZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpOZihhLGMpO2Y9QSh7fSxjLHt2YWx1ZTp2b2lkIDB9KTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2hnKGQsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpQZihhLGMpO2Y9T2YoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2hnKGQsXCJvbkNoYW5nZVwiKTticmVhaztkZWZhdWx0OmY9Y31kZyhiLGYsZ2cpO3ZhciBnPWYsaztmb3IoayBpbiBnKWlmKGcuaGFzT3duUHJvcGVydHkoaykpe3ZhciBoPWdba107XCJzdHlsZVwiPT09az9iZyhhLGgsZ2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWs/KGg9aD9oLl9faHRtbDp2b2lkIDAsbnVsbCE9aCYmV2YoYSxoKSk6XCJjaGlsZHJlblwiPT09az9cInN0cmluZ1wiPT09dHlwZW9mIGg/KFwidGV4dGFyZWFcIiE9PWJ8fFwiXCIhPT1oKSYmWmYoYSxoKTpcIm51bWJlclwiPT09dHlwZW9mIGgmJlpmKGEsXG5cIlwiK2gpOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1rJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ayYmXCJhdXRvRm9jdXNcIiE9PWsmJihQYS5oYXNPd25Qcm9wZXJ0eShrKT9udWxsIT1oJiZoZyhkLGspOmU/RmYoYSxrLGgpOm51bGwhPWgmJkRmKGEsayxoKSl9c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkFjKGEpO0pmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QWMoYSk7UmYoYSxjKTticmVhaztjYXNlIFwib3B0aW9uXCI6bnVsbCE9Yy52YWx1ZSYmYS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLGMudmFsdWUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLm11bHRpcGxlPSEhYy5tdWx0aXBsZTtiPWMudmFsdWU7bnVsbCE9Yj9NZihhLCEhYy5tdWx0aXBsZSxiLCExKTpudWxsIT1jLmRlZmF1bHRWYWx1ZSYmTWYoYSwhIWMubXVsdGlwbGUsYy5kZWZhdWx0VmFsdWUsITApO2JyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGYub25DbGljayYmKGEub25jbGljaz1cbkIpfX1cbmZ1bmN0aW9uIHBnKGEsYixjLGQsZSl7dmFyIGY9bnVsbDtzd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6Yz1HZihhLGMpO2Q9R2YoYSxkKTtmPVtdO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpjPUxmKGEsYyk7ZD1MZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmM9QSh7fSxjLHt2YWx1ZTp2b2lkIDB9KTtkPUEoe30sZCx7dmFsdWU6dm9pZCAwfSk7Zj1bXTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpjPU9mKGEsYyk7ZD1PZihhLGQpO2Y9W107YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCIhPT10eXBlb2YgYy5vbkNsaWNrJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgZC5vbkNsaWNrJiYoYS5vbmNsaWNrPUIpfWRnKGIsZCxnZyk7dmFyIGcsazthPW51bGw7Zm9yKGcgaW4gYylpZighZC5oYXNPd25Qcm9wZXJ0eShnKSYmYy5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9Y1tnXSlpZihcInN0eWxlXCI9PT1nKWZvcihrIGluIGI9Y1tnXSxiKWIuaGFzT3duUHJvcGVydHkoaykmJihhfHwoYT17fSksYVtrXT1cblwiXCIpO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCIhPT1nJiZcImNoaWxkcmVuXCIhPT1nJiZcInN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZ1wiIT09ZyYmXCJzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmdcIiE9PWcmJlwiYXV0b0ZvY3VzXCIhPT1nJiYoUGEuaGFzT3duUHJvcGVydHkoZyk/Znx8KGY9W10pOihmPWZ8fFtdKS5wdXNoKGcsbnVsbCkpO2ZvcihnIGluIGQpe3ZhciBoPWRbZ107Yj1udWxsIT1jP2NbZ106dm9pZCAwO2lmKGQuaGFzT3duUHJvcGVydHkoZykmJmghPT1iJiYobnVsbCE9aHx8bnVsbCE9YikpaWYoXCJzdHlsZVwiPT09ZylpZihiKXtmb3IoayBpbiBiKSFiLmhhc093blByb3BlcnR5KGspfHxoJiZoLmhhc093blByb3BlcnR5KGspfHwoYXx8KGE9e30pLGFba109XCJcIik7Zm9yKGsgaW4gaCloLmhhc093blByb3BlcnR5KGspJiZiW2tdIT09aFtrXSYmKGF8fChhPXt9KSxhW2tdPWhba10pfWVsc2UgYXx8KGZ8fChmPVtdKSxmLnB1c2goZyxhKSksYT1oO2Vsc2VcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1cbmc/KGg9aD9oLl9faHRtbDp2b2lkIDAsYj1iP2IuX19odG1sOnZvaWQgMCxudWxsIT1oJiZiIT09aCYmKGY9Znx8W10pLnB1c2goZyxcIlwiK2gpKTpcImNoaWxkcmVuXCI9PT1nP2I9PT1ofHxcInN0cmluZ1wiIT09dHlwZW9mIGgmJlwibnVtYmVyXCIhPT10eXBlb2YgaHx8KGY9Znx8W10pLnB1c2goZyxcIlwiK2gpOlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmKFBhLmhhc093blByb3BlcnR5KGcpPyhudWxsIT1oJiZoZyhlLGcpLGZ8fGI9PT1ofHwoZj1bXSkpOihmPWZ8fFtdKS5wdXNoKGcsaCkpfWEmJihmPWZ8fFtdKS5wdXNoKFwic3R5bGVcIixhKTtyZXR1cm4gZn1cbmZ1bmN0aW9uIHFnKGEsYixjLGQsZSl7ZWcoYyxkKTtkPWVnKGMsZSk7Zm9yKHZhciBmPTA7ZjxiLmxlbmd0aDtmKz0yKXt2YXIgZz1iW2ZdLGs9YltmKzFdO1wic3R5bGVcIj09PWc/YmcoYSxrLGdnKTpcImRhbmdlcm91c2x5U2V0SW5uZXJIVE1MXCI9PT1nP1dmKGEsayk6XCJjaGlsZHJlblwiPT09Zz9aZihhLGspOmQ/bnVsbCE9az9GZihhLGcsayk6YS5yZW1vdmVBdHRyaWJ1dGUoZyk6bnVsbCE9az9EZihhLGcsayk6RWYoYSxnKX1zd2l0Y2goYyl7Y2FzZSBcImlucHV0XCI6SWYoYSxlKTtCYyhhKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpRZihhLGUpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjphLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlPXZvaWQgMCxiPWEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZSxhLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU9ISFlLm11bHRpcGxlLGM9ZS52YWx1ZSxudWxsIT1jP01mKGEsISFlLm11bHRpcGxlLGMsITEpOmIhPT0hIWUubXVsdGlwbGUmJihudWxsIT1cbmUuZGVmYXVsdFZhbHVlP01mKGEsISFlLm11bHRpcGxlLGUuZGVmYXVsdFZhbHVlLCEwKTpNZihhLCEhZS5tdWx0aXBsZSxlLm11bHRpcGxlP1tdOlwiXCIsITEpKX19XG5mdW5jdGlvbiByZyhhLGIsYyxkLGUpe3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcInZpZGVvXCI6Y2FzZSBcImF1ZGlvXCI6Zm9yKHZhciBmIGluIGlnKWlnLmhhc093blByb3BlcnR5KGYpJiZVKGYsaWdbZl0sYSk7YnJlYWs7Y2FzZSBcInNvdXJjZVwiOlUoXCJ0b3BFcnJvclwiLFwiZXJyb3JcIixhKTticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7YnJlYWs7Y2FzZSBcImZvcm1cIjpVKFwidG9wUmVzZXRcIixcInJlc2V0XCIsYSk7VShcInRvcFN1Ym1pdFwiLFwic3VibWl0XCIsYSk7YnJlYWs7Y2FzZSBcImRldGFpbHNcIjpVKFwidG9wVG9nZ2xlXCIsXCJ0b2dnbGVcIixhKTticmVhaztjYXNlIFwiaW5wdXRcIjpIZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7aGcoZSxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpOZihhLGMpO1xuVShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtoZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6UGYoYSxjKSxVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpLGhnKGUsXCJvbkNoYW5nZVwiKX1kZyhiLGMsZ2cpO2Q9bnVsbDtmb3IodmFyIGcgaW4gYyljLmhhc093blByb3BlcnR5KGcpJiYoZj1jW2ddLFwiY2hpbGRyZW5cIj09PWc/XCJzdHJpbmdcIj09PXR5cGVvZiBmP2EudGV4dENvbnRlbnQhPT1mJiYoZD1bXCJjaGlsZHJlblwiLGZdKTpcIm51bWJlclwiPT09dHlwZW9mIGYmJmEudGV4dENvbnRlbnQhPT1cIlwiK2YmJihkPVtcImNoaWxkcmVuXCIsXCJcIitmXSk6UGEuaGFzT3duUHJvcGVydHkoZykmJm51bGwhPWYmJmhnKGUsZykpO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpBYyhhKTtKZihhLGMpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOkFjKGEpO1JmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJvcHRpb25cIjpicmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIj09PXR5cGVvZiBjLm9uQ2xpY2smJlxuKGEub25jbGljaz1CKX1yZXR1cm4gZH1mdW5jdGlvbiBzZyhhLGIpe3JldHVybiBhLm5vZGVWYWx1ZSE9PWJ9XG52YXIgdGc9T2JqZWN0LmZyZWV6ZSh7Y3JlYXRlRWxlbWVudDpqZyxjcmVhdGVUZXh0Tm9kZTprZyxzZXRJbml0aWFsUHJvcGVydGllczpvZyxkaWZmUHJvcGVydGllczpwZyx1cGRhdGVQcm9wZXJ0aWVzOnFnLGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6cmcsZGlmZkh5ZHJhdGVkVGV4dDpzZyx3YXJuRm9yVW5tYXRjaGVkVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDpmdW5jdGlvbigpe30sd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDpmdW5jdGlvbigpe30sd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6ZnVuY3Rpb24oKXt9LHJlc3RvcmVDb250cm9sbGVkU3RhdGU6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpJZihhLGMpO2I9Yy5uYW1lO2lmKFwicmFkaW9cIj09PWMudHlwZSYmbnVsbCE9Yil7Zm9yKGM9YTtjLnBhcmVudE5vZGU7KWM9XG5jLnBhcmVudE5vZGU7Yz1jLnF1ZXJ5U2VsZWN0b3JBbGwoXCJpbnB1dFtuYW1lXFx4M2RcIitKU09OLnN0cmluZ2lmeShcIlwiK2IpKyddW3R5cGVcXHgzZFwicmFkaW9cIl0nKTtmb3IoYj0wO2I8Yy5sZW5ndGg7YisrKXt2YXIgZD1jW2JdO2lmKGQhPT1hJiZkLmZvcm09PT1hLmZvcm0pe3ZhciBlPXJiKGQpO2U/dm9pZCAwOkQoXCI5MFwiKTtJZihkLGUpfX19YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6UWYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Yj1jLnZhbHVlLG51bGwhPWImJk1mKGEsISFjLm11bHRpcGxlLGIsITEpfX19KTttYy5pbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50KHRnKTt2YXIgR2c9bnVsbCxIZz1udWxsO2Z1bmN0aW9uIElnKGEpe3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlJiY5IT09YS5ub2RlVHlwZSYmMTEhPT1hLm5vZGVUeXBlJiYoOCE9PWEubm9kZVR5cGV8fFwiIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlIFwiIT09YS5ub2RlVmFsdWUpKX1cbmZ1bmN0aW9uIEpnKGEpe2E9YT85PT09YS5ub2RlVHlwZT9hLmRvY3VtZW50RWxlbWVudDphLmZpcnN0Q2hpbGQ6bnVsbDtyZXR1cm4hKCFhfHwxIT09YS5ub2RlVHlwZXx8IWEuaGFzQXR0cmlidXRlKFwiZGF0YS1yZWFjdHJvb3RcIikpfVxudmFyIFo9bWYoe2dldFJvb3RIb3N0Q29udGV4dDpmdW5jdGlvbihhKXt2YXIgYj1hLm5vZGVUeXBlO3N3aXRjaChiKXtjYXNlIDk6Y2FzZSAxMTphPShhPWEuZG9jdW1lbnRFbGVtZW50KT9hLm5hbWVzcGFjZVVSSTpVZihudWxsLFwiXCIpO2JyZWFrO2RlZmF1bHQ6Yj04PT09Yj9hLnBhcmVudE5vZGU6YSxhPWIubmFtZXNwYWNlVVJJfHxudWxsLGI9Yi50YWdOYW1lLGE9VWYoYSxiKX1yZXR1cm4gYX0sZ2V0Q2hpbGRIb3N0Q29udGV4dDpmdW5jdGlvbihhLGIpe3JldHVybiBVZihhLGIpfSxnZXRQdWJsaWNJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gYX0scHJlcGFyZUZvckNvbW1pdDpmdW5jdGlvbigpe0dnPW9kO3ZhciBhPWRhKCk7aWYoRmQoYSkpe2lmKFwic2VsZWN0aW9uU3RhcnRcImluIGEpdmFyIGI9e3N0YXJ0OmEuc2VsZWN0aW9uU3RhcnQsZW5kOmEuc2VsZWN0aW9uRW5kfTtlbHNlIGE6e3ZhciBjPXdpbmRvdy5nZXRTZWxlY3Rpb24mJndpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbmlmKGMmJjAhPT1jLnJhbmdlQ291bnQpe2I9Yy5hbmNob3JOb2RlO3ZhciBkPWMuYW5jaG9yT2Zmc2V0LGU9Yy5mb2N1c05vZGU7Yz1jLmZvY3VzT2Zmc2V0O3RyeXtiLm5vZGVUeXBlLGUubm9kZVR5cGV9Y2F0Y2goeCl7Yj1udWxsO2JyZWFrIGF9dmFyIGY9MCxnPS0xLGs9LTEsaD0wLHI9MCxuPWEseT1udWxsO2I6Zm9yKDs7KXtmb3IodmFyIHU7Oyl7biE9PWJ8fDAhPT1kJiYzIT09bi5ub2RlVHlwZXx8KGc9ZitkKTtuIT09ZXx8MCE9PWMmJjMhPT1uLm5vZGVUeXBlfHwoaz1mK2MpOzM9PT1uLm5vZGVUeXBlJiYoZis9bi5ub2RlVmFsdWUubGVuZ3RoKTtpZihudWxsPT09KHU9bi5maXJzdENoaWxkKSlicmVhazt5PW47bj11fWZvcig7Oyl7aWYobj09PWEpYnJlYWsgYjt5PT09YiYmKytoPT09ZCYmKGc9Zik7eT09PWUmJisrcj09PWMmJihrPWYpO2lmKG51bGwhPT0odT1uLm5leHRTaWJsaW5nKSlicmVhaztuPXk7eT1uLnBhcmVudE5vZGV9bj11fWI9LTE9PT1nfHwtMT09PWs/bnVsbDpcbntzdGFydDpnLGVuZDprfX1lbHNlIGI9bnVsbH1iPWJ8fHtzdGFydDowLGVuZDowfX1lbHNlIGI9bnVsbDtIZz17Zm9jdXNlZEVsZW06YSxzZWxlY3Rpb25SYW5nZTpifTtwZCghMSl9LHJlc2V0QWZ0ZXJDb21taXQ6ZnVuY3Rpb24oKXt2YXIgYT1IZyxiPWRhKCksYz1hLmZvY3VzZWRFbGVtLGQ9YS5zZWxlY3Rpb25SYW5nZTtpZihiIT09YyYmaGEoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LGMpKXtpZihGZChjKSlpZihiPWQuc3RhcnQsYT1kLmVuZCx2b2lkIDA9PT1hJiYoYT1iKSxcInNlbGVjdGlvblN0YXJ0XCJpbiBjKWMuc2VsZWN0aW9uU3RhcnQ9YixjLnNlbGVjdGlvbkVuZD1NYXRoLm1pbihhLGMudmFsdWUubGVuZ3RoKTtlbHNlIGlmKHdpbmRvdy5nZXRTZWxlY3Rpb24pe2I9d2luZG93LmdldFNlbGVjdGlvbigpO3ZhciBlPWNbRGIoKV0ubGVuZ3RoO2E9TWF0aC5taW4oZC5zdGFydCxlKTtkPXZvaWQgMD09PWQuZW5kP2E6TWF0aC5taW4oZC5lbmQsZSk7IWIuZXh0ZW5kJiZhPlxuZCYmKGU9ZCxkPWEsYT1lKTtlPUVkKGMsYSk7dmFyIGY9RWQoYyxkKTtpZihlJiZmJiYoMSE9PWIucmFuZ2VDb3VudHx8Yi5hbmNob3JOb2RlIT09ZS5ub2RlfHxiLmFuY2hvck9mZnNldCE9PWUub2Zmc2V0fHxiLmZvY3VzTm9kZSE9PWYubm9kZXx8Yi5mb2N1c09mZnNldCE9PWYub2Zmc2V0KSl7dmFyIGc9ZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtnLnNldFN0YXJ0KGUubm9kZSxlLm9mZnNldCk7Yi5yZW1vdmVBbGxSYW5nZXMoKTthPmQ/KGIuYWRkUmFuZ2UoZyksYi5leHRlbmQoZi5ub2RlLGYub2Zmc2V0KSk6KGcuc2V0RW5kKGYubm9kZSxmLm9mZnNldCksYi5hZGRSYW5nZShnKSl9fWI9W107Zm9yKGE9YzthPWEucGFyZW50Tm9kZTspMT09PWEubm9kZVR5cGUmJmIucHVzaCh7ZWxlbWVudDphLGxlZnQ6YS5zY3JvbGxMZWZ0LHRvcDphLnNjcm9sbFRvcH0pO2lhKGMpO2ZvcihjPTA7YzxiLmxlbmd0aDtjKyspYT1iW2NdLGEuZWxlbWVudC5zY3JvbGxMZWZ0PWEubGVmdCxhLmVsZW1lbnQuc2Nyb2xsVG9wPVxuYS50b3B9SGc9bnVsbDtwZChHZyk7R2c9bnVsbH0sY3JlYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlKXthPWpnKGEsYixjLGQpO2FbT109ZTthW29iXT1iO3JldHVybiBhfSxhcHBlbmRJbml0aWFsQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjpmdW5jdGlvbihhLGIsYyxkKXtvZyhhLGIsYyxkKTthOntzd2l0Y2goYil7Y2FzZSBcImJ1dHRvblwiOmNhc2UgXCJpbnB1dFwiOmNhc2UgXCJzZWxlY3RcIjpjYXNlIFwidGV4dGFyZWFcIjphPSEhYy5hdXRvRm9jdXM7YnJlYWsgYX1hPSExfXJldHVybiBhfSxwcmVwYXJlVXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7cmV0dXJuIHBnKGEsYixjLGQsZSl9LHNob3VsZFNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEsYil7cmV0dXJuXCJ0ZXh0YXJlYVwiPT09YXx8XCJzdHJpbmdcIj09PXR5cGVvZiBiLmNoaWxkcmVufHxcIm51bWJlclwiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwib2JqZWN0XCI9PT1cbnR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZudWxsIT09Yi5kYW5nZXJvdXNseVNldElubmVySFRNTCYmXCJzdHJpbmdcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbH0sc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTpmdW5jdGlvbihhLGIpe3JldHVybiEhYi5oaWRkZW59LGNyZWF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkKXthPWtnKGEsYik7YVtPXT1kO3JldHVybiBhfSxub3c6b2YsbXV0YXRpb246e2NvbW1pdE1vdW50OmZ1bmN0aW9uKGEpe2EuZm9jdXMoKX0sY29tbWl0VXBkYXRlOmZ1bmN0aW9uKGEsYixjLGQsZSl7YVtvYl09ZTtxZyhhLGIsYyxkLGUpfSxyZXNldFRleHRDb250ZW50OmZ1bmN0aW9uKGEpe2EudGV4dENvbnRlbnQ9XCJcIn0sY29tbWl0VGV4dFVwZGF0ZTpmdW5jdGlvbihhLGIsYyl7YS5ub2RlVmFsdWU9Y30sYXBwZW5kQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLmFwcGVuZENoaWxkKGIpfSxhcHBlbmRDaGlsZFRvQ29udGFpbmVyOmZ1bmN0aW9uKGEsXG5iKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYSk6YS5hcHBlbmRDaGlsZChiKX0saW5zZXJ0QmVmb3JlOmZ1bmN0aW9uKGEsYixjKXthLmluc2VydEJlZm9yZShiLGMpfSxpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTpmdW5jdGlvbihhLGIsYyl7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShiLGMpOmEuaW5zZXJ0QmVmb3JlKGIsYyl9LHJlbW92ZUNoaWxkOmZ1bmN0aW9uKGEsYil7YS5yZW1vdmVDaGlsZChiKX0scmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOmZ1bmN0aW9uKGEsYil7OD09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGIpOmEucmVtb3ZlQ2hpbGQoYil9fSxoeWRyYXRpb246e2Nhbkh5ZHJhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIpe3JldHVybiAxPT09YS5ub2RlVHlwZSYmYi50b0xvd2VyQ2FzZSgpPT09YS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpfSxjYW5IeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXtyZXR1cm5cIlwiPT09Yj8hMTozPT09YS5ub2RlVHlwZX0sZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nOmZ1bmN0aW9uKGEpe2ZvcihhPWEubmV4dFNpYmxpbmc7YSYmMSE9PWEubm9kZVR5cGUmJjMhPT1hLm5vZGVUeXBlOylhPWEubmV4dFNpYmxpbmc7cmV0dXJuIGF9LGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOmZ1bmN0aW9uKGEpe2ZvcihhPWEuZmlyc3RDaGlsZDthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0saHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXthW09dPWY7YVtvYl09YztyZXR1cm4gcmcoYSxiLGMsZSxkKX0saHlkcmF0ZVRleHRJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyl7YVtPXT1jO3JldHVybiBzZyhhLGIpfSxkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxcbmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90SHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbigpe30sZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9fSxzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2s6cGYsdXNlU3luY1NjaGVkdWxpbmc6ITB9KTtxYz1aLmJhdGNoZWRVcGRhdGVzO1xuZnVuY3Rpb24gS2coYSxiLGMsZCxlKXtJZyhjKT92b2lkIDA6RChcIjIwMFwiKTt2YXIgZj1jLl9yZWFjdFJvb3RDb250YWluZXI7aWYoZilaLnVwZGF0ZUNvbnRhaW5lcihiLGYsYSxlKTtlbHNle2Q9ZHx8SmcoYyk7aWYoIWQpZm9yKGY9dm9pZCAwO2Y9Yy5sYXN0Q2hpbGQ7KWMucmVtb3ZlQ2hpbGQoZik7dmFyIGc9Wi5jcmVhdGVDb250YWluZXIoYyxkKTtmPWMuX3JlYWN0Um9vdENvbnRhaW5lcj1nO1oudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe1oudXBkYXRlQ29udGFpbmVyKGIsZyxhLGUpfSl9cmV0dXJuIFouZ2V0UHVibGljUm9vdEluc3RhbmNlKGYpfWZ1bmN0aW9uIExnKGEsYil7dmFyIGM9Mjxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbMl0/YXJndW1lbnRzWzJdOm51bGw7SWcoYik/dm9pZCAwOkQoXCIyMDBcIik7cmV0dXJuIE9lKGEsYixudWxsLGMpfVxuZnVuY3Rpb24gTWcoYSxiKXt0aGlzLl9yZWFjdFJvb3RDb250YWluZXI9Wi5jcmVhdGVDb250YWluZXIoYSxiKX1NZy5wcm90b3R5cGUucmVuZGVyPWZ1bmN0aW9uKGEsYil7Wi51cGRhdGVDb250YWluZXIoYSx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxiKX07TWcucHJvdG90eXBlLnVubW91bnQ9ZnVuY3Rpb24oYSl7Wi51cGRhdGVDb250YWluZXIobnVsbCx0aGlzLl9yZWFjdFJvb3RDb250YWluZXIsbnVsbCxhKX07XG52YXIgTmc9e2NyZWF0ZVBvcnRhbDpMZyxmaW5kRE9NTm9kZTpmdW5jdGlvbihhKXtpZihudWxsPT1hKXJldHVybiBudWxsO2lmKDE9PT1hLm5vZGVUeXBlKXJldHVybiBhO3ZhciBiPWEuX3JlYWN0SW50ZXJuYWxGaWJlcjtpZihiKXJldHVybiBaLmZpbmRIb3N0SW5zdGFuY2UoYik7XCJmdW5jdGlvblwiPT09dHlwZW9mIGEucmVuZGVyP0QoXCIxODhcIik6RChcIjIxM1wiLE9iamVjdC5rZXlzKGEpKX0saHlkcmF0ZTpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIEtnKG51bGwsYSxiLCEwLGMpfSxyZW5kZXI6ZnVuY3Rpb24oYSxiLGMpe3JldHVybiBLZyhudWxsLGEsYiwhMSxjKX0sdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6ZnVuY3Rpb24oYSxiLGMsZCl7bnVsbD09YXx8dm9pZCAwPT09YS5fcmVhY3RJbnRlcm5hbEZpYmVyP0QoXCIzOFwiKTp2b2lkIDA7cmV0dXJuIEtnKGEsYixjLCExLGQpfSx1bm1vdW50Q29tcG9uZW50QXROb2RlOmZ1bmN0aW9uKGEpe0lnKGEpP3ZvaWQgMDpcbkQoXCI0MFwiKTtyZXR1cm4gYS5fcmVhY3RSb290Q29udGFpbmVyPyhaLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24oKXtLZyhudWxsLG51bGwsYSwhMSxmdW5jdGlvbigpe2EuX3JlYWN0Um9vdENvbnRhaW5lcj1udWxsfSl9KSwhMCk6ITF9LHVuc3RhYmxlX2NyZWF0ZVBvcnRhbDpMZyx1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczpzYyx1bnN0YWJsZV9kZWZlcnJlZFVwZGF0ZXM6Wi5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOlouZmx1c2hTeW5jLF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOntFdmVudFBsdWdpbkh1YjptYixFdmVudFBsdWdpblJlZ2lzdHJ5OlRhLEV2ZW50UHJvcGFnYXRvcnM6QmIsUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OnBjLFJlYWN0RE9NQ29tcG9uZW50VHJlZTpzYixSZWFjdERPTUV2ZW50TGlzdGVuZXI6c2R9fTtcblouaW5qZWN0SW50b0RldlRvb2xzKHtmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTpwYixidW5kbGVUeXBlOjAsdmVyc2lvbjpcIjE2LjEuMFwiLHJlbmRlcmVyUGFja2FnZU5hbWU6XCJyZWFjdC1kb21cIn0pO3ZhciBPZz1PYmplY3QuZnJlZXplKHtkZWZhdWx0Ok5nfSksUGc9T2cmJk5nfHxPZzttb2R1bGUuZXhwb3J0cz1QZ1tcImRlZmF1bHRcIl0/UGdbXCJkZWZhdWx0XCJdOlBnO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIGlzTm9kZSA9IHJlcXVpcmUoJy4vaXNOb2RlJyk7XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gdGV4dCBub2RlLlxuICovXG5mdW5jdGlvbiBpc1RleHROb2RlKG9iamVjdCkge1xuICByZXR1cm4gaXNOb2RlKG9iamVjdCkgJiYgb2JqZWN0Lm5vZGVUeXBlID09IDM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNUZXh0Tm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaXNUZXh0Tm9kZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbi8qKlxuICogQHBhcmFtIHsqfSBvYmplY3QgVGhlIG9iamVjdCB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgb3Igbm90IHRoZSBvYmplY3QgaXMgYSBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICB2YXIgZG9jID0gb2JqZWN0ID8gb2JqZWN0Lm93bmVyRG9jdW1lbnQgfHwgb2JqZWN0IDogZG9jdW1lbnQ7XG4gIHZhciBkZWZhdWx0VmlldyA9IGRvYy5kZWZhdWx0VmlldyB8fCB3aW5kb3c7XG4gIHJldHVybiAhIShvYmplY3QgJiYgKHR5cGVvZiBkZWZhdWx0Vmlldy5Ob2RlID09PSAnZnVuY3Rpb24nID8gb2JqZWN0IGluc3RhbmNlb2YgZGVmYXVsdFZpZXcuTm9kZSA6IHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvYmplY3Qubm9kZVR5cGUgPT09ICdudW1iZXInICYmIHR5cGVvZiBvYmplY3Qubm9kZU5hbWUgPT09ICdzdHJpbmcnKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEuMFxuICogcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBfYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24kMSA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBFdmVudExpc3RlbmVyID0gcmVxdWlyZSgnZmJqcy9saWIvRXZlbnRMaXN0ZW5lcicpO1xudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgncHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcycpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIGNhbWVsaXplU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUnKTtcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbiFSZWFjdCA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0RE9NIHdhcyBsb2FkZWQgYmVmb3JlIFJlYWN0LiBNYWtlIHN1cmUgeW91IGxvYWQgdGhlIFJlYWN0IHBhY2thZ2UgYmVmb3JlIGxvYWRpbmcgUmVhY3RET00uJykgOiB2b2lkIDA7XG5cbi8vIFRoZXNlIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGFsbCBsb3dlcmNhc2UgdG8gYWxsb3cgZm9yXG4vLyBjYXNlIGluc2Vuc2l0aXZlIGNoZWNrc1xudmFyIFJFU0VSVkVEX1BST1BTID0ge1xuICBjaGlsZHJlbjogdHJ1ZSxcbiAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gIGRlZmF1bHRWYWx1ZTogdHJ1ZSxcbiAgZGVmYXVsdENoZWNrZWQ6IHRydWUsXG4gIGlubmVySFRNTDogdHJ1ZSxcbiAgc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nOiB0cnVlLFxuICBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6IHRydWUsXG4gIHN0eWxlOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9QUk9QRVJUWTogMHgxLFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg0LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHg4LFxuICBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTogMHgxMCB8IDB4OCxcbiAgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRTogMHgyMCxcbiAgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIFByb3BlcnRpZXM6IG9iamVjdCBtYXBwaW5nIERPTSBwcm9wZXJ0eSBuYW1lIHRvIG9uZSBvZiB0aGVcbiAgICogRE9NUHJvcGVydHlJbmplY3Rpb24gY29uc3RhbnRzIG9yIG51bGwuIElmIHlvdXIgYXR0cmlidXRlIGlzbid0IGluIGhlcmUsXG4gICAqIGl0IHdvbid0IGdldCB3cml0dGVuIHRvIHRoZSBET00uXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lLiBBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlICoqbG93ZXJjYXNlKipcbiAgICogbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiBvYmplY3QgbWFwcGluZyBSZWFjdCBhdHRyaWJ1dGUgbmFtZSB0byB0aGUgRE9NXG4gICAqIGF0dHJpYnV0ZSBuYW1lc3BhY2UgVVJMLiAoQXR0cmlidXRlIG5hbWVzIG5vdCBzcGVjaWZpZWQgdXNlIG5vIG5hbWVzcGFjZS4pXG4gICAqXG4gICAqIERPTVByb3BlcnR5TmFtZXM6IHNpbWlsYXIgdG8gRE9NQXR0cmlidXRlTmFtZXMgYnV0IGZvciBET00gcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbm90IHNwZWNpZmllZCB1c2UgdGhlIG5vcm1hbGl6ZWQgbmFtZS5cbiAgICpcbiAgICogRE9NTXV0YXRpb25NZXRob2RzOiBQcm9wZXJ0aWVzIHRoYXQgcmVxdWlyZSBzcGVjaWFsIG11dGF0aW9uIG1ldGhvZHMuIElmXG4gICAqIGB2YWx1ZWAgaXMgdW5kZWZpbmVkLCB0aGUgbXV0YXRpb24gbWV0aG9kIHNob3VsZCB1bnNldCB0aGUgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBkb21Qcm9wZXJ0eUNvbmZpZyB0aGUgY29uZmlnIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICovXG4gIGluamVjdERPTVByb3BlcnR5Q29uZmlnOiBmdW5jdGlvbiAoZG9tUHJvcGVydHlDb25maWcpIHtcbiAgICB2YXIgSW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG4gICAgdmFyIFByb3BlcnRpZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5Qcm9wZXJ0aWVzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lc3BhY2VzID0gZG9tUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNwYWNlcyB8fCB7fTtcbiAgICB2YXIgRE9NQXR0cmlidXRlTmFtZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IGludmFyaWFudChmYWxzZSwgXCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3UncmUgdHJ5aW5nIHRvIGluamVjdCBET00gcHJvcGVydHkgJyVzJyB3aGljaCBoYXMgYWxyZWFkeSBiZWVuIGluamVjdGVkLiBZb3UgbWF5IGJlIGFjY2lkZW50YWxseSBpbmplY3RpbmcgdGhlIHNhbWUgRE9NIHByb3BlcnR5IGNvbmZpZyB0d2ljZSwgb3IgeW91IG1heSBiZSBpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLlwiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZVByb3BlcnR5OiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNTdHJpbmdCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFKVxuICAgICAgfTtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgXCJET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yIG51bWVyaWMgdmFsdWUsIGJ1dCBub3QgYSBjb21iaW5hdGlvbjogJXNcIiwgcHJvcE5hbWUpIDogdm9pZCAwO1xuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gRE9NQXR0cmlidXRlTmFtZXNbcHJvcE5hbWVdO1xuXG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lc3BhY2UgPSBET01BdHRyaWJ1dGVOYW1lc3BhY2VzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgaWYgKERPTU11dGF0aW9uTWV0aG9kcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kID0gRE9NTXV0YXRpb25NZXRob2RzW3Byb3BOYW1lXTtcbiAgICAgIH1cblxuICAgICAgLy8gRG93bmNhc2UgcmVmZXJlbmNlcyB0byB3aGl0ZWxpc3QgcHJvcGVydGllcyB0byBjaGVjayBmb3IgbWVtYmVyc2hpcFxuICAgICAgLy8gd2l0aG91dCBjYXNlLXNlbnNpdGl2aXR5LiBUaGlzIGFsbG93cyB0aGUgd2hpdGVsaXN0IHRvIHBpY2sgdXBcbiAgICAgIC8vIGBhbGxvd2Z1bGxzY3JlZW5gLCB3aGljaCBzaG91bGQgYmUgd3JpdHRlbiB1c2luZyB0aGUgcHJvcGVydHkgY29uZmlndXJhdGlvblxuICAgICAgLy8gZm9yIGBhbGxvd0Z1bGxzY3JlZW5gXG4gICAgICBwcm9wZXJ0aWVzW3Byb3BOYW1lXSA9IHByb3BlcnR5SW5mbztcbiAgICB9XG4gIH1cbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSID0gXCI6QS1aX2EtelxcXFx1MDBDMC1cXFxcdTAwRDZcXFxcdTAwRDgtXFxcXHUwMEY2XFxcXHUwMEY4LVxcXFx1MDJGRlxcXFx1MDM3MC1cXFxcdTAzN0RcXFxcdTAzN0YtXFxcXHUxRkZGXFxcXHUyMDBDLVxcXFx1MjAwRFxcXFx1MjA3MC1cXFxcdTIxOEZcXFxcdTJDMDAtXFxcXHUyRkVGXFxcXHUzMDAxLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkZEXCI7XG4vKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cbnZhciBBVFRSSUJVVEVfTkFNRV9DSEFSID0gQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiArIFwiXFxcXC0uMC05XFxcXHUwMEI3XFxcXHUwMzAwLVxcXFx1MDM2RlxcXFx1MjAzRi1cXFxcdTIwNDBcIjtcblxuXG52YXIgUk9PVF9BVFRSSUJVVEVfTkFNRSA9ICdkYXRhLXJlYWN0cm9vdCc7XG5cbi8qKlxuICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gKiB0aGUgcHJvcGVydHkgaW4gdGhlIERPTS4gRWFjaCBvYmplY3QgY29udGFpbnM6XG4gKlxuICogYXR0cmlidXRlTmFtZTpcbiAqICAgVXNlZCB3aGVuIHJlbmRlcmluZyBtYXJrdXAgb3Igd2l0aCBgKkF0dHJpYnV0ZSgpYC5cbiAqIGF0dHJpYnV0ZU5hbWVzcGFjZVxuICogcHJvcGVydHlOYW1lOlxuICogICBVc2VkIG9uIERPTSBub2RlIGluc3RhbmNlcy4gKFRoaXMgaW5jbHVkZXMgcHJvcGVydGllcyB0aGF0IG11dGF0ZSBkdWUgdG9cbiAqICAgZXh0ZXJuYWwgZmFjdG9ycy4pXG4gKiBtdXRhdGlvbk1ldGhvZDpcbiAqICAgSWYgbm9uLW51bGwsIHVzZWQgaW5zdGVhZCBvZiB0aGUgcHJvcGVydHkgb3IgYHNldEF0dHJpYnV0ZSgpYCBhZnRlclxuICogICBpbml0aWFsIHJlbmRlci5cbiAqIG11c3RVc2VQcm9wZXJ0eTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gKiBoYXNCb29sZWFuVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzTnVtZXJpY1ZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBudW1lcmljIGFuZCBzaG91bGQgYmVcbiAqICAgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIHBvc2l0aXZlIG51bWVyaWMgb3IgcGFyc2UgYXMgYSBwb3NpdGl2ZVxuICogICBudW1lcmljIGFuZCBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IGNhbiBiZSB1c2VkIGFzIGEgZmxhZyBhcyB3ZWxsIGFzIHdpdGggYSB2YWx1ZS5cbiAqICAgUmVtb3ZlZCB3aGVuIHN0cmljdGx5IGVxdWFsIHRvIGZhbHNlOyBwcmVzZW50IHdpdGhvdXQgYSB2YWx1ZSB3aGVuXG4gKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAqL1xudmFyIHByb3BlcnRpZXMgPSB7fTtcblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSB3cml0ZWFibGUgYXR0cmlidXRlLlxuICogQG1ldGhvZFxuICovXG5mdW5jdGlvbiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgaWYgKGlzUmVzZXJ2ZWRQcm9wKG5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChuYW1lLmxlbmd0aCA+IDIgJiYgKG5hbWVbMF0gPT09ICdvJyB8fCBuYW1lWzBdID09PSAnTycpICYmIChuYW1lWzFdID09PSAnbicgfHwgbmFtZVsxXSA9PT0gJ04nKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKTtcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGZ1bmN0aW9uLCBzeW1ib2xcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRQcm9wZXJ0eUluZm8obmFtZSkge1xuICByZXR1cm4gcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUobmFtZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTtcbiAgfVxuICB2YXIgcHJlZml4ID0gbmFtZS50b0xvd2VyQ2FzZSgpLnNsaWNlKDAsIDUpO1xuICByZXR1cm4gcHJlZml4ID09PSAnZGF0YS0nIHx8IHByZWZpeCA9PT0gJ2FyaWEtJztcbn1cblxuLyoqXG4gKiBDaGVja3MgdG8gc2VlIGlmIGEgcHJvcGVydHkgbmFtZSBpcyB3aXRoaW4gdGhlIGxpc3Qgb2YgcHJvcGVydGllc1xuICogcmVzZXJ2ZWQgZm9yIGludGVybmFsIFJlYWN0IG9wZXJhdGlvbnMuIFRoZXNlIHByb3BlcnRpZXMgc2hvdWxkXG4gKiBub3QgYmUgc2V0IG9uIGFuIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IElmIHRoZSBuYW1lIGlzIHdpdGhpbiByZXNlcnZlZCBwcm9wc1xuICovXG5mdW5jdGlvbiBpc1Jlc2VydmVkUHJvcChuYW1lKSB7XG4gIHJldHVybiBSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbn1cblxudmFyIGluamVjdGlvbiA9IERPTVByb3BlcnR5SW5qZWN0aW9uO1xuXG52YXIgTVVTVF9VU0VfUFJPUEVSVFkgPSBpbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFk7XG52YXIgSEFTX0JPT0xFQU5fVkFMVUUgPSBpbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX05VTUVSSUNfVkFMVUUgPSBpbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUgPSBpbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU7XG52YXIgSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIC8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhpcyBsaXN0LCBiZSBzdXJlIHRvIGFsc28gYWRkIHRoZW0gdG9cbiAgLy8gdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3RcbiAgLy8gbmFtZSB3YXJuaW5ncy5cbiAgUHJvcGVydGllczoge1xuICAgIGFsbG93RnVsbFNjcmVlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0ZvY3VzOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gc3BlY2lmaWVzIHRhcmdldCBjb250ZXh0IGZvciBsaW5rcyB3aXRoIGBwcmVsb2FkYCB0eXBlXG4gICAgYXN5bmM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjaGVja2VkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNvbHM6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbnRlbnRFZGl0YWJsZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFLFxuICAgIGNvbnRyb2xzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAnZGVmYXVsdCc6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRlZmVyOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkaXNhYmxlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZG93bmxvYWQ6IEhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsXG4gICAgZHJhZ2dhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgZm9ybU5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGhpZGRlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG9vcDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gQ2F1dGlvbjsgYG9wdGlvbi5zZWxlY3RlZGAgaXMgbm90IHVwZGF0ZWQgaWYgYHNlbGVjdC5tdWx0aXBsZWAgaXNcbiAgICAvLyBkaXNhYmxlZCB3aXRoIGByZW1vdmVBdHRyaWJ1dGVgLlxuICAgIG11bHRpcGxlOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG11dGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG5vVmFsaWRhdGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIG9wZW46IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHBsYXlzSW5saW5lOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZWFkT25seTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVxdWlyZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJldmVyc2VkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByb3dzOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICByb3dTcGFuOiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlYW1sZXNzOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzZWxlY3RlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBzaXplOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzdGFydDogSEFTX05VTUVSSUNfVkFMVUUsXG4gICAgLy8gc3VwcG9ydCBmb3IgcHJvamVjdGluZyByZWd1bGFyIERPTSBFbGVtZW50cyB2aWEgVjEgbmFtZWQgc2xvdHMgKCBzaGFkb3cgZG9tIClcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gU3R5bGUgbXVzdCBiZSBleHBsaWNpdGx5IHNldCBpbiB0aGUgYXR0cmlidXRlIGxpc3QuIFJlYWN0IGNvbXBvbmVudHNcbiAgICAvLyBleHBlY3QgYSBzdHlsZSBvYmplY3RcbiAgICBzdHlsZTogMCxcbiAgICAvLyBLZWVwIGl0IGluIHRoZSB3aGl0ZWxpc3QgYmVjYXVzZSBpdCBpcyBjYXNlLXNlbnNpdGl2ZSBmb3IgU1ZHLlxuICAgIHRhYkluZGV4OiAwLFxuICAgIC8vIGl0ZW1TY29wZSBpcyBmb3IgZm9yIE1pY3JvZGF0YSBzdXBwb3J0LlxuICAgIC8vIFNlZSBodHRwOi8vc2NoZW1hLm9yZy9kb2NzL2dzLmh0bWxcbiAgICBpdGVtU2NvcGU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIC8vIFRoZXNlIGF0dHJpYnV0ZXMgbXVzdCBzdGF5IGluIHRoZSB3aGl0ZS1saXN0IGJlY2F1c2UgdGhleSBoYXZlXG4gICAgLy8gZGlmZmVyZW50IGF0dHJpYnV0ZSBuYW1lcyAoc2VlIERPTUF0dHJpYnV0ZU5hbWVzIGJlbG93KVxuICAgIGFjY2VwdENoYXJzZXQ6IDAsXG4gICAgY2xhc3NOYW1lOiAwLFxuICAgIGh0bWxGb3I6IDAsXG4gICAgaHR0cEVxdWl2OiAwLFxuICAgIC8vIEF0dHJpYnV0ZXMgd2l0aCBtdXRhdGlvbiBtZXRob2RzIG11c3QgYmUgc3BlY2lmaWVkIGluIHRoZSB3aGl0ZWxpc3RcbiAgICAvLyBTZXQgdGhlIHN0cmluZyBib29sZWFuIGZsYWcgdG8gYWxsb3cgdGhlIGJlaGF2aW9yXG4gICAgdmFsdWU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRVxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGFjY2VwdENoYXJzZXQ6ICdhY2NlcHQtY2hhcnNldCcsXG4gICAgY2xhc3NOYW1lOiAnY2xhc3MnLFxuICAgIGh0bWxGb3I6ICdmb3InLFxuICAgIGh0dHBFcXVpdjogJ2h0dHAtZXF1aXYnXG4gIH0sXG4gIERPTU11dGF0aW9uTWV0aG9kczoge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAobm9kZSwgdmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBub2RlLnJlbW92ZUF0dHJpYnV0ZSgndmFsdWUnKTtcbiAgICAgIH1cblxuICAgICAgLy8gTnVtYmVyIGlucHV0cyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgZHVlIHRvIHNvbWUgZWRnZSBjYXNlcyBpblxuICAgICAgLy8gQ2hyb21lLiBMZXQgZXZlcnl0aGluZyBlbHNlIGFzc2lnbiB0aGUgdmFsdWUgYXR0cmlidXRlIGFzIG5vcm1hbC5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1MyNpc3N1ZWNvbW1lbnQtMjM2MDc0MzI2XG4gICAgICBpZiAobm9kZS50eXBlICE9PSAnbnVtYmVyJyB8fCBub2RlLmhhc0F0dHJpYnV0ZSgndmFsdWUnKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudmFsaWRpdHkgJiYgIW5vZGUudmFsaWRpdHkuYmFkSW5wdXQgJiYgbm9kZS5vd25lckRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IG5vZGUpIHtcbiAgICAgICAgLy8gRG9uJ3QgYXNzaWduIGFuIGF0dHJpYnV0ZSBpZiB2YWxpZGF0aW9uIHJlcG9ydHMgYmFkXG4gICAgICAgIC8vIGlucHV0LiBDaHJvbWUgd2lsbCBjbGVhciB0aGUgdmFsdWUuIEFkZGl0aW9uYWxseSwgZG9uJ3RcbiAgICAgICAgLy8gb3BlcmF0ZSBvbiBpbnB1dHMgdGhhdCBoYXZlIGZvY3VzLCBvdGhlcndpc2UgQ2hyb21lIG1pZ2h0XG4gICAgICAgIC8vIHN0cmlwIG9mZiB0cmFpbGluZyBkZWNpbWFsIHBsYWNlcyBhbmQgY2F1c2UgdGhlIHVzZXInc1xuICAgICAgICAvLyBjdXJzb3IgcG9zaXRpb24gdG8ganVtcCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBpbnB1dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gSW4gUmVhY3RET01JbnB1dCwgd2UgaGF2ZSBhbiBvbkJsdXIgZXZlbnQgdGhhdCB3aWxsIHRyaWdnZXJcbiAgICAgICAgLy8gdGhpcyBmdW5jdGlvbiBhZ2FpbiB3aGVuIGZvY3VzIGlzIGxvc3QuXG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxuXG52YXIgTlMgPSB7XG4gIHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG4gIHhtbDogJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZSdcbn07XG5cbi8qKlxuICogVGhpcyBpcyBhIGxpc3Qgb2YgYWxsIFNWRyBhdHRyaWJ1dGVzIHRoYXQgbmVlZCBzcGVjaWFsIGNhc2luZyxcbiAqIG5hbWVzcGFjaW5nLCBvciBib29sZWFuIHZhbHVlIGFzc2lnbm1lbnQuXG4gKlxuICogV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICogdGhlIGBwb3NzaWJsZVN0YW5kYXJkTmFtZXNgIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3RcbiAqIG5hbWUgd2FybmluZ3MuXG4gKlxuICogU1ZHIEF0dHJpYnV0ZXMgTGlzdDpcbiAqIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9TVkcvYXR0aW5kZXguaHRtbFxuICogU01JTCBTcGVjOlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL3NtaWxcbiAqL1xudmFyIEFUVFJTID0gWydhY2NlbnQtaGVpZ2h0JywgJ2FsaWdubWVudC1iYXNlbGluZScsICdhcmFiaWMtZm9ybScsICdiYXNlbGluZS1zaGlmdCcsICdjYXAtaGVpZ2h0JywgJ2NsaXAtcGF0aCcsICdjbGlwLXJ1bGUnLCAnY29sb3ItaW50ZXJwb2xhdGlvbicsICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnY29sb3ItcHJvZmlsZScsICdjb2xvci1yZW5kZXJpbmcnLCAnZG9taW5hbnQtYmFzZWxpbmUnLCAnZW5hYmxlLWJhY2tncm91bmQnLCAnZmlsbC1vcGFjaXR5JywgJ2ZpbGwtcnVsZScsICdmbG9vZC1jb2xvcicsICdmbG9vZC1vcGFjaXR5JywgJ2ZvbnQtZmFtaWx5JywgJ2ZvbnQtc2l6ZScsICdmb250LXNpemUtYWRqdXN0JywgJ2ZvbnQtc3RyZXRjaCcsICdmb250LXN0eWxlJywgJ2ZvbnQtdmFyaWFudCcsICdmb250LXdlaWdodCcsICdnbHlwaC1uYW1lJywgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnLCAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLCAnaG9yaXotYWR2LXgnLCAnaG9yaXotb3JpZ2luLXgnLCAnaW1hZ2UtcmVuZGVyaW5nJywgJ2xldHRlci1zcGFjaW5nJywgJ2xpZ2h0aW5nLWNvbG9yJywgJ21hcmtlci1lbmQnLCAnbWFya2VyLW1pZCcsICdtYXJrZXItc3RhcnQnLCAnb3ZlcmxpbmUtcG9zaXRpb24nLCAnb3ZlcmxpbmUtdGhpY2tuZXNzJywgJ3BhaW50LW9yZGVyJywgJ3Bhbm9zZS0xJywgJ3BvaW50ZXItZXZlbnRzJywgJ3JlbmRlcmluZy1pbnRlbnQnLCAnc2hhcGUtcmVuZGVyaW5nJywgJ3N0b3AtY29sb3InLCAnc3RvcC1vcGFjaXR5JywgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nLCAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnLCAnc3Ryb2tlLWRhc2hhcnJheScsICdzdHJva2UtZGFzaG9mZnNldCcsICdzdHJva2UtbGluZWNhcCcsICdzdHJva2UtbGluZWpvaW4nLCAnc3Ryb2tlLW1pdGVybGltaXQnLCAnc3Ryb2tlLW9wYWNpdHknLCAnc3Ryb2tlLXdpZHRoJywgJ3RleHQtYW5jaG9yJywgJ3RleHQtZGVjb3JhdGlvbicsICd0ZXh0LXJlbmRlcmluZycsICd1bmRlcmxpbmUtcG9zaXRpb24nLCAndW5kZXJsaW5lLXRoaWNrbmVzcycsICd1bmljb2RlLWJpZGknLCAndW5pY29kZS1yYW5nZScsICd1bml0cy1wZXItZW0nLCAndi1hbHBoYWJldGljJywgJ3YtaGFuZ2luZycsICd2LWlkZW9ncmFwaGljJywgJ3YtbWF0aGVtYXRpY2FsJywgJ3ZlY3Rvci1lZmZlY3QnLCAndmVydC1hZHYteScsICd2ZXJ0LW9yaWdpbi14JywgJ3ZlcnQtb3JpZ2luLXknLCAnd29yZC1zcGFjaW5nJywgJ3dyaXRpbmctbW9kZScsICd4LWhlaWdodCcsICd4bGluazphY3R1YXRlJywgJ3hsaW5rOmFyY3JvbGUnLCAneGxpbms6aHJlZicsICd4bGluazpyb2xlJywgJ3hsaW5rOnNob3cnLCAneGxpbms6dGl0bGUnLCAneGxpbms6dHlwZScsICd4bWw6YmFzZScsICd4bWxuczp4bGluaycsICd4bWw6bGFuZycsICd4bWw6c3BhY2UnXTtcblxudmFyIFNWR0RPTVByb3BlcnR5Q29uZmlnID0ge1xuICBQcm9wZXJ0aWVzOiB7XG4gICAgYXV0b1JldmVyc2U6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxLFxuICAgIGV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQ6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxLFxuICAgIHByZXNlcnZlQWxwaGE6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSQxXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYXV0b1JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogJ2V4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWQnLFxuICAgIHByZXNlcnZlQWxwaGE6ICdwcmVzZXJ2ZUFscGhhJ1xuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lc3BhY2VzOiB7XG4gICAgeGxpbmtBY3R1YXRlOiBOUy54bGluayxcbiAgICB4bGlua0FyY3JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rSHJlZjogTlMueGxpbmssXG4gICAgeGxpbmtSb2xlOiBOUy54bGluayxcbiAgICB4bGlua1Nob3c6IE5TLnhsaW5rLFxuICAgIHhsaW5rVGl0bGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rVHlwZTogTlMueGxpbmssXG4gICAgeG1sQmFzZTogTlMueG1sLFxuICAgIHhtbExhbmc6IE5TLnhtbCxcbiAgICB4bWxTcGFjZTogTlMueG1sXG4gIH1cbn07XG5cbnZhciBDQU1FTElaRSA9IC9bXFwtXFw6XShbYS16XSkvZztcbnZhciBjYXBpdGFsaXplID0gZnVuY3Rpb24gKHRva2VuKSB7XG4gIHJldHVybiB0b2tlblsxXS50b1VwcGVyQ2FzZSgpO1xufTtcblxuQVRUUlMuZm9yRWFjaChmdW5jdGlvbiAob3JpZ2luYWwpIHtcbiAgdmFyIHJlYWN0TmFtZSA9IG9yaWdpbmFsLnJlcGxhY2UoQ0FNRUxJWkUsIGNhcGl0YWxpemUpO1xuXG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXNbcmVhY3ROYW1lXSA9IDA7XG4gIFNWR0RPTVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzW3JlYWN0TmFtZV0gPSBvcmlnaW5hbDtcbn0pO1xuXG5pbmplY3Rpb24uaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhTVkdET01Qcm9wZXJ0eUNvbmZpZyk7XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIC8vIFVzZWQgYnkgRmliZXIgdG8gc2ltdWxhdGUgYSB0cnktY2F0Y2guXG4gIF9jYXVnaHRFcnJvcjogbnVsbCxcbiAgX2hhc0NhdWdodEVycm9yOiBmYWxzZSxcblxuICAvLyBVc2VkIGJ5IGV2ZW50IHN5c3RlbSB0byBjYXB0dXJlL3JldGhyb3cgdGhlIGZpcnN0IGVycm9yLlxuICBfcmV0aHJvd0Vycm9yOiBudWxsLFxuICBfaGFzUmV0aHJvd0Vycm9yOiBmYWxzZSxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFcnJvclV0aWxzOiBmdW5jdGlvbiAoaW5qZWN0ZWRFcnJvclV0aWxzKSB7XG4gICAgICAhKHR5cGVvZiBpbmplY3RlZEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0luamVjdGVkIGludm9rZUd1YXJkZWRDYWxsYmFjaygpIG11c3QgYmUgYSBmdW5jdGlvbi4nKSA6IHZvaWQgMDtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDYWxsIGEgZnVuY3Rpb24gd2hpbGUgZ3VhcmRpbmcgYWdhaW5zdCBlcnJvcnMgdGhhdCBoYXBwZW5zIHdpdGhpbiBpdC5cbiAgICogUmV0dXJucyBhbiBlcnJvciBpZiBpdCB0aHJvd3MsIG90aGVyd2lzZSBudWxsLlxuICAgKlxuICAgKiBJbiBwcm9kdWN0aW9uLCB0aGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgdHJ5LWNhdGNoLiBUaGUgcmVhc29uIHdlIGRvbid0XG4gICAqIHVzZSBhIHRyeS1jYXRjaCBkaXJlY3RseSBpcyBzbyB0aGF0IHdlIGNhbiBzd2FwIG91dCBhIGRpZmZlcmVudFxuICAgKiBpbXBsZW1lbnRhdGlvbiBpbiBERVYgbW9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjay5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNhbWUgYXMgaW52b2tlR3VhcmRlZENhbGxiYWNrLCBidXQgaW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gZXJyb3IsIGl0IHN0b3Jlc1xuICAgKiBpdCBpbiBhIGdsb2JhbCBzbyBpdCBjYW4gYmUgcmV0aHJvd24gYnkgYHJldGhyb3dDYXVnaHRFcnJvcmAgbGF0ZXIuXG4gICAqIFRPRE86IFNlZSBpZiBfY2F1Z2h0RXJyb3IgYW5kIF9yZXRocm93RXJyb3IgY2FuIGJlIHVuaWZpZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIG9mIHRoZSBndWFyZCB0byB1c2UgZm9yIGxvZ2dpbmcgb3IgZGVidWdnaW5nXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGludm9rZVxuICAgKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gdXNlIHdoZW4gY2FsbGluZyB0aGUgZnVuY3Rpb25cbiAgICogQHBhcmFtIHsuLi4qfSBhcmdzIEFyZ3VtZW50cyBmb3IgZnVuY3Rpb25cbiAgICovXG4gIGludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcjogZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgaWYgKCFSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEdXJpbmcgZXhlY3V0aW9uIG9mIGd1YXJkZWQgZnVuY3Rpb25zIHdlIHdpbGwgY2FwdHVyZSB0aGUgZmlyc3QgZXJyb3Igd2hpY2hcbiAgICogd2Ugd2lsbCByZXRocm93IHRvIGJlIGhhbmRsZWQgYnkgdGhlIHRvcCBsZXZlbCBlcnJvciBoYW5kbGVyLlxuICAgKi9cbiAgcmV0aHJvd0NhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJldGhyb3dDYXVnaHRFcnJvci5hcHBseShSZWFjdEVycm9yVXRpbHMsIGFyZ3VtZW50cyk7XG4gIH0sXG5cbiAgaGFzQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcjtcbiAgfSxcblxuICBjbGVhckNhdWdodEVycm9yOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3I7XG4gICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnY2xlYXJDYXVnaHRFcnJvciB3YXMgY2FsbGVkIGJ1dCBubyBlcnJvciB3YXMgY2FwdHVyZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gZnVuY3Rpb24gKG5hbWUsIGZ1bmMsIGNvbnRleHQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgdHJ5IHtcbiAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gIH1cbn07XG5cbntcbiAgLy8gSW4gREVWIG1vZGUsIHdlIHN3YXAgb3V0IGludm9rZUd1YXJkZWRDYWxsYmFjayBmb3IgYSBzcGVjaWFsIHZlcnNpb25cbiAgLy8gdGhhdCBwbGF5cyBtb3JlIG5pY2VseSB3aXRoIHRoZSBicm93c2VyJ3MgRGV2VG9vbHMuIFRoZSBpZGVhIGlzIHRvIHByZXNlcnZlXG4gIC8vIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLiBCZWNhdXNlIFJlYWN0IHdyYXBzIGFsbCB1c2VyLXByb3ZpZGVkXG4gIC8vIGZ1bmN0aW9ucyBpbiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGFuZCB0aGUgcHJvZHVjdGlvbiB2ZXJzaW9uIG9mXG4gIC8vIGludm9rZUd1YXJkZWRDYWxsYmFjayB1c2VzIGEgdHJ5LWNhdGNoLCBhbGwgdXNlciBleGNlcHRpb25zIGFyZSB0cmVhdGVkXG4gIC8vIGxpa2UgY2F1Z2h0IGV4Y2VwdGlvbnMsIGFuZCB0aGUgRGV2VG9vbHMgd29uJ3QgcGF1c2UgdW5sZXNzIHRoZSBkZXZlbG9wZXJcbiAgLy8gdGFrZXMgdGhlIGV4dHJhIHN0ZXAgb2YgZW5hYmxpbmcgcGF1c2Ugb24gY2F1Z2h0IGV4Y2VwdGlvbnMuIFRoaXMgaXNcbiAgLy8gdW50aW50dWl0aXZlLCB0aG91Z2gsIGJlY2F1c2UgZXZlbiB0aG91Z2ggUmVhY3QgaGFzIGNhdWdodCB0aGUgZXJyb3IsIGZyb21cbiAgLy8gdGhlIGRldmVsb3BlcidzIHBlcnNwZWN0aXZlLCB0aGUgZXJyb3IgaXMgdW5jYXVnaHQuXG4gIC8vXG4gIC8vIFRvIHByZXNlcnZlIHRoZSBleHBlY3RlZCBcIlBhdXNlIG9uIGV4Y2VwdGlvbnNcIiBiZWhhdmlvciwgd2UgZG9uJ3QgdXNlIGFcbiAgLy8gdHJ5LWNhdGNoIGluIERFVi4gSW5zdGVhZCwgd2Ugc3luY2hyb25vdXNseSBkaXNwYXRjaCBhIGZha2UgZXZlbnQgdG8gYSBmYWtlXG4gIC8vIERPTSBub2RlLCBhbmQgY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayBmcm9tIGluc2lkZSBhbiBldmVudCBoYW5kbGVyXG4gIC8vIGZvciB0aGF0IGZha2UgZXZlbnQuIElmIHRoZSBjYWxsYmFjayB0aHJvd3MsIHRoZSBlcnJvciBpcyBcImNhcHR1cmVkXCIgdXNpbmdcbiAgLy8gYSBnbG9iYWwgZXZlbnQgaGFuZGxlci4gQnV0IGJlY2F1c2UgdGhlIGVycm9yIGhhcHBlbnMgaW4gYSBkaWZmZXJlbnRcbiAgLy8gZXZlbnQgbG9vcCBjb250ZXh0LCBpdCBkb2VzIG5vdCBpbnRlcnJ1cHQgdGhlIG5vcm1hbCBwcm9ncmFtIGZsb3cuXG4gIC8vIEVmZmVjdGl2ZWx5LCB0aGlzIGdpdmVzIHVzIHRyeS1jYXRjaCBiZWhhdmlvciB3aXRob3V0IGFjdHVhbGx5IHVzaW5nXG4gIC8vIHRyeS1jYXRjaC4gTmVhdCFcblxuICAvLyBDaGVjayB0aGF0IHRoZSBicm93c2VyIHN1cHBvcnRzIHRoZSBBUElzIHdlIG5lZWQgdG8gaW1wbGVtZW50IG91ciBzcGVjaWFsXG4gIC8vIERFViB2ZXJzaW9uIG9mIGludm9rZUd1YXJkZWRDYWxsYmFja1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5kaXNwYXRjaEV2ZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGRvY3VtZW50LmNyZWF0ZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGZha2VOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncmVhY3QnKTtcblxuICAgIHZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgICAgLy8gS2VlcHMgdHJhY2sgb2Ygd2hldGhlciB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjayB0aHJldyBhbiBlcnJvci4gV2VcbiAgICAgIC8vIHNldCB0aGlzIHRvIHRydWUgYXQgdGhlIGJlZ2lubmluZywgdGhlbiBzZXQgaXQgdG8gZmFsc2UgcmlnaHQgYWZ0ZXJcbiAgICAgIC8vIGNhbGxpbmcgdGhlIGZ1bmN0aW9uLiBJZiB0aGUgZnVuY3Rpb24gZXJyb3JzLCBgZGlkRXJyb3JgIHdpbGwgbmV2ZXIgYmVcbiAgICAgIC8vIHNldCB0byBmYWxzZS4gVGhpcyBzdHJhdGVneSB3b3JrcyBldmVuIGlmIHRoZSBicm93c2VyIGlzIGZsYWt5IGFuZFxuICAgICAgLy8gZmFpbHMgdG8gY2FsbCBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIsIGJlY2F1c2UgaXQgZG9lc24ndCByZWx5IG9uXG4gICAgICAvLyB0aGUgZXJyb3IgZXZlbnQgYXQgYWxsLlxuICAgICAgdmFyIGRpZEVycm9yID0gdHJ1ZTtcblxuICAgICAgLy8gQ3JlYXRlIGFuIGV2ZW50IGhhbmRsZXIgZm9yIG91ciBmYWtlIGV2ZW50LiBXZSB3aWxsIHN5bmNocm9ub3VzbHlcbiAgICAgIC8vIGRpc3BhdGNoIG91ciBmYWtlIGV2ZW50IHVzaW5nIGBkaXNwYXRjaEV2ZW50YC4gSW5zaWRlIHRoZSBoYW5kbGVyLCB3ZVxuICAgICAgLy8gY2FsbCB0aGUgdXNlci1wcm92aWRlZCBjYWxsYmFjay5cbiAgICAgIHZhciBmdW5jQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XG4gICAgICBmdW5jdGlvbiBjYWxsQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIFdlIGltbWVkaWF0ZWx5IHJlbW92ZSB0aGUgY2FsbGJhY2sgZnJvbSBldmVudCBsaXN0ZW5lcnMgc28gdGhhdFxuICAgICAgICAvLyBuZXN0ZWQgYGludm9rZUd1YXJkZWRDYWxsYmFja2AgY2FsbHMgZG8gbm90IGNsYXNoLiBPdGhlcndpc2UsIGFcbiAgICAgICAgLy8gbmVzdGVkIGNhbGwgd291bGQgdHJpZ2dlciB0aGUgZmFrZSBldmVudCBoYW5kbGVycyBvZiBhbnkgY2FsbCBoaWdoZXJcbiAgICAgICAgLy8gaW4gdGhlIHN0YWNrLlxuICAgICAgICBmYWtlTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGNhbGxDYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICBmdW5jLmFwcGx5KGNvbnRleHQsIGZ1bmNBcmdzKTtcbiAgICAgICAgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgLy8gQ3JlYXRlIGEgZ2xvYmFsIGVycm9yIGV2ZW50IGhhbmRsZXIuIFdlIHVzZSB0aGlzIHRvIGNhcHR1cmUgdGhlIHZhbHVlXG4gICAgICAvLyB0aGF0IHdhcyB0aHJvd24uIEl0J3MgcG9zc2libGUgdGhhdCB0aGlzIGVycm9yIGhhbmRsZXIgd2lsbCBmaXJlIG1vcmVcbiAgICAgIC8vIHRoYW4gb25jZTsgZm9yIGV4YW1wbGUsIGlmIG5vbi1SZWFjdCBjb2RlIGFsc28gY2FsbHMgYGRpc3BhdGNoRXZlbnRgXG4gICAgICAvLyBhbmQgYSBoYW5kbGVyIGZvciB0aGF0IGV2ZW50IHRocm93cy4gV2Ugc2hvdWxkIGJlIHJlc2lsaWVudCB0byBtb3N0IG9mXG4gICAgICAvLyB0aG9zZSBjYXNlcy4gRXZlbiBpZiBvdXIgZXJyb3IgZXZlbnQgaGFuZGxlciBmaXJlcyBtb3JlIHRoYW4gb25jZSwgdGhlXG4gICAgICAvLyBsYXN0IGVycm9yIGV2ZW50IGlzIGFsd2F5cyB1c2VkLiBJZiB0aGUgY2FsbGJhY2sgYWN0dWFsbHkgZG9lcyBlcnJvcixcbiAgICAgIC8vIHdlIGtub3cgdGhhdCB0aGUgbGFzdCBlcnJvciBldmVudCBpcyB0aGUgY29ycmVjdCBvbmUsIGJlY2F1c2UgaXQncyBub3RcbiAgICAgIC8vIHBvc3NpYmxlIGZvciBhbnl0aGluZyBlbHNlIHRvIGhhdmUgaGFwcGVuZWQgaW4gYmV0d2VlbiBvdXIgY2FsbGJhY2tcbiAgICAgIC8vIGVycm9yaW5nIGFuZCB0aGUgY29kZSB0aGF0IGZvbGxvd3MgdGhlIGBkaXNwYXRjaEV2ZW50YCBjYWxsIGJlbG93LiBJZlxuICAgICAgLy8gdGhlIGNhbGxiYWNrIGRvZXNuJ3QgZXJyb3IsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgd2FzIGZpcmVkLCB3ZSBrbm93IHRvXG4gICAgICAvLyBpZ25vcmUgaXQgYmVjYXVzZSBgZGlkRXJyb3JgIHdpbGwgYmUgZmFsc2UsIGFzIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAgIHZhciBlcnJvciA9IHZvaWQgMDtcbiAgICAgIC8vIFVzZSB0aGlzIHRvIHRyYWNrIHdoZXRoZXIgdGhlIGVycm9yIGV2ZW50IGlzIGV2ZXIgY2FsbGVkLlxuICAgICAgdmFyIGRpZFNldEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgaXNDcm9zc09yaWdpbkVycm9yID0gZmFsc2U7XG5cbiAgICAgIGZ1bmN0aW9uIG9uRXJyb3IoZXZlbnQpIHtcbiAgICAgICAgZXJyb3IgPSBldmVudC5lcnJvcjtcbiAgICAgICAgZGlkU2V0RXJyb3IgPSB0cnVlO1xuICAgICAgICBpZiAoZXJyb3IgPT09IG51bGwgJiYgZXZlbnQuY29sbm8gPT09IDAgJiYgZXZlbnQubGluZW5vID09PSAwKSB7XG4gICAgICAgICAgaXNDcm9zc09yaWdpbkVycm9yID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBmYWtlIGV2ZW50IHR5cGUuXG4gICAgICB2YXIgZXZ0VHlwZSA9ICdyZWFjdC0nICsgKG5hbWUgPyBuYW1lIDogJ2ludm9rZWd1YXJkZWRjYWxsYmFjaycpO1xuXG4gICAgICAvLyBBdHRhY2ggb3VyIGV2ZW50IGhhbmRsZXJzXG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICAgIGZha2VOb2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG5cbiAgICAgIC8vIFN5bmNocm9ub3VzbHkgZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQuIElmIHRoZSB1c2VyLXByb3ZpZGVkIGZ1bmN0aW9uXG4gICAgICAvLyBlcnJvcnMsIGl0IHdpbGwgdHJpZ2dlciBvdXIgZ2xvYmFsIGVycm9yIGhhbmRsZXIuXG4gICAgICB2YXIgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0V2ZW50Jyk7XG4gICAgICBldnQuaW5pdEV2ZW50KGV2dFR5cGUsIGZhbHNlLCBmYWxzZSk7XG4gICAgICBmYWtlTm9kZS5kaXNwYXRjaEV2ZW50KGV2dCk7XG5cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICBpZiAoIWRpZFNldEVycm9yKSB7XG4gICAgICAgICAgLy8gVGhlIGNhbGxiYWNrIGVycm9yZWQsIGJ1dCB0aGUgZXJyb3IgZXZlbnQgbmV2ZXIgZmlyZWQuXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIG9uZSBvZiB5b3VyIGNvbXBvbmVudHMsIGJ1dCBSZWFjdCAnICsgXCJkb2Vzbid0IGtub3cgd2hhdCBpdCB3YXMuIFRoaXMgaXMgbGlrZWx5IGR1ZSB0byBicm93c2VyIFwiICsgJ2ZsYWtpbmVzcy4gUmVhY3QgZG9lcyBpdHMgYmVzdCB0byBwcmVzZXJ2ZSB0aGUgXCJQYXVzZSBvbiAnICsgJ2V4Y2VwdGlvbnNcIiBiZWhhdmlvciBvZiB0aGUgRGV2VG9vbHMsIHdoaWNoIHJlcXVpcmVzIHNvbWUgJyArIFwiREVWLW1vZGUgb25seSB0cmlja3MuIEl0J3MgcG9zc2libGUgdGhhdCB0aGVzZSBkb24ndCB3b3JrIGluIFwiICsgJ3lvdXIgYnJvd3Nlci4gVHJ5IHRyaWdnZXJpbmcgdGhlIGVycm9yIGluIHByb2R1Y3Rpb24gbW9kZSwgJyArICdvciBzd2l0Y2hpbmcgdG8gYSBtb2Rlcm4gYnJvd3Nlci4gSWYgeW91IHN1c3BlY3QgdGhhdCB0aGlzIGlzICcgKyAnYWN0dWFsbHkgYW4gaXNzdWUgd2l0aCBSZWFjdCwgcGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDcm9zc09yaWdpbkVycm9yKSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoXCJBIGNyb3NzLW9yaWdpbiBlcnJvciB3YXMgdGhyb3duLiBSZWFjdCBkb2Vzbid0IGhhdmUgYWNjZXNzIHRvIFwiICsgJ3RoZSBhY3R1YWwgZXJyb3Igb2JqZWN0IGluIGRldmVsb3BtZW50LiAnICsgJ1NlZSBodHRwczovL2ZiLm1lL3JlYWN0LWNyb3Nzb3JpZ2luLWVycm9yIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICB9XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSB0cnVlO1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2NhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgb3VyIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgb25FcnJvcik7XG4gICAgfTtcblxuICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayA9IGludm9rZUd1YXJkZWRDYWxsYmFja0RldjtcbiAgfVxufVxuXG52YXIgcmV0aHJvd0NhdWdodEVycm9yID0gZnVuY3Rpb24gKCkge1xuICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX3JldGhyb3dFcnJvciA9IG51bGw7XG4gICAgUmVhY3RFcnJvclV0aWxzLl9oYXNSZXRocm93RXJyb3IgPSBmYWxzZTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG9yZGVyaW5nIG9mIGV2ZW50IHBsdWdpbnMuXG4gKi9cbnZhciBldmVudFBsdWdpbk9yZGVyID0gbnVsbDtcblxuLyoqXG4gKiBJbmplY3RhYmxlIG1hcHBpbmcgZnJvbSBuYW1lcyB0byBldmVudCBwbHVnaW4gbW9kdWxlcy5cbiAqL1xudmFyIG5hbWVzVG9QbHVnaW5zID0ge307XG5cbi8qKlxuICogUmVjb21wdXRlcyB0aGUgcGx1Z2luIGxpc3QgdXNpbmcgdGhlIGluamVjdGVkIHBsdWdpbnMgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpIHtcbiAgaWYgKCFldmVudFBsdWdpbk9yZGVyKSB7XG4gICAgLy8gV2FpdCB1bnRpbCBhbiBgZXZlbnRQbHVnaW5PcmRlcmAgaXMgaW5qZWN0ZWQuXG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gbmFtZXNUb1BsdWdpbnMpIHtcbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgdmFyIHBsdWdpbkluZGV4ID0gZXZlbnRQbHVnaW5PcmRlci5pbmRleE9mKHBsdWdpbk5hbWUpO1xuICAgICEocGx1Z2luSW5kZXggPiAtMSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbnMgdGhhdCBkbyBub3QgZXhpc3QgaW4gdGhlIHBsdWdpbiBvcmRlcmluZywgYCVzYC4nLCBwbHVnaW5OYW1lKSA6IHZvaWQgMDtcbiAgICBpZiAocGx1Z2luc1twbHVnaW5JbmRleF0pIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICAhcGx1Z2luTW9kdWxlLmV4dHJhY3RFdmVudHMgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudCBwbHVnaW5zIG11c3QgaW1wbGVtZW50IGFuIGBleHRyYWN0RXZlbnRzYCBtZXRob2QsIGJ1dCBgJXNgIGRvZXMgbm90LicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIHBsdWdpbnNbcGx1Z2luSW5kZXhdID0gcGx1Z2luTW9kdWxlO1xuICAgIHZhciBwdWJsaXNoZWRFdmVudHMgPSBwbHVnaW5Nb2R1bGUuZXZlbnRUeXBlcztcbiAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gcHVibGlzaGVkRXZlbnRzKSB7XG4gICAgICAhcHVibGlzaEV2ZW50Rm9yUGx1Z2luKHB1Ymxpc2hlZEV2ZW50c1tldmVudE5hbWVdLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBGYWlsZWQgdG8gcHVibGlzaCBldmVudCBgJXNgIGZvciBwbHVnaW4gYCVzYC4nLCBldmVudE5hbWUsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgZXZlbnQgbmFtZSwgYCVzYC4nLCBldmVudE5hbWUpIDogdm9pZCAwO1xuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXSA9IGRpc3BhdGNoQ29uZmlnO1xuXG4gIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyA9IGRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO1xuICBpZiAocGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICBmb3IgKHZhciBwaGFzZU5hbWUgaW4gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICAgIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZU5hbWUpKSB7XG4gICAgICAgIHZhciBwaGFzZWRSZWdpc3RyYXRpb25OYW1lID0gcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcGhhc2VOYW1lXTtcbiAgICAgICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUocGhhc2VkUmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgcHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUoZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSwgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBQdWJsaXNoZXMgYSByZWdpc3RyYXRpb24gbmFtZSB0aGF0IGlzIHVzZWQgdG8gaWRlbnRpZnkgZGlzcGF0Y2hlZCBldmVudHMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIXJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lIHJlZ2lzdHJhdGlvbiBuYW1lLCBgJXNgLicsIHJlZ2lzdHJhdGlvbk5hbWUpIDogdm9pZCAwO1xuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXSA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzW2V2ZW50TmFtZV0uZGVwZW5kZW5jaWVzO1xuXG4gIHtcbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSByZWdpc3RyYXRpb25OYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lc1tsb3dlckNhc2VkTmFtZV0gPSByZWdpc3RyYXRpb25OYW1lO1xuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWUgPT09ICdvbkRvdWJsZUNsaWNrJykge1xuICAgICAgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5vbmRibGNsaWNrID0gcmVnaXN0cmF0aW9uTmFtZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xuXG4vKipcbiAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICovXG52YXIgcGx1Z2lucyA9IFtdO1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICovXG52YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAqL1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0ge307XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAqL1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHJlZ2lzdHJhdGlvbiBuYW1lcyB0byB0aGUgcHJvcGVybHkgY2FzZWQgdmVyc2lvbixcbiAqIHVzZWQgdG8gd2FybiBpbiB0aGUgY2FzZSBvZiBtaXNzaW5nIGV2ZW50IGhhbmRsZXJzLiBBdmFpbGFibGVcbiAqIG9ubHkgaW4gdHJ1ZS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbnZhciBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzID0ge307XG4vLyBUcnVzdCB0aGUgZGV2ZWxvcGVyIHRvIG9ubHkgdXNlIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgaW4gdHJ1ZVxuXG4vKipcbiAqIEluamVjdHMgYW4gb3JkZXJpbmcgb2YgcGx1Z2lucyAoYnkgcGx1Z2luIG5hbWUpLiBUaGlzIGFsbG93cyB0aGUgb3JkZXJpbmdcbiAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICogYWx3YXlzIGRldGVybWluaXN0aWMgcmVnYXJkbGVzcyBvZiBwYWNrYWdpbmcsIG9uLXRoZS1mbHkgaW5qZWN0aW9uLCBldGMuXG4gKlxuICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gKiBAaW50ZXJuYWxcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbk9yZGVyfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbk9yZGVyKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcikge1xuICAhIWV2ZW50UGx1Z2luT3JkZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IGV2ZW50IHBsdWdpbiBvcmRlcmluZyBtb3JlIHRoYW4gb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogdm9pZCAwO1xuICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gIGV2ZW50UGx1Z2luT3JkZXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpO1xuICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xufVxuXG4vKipcbiAqIEluamVjdHMgcGx1Z2lucyB0byBiZSB1c2VkIGJ5IGBFdmVudFBsdWdpbkh1YmAuIFRoZSBwbHVnaW4gbmFtZXMgbXVzdCBiZVxuICogaW4gdGhlIG9yZGVyaW5nIGluamVjdGVkIGJ5IGBpbmplY3RFdmVudFBsdWdpbk9yZGVyYC5cbiAqXG4gKiBQbHVnaW5zIGNhbiBiZSBpbmplY3RlZCBhcyBwYXJ0IG9mIHBhZ2UgaW5pdGlhbGl6YXRpb24gb3Igb24tdGhlLWZseS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZX1cbiAqL1xuZnVuY3Rpb24gaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIGluamVjdGVkTmFtZXNUb1BsdWdpbnMpIHtcbiAgICBpZiAoIWluamVjdGVkTmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgcGx1Z2luTW9kdWxlID0gaW5qZWN0ZWROYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBwbHVnaW5Nb2R1bGUpIHtcbiAgICAgICEhbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyB1c2luZyB0aGUgc2FtZSBuYW1lLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgICAgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgICBpc09yZGVyaW5nRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoaXNPcmRlcmluZ0RpcnR5KSB7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfVxufVxuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IE9iamVjdC5mcmVlemUoe1xuXHRwbHVnaW5zOiBwbHVnaW5zLFxuXHRldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblx0cmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6IHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLFxuXHRyZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzOiByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzLFxuXHRwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOiBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLFxuXHRpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXHRpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufSk7XG5cbnZhciBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gbnVsbDtcbnZhciBnZXRJbnN0YW5jZUZyb21Ob2RlID0gbnVsbDtcbnZhciBnZXROb2RlRnJvbUluc3RhbmNlID0gbnVsbDtcblxudmFyIGluamVjdGlvbiQyID0ge1xuICBpbmplY3RDb21wb25lbnRUcmVlOiBmdW5jdGlvbiAoSW5qZWN0ZWQpIHtcbiAgICBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlID0gSW5qZWN0ZWQuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtcbiAgICBnZXRJbnN0YW5jZUZyb21Ob2RlID0gSW5qZWN0ZWQuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiAgICBnZXROb2RlRnJvbUluc3RhbmNlID0gSW5qZWN0ZWQuZ2V0Tm9kZUZyb21JbnN0YW5jZTtcblxuICAgIHtcbiAgICAgIHdhcm5pbmcoZ2V0Tm9kZUZyb21JbnN0YW5jZSAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlLCAnRXZlbnRQbHVnaW5VdGlscy5pbmplY3Rpb24uaW5qZWN0Q29tcG9uZW50VHJlZSguLi4pOiBJbmplY3RlZCAnICsgJ21vZHVsZSBpcyBtaXNzaW5nIGdldE5vZGVGcm9tSW5zdGFuY2Ugb3IgZ2V0SW5zdGFuY2VGcm9tTm9kZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cblxuXG5cblxuXG52YXIgdmFsaWRhdGVFdmVudERpc3BhdGNoZXM7XG57XG4gIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICAgIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcblxuICAgIHZhciBsaXN0ZW5lcnNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpO1xuICAgIHZhciBsaXN0ZW5lcnNMZW4gPSBsaXN0ZW5lcnNJc0FyciA/IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aCA6IGRpc3BhdGNoTGlzdGVuZXJzID8gMSA6IDA7XG5cbiAgICB2YXIgaW5zdGFuY2VzSXNBcnIgPSBBcnJheS5pc0FycmF5KGRpc3BhdGNoSW5zdGFuY2VzKTtcbiAgICB2YXIgaW5zdGFuY2VzTGVuID0gaW5zdGFuY2VzSXNBcnIgPyBkaXNwYXRjaEluc3RhbmNlcy5sZW5ndGggOiBkaXNwYXRjaEluc3RhbmNlcyA/IDEgOiAwO1xuXG4gICAgd2FybmluZyhpbnN0YW5jZXNJc0FyciA9PT0gbGlzdGVuZXJzSXNBcnIgJiYgaW5zdGFuY2VzTGVuID09PSBsaXN0ZW5lcnNMZW4sICdFdmVudFBsdWdpblV0aWxzOiBJbnZhbGlkIGBldmVudGAuJyk7XG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggdGhlIGV2ZW50IHRvIHRoZSBsaXN0ZW5lci5cbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50IFN5bnRoZXRpY0V2ZW50IHRvIGhhbmRsZVxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBsaXN0ZW5lciBBcHBsaWNhdGlvbi1sZXZlbCBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBpbnN0IEludGVybmFsIGNvbXBvbmVudCBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgbGlzdGVuZXIsIGluc3QpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdCk7XG4gIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3IodHlwZSwgbGlzdGVuZXIsIHVuZGVmaW5lZCwgZXZlbnQpO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJbnN0YW5jZXMgPSBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXM7XG4gIHtcbiAgICB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyhldmVudCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hMaXN0ZW5lcnMpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBMaXN0ZW5lcnMgYW5kIEluc3RhbmNlcyBhcmUgdHdvIHBhcmFsbGVsIGFycmF5cyB0aGF0IGFyZSBhbHdheXMgaW4gc3luYy5cbiAgICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVyc1tpXSwgZGlzcGF0Y2hJbnN0YW5jZXNbaV0pO1xuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBkaXNwYXRjaExpc3RlbmVycywgZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICB9XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IG51bGw7XG59XG5cbi8qKlxuICogQHNlZSBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXJTdG9wQXRUcnVlSW1wbFxuICovXG5cblxuLyoqXG4gKiBFeGVjdXRpb24gb2YgYSBcImRpcmVjdFwiIGRpc3BhdGNoIC0gdGhlcmUgbXVzdCBiZSBhdCBtb3N0IG9uZSBkaXNwYXRjaFxuICogYWNjdW11bGF0ZWQgb24gdGhlIGV2ZW50IG9yIGl0IGlzIGNvbnNpZGVyZWQgYW4gZXJyb3IuIEl0IGRvZXNuJ3QgcmVhbGx5IG1ha2VcbiAqIHNlbnNlIGZvciBhbiBldmVudCB3aXRoIG11bHRpcGxlIGRpc3BhdGNoZXMgKGJ1YmJsZWQpIHRvIGtlZXAgdHJhY2sgb2YgdGhlXG4gKiByZXR1cm4gdmFsdWVzIGF0IGVhY2ggZGlzcGF0Y2ggZXhlY3V0aW9uLCBidXQgaXQgZG9lcyB0ZW5kIHRvIG1ha2Ugc2Vuc2Ugd2hlblxuICogZGVhbGluZyB3aXRoIFwiZGlyZWN0XCIgZGlzcGF0Y2hlcy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBUaGUgcmV0dXJuIHZhbHVlIG9mIGV4ZWN1dGluZyB0aGUgc2luZ2xlIGRpc3BhdGNoLlxuICovXG5cblxuLyoqXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZmYgbnVtYmVyIG9mIGRpc3BhdGNoZXMgYWNjdW11bGF0ZWQgaXMgZ3JlYXRlciB0aGFuIDAuXG4gKi9cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2FjY3VtdWxhdGVJbnRvKC4uLik6IEFjY3VtdWxhdGVkIGl0ZW1zIG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkLicpIDogdm9pZCAwO1xuXG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmV4dCkpIHtcbiAgICAgIGN1cnJlbnQucHVzaC5hcHBseShjdXJyZW50LCBuZXh0KTtcbiAgICAgIHJldHVybiBjdXJyZW50O1xuICAgIH1cbiAgICBjdXJyZW50LnB1c2gobmV4dCk7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgIC8vIEEgYml0IHRvbyBkYW5nZXJvdXMgdG8gbXV0YXRlIGBuZXh0YC5cbiAgICByZXR1cm4gW2N1cnJlbnRdLmNvbmNhdChuZXh0KTtcbiAgfVxuXG4gIHJldHVybiBbY3VycmVudCwgbmV4dF07XG59XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiBDYWxsYmFjayBpbnZva2VkIHdpdGggZWFjaCBlbGVtZW50IG9yIGEgY29sbGVjdGlvbi5cbiAqIEBwYXJhbSB7P30gW3Njb3BlXSBTY29wZSB1c2VkIGFzIGB0aGlzYCBpbiBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBmb3JFYWNoQWNjdW11bGF0ZWQoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcihldmVudCwgc2ltdWxhdGVkKTtcblxuICAgIGlmICghZXZlbnQuaXNQZXJzaXN0ZW50KCkpIHtcbiAgICAgIGV2ZW50LmNvbnN0cnVjdG9yLnJlbGVhc2UoZXZlbnQpO1xuICAgIH1cbiAgfVxufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQgPSBmdW5jdGlvbiAoZSkge1xuICByZXR1cm4gZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlKGUsIHRydWUpO1xufTtcbnZhciBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gaXNJbnRlcmFjdGl2ZSh0YWcpIHtcbiAgcmV0dXJuIHRhZyA9PT0gJ2J1dHRvbicgfHwgdGFnID09PSAnaW5wdXQnIHx8IHRhZyA9PT0gJ3NlbGVjdCcgfHwgdGFnID09PSAndGV4dGFyZWEnO1xufVxuXG5mdW5jdGlvbiBzaG91bGRQcmV2ZW50TW91c2VFdmVudChuYW1lLCB0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdvbkNsaWNrJzpcbiAgICBjYXNlICdvbkNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGljayc6XG4gICAgY2FzZSAnb25Eb3VibGVDbGlja0NhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VEb3duJzpcbiAgICBjYXNlICdvbk1vdXNlRG93bkNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlJzpcbiAgICBjYXNlICdvbk1vdXNlTW92ZUNhcHR1cmUnOlxuICAgIGNhc2UgJ29uTW91c2VVcCc6XG4gICAgY2FzZSAnb25Nb3VzZVVwQ2FwdHVyZSc6XG4gICAgICByZXR1cm4gISEocHJvcHMuZGlzYWJsZWQgJiYgaXNJbnRlcmFjdGl2ZSh0eXBlKSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgaXMgYSB1bmlmaWVkIGludGVyZmFjZSBmb3IgZXZlbnQgcGx1Z2lucyB0byBiZSBpbnN0YWxsZWQgYW5kIGNvbmZpZ3VyZWQuXG4gKlxuICogRXZlbnQgcGx1Z2lucyBjYW4gaW1wbGVtZW50IHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqXG4gKiAgIGBleHRyYWN0RXZlbnRzYCB7ZnVuY3Rpb24oc3RyaW5nLCBET01FdmVudFRhcmdldCwgc3RyaW5nLCBvYmplY3QpOiAqfVxuICogICAgIFJlcXVpcmVkLiBXaGVuIGEgdG9wLWxldmVsIGV2ZW50IGlzIGZpcmVkLCB0aGlzIG1ldGhvZCBpcyBleHBlY3RlZCB0b1xuICogICAgIGV4dHJhY3Qgc3ludGhldGljIGV2ZW50cyB0aGF0IHdpbGwgaW4gdHVybiBiZSBxdWV1ZWQgYW5kIGRpc3BhdGNoZWQuXG4gKlxuICogICBgZXZlbnRUeXBlc2Age29iamVjdH1cbiAqICAgICBPcHRpb25hbCwgcGx1Z2lucyB0aGF0IGZpcmUgZXZlbnRzIG11c3QgcHVibGlzaCBhIG1hcHBpbmcgb2YgcmVnaXN0cmF0aW9uXG4gKiAgICAgbmFtZXMgdGhhdCBhcmUgdXNlZCB0byByZWdpc3RlciBsaXN0ZW5lcnMuIFZhbHVlcyBvZiB0aGlzIG1hcHBpbmcgbXVzdFxuICogICAgIGJlIG9iamVjdHMgdGhhdCBjb250YWluIGByZWdpc3RyYXRpb25OYW1lYCBvciBgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNgLlxuICpcbiAqICAgYGV4ZWN1dGVEaXNwYXRjaGAge2Z1bmN0aW9uKG9iamVjdCwgZnVuY3Rpb24sIHN0cmluZyl9XG4gKiAgICAgT3B0aW9uYWwsIGFsbG93cyBwbHVnaW5zIHRvIG92ZXJyaWRlIGhvdyBhbiBldmVudCBnZXRzIGRpc3BhdGNoZWQuIEJ5XG4gKiAgICAgZGVmYXVsdCwgdGhlIGxpc3RlbmVyIGlzIHNpbXBseSBpbnZva2VkLlxuICpcbiAqIEVhY2ggcGx1Z2luIHRoYXQgaXMgaW5qZWN0ZWQgaW50byBgRXZlbnRzUGx1Z2luSHViYCBpcyBpbW1lZGlhdGVseSBvcGVyYWJsZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cblxuLyoqXG4gKiBNZXRob2RzIGZvciBpbmplY3RpbmcgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgaW5qZWN0aW9uJDEgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogaW5qZWN0RXZlbnRQbHVnaW5PcmRlcixcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gaW5zdCBUaGUgaW5zdGFuY2UsIHdoaWNoIGlzIHRoZSBzb3VyY2Ugb2YgZXZlbnRzLlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBsaXN0ZW5lcjtcblxuICAvLyBUT0RPOiBzaG91bGRQcmV2ZW50TW91c2VFdmVudCBpcyBET00tc3BlY2lmaWMgYW5kIGRlZmluaXRlbHkgc2hvdWxkIG5vdFxuICAvLyBsaXZlIGhlcmU7IG5lZWRzIHRvIGJlIG1vdmVkIHRvIGEgYmV0dGVyIHBsYWNlIHNvb25cbiAgdmFyIHN0YXRlTm9kZSA9IGluc3Quc3RhdGVOb2RlO1xuICBpZiAoIXN0YXRlTm9kZSkge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MgKGV4OiBvbmxvYWQgZXZlbnRzIGluIGluY3JlbWVudGFsIG1vZGUpLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBwcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUoc3RhdGVOb2RlKTtcbiAgaWYgKCFwcm9wcykge1xuICAgIC8vIFdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgbGlzdGVuZXIgPSBwcm9wc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgaWYgKHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KHJlZ2lzdHJhdGlvbk5hbWUsIGluc3QudHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgISghbGlzdGVuZXIgfHwgdHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IHZvaWQgMDtcbiAgcmV0dXJuIGxpc3RlbmVyO1xufVxuXG4vKipcbiAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAqIG5hdGl2ZSBicm93c2VyIGV2ZW50cy5cbiAqXG4gKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRzKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudHM7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGx1Z2lucy5sZW5ndGg7IGkrKykge1xuICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICB2YXIgcG9zc2libGVQbHVnaW4gPSBwbHVnaW5zW2ldO1xuICAgIGlmIChwb3NzaWJsZVBsdWdpbikge1xuICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICBldmVudHMgPSBhY2N1bXVsYXRlSW50byhldmVudHMsIGV4dHJhY3RlZEV2ZW50cyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBldmVudHM7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgYSBzeW50aGV0aWMgZXZlbnQgdGhhdCBzaG91bGQgYmUgZGlzcGF0Y2hlZCB3aGVuXG4gKiBgcHJvY2Vzc0V2ZW50UXVldWVgIGlzIGludm9rZWQuXG4gKlxuICogQHBhcmFtIHsqfSBldmVudHMgQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZW5xdWV1ZUV2ZW50cyhldmVudHMpIHtcbiAgaWYgKGV2ZW50cykge1xuICAgIGV2ZW50UXVldWUgPSBhY2N1bXVsYXRlSW50byhldmVudFF1ZXVlLCBldmVudHMpO1xuICB9XG59XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbGwgc3ludGhldGljIGV2ZW50cyBvbiB0aGUgZXZlbnQgcXVldWUuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NFdmVudFF1ZXVlKHNpbXVsYXRlZCkge1xuICAvLyBTZXQgYGV2ZW50UXVldWVgIHRvIG51bGwgYmVmb3JlIHByb2Nlc3NpbmcgaXQgc28gdGhhdCB3ZSBjYW4gdGVsbCBpZiBtb3JlXG4gIC8vIGV2ZW50cyBnZXQgZW5xdWV1ZWQgd2hpbGUgcHJvY2Vzc2luZy5cbiAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgZXZlbnRRdWV1ZSA9IG51bGw7XG4gIGlmIChzaW11bGF0ZWQpIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gIH0gZWxzZSB7XG4gICAgZm9yRWFjaEFjY3VtdWxhdGVkKHByb2Nlc3NpbmdFdmVudFF1ZXVlLCBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCk7XG4gIH1cbiAgISFldmVudFF1ZXVlID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nIGFuIGV2ZW50IHF1ZXVlLiBTdXBwb3J0IGZvciB0aGlzIGhhcyBub3QgeWV0IGJlZW4gaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG4gIC8vIFRoaXMgd291bGQgYmUgYSBnb29kIHRpbWUgdG8gcmV0aHJvdyBpZiBhbnkgb2YgdGhlIGV2ZW50IGhhbmRsZXJzIHRocmV3LlxuICBSZWFjdEVycm9yVXRpbHMucmV0aHJvd0NhdWdodEVycm9yKCk7XG59XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQxLFxuXHRnZXRMaXN0ZW5lcjogZ2V0TGlzdGVuZXIsXG5cdGV4dHJhY3RFdmVudHM6IGV4dHJhY3RFdmVudHMsXG5cdGVucXVldWVFdmVudHM6IGVucXVldWVFdmVudHMsXG5cdHByb2Nlc3NFdmVudFF1ZXVlOiBwcm9jZXNzRXZlbnRRdWV1ZVxufSk7XG5cbnZhciBJbmRldGVybWluYXRlQ29tcG9uZW50ID0gMDsgLy8gQmVmb3JlIHdlIGtub3cgd2hldGhlciBpdCBpcyBmdW5jdGlvbmFsIG9yIGNsYXNzXG52YXIgRnVuY3Rpb25hbENvbXBvbmVudCA9IDE7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAyO1xudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG52YXIgSG9zdFBvcnRhbCA9IDQ7IC8vIEEgc3VidHJlZS4gQ291bGQgYmUgYW4gZW50cnkgcG9pbnQgdG8gYSBkaWZmZXJlbnQgcmVuZGVyZXIuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIENhbGxDb21wb25lbnQgPSA3O1xudmFyIENhbGxIYW5kbGVyUGhhc2UgPSA4O1xudmFyIFJldHVybkNvbXBvbmVudCA9IDk7XG52YXIgRnJhZ21lbnQgPSAxMDtcblxudmFyIHJhbmRvbUtleSA9IE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnNsaWNlKDIpO1xudmFyIGludGVybmFsSW5zdGFuY2VLZXkgPSAnX19yZWFjdEludGVybmFsSW5zdGFuY2UkJyArIHJhbmRvbUtleTtcbnZhciBpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXkgPSAnX19yZWFjdEV2ZW50SGFuZGxlcnMkJyArIHJhbmRvbUtleTtcblxuZnVuY3Rpb24gcHJlY2FjaGVGaWJlck5vZGUkMShob3N0SW5zdCwgbm9kZSkge1xuICBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldID0gaG9zdEluc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBjbG9zZXN0IFJlYWN0RE9NQ29tcG9uZW50IG9yXG4gKiBSZWFjdERPTVRleHRDb21wb25lbnQgaW5zdGFuY2UgYW5jZXN0b3IuXG4gKi9cbmZ1bmN0aW9uIGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5vZGUpIHtcbiAgaWYgKG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICByZXR1cm4gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XTtcbiAgfVxuXG4gIC8vIFdhbGsgdXAgdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhbiBhbmNlc3RvciB3aG9zZSBpbnN0YW5jZSB3ZSBoYXZlIGNhY2hlZC5cbiAgdmFyIHBhcmVudHMgPSBbXTtcbiAgd2hpbGUgKCFub2RlW2ludGVybmFsSW5zdGFuY2VLZXldKSB7XG4gICAgcGFyZW50cy5wdXNoKG5vZGUpO1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvcCBvZiB0aGUgdHJlZS4gVGhpcyBub2RlIG11c3Qgbm90IGJlIHBhcnQgb2YgYSBSZWFjdCB0cmVlIChvciBpc1xuICAgICAgLy8gdW5tb3VudGVkLCBwb3RlbnRpYWxseSkuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cblxuICB2YXIgY2xvc2VzdCA9IHZvaWQgMDtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdC50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgaW5zdC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgLy8gSW4gRmliZXIsIHRoaXMgd2lsbCBhbHdheXMgYmUgdGhlIGRlZXBlc3Qgcm9vdC5cbiAgICByZXR1cm4gaW5zdDtcbiAgfVxuICBmb3IgKDsgbm9kZSAmJiAoaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pOyBub2RlID0gcGFyZW50cy5wb3AoKSkge1xuICAgIGNsb3Nlc3QgPSBpbnN0O1xuICB9XG5cbiAgcmV0dXJuIGNsb3Nlc3Q7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBET00gbm9kZSwgcmV0dXJuIHRoZSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIGluc3RhbmNlLCBvciBudWxsIGlmIHRoZSBub2RlIHdhcyBub3QgcmVuZGVyZWQgYnkgdGhpcyBSZWFjdC5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKG5vZGUpIHtcbiAgdmFyIGluc3QgPSBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICBpZiAoaW5zdCkge1xuICAgIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBpbnN0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBSZWFjdERPTUNvbXBvbmVudCBvciBSZWFjdERPTVRleHRDb21wb25lbnQsIHJldHVybiB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NIG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UkMShpbnN0KSB7XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciB0aGlzLCBpcyBqdXN0IHRoZSBzdGF0ZSBub2RlIHJpZ2h0IG5vdy4gV2UgYXNzdW1lIGl0IHdpbGwgYmVcbiAgICAvLyBhIGhvc3QgY29tcG9uZW50IG9yIGhvc3QgdGV4dC5cbiAgICByZXR1cm4gaW5zdC5zdGF0ZU5vZGU7XG4gIH1cblxuICAvLyBXaXRob3V0IHRoaXMgZmlyc3QgaW52YXJpYW50LCBwYXNzaW5nIGEgbm9uLURPTS1jb21wb25lbnQgdHJpZ2dlcnMgdGhlIG5leHRcbiAgLy8gaW52YXJpYW50IGZvciBhIG1pc3NpbmcgcGFyZW50LCB3aGljaCBpcyBzdXBlciBjb25mdXNpbmcuXG4gIGludmFyaWFudChmYWxzZSwgJ2dldE5vZGVGcm9tSW5zdGFuY2U6IEludmFsaWQgYXJndW1lbnQuJyk7XG59XG5cbmZ1bmN0aW9uIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShub2RlKSB7XG4gIHJldHVybiBub2RlW2ludGVybmFsRXZlbnRIYW5kbGVyc0tleV0gfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRmliZXJQcm9wcyQxKG5vZGUsIHByb3BzKSB7XG4gIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSA9IHByb3BzO1xufVxuXG52YXIgUmVhY3RET01Db21wb25lbnRUcmVlID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHByZWNhY2hlRmliZXJOb2RlOiBwcmVjYWNoZUZpYmVyTm9kZSQxLFxuXHRnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTogZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUsXG5cdGdldEluc3RhbmNlRnJvbU5vZGU6IGdldEluc3RhbmNlRnJvbU5vZGUkMSxcblx0Z2V0Tm9kZUZyb21JbnN0YW5jZTogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxLFxuXHRnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlOiBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEsXG5cdHVwZGF0ZUZpYmVyUHJvcHM6IHVwZGF0ZUZpYmVyUHJvcHMkMVxufSk7XG5cbmZ1bmN0aW9uIGdldFBhcmVudChpbnN0KSB7XG4gIGRvIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIEhvc3RSb290IHdlIG1pZ2h0IHdhbnQgdG8gYmFpbCBvdXQuXG4gICAgLy8gVGhhdCBpcyBkZXBlbmRpbmcgb24gaWYgd2Ugd2FudCBuZXN0ZWQgc3VidHJlZXMgKGxheWVycykgdG8gYnViYmxlXG4gICAgLy8gZXZlbnRzIHRvIHRoZWlyIHBhcmVudC4gV2UgY291bGQgYWxzbyBnbyB0aHJvdWdoIHBhcmVudE5vZGUgb24gdGhlXG4gICAgLy8gaG9zdCBub2RlIGJ1dCB0aGF0IHdvdWxkbid0IHdvcmsgZm9yIFJlYWN0IE5hdGl2ZSBhbmQgZG9lc24ndCBsZXQgdXNcbiAgICAvLyBkbyB0aGUgcG9ydGFsIGZlYXR1cmUuXG4gIH0gd2hpbGUgKGluc3QgJiYgaW5zdC50YWcgIT09IEhvc3RDb21wb25lbnQpO1xuICBpZiAoaW5zdCkge1xuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbG93ZXN0IGNvbW1vbiBhbmNlc3RvciBvZiBBIGFuZCBCLCBvciBudWxsIGlmIHRoZXkgYXJlIGluXG4gKiBkaWZmZXJlbnQgdHJlZXMuXG4gKi9cbmZ1bmN0aW9uIGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGluc3RBLCBpbnN0Qikge1xuICB2YXIgZGVwdGhBID0gMDtcbiAgZm9yICh2YXIgdGVtcEEgPSBpbnN0QTsgdGVtcEE7IHRlbXBBID0gZ2V0UGFyZW50KHRlbXBBKSkge1xuICAgIGRlcHRoQSsrO1xuICB9XG4gIHZhciBkZXB0aEIgPSAwO1xuICBmb3IgKHZhciB0ZW1wQiA9IGluc3RCOyB0ZW1wQjsgdGVtcEIgPSBnZXRQYXJlbnQodGVtcEIpKSB7XG4gICAgZGVwdGhCKys7XG4gIH1cblxuICAvLyBJZiBBIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEEgLSBkZXB0aEIgPiAwKSB7XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGRlcHRoQS0tO1xuICB9XG5cbiAgLy8gSWYgQiBpcyBkZWVwZXIsIGNyYXdsIHVwLlxuICB3aGlsZSAoZGVwdGhCIC0gZGVwdGhBID4gMCkge1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgICBkZXB0aEItLTtcbiAgfVxuXG4gIC8vIFdhbGsgaW4gbG9ja3N0ZXAgdW50aWwgd2UgZmluZCBhIG1hdGNoLlxuICB2YXIgZGVwdGggPSBkZXB0aEE7XG4gIHdoaWxlIChkZXB0aC0tKSB7XG4gICAgaWYgKGluc3RBID09PSBpbnN0QiB8fCBpbnN0QSA9PT0gaW5zdEIuYWx0ZXJuYXRlKSB7XG4gICAgICByZXR1cm4gaW5zdEE7XG4gICAgfVxuICAgIGluc3RBID0gZ2V0UGFyZW50KGluc3RBKTtcbiAgICBpbnN0QiA9IGdldFBhcmVudChpbnN0Qik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIGlmIEEgaXMgYW4gYW5jZXN0b3Igb2YgQi5cbiAqL1xuXG5cbi8qKlxuICogUmV0dXJuIHRoZSBwYXJlbnQgaW5zdGFuY2Ugb2YgdGhlIHBhc3NlZC1pbiBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SW5zdGFuY2UoaW5zdCkge1xuICByZXR1cm4gZ2V0UGFyZW50KGluc3QpO1xufVxuXG4vKipcbiAqIFNpbXVsYXRlcyB0aGUgdHJhdmVyc2FsIG9mIGEgdHdvLXBoYXNlLCBjYXB0dXJlL2J1YmJsZSBldmVudCBkaXNwYXRjaC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VUd29QaGFzZShpbnN0LCBmbiwgYXJnKSB7XG4gIHZhciBwYXRoID0gW107XG4gIHdoaWxlIChpbnN0KSB7XG4gICAgcGF0aC5wdXNoKGluc3QpO1xuICAgIGluc3QgPSBnZXRQYXJlbnQoaW5zdCk7XG4gIH1cbiAgdmFyIGk7XG4gIGZvciAoaSA9IHBhdGgubGVuZ3RoOyBpLS0gPiAwOykge1xuICAgIGZuKHBhdGhbaV0sICdjYXB0dXJlZCcsIGFyZyk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICBmbihwYXRoW2ldLCAnYnViYmxlZCcsIGFyZyk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIElEIGhpZXJhcmNoeSBhbmQgaW52b2tlcyB0aGUgc3VwcGxpZWQgYGNiYCBvbiBhbnkgSURzIHRoYXRcbiAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAqXG4gKiBEb2VzIG5vdCBpbnZva2UgdGhlIGNhbGxiYWNrIG9uIHRoZSBuZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBiZWNhdXNlIG5vdGhpbmdcbiAqIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VFbnRlckxlYXZlKGZyb20sIHRvLCBmbiwgYXJnRnJvbSwgYXJnVG8pIHtcbiAgdmFyIGNvbW1vbiA9IGZyb20gJiYgdG8gPyBnZXRMb3dlc3RDb21tb25BbmNlc3Rvcihmcm9tLCB0bykgOiBudWxsO1xuICB2YXIgcGF0aEZyb20gPSBbXTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAoIWZyb20pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoZnJvbSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZyb20uYWx0ZXJuYXRlO1xuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwgJiYgYWx0ZXJuYXRlID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXRoRnJvbS5wdXNoKGZyb20pO1xuICAgIGZyb20gPSBnZXRQYXJlbnQoZnJvbSk7XG4gIH1cbiAgdmFyIHBhdGhUbyA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghdG8pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAodG8gPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBfYWx0ZXJuYXRlID0gdG8uYWx0ZXJuYXRlO1xuICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsICYmIF9hbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhUby5wdXNoKHRvKTtcbiAgICB0byA9IGdldFBhcmVudCh0byk7XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoRnJvbS5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhGcm9tW2ldLCAnYnViYmxlZCcsIGFyZ0Zyb20pO1xuICB9XG4gIGZvciAodmFyIF9pID0gcGF0aFRvLmxlbmd0aDsgX2ktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFRvW19pXSwgJ2NhcHR1cmVkJywgYXJnVG8pO1xuICB9XG59XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGluc3QsIGV2ZW50LCBwcm9wYWdhdGlvblBoYXNlKSB7XG4gIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXNbcHJvcGFnYXRpb25QaGFzZV07XG4gIHJldHVybiBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVuIGFcbiAqIHNpbmdsZSBvbmUuXG4gKi9cblxuLyoqXG4gKiBUYWdzIGEgYFN5bnRoZXRpY0V2ZW50YCB3aXRoIGRpc3BhdGNoZWQgbGlzdGVuZXJzLiBDcmVhdGluZyB0aGlzIGZ1bmN0aW9uXG4gKiBoZXJlLCBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gYmluZCBvciBjcmVhdGUgZnVuY3Rpb25zIGZvciBlYWNoIGV2ZW50LlxuICogTXV0YXRpbmcgdGhlIGV2ZW50J3MgbWVtYmVycyBhbGxvd3MgdXMgdG8gbm90IGhhdmUgdG8gY3JlYXRlIGEgd3JhcHBpbmdcbiAqIFwiZGlzcGF0Y2hcIiBvYmplY3QgdGhhdCBwYWlycyB0aGUgZXZlbnQgd2l0aCB0aGUgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMoaW5zdCwgcGhhc2UsIGV2ZW50KSB7XG4gIHtcbiAgICB3YXJuaW5nKGluc3QsICdEaXNwYXRjaGluZyBpbnN0IG11c3Qgbm90IGJlIG51bGwnKTtcbiAgfVxuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHBoYXNlKTtcbiAgaWYgKGxpc3RlbmVyKSB7XG4gICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIENvbGxlY3QgZGlzcGF0Y2hlcyAobXVzdCBiZSBlbnRpcmVseSBjb2xsZWN0ZWQgYmVmb3JlIGRpc3BhdGNoaW5nIC0gc2VlIHVuaXRcbiAqIHRlc3RzKS4gTGF6aWx5IGFsbG9jYXRlIHRoZSBhcnJheSB0byBjb25zZXJ2ZSBtZW1vcnkuICBXZSBtdXN0IGxvb3AgdGhyb3VnaFxuICogZWFjaCBldmVudCBhbmQgcGVyZm9ybSB0aGUgdHJhdmVyc2FsIGZvciBlYWNoIG9uZS4gV2UgY2Fubm90IHBlcmZvcm0gYVxuICogc2luZ2xlIHRyYXZlcnNhbCBmb3IgdGhlIGVudGlyZSBjb2xsZWN0aW9uIG9mIGV2ZW50cyBiZWNhdXNlIGVhY2ggZXZlbnQgbWF5XG4gKiBoYXZlIGEgZGlmZmVyZW50IHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKGV2ZW50Ll90YXJnZXRJbnN0LCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBTYW1lIGFzIGBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlYCwgYnV0IHNraXBzIG92ZXIgdGhlIHRhcmdldElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldChldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpIHtcbiAgICB2YXIgdGFyZ2V0SW5zdCA9IGV2ZW50Ll90YXJnZXRJbnN0O1xuICAgIHZhciBwYXJlbnRJbnN0ID0gdGFyZ2V0SW5zdCA/IGdldFBhcmVudEluc3RhbmNlKHRhcmdldEluc3QpIDogbnVsbDtcbiAgICB0cmF2ZXJzZVR3b1BoYXNlKHBhcmVudEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIEFjY3VtdWxhdGVzIHdpdGhvdXQgcmVnYXJkIHRvIGRpcmVjdGlvbiwgZG9lcyBub3QgbG9vayBmb3IgcGhhc2VkXG4gKiByZWdpc3RyYXRpb24gbmFtZXMuIFNhbWUgYXMgYGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlYCBidXQgd2l0aG91dFxuICogcmVxdWlyaW5nIHRoYXQgdGhlIGBkaXNwYXRjaE1hcmtlcmAgYmUgdGhlIHNhbWUgYXMgdGhlIGRpc3BhdGNoZWQgSUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGluc3QsIGlnbm9yZWREaXJlY3Rpb24sIGV2ZW50KSB7XG4gIGlmIChpbnN0ICYmIGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaW5zdCwgcmVnaXN0cmF0aW9uTmFtZSk7XG4gICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcywgaW5zdCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgZGlzcGF0Y2hlcyBvbiBhbiBgU3ludGhldGljRXZlbnRgLCBidXQgb25seSBmb3IgdGhlXG4gKiBgZGlzcGF0Y2hNYXJrZXJgLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUoZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhldmVudC5fdGFyZ2V0SW5zdCwgbnVsbCwgZXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldChldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0bykge1xuICB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGFjY3VtdWxhdGVEaXNwYXRjaGVzLCBsZWF2ZSwgZW50ZXIpO1xufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGUpO1xufVxuXG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IE9iamVjdC5mcmVlemUoe1xuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG5cdGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlczogYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzLFxuXHRhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlczogYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNcbn0pO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBvYmplY3Qgc3RvcmVzIGluZm9ybWF0aW9uIGFib3V0IHRleHQgY29udGVudCBvZiBhIHRhcmdldCBub2RlLFxuICogYWxsb3dpbmcgY29tcGFyaXNvbiBvZiBjb250ZW50IGJlZm9yZSBhbmQgYWZ0ZXIgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBJZGVudGlmeSB0aGUgbm9kZSB3aGVyZSBzZWxlY3Rpb24gY3VycmVudGx5IGJlZ2lucywgdGhlbiBvYnNlcnZlXG4gKiBib3RoIGl0cyB0ZXh0IGNvbnRlbnQgYW5kIGl0cyBjdXJyZW50IHBvc2l0aW9uIGluIHRoZSBET00uIFNpbmNlIHRoZVxuICogYnJvd3NlciBtYXkgbmF0aXZlbHkgcmVwbGFjZSB0aGUgdGFyZ2V0IG5vZGUgZHVyaW5nIGNvbXBvc2l0aW9uLCB3ZSBjYW5cbiAqIHVzZSBpdHMgcG9zaXRpb24gdG8gZmluZCBpdHMgcmVwbGFjZW1lbnQuXG4gKlxuICpcbiAqL1xudmFyIGNvbXBvc2l0aW9uU3RhdGUgPSB7XG4gIF9yb290OiBudWxsLFxuICBfc3RhcnRUZXh0OiBudWxsLFxuICBfZmFsbGJhY2tUZXh0OiBudWxsXG59O1xuXG5mdW5jdGlvbiBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fc3RhcnRUZXh0ID0gZ2V0VGV4dCgpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQoKSB7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QgPSBudWxsO1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBudWxsO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXREYXRhKCkge1xuICBpZiAoY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0KSB7XG4gICAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbiAgfVxuXG4gIHZhciBzdGFydDtcbiAgdmFyIHN0YXJ0VmFsdWUgPSBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQ7XG4gIHZhciBzdGFydExlbmd0aCA9IHN0YXJ0VmFsdWUubGVuZ3RoO1xuICB2YXIgZW5kO1xuICB2YXIgZW5kVmFsdWUgPSBnZXRUZXh0KCk7XG4gIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgc3RhcnRMZW5ndGg7IHN0YXJ0KyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydF0gIT09IGVuZFZhbHVlW3N0YXJ0XSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gIGZvciAoZW5kID0gMTsgZW5kIDw9IG1pbkVuZDsgZW5kKyspIHtcbiAgICBpZiAoc3RhcnRWYWx1ZVtzdGFydExlbmd0aCAtIGVuZF0gIT09IGVuZFZhbHVlW2VuZExlbmd0aCAtIGVuZF0pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0ID0gZW5kVmFsdWUuc2xpY2Uoc3RhcnQsIHNsaWNlVGFpbCk7XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQ7XG59XG5cbmZ1bmN0aW9uIGdldFRleHQoKSB7XG4gIGlmICgndmFsdWUnIGluIGNvbXBvc2l0aW9uU3RhdGUuX3Jvb3QpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdC52YWx1ZTtcbiAgfVxuICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xufVxuXG4vKiBlc2xpbnQgdmFsaWQtdHlwZW9mOiAwICovXG5cbnZhciBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IGZhbHNlO1xudmFyIGlzUHJveHlTdXBwb3J0ZWQgPSB0eXBlb2YgUHJveHkgPT09ICdmdW5jdGlvbic7XG52YXIgRVZFTlRfUE9PTF9TSVpFID0gMTA7XG5cbnZhciBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyA9IFsnZGlzcGF0Y2hDb25maWcnLCAnX3RhcmdldEluc3QnLCAnbmF0aXZlRXZlbnQnLCAnaXNEZWZhdWx0UHJldmVudGVkJywgJ2lzUHJvcGFnYXRpb25TdG9wcGVkJywgJ19kaXNwYXRjaExpc3RlbmVycycsICdfZGlzcGF0Y2hJbnN0YW5jZXMnXTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEV2ZW50SW50ZXJmYWNlID0ge1xuICB0eXBlOiBudWxsLFxuICB0YXJnZXQ6IG51bGwsXG4gIC8vIGN1cnJlbnRUYXJnZXQgaXMgc2V0IHdoZW4gZGlzcGF0Y2hpbmc7IG5vIHVzZSBpbiBjb3B5aW5nIGl0IGhlcmVcbiAgY3VycmVudFRhcmdldDogZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0geyp9IHRhcmdldEluc3QgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSBuYXRpdmVFdmVudFRhcmdldCBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB7XG4gICAgLy8gdGhlc2UgaGF2ZSBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgZGVsZXRlIHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgZGVsZXRlIHRoaXMucHJldmVudERlZmF1bHQ7XG4gICAgZGVsZXRlIHRoaXMuc3RvcFByb3BhZ2F0aW9uO1xuICB9XG5cbiAgdGhpcy5kaXNwYXRjaENvbmZpZyA9IGRpc3BhdGNoQ29uZmlnO1xuICB0aGlzLl90YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuXG4gIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gSW50ZXJmYWNlKSB7XG4gICAgaWYgKCFJbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAge1xuICAgICAgZGVsZXRlIHRoaXNbcHJvcE5hbWVdOyAvLyB0aGlzIGhhcyBhIGdldHRlci9zZXR0ZXIgZm9yIHdhcm5pbmdzXG4gICAgfVxuICAgIHZhciBub3JtYWxpemUgPSBJbnRlcmZhY2VbcHJvcE5hbWVdO1xuICAgIGlmIChub3JtYWxpemUpIHtcbiAgICAgIHRoaXNbcHJvcE5hbWVdID0gbm9ybWFsaXplKG5hdGl2ZUV2ZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb3BOYW1lID09PSAndGFyZ2V0Jykge1xuICAgICAgICB0aGlzLnRhcmdldCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpc1twcm9wTmFtZV0gPSBuYXRpdmVFdmVudFtwcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRQcmV2ZW50ZWQgPSBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkICE9IG51bGwgPyBuYXRpdmVFdmVudC5kZWZhdWx0UHJldmVudGVkIDogbmF0aXZlRXZlbnQucmV0dXJuVmFsdWUgPT09IGZhbHNlO1xuICBpZiAoZGVmYXVsdFByZXZlbnRlZCkge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24kMS50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNGYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbl9hc3NpZ24oU3ludGhldGljRXZlbnQucHJvdG90eXBlLCB7XG4gIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB2YXIgZXZlbnQgPSB0aGlzLm5hdGl2ZUV2ZW50O1xuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQucmV0dXJuVmFsdWUgIT09ICd1bmtub3duJykge1xuICAgICAgZXZlbnQucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV2ZW50LmNhbmNlbEJ1YmJsZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICAvLyBUaGUgQ2hhbmdlRXZlbnRQbHVnaW4gcmVnaXN0ZXJzIGEgXCJwcm9wZXJ0eWNoYW5nZVwiIGV2ZW50IGZvclxuICAgICAgLy8gSUUuIFRoaXMgZXZlbnQgZG9lcyBub3Qgc3VwcG9ydCBidWJibGluZyBvciBjYW5jZWxsaW5nLCBhbmRcbiAgICAgIC8vIGFueSByZWZlcmVuY2VzIHRvIGNhbmNlbEJ1YmJsZSB0aHJvdyBcIk1lbWJlciBub3QgZm91bmRcIi4gIEFcbiAgICAgIC8vIHR5cGVvZiBjaGVjayBvZiBcInVua25vd25cIiBjaXJjdW12ZW50cyB0aGlzIGlzc3VlIChhbmQgaXMgYWxzb1xuICAgICAgLy8gSUUgc3BlY2lmaWMpLlxuICAgICAgZXZlbnQuY2FuY2VsQnViYmxlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkID0gZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoaXMgZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGJhY2sgaW50byB0aGUgcG9vbC5cbiAgICpcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGlzIHNob3VsZCBub3QgYmUgcmVsZWFzZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIGlzUGVyc2lzdGVudDogZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zRmFsc2UsXG5cbiAgLyoqXG4gICAqIGBQb29sZWRDbGFzc2AgbG9va3MgZm9yIGBkZXN0cnVjdG9yYCBvbiBlYWNoIGluc3RhbmNlIGl0IHJlbGVhc2VzLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBJbnRlcmZhY2UgPSB0aGlzLmNvbnN0cnVjdG9yLkludGVyZmFjZTtcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICAgIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIHByb3BOYW1lLCBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBJbnRlcmZhY2VbcHJvcE5hbWVdKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXNbc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXNbaV1dID0gbnVsbDtcbiAgICB9XG4gICAge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICduYXRpdmVFdmVudCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ25hdGl2ZUV2ZW50JywgbnVsbCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdwcmV2ZW50RGVmYXVsdCcsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3ByZXZlbnREZWZhdWx0JywgZW1wdHlGdW5jdGlvbiQxKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3N0b3BQcm9wYWdhdGlvbicsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24oJ3N0b3BQcm9wYWdhdGlvbicsIGVtcHR5RnVuY3Rpb24kMSkpO1xuICAgIH1cbiAgfVxufSk7XG5cblN5bnRoZXRpY0V2ZW50LkludGVyZmFjZSA9IEV2ZW50SW50ZXJmYWNlO1xuXG4vKipcbiAqIEhlbHBlciB0byByZWR1Y2UgYm9pbGVycGxhdGUgd2hlbiBjcmVhdGluZyBzdWJjbGFzc2VzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IENsYXNzXG4gKiBAcGFyYW0gez9vYmplY3R9IEludGVyZmFjZVxuICovXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MgPSBmdW5jdGlvbiAoQ2xhc3MsIEludGVyZmFjZSkge1xuICB2YXIgU3VwZXIgPSB0aGlzO1xuXG4gIHZhciBFID0gZnVuY3Rpb24gKCkge307XG4gIEUucHJvdG90eXBlID0gU3VwZXIucHJvdG90eXBlO1xuICB2YXIgcHJvdG90eXBlID0gbmV3IEUoKTtcblxuICBfYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBfYXNzaWduKHt9LCBTdXBlci5JbnRlcmZhY2UsIEludGVyZmFjZSk7XG4gIENsYXNzLmF1Z21lbnRDbGFzcyA9IFN1cGVyLmF1Z21lbnRDbGFzcztcbiAgYWRkRXZlbnRQb29saW5nVG8oQ2xhc3MpO1xufTtcblxuLyoqIFByb3h5aW5nIGFmdGVyIGV2ZXJ5dGhpbmcgc2V0IG9uIFN5bnRoZXRpY0V2ZW50XG4gKiB0byByZXNvbHZlIFByb3h5IGlzc3VlIG9uIHNvbWUgV2ViS2l0IGJyb3dzZXJzXG4gKiBpbiB3aGljaCBzb21lIEV2ZW50IHByb3BlcnRpZXMgYXJlIHNldCB0byB1bmRlZmluZWQgKEdIIzEwMDEwKVxuICovXG57XG4gIGlmIChpc1Byb3h5U3VwcG9ydGVkKSB7XG4gICAgLyplc2xpbnQtZGlzYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICAgIFN5bnRoZXRpY0V2ZW50ID0gbmV3IFByb3h5KFN5bnRoZXRpY0V2ZW50LCB7XG4gICAgICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uICh0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXBwbHkodGFyZ2V0LCBPYmplY3QuY3JlYXRlKHRhcmdldC5wcm90b3R5cGUpLCBhcmdzKTtcbiAgICAgIH0sXG4gICAgICBhcHBseTogZnVuY3Rpb24gKGNvbnN0cnVjdG9yLCB0aGF0LCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJveHkoY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJncyksIHtcbiAgICAgICAgICBzZXQ6IGZ1bmN0aW9uICh0YXJnZXQsIHByb3AsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAocHJvcCAhPT0gJ2lzUGVyc2lzdGVudCcgJiYgIXRhcmdldC5jb25zdHJ1Y3Rvci5JbnRlcmZhY2UuaGFzT3duUHJvcGVydHkocHJvcCkgJiYgc2hvdWxkQmVSZWxlYXNlZFByb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgd2FybmluZyhkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSB8fCB0YXJnZXQuaXNQZXJzaXN0ZW50KCksIFwiVGhpcyBzeW50aGV0aWMgZXZlbnQgaXMgcmV1c2VkIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLiBJZiB5b3UncmUgXCIgKyBcInNlZWluZyB0aGlzLCB5b3UncmUgYWRkaW5nIGEgbmV3IHByb3BlcnR5IGluIHRoZSBzeW50aGV0aWMgZXZlbnQgb2JqZWN0LiBcIiArICdUaGUgcHJvcGVydHkgaXMgbmV2ZXIgcmVsZWFzZWQuIFNlZSAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKTtcbiAgICAgICAgICAgICAgZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFyZ2V0W3Byb3BdID0gdmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIC8qZXNsaW50LWVuYWJsZSBuby1mdW5jLWFzc2lnbiAqL1xuICB9XG59XG5cbmFkZEV2ZW50UG9vbGluZ1RvKFN5bnRoZXRpY0V2ZW50KTtcblxuLyoqXG4gKiBIZWxwZXIgdG8gbnVsbGlmeSBzeW50aGV0aWNFdmVudCBpbnN0YW5jZSBwcm9wZXJ0aWVzIHdoZW4gZGVzdHJ1Y3RpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcHJvcE5hbWVcbiAqIEBwYXJhbSB7P29iamVjdH0gZ2V0VmFsXG4gKiBAcmV0dXJuIHtvYmplY3R9IGRlZmluZVByb3BlcnR5IG9iamVjdFxuICovXG5mdW5jdGlvbiBnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uKHByb3BOYW1lLCBnZXRWYWwpIHtcbiAgdmFyIGlzRnVuY3Rpb24gPSB0eXBlb2YgZ2V0VmFsID09PSAnZnVuY3Rpb24nO1xuICByZXR1cm4ge1xuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBzZXQ6IHNldCxcbiAgICBnZXQ6IGdldFxuICB9O1xuXG4gIGZ1bmN0aW9uIHNldCh2YWwpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdzZXR0aW5nIHRoZSBtZXRob2QnIDogJ3NldHRpbmcgdGhlIHByb3BlcnR5JztcbiAgICB3YXJuKGFjdGlvbiwgJ1RoaXMgaXMgZWZmZWN0aXZlbHkgYSBuby1vcCcpO1xuICAgIHJldHVybiB2YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXQoKSB7XG4gICAgdmFyIGFjdGlvbiA9IGlzRnVuY3Rpb24gPyAnYWNjZXNzaW5nIHRoZSBtZXRob2QnIDogJ2FjY2Vzc2luZyB0aGUgcHJvcGVydHknO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gJ1RoaXMgaXMgYSBuby1vcCBmdW5jdGlvbicgOiAnVGhpcyBpcyBzZXQgdG8gbnVsbCc7XG4gICAgd2FybihhY3Rpb24sIHJlc3VsdCk7XG4gICAgcmV0dXJuIGdldFZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHdhcm4oYWN0aW9uLCByZXN1bHQpIHtcbiAgICB2YXIgd2FybmluZ0NvbmRpdGlvbiA9IGZhbHNlO1xuICAgIHdhcm5pbmcod2FybmluZ0NvbmRpdGlvbiwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgXCIgKyBcInlvdSdyZSAlcyBgJXNgIG9uIGEgcmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gJXMuIFwiICsgJ0lmIHlvdSBtdXN0IGtlZXAgdGhlIG9yaWdpbmFsIHN5bnRoZXRpYyBldmVudCBhcm91bmQsIHVzZSBldmVudC5wZXJzaXN0KCkuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtZXZlbnQtcG9vbGluZyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBhY3Rpb24sIHByb3BOYW1lLCByZXN1bHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFBvb2xlZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wb3AoKTtcbiAgICBFdmVudENvbnN0cnVjdG9yLmNhbGwoaW5zdGFuY2UsIGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIHJldHVybiBuZXcgRXZlbnRDb25zdHJ1Y3RvcihkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUluc3QpO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUG9vbGVkRXZlbnQoZXZlbnQpIHtcbiAgdmFyIEV2ZW50Q29uc3RydWN0b3IgPSB0aGlzO1xuICAhKGV2ZW50IGluc3RhbmNlb2YgRXZlbnRDb25zdHJ1Y3RvcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUcnlpbmcgdG8gcmVsZWFzZSBhbiBldmVudCBpbnN0YW5jZSAgaW50byBhIHBvb2wgb2YgYSBkaWZmZXJlbnQgdHlwZS4nKSA6IHZvaWQgMDtcbiAgZXZlbnQuZGVzdHJ1Y3RvcigpO1xuICBpZiAoRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wubGVuZ3RoIDwgRVZFTlRfUE9PTF9TSVpFKSB7XG4gICAgRXZlbnRDb25zdHJ1Y3Rvci5ldmVudFBvb2wucHVzaChldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkRXZlbnRQb29saW5nVG8oRXZlbnRDb25zdHJ1Y3Rvcikge1xuICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbCA9IFtdO1xuICBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZCA9IGdldFBvb2xlZEV2ZW50O1xuICBFdmVudENvbnN0cnVjdG9yLnJlbGVhc2UgPSByZWxlYXNlUG9vbGVkRXZlbnQ7XG59XG5cbnZhciBTeW50aGV0aWNFdmVudCQxID0gU3ludGhldGljRXZlbnQ7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvI2V2ZW50cy1jb21wb3NpdGlvbmV2ZW50c1xuICovXG52YXIgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQsIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNJbnB1dEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxuLy8gRXZlbnRzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIHByb3BlcnR5IG5hbWVzLlxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGJlZm9yZUlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkJlZm9yZUlucHV0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25CZWZvcmVJbnB1dENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5UHJlc3MnLCAndG9wVGV4dElucHV0JywgJ3RvcFBhc3RlJ11cbiAgfSxcbiAgY29tcG9zaXRpb25FbmQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ29tcG9zaXRpb25FbmQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uRW5kJywgJ3RvcEtleURvd24nLCAndG9wS2V5UHJlc3MnLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJ11cbiAgfSxcbiAgY29tcG9zaXRpb25TdGFydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblN0YXJ0JyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbXBvc2l0aW9uU3RhcnQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvblVwZGF0ZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25VcGRhdGUnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9XG59O1xuXG4vLyBUcmFjayB3aGV0aGVyIHdlJ3ZlIGV2ZXIgaGFuZGxlZCBhIGtleXByZXNzIG9uIHRoZSBzcGFjZSBrZXkuXG52YXIgaGFzU3BhY2VLZXlwcmVzcyA9IGZhbHNlO1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIGEgbmF0aXZlIGtleXByZXNzIGV2ZW50IGlzIGFzc3VtZWQgdG8gYmUgYSBjb21tYW5kLlxuICogVGhpcyBpcyByZXF1aXJlZCBiZWNhdXNlIEZpcmVmb3ggZmlyZXMgYGtleXByZXNzYCBldmVudHMgZm9yIGtleSBjb21tYW5kc1xuICogKGN1dCwgY29weSwgc2VsZWN0LWFsbCwgZXRjLikgZXZlbiB0aG91Z2ggbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLlxuICovXG5mdW5jdGlvbiBpc0tleXByZXNzQ29tbWFuZChuYXRpdmVFdmVudCkge1xuICByZXR1cm4gKG5hdGl2ZUV2ZW50LmN0cmxLZXkgfHwgbmF0aXZlRXZlbnQuYWx0S2V5IHx8IG5hdGl2ZUV2ZW50Lm1ldGFLZXkpICYmXG4gIC8vIGN0cmxLZXkgJiYgYWx0S2V5IGlzIGVxdWl2YWxlbnQgdG8gQWx0R3IsIGFuZCBpcyBub3QgYSBjb21tYW5kLlxuICAhKG5hdGl2ZUV2ZW50LmN0cmxLZXkgJiYgbmF0aXZlRXZlbnQuYWx0S2V5KTtcbn1cblxuLyoqXG4gKiBUcmFuc2xhdGUgbmF0aXZlIHRvcCBsZXZlbCBldmVudHMgaW50byBldmVudCB0eXBlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uU3RhcnQnOlxuICAgICAgcmV0dXJuIGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvblVwZGF0ZSc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblVwZGF0ZTtcbiAgfVxufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIGJlc3QtZ3Vlc3MgbW9kZWwgdGhpbmsgdGhpcyBldmVudCBzaWduaWZpZXMgdGhhdFxuICogY29tcG9zaXRpb24gaGFzIGJlZ3VuP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicgJiYgbmF0aXZlRXZlbnQua2V5Q29kZSA9PT0gU1RBUlRfS0VZQ09ERTtcbn1cblxuLyoqXG4gKiBEb2VzIG91ciBmYWxsYmFjayBtb2RlIHRoaW5rIHRoYXQgdGhpcyBldmVudCBpcyB0aGUgZW5kIG9mIGNvbXBvc2l0aW9uP1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAvLyBDb21tYW5kIGtleXMgaW5zZXJ0IG9yIGNsZWFyIElNRSBpbnB1dC5cbiAgICAgIHJldHVybiBFTkRfS0VZQ09ERVMuaW5kZXhPZihuYXRpdmVFdmVudC5rZXlDb2RlKSAhPT0gLTE7XG4gICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICAvLyBFeHBlY3QgSU1FIGtleUNvZGUgb24gZWFjaCBrZXlkb3duLiBJZiB3ZSBnZXQgYW55IG90aGVyXG4gICAgICAvLyBjb2RlIHdlIG11c3QgaGF2ZSBleGl0ZWQgZWFybGllci5cbiAgICAgIHJldHVybiBuYXRpdmVFdmVudC5rZXlDb2RlICE9PSBTVEFSVF9LRVlDT0RFO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgLy8gRXZlbnRzIGFyZSBub3QgcG9zc2libGUgd2l0aG91dCBjYW5jZWxsaW5nIElNRS5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuLyoqXG4gKiBHb29nbGUgSW5wdXQgVG9vbHMgcHJvdmlkZXMgY29tcG9zaXRpb24gZGF0YSB2aWEgYSBDdXN0b21FdmVudCxcbiAqIHdpdGggdGhlIGBkYXRhYCBwcm9wZXJ0eSBwb3B1bGF0ZWQgaW4gdGhlIGBkZXRhaWxgIG9iamVjdC4gSWYgdGhpc1xuICogaXMgYXZhaWxhYmxlIG9uIHRoZSBldmVudCBvYmplY3QsIHVzZSBpdC4gSWYgbm90LCB0aGlzIGlzIGEgcGxhaW5cbiAqIGNvbXBvc2l0aW9uIGV2ZW50IGFuZCB3ZSBoYXZlIG5vdGhpbmcgc3BlY2lhbCB0byBleHRyYWN0LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudFxuICogQHJldHVybiB7P3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZGV0YWlsID0gbmF0aXZlRXZlbnQuZGV0YWlsO1xuICBpZiAodHlwZW9mIGRldGFpbCA9PT0gJ29iamVjdCcgJiYgJ2RhdGEnIGluIGRldGFpbCkge1xuICAgIHJldHVybiBkZXRhaWwuZGF0YTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gVHJhY2sgdGhlIGN1cnJlbnQgSU1FIGNvbXBvc2l0aW9uIHN0YXR1cywgaWYgYW55LlxudmFyIGlzQ29tcG9zaW5nID0gZmFsc2U7XG5cbi8qKlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRUeXBlO1xuICB2YXIgZmFsbGJhY2tEYXRhO1xuXG4gIGlmIChjYW5Vc2VDb21wb3NpdGlvbkV2ZW50KSB7XG4gICAgZXZlbnRUeXBlID0gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKTtcbiAgfSBlbHNlIGlmICghaXNDb21wb3NpbmcpIHtcbiAgICBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uU3RhcnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIGV2ZW50VHlwZSA9IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZDtcbiAgfVxuXG4gIGlmICghZXZlbnRUeXBlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAodXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEpIHtcbiAgICAvLyBUaGUgY3VycmVudCBjb21wb3NpdGlvbiBpcyBzdG9yZWQgc3RhdGljYWxseSBhbmQgbXVzdCBub3QgYmVcbiAgICAvLyBvdmVyd3JpdHRlbiB3aGlsZSBjb21wb3NpdGlvbiBjb250aW51ZXMuXG4gICAgaWYgKCFpc0NvbXBvc2luZyAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgaXNDb21wb3NpbmcgPSBpbml0aWFsaXplKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9IGVsc2UgaWYgKGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvbkVuZCkge1xuICAgICAgaWYgKGlzQ29tcG9zaW5nKSB7XG4gICAgICAgIGZhbGxiYWNrRGF0YSA9IGdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7VG9wTGV2ZWxUeXBlc30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSAndG9wVGV4dElucHV0JzpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgQnJvd3NlckV2ZW50Q29uc3RhbnRzYC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4gez9zdHJpbmd9IFRoZSBmYWxsYmFjayBzdHJpbmcgZm9yIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgLy8gSWYgd2UgYXJlIGN1cnJlbnRseSBjb21wb3NpbmcgKElNRSkgYW5kIHVzaW5nIGEgZmFsbGJhY2sgdG8gZG8gc28sXG4gIC8vIHRyeSB0byBleHRyYWN0IHRoZSBjb21wb3NlZCBjaGFyYWN0ZXJzIGZyb20gdGhlIGZhbGxiYWNrIG9iamVjdC5cbiAgLy8gSWYgY29tcG9zaXRpb24gZXZlbnQgaXMgYXZhaWxhYmxlLCB3ZSBleHRyYWN0IGEgc3RyaW5nIG9ubHkgYXRcbiAgLy8gY29tcG9zaXRpb25ldmVudCwgb3RoZXJ3aXNlIGV4dHJhY3QgaXQgYXQgZmFsbGJhY2sgZXZlbnRzLlxuICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ29tcG9zaXRpb25FbmQnIHx8ICFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ICYmIGlzRmFsbGJhY2tDb21wb3NpdGlvbkVuZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgdmFyIGNoYXJzID0gZ2V0RGF0YSgpO1xuICAgICAgcmVzZXQoKTtcbiAgICAgIGlzQ29tcG9zaW5nID0gZmFsc2U7XG4gICAgICByZXR1cm4gY2hhcnM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BQYXN0ZSc6XG4gICAgICAvLyBJZiBhIHBhc3RlIGV2ZW50IG9jY3VycyBhZnRlciBhIGtleXByZXNzLCB0aHJvdyBvdXQgdGhlIGlucHV0XG4gICAgICAvLyBjaGFycy4gUGFzdGUgZXZlbnRzIHNob3VsZCBub3QgbGVhZCB0byBCZWZvcmVJbnB1dCBldmVudHMuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAvKipcbiAgICAgICAqIEFzIG9mIHYyNywgRmlyZWZveCBtYXkgZmlyZSBrZXlwcmVzcyBldmVudHMgZXZlbiB3aGVuIG5vIGNoYXJhY3RlclxuICAgICAgICogd2lsbCBiZSBpbnNlcnRlZC4gQSBmZXcgcG9zc2liaWxpdGllczpcbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgYDBgLiBBcnJvdyBrZXlzLCBFc2Mga2V5LCBldGMuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgbm8gY2hhciBpcyBhdmFpbGFibGUuXG4gICAgICAgKiAgIEV4OiAnQWx0R3IgKyBkYCBpbiBQb2xpc2guIFRoZXJlIGlzIG5vIG1vZGlmaWVkIGNoYXJhY3RlciBmb3JcbiAgICAgICAqICAgdGhpcyBrZXkgY29tYmluYXRpb24gYW5kIG5vIGNoYXJhY3RlciBpcyBpbnNlcnRlZCBpbnRvIHRoZVxuICAgICAgICogICBkb2N1bWVudCwgYnV0IEZGIGZpcmVzIHRoZSBrZXlwcmVzcyBmb3IgY2hhciBjb2RlIGAxMDBgIGFueXdheS5cbiAgICAgICAqICAgTm8gYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyB0aGUgcHJlc3NlZCBrZXkgY29kZSwgYnV0IGEgY29tbWFuZCBjb21iaW5hdGlvbiBpc1xuICAgICAgICogICBiZWluZyB1c2VkLiBFeDogYENtZCtDYC4gTm8gY2hhcmFjdGVyIGlzIGluc2VydGVkLCBhbmQgbm9cbiAgICAgICAqICAgYGlucHV0YCBldmVudCB3aWxsIG9jY3VyLlxuICAgICAgICovXG4gICAgICBpZiAoIWlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSkge1xuICAgICAgICAvLyBJRSBmaXJlcyB0aGUgYGtleXByZXNzYCBldmVudCB3aGVuIGEgdXNlciB0eXBlcyBhbiBlbW9qaSB2aWFcbiAgICAgICAgLy8gVG91Y2gga2V5Ym9hcmQgb2YgV2luZG93cy4gIEluIHN1Y2ggYSBjYXNlLCB0aGUgYGNoYXJgIHByb3BlcnR5XG4gICAgICAgIC8vIGhvbGRzIGFuIGVtb2ppIGNoYXJhY3RlciBsaWtlIGBcXHVEODNEXFx1REUwQWAuICBCZWNhdXNlIGl0cyBsZW5ndGhcbiAgICAgICAgLy8gaXMgMiwgdGhlIHByb3BlcnR5IGB3aGljaGAgZG9lcyBub3QgcmVwcmVzZW50IGFuIGVtb2ppIGNvcnJlY3RseS5cbiAgICAgICAgLy8gSW4gc3VjaCBhIGNhc2UsIHdlIGRpcmVjdGx5IHJldHVybiB0aGUgYGNoYXJgIHByb3BlcnR5IGluc3RlYWQgb2ZcbiAgICAgICAgLy8gdXNpbmcgYHdoaWNoYC5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmNoYXIgJiYgbmF0aXZlRXZlbnQuY2hhci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmNoYXI7XG4gICAgICAgIH0gZWxzZSBpZiAobmF0aXZlRXZlbnQud2hpY2gpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShuYXRpdmVFdmVudC53aGljaCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBjaGFycztcblxuICBpZiAoY2FuVXNlVGV4dElucHV0RXZlbnQpIHtcbiAgICBjaGFycyA9IGdldE5hdGl2ZUJlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH0gZWxzZSB7XG4gICAgY2hhcnMgPSBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCk7XG4gIH1cblxuICAvLyBJZiBubyBjaGFyYWN0ZXJzIGFyZSBiZWluZyBpbnNlcnRlZCwgbm8gQmVmb3JlSW5wdXQgZXZlbnQgc2hvdWxkXG4gIC8vIGJlIGZpcmVkLlxuICBpZiAoIWNoYXJzKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNJbnB1dEV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLmJlZm9yZUlucHV0LCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gIGV2ZW50LmRhdGEgPSBjaGFycztcbiAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gIHJldHVybiBldmVudDtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYW4gYG9uQmVmb3JlSW5wdXRgIGV2ZW50IHRvIG1hdGNoXG4gKiBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNS8jZXZlbnRzLWlucHV0ZXZlbnRzLlxuICpcbiAqIFRoaXMgZXZlbnQgcGx1Z2luIGlzIGJhc2VkIG9uIHRoZSBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRcbiAqIGF2YWlsYWJsZSBpbiBDaHJvbWUsIFNhZmFyaSwgT3BlcmEsIGFuZCBJRS4gVGhpcyBldmVudCBmaXJlcyBhZnRlclxuICogYG9uS2V5UHJlc3NgIGFuZCBgb25Db21wb3NpdGlvbkVuZGAsIGJ1dCBiZWZvcmUgYG9uSW5wdXRgLlxuICpcbiAqIGBiZWZvcmVJbnB1dGAgaXMgc3BlYydkIGJ1dCBub3QgaW1wbGVtZW50ZWQgaW4gYW55IGJyb3dzZXJzLCBhbmRcbiAqIHRoZSBgaW5wdXRgIGV2ZW50IGRvZXMgbm90IHByb3ZpZGUgYW55IHVzZWZ1bCBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGhhc1xuICogYWN0dWFsbHkgYmVlbiBhZGRlZCwgY29udHJhcnkgdG8gdGhlIHNwZWMuIFRodXMsIGB0ZXh0SW5wdXRgIGlzIHRoZSBiZXN0XG4gKiBhdmFpbGFibGUgZXZlbnQgdG8gaWRlbnRpZnkgdGhlIGNoYXJhY3RlcnMgdGhhdCBoYXZlIGFjdHVhbGx5IGJlZW4gaW5zZXJ0ZWRcbiAqIGludG8gdGhlIHRhcmdldCBub2RlLlxuICpcbiAqIFRoaXMgcGx1Z2luIGlzIGFsc28gcmVzcG9uc2libGUgZm9yIGVtaXR0aW5nIGBjb21wb3NpdGlvbmAgZXZlbnRzLCB0aHVzXG4gKiBhbGxvd2luZyB1cyB0byBzaGFyZSBjb21wb3NpdGlvbiBmYWxsYmFjayBjb2RlIGZvciBib3RoIGBiZWZvcmVJbnB1dGAgYW5kXG4gKiBgY29tcG9zaXRpb25gIGV2ZW50IHR5cGVzLlxuICovXG52YXIgQmVmb3JlSW5wdXRFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICByZXR1cm4gW2V4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSwgZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxuLy8gVXNlIHRvIHJlc3RvcmUgY29udHJvbGxlZCBzdGF0ZSBhZnRlciBhIGNoYW5nZSBldmVudCBoYXMgZmlyZWQuXG5cbnZhciBmaWJlckhvc3RDb21wb25lbnQgPSBudWxsO1xuXG52YXIgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OiBmdW5jdGlvbiAoaG9zdENvbXBvbmVudEltcGwpIHtcbiAgICAvLyBUaGUgZmliZXIgaW1wbGVtZW50YXRpb24gZG9lc24ndCB1c2UgZHluYW1pYyBkaXNwYXRjaCBzbyB3ZSBuZWVkIHRvXG4gICAgLy8gaW5qZWN0IHRoZSBpbXBsZW1lbnRhdGlvbi5cbiAgICBmaWJlckhvc3RDb21wb25lbnQgPSBob3N0Q29tcG9uZW50SW1wbDtcbiAgfVxufTtcblxudmFyIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xudmFyIHJlc3RvcmVRdWV1ZSA9IG51bGw7XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCkge1xuICAvLyBXZSBwZXJmb3JtIHRoaXMgdHJhbnNsYXRpb24gYXQgdGhlIGVuZCBvZiB0aGUgZXZlbnQgbG9vcCBzbyB0aGF0IHdlXG4gIC8vIGFsd2F5cyByZWNlaXZlIHRoZSBjb3JyZWN0IGZpYmVyIGhlcmVcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKHRhcmdldCk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIC8vIFVubW91bnRlZFxuICAgIHJldHVybjtcbiAgfVxuICAhKGZpYmVySG9zdENvbXBvbmVudCAmJiB0eXBlb2YgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRmliZXIgbmVlZHMgdG8gYmUgaW5qZWN0ZWQgdG8gaGFuZGxlIGEgZmliZXIgdGFyZ2V0IGZvciBjb250cm9sbGVkIGV2ZW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShpbnRlcm5hbEluc3RhbmNlLnN0YXRlTm9kZSk7XG4gIGZpYmVySG9zdENvbXBvbmVudC5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlLCBpbnRlcm5hbEluc3RhbmNlLnR5cGUsIHByb3BzKTtcbn1cblxudmFyIGluamVjdGlvbiQzID0gUmVhY3RDb250cm9sbGVkQ29tcG9uZW50SW5qZWN0aW9uO1xuXG5mdW5jdGlvbiBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCkge1xuICBpZiAocmVzdG9yZVRhcmdldCkge1xuICAgIGlmIChyZXN0b3JlUXVldWUpIHtcbiAgICAgIHJlc3RvcmVRdWV1ZS5wdXNoKHRhcmdldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3RvcmVRdWV1ZSA9IFt0YXJnZXRdO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXN0b3JlVGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCkge1xuICBpZiAoIXJlc3RvcmVUYXJnZXQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIHRhcmdldCA9IHJlc3RvcmVUYXJnZXQ7XG4gIHZhciBxdWV1ZWRUYXJnZXRzID0gcmVzdG9yZVF1ZXVlO1xuICByZXN0b3JlVGFyZ2V0ID0gbnVsbDtcbiAgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuICByZXN0b3JlU3RhdGVPZlRhcmdldCh0YXJnZXQpO1xuICBpZiAocXVldWVkVGFyZ2V0cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcXVldWVkVGFyZ2V0cy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzdG9yZVN0YXRlT2ZUYXJnZXQocXVldWVkVGFyZ2V0c1tpXSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0aW5qZWN0aW9uOiBpbmplY3Rpb24kMyxcblx0ZW5xdWV1ZVN0YXRlUmVzdG9yZTogZW5xdWV1ZVN0YXRlUmVzdG9yZSxcblx0cmVzdG9yZVN0YXRlSWZOZWVkZWQ6IHJlc3RvcmVTdGF0ZUlmTmVlZGVkXG59KTtcblxuLy8gVXNlZCBhcyBhIHdheSB0byBjYWxsIGJhdGNoZWRVcGRhdGVzIHdoZW4gd2UgZG9uJ3QgaGF2ZSBhIHJlZmVyZW5jZSB0b1xuLy8gdGhlIHJlbmRlcmVyLiBTdWNoIGFzIHdoZW4gd2UncmUgZGlzcGF0Y2hpbmcgZXZlbnRzIG9yIGlmIHRoaXJkIHBhcnR5XG4vLyBsaWJyYXJpZXMgbmVlZCB0byBjYWxsIGJhdGNoZWRVcGRhdGVzLiBFdmVudHVhbGx5LCB0aGlzIEFQSSB3aWxsIGdvIGF3YXkgd2hlblxuLy8gZXZlcnl0aGluZyBpcyBiYXRjaGVkIGJ5IGRlZmF1bHQuIFdlJ2xsIHRoZW4gaGF2ZSBhIHNpbWlsYXIgQVBJIHRvIG9wdC1vdXQgb2Zcbi8vIHNjaGVkdWxlZCB3b3JrIGFuZCBpbnN0ZWFkIGRvIHN5bmNocm9ub3VzIHdvcmsuXG5cbi8vIERlZmF1bHRzXG52YXIgZmliZXJCYXRjaGVkVXBkYXRlcyA9IGZ1bmN0aW9uIChmbiwgYm9va2tlZXBpbmcpIHtcbiAgcmV0dXJuIGZuKGJvb2trZWVwaW5nKTtcbn07XG5cbnZhciBpc05lc3RpbmdCYXRjaGVkID0gZmFsc2U7XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpIHtcbiAgaWYgKGlzTmVzdGluZ0JhdGNoZWQpIHtcbiAgICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGluc2lkZSBhbm90aGVyIGJhdGNoLCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXRcbiAgICAvLyBmdWxseSBjb21wbGV0ZXMgYmVmb3JlIHJlc3RvcmluZyBzdGF0ZS4gVGhlcmVmb3JlLCB3ZSBhZGQgdGhlIHRhcmdldCB0b1xuICAgIC8vIGEgcXVldWUgb2Ygd29yay5cbiAgICByZXR1cm4gZmliZXJCYXRjaGVkVXBkYXRlcyhmbiwgYm9va2tlZXBpbmcpO1xuICB9XG4gIGlzTmVzdGluZ0JhdGNoZWQgPSB0cnVlO1xuICB0cnkge1xuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH0gZmluYWxseSB7XG4gICAgLy8gSGVyZSB3ZSB3YWl0IHVudGlsIGFsbCB1cGRhdGVzIGhhdmUgcHJvcGFnYXRlZCwgd2hpY2ggaXMgaW1wb3J0YW50XG4gICAgLy8gd2hlbiB1c2luZyBjb250cm9sbGVkIGNvbXBvbmVudHMgd2l0aGluIGxheWVyczpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgICAvLyBUaGVuIHdlIHJlc3RvcmUgc3RhdGUgb2YgYW55IGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICAgIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbiAgICByZXN0b3JlU3RhdGVJZk5lZWRlZCgpO1xuICB9XG59XG5cbnZhciBSZWFjdEdlbmVyaWNCYXRjaGluZ0luamVjdGlvbiA9IHtcbiAgaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlczogZnVuY3Rpb24gKF9iYXRjaGVkVXBkYXRlcykge1xuICAgIGZpYmVyQmF0Y2hlZFVwZGF0ZXMgPSBfYmF0Y2hlZFVwZGF0ZXM7XG4gIH1cbn07XG5cbnZhciBpbmplY3Rpb24kNCA9IFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgY29sb3I6IHRydWUsXG4gIGRhdGU6IHRydWUsXG4gIGRhdGV0aW1lOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICBlbWFpbDogdHJ1ZSxcbiAgbW9udGg6IHRydWUsXG4gIG51bWJlcjogdHJ1ZSxcbiAgcGFzc3dvcmQ6IHRydWUsXG4gIHJhbmdlOiB0cnVlLFxuICBzZWFyY2g6IHRydWUsXG4gIHRlbDogdHJ1ZSxcbiAgdGV4dDogdHJ1ZSxcbiAgdGltZTogdHJ1ZSxcbiAgdXJsOiB0cnVlLFxuICB3ZWVrOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBpc1RleHRJbnB1dEVsZW1lbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIGlmIChub2RlTmFtZSA9PT0gJ2lucHV0Jykge1xuICAgIHJldHVybiAhIXN1cHBvcnRlZElucHV0VHlwZXNbZWxlbS50eXBlXTtcbiAgfVxuXG4gIGlmIChub2RlTmFtZSA9PT0gJ3RleHRhcmVhJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEhUTUwgbm9kZVR5cGUgdmFsdWVzIHRoYXQgcmVwcmVzZW50IHRoZSB0eXBlIG9mIHRoZSBub2RlXG4gKi9cblxudmFyIEVMRU1FTlRfTk9ERSA9IDE7XG52YXIgVEVYVF9OT0RFID0gMztcbnZhciBDT01NRU5UX05PREUgPSA4O1xudmFyIERPQ1VNRU5UX05PREUgPSA5O1xudmFyIERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgPSAxMTtcblxuLyoqXG4gKiBHZXRzIHRoZSB0YXJnZXQgbm9kZSBmcm9tIGEgbmF0aXZlIGJyb3dzZXIgZXZlbnQgYnkgYWNjb3VudGluZyBmb3JcbiAqIGluY29uc2lzdGVuY2llcyBpbiBicm93c2VyIERPTSBBUElzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBUYXJnZXQgbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpIHtcbiAgdmFyIHRhcmdldCA9IG5hdGl2ZUV2ZW50LnRhcmdldCB8fCBuYXRpdmVFdmVudC5zcmNFbGVtZW50IHx8IHdpbmRvdztcblxuICAvLyBOb3JtYWxpemUgU1ZHIDx1c2U+IGVsZW1lbnQgZXZlbnRzICM0OTYzXG4gIGlmICh0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQpIHtcbiAgICB0YXJnZXQgPSB0YXJnZXQuY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gIH1cblxuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSBURVhUX05PREUgPyB0YXJnZXQucGFyZW50Tm9kZSA6IHRhcmdldDtcbn1cblxudmFyIHVzZUhhc0ZlYXR1cmU7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHVzZUhhc0ZlYXR1cmUgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbiAmJiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmXG4gIC8vIGFsd2F5cyByZXR1cm5zIHRydWUgaW4gbmV3ZXIgYnJvd3NlcnMgYXMgcGVyIHRoZSBzdGFuZGFyZC5cbiAgLy8gQHNlZSBodHRwOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jZG9tLWRvbWltcGxlbWVudGF0aW9uLWhhc2ZlYXR1cmVcbiAgZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnJywgJycpICE9PSB0cnVlO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhbiBldmVudCBpcyBzdXBwb3J0ZWQgaW4gdGhlIGN1cnJlbnQgZXhlY3V0aW9uIGVudmlyb25tZW50LlxuICpcbiAqIE5PVEU6IFRoaXMgd2lsbCBub3Qgd29yayBjb3JyZWN0bHkgZm9yIG5vbi1nZW5lcmljIGV2ZW50cyBzdWNoIGFzIGBjaGFuZ2VgLFxuICogYHJlc2V0YCwgYGxvYWRgLCBgZXJyb3JgLCBhbmQgYHNlbGVjdGAuXG4gKlxuICogQm9ycm93cyBmcm9tIE1vZGVybml6ci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lU3VmZml4IEV2ZW50IG5hbWUsIGUuZy4gXCJjbGlja1wiLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gY2FwdHVyZSBDaGVjayBpZiB0aGUgY2FwdHVyZSBwaGFzZSBpcyBzdXBwb3J0ZWQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCBpcyBzdXBwb3J0ZWQuXG4gKiBAaW50ZXJuYWxcbiAqIEBsaWNlbnNlIE1vZGVybml6ciAzLjAuMHByZSAoQ3VzdG9tIEJ1aWxkKSB8IE1JVFxuICovXG5mdW5jdGlvbiBpc0V2ZW50U3VwcG9ydGVkKGV2ZW50TmFtZVN1ZmZpeCwgY2FwdHVyZSkge1xuICBpZiAoIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSB8fCBjYXB0dXJlICYmICEoJ2FkZEV2ZW50TGlzdGVuZXInIGluIGRvY3VtZW50KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBldmVudE5hbWUgPSAnb24nICsgZXZlbnROYW1lU3VmZml4O1xuICB2YXIgaXNTdXBwb3J0ZWQgPSBldmVudE5hbWUgaW4gZG9jdW1lbnQ7XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCkge1xuICAgIHZhciBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoZXZlbnROYW1lLCAncmV0dXJuOycpO1xuICAgIGlzU3VwcG9ydGVkID0gdHlwZW9mIGVsZW1lbnRbZXZlbnROYW1lXSA9PT0gJ2Z1bmN0aW9uJztcbiAgfVxuXG4gIGlmICghaXNTdXBwb3J0ZWQgJiYgdXNlSGFzRmVhdHVyZSAmJiBldmVudE5hbWVTdWZmaXggPT09ICd3aGVlbCcpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBvbmx5IHdheSB0byB0ZXN0IHN1cHBvcnQgZm9yIHRoZSBgd2hlZWxgIGV2ZW50IGluIElFOSsuXG4gICAgaXNTdXBwb3J0ZWQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCdFdmVudHMud2hlZWwnLCAnMy4wJyk7XG4gIH1cblxuICByZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQ2hlY2thYmxlKGVsZW0pIHtcbiAgdmFyIHR5cGUgPSBlbGVtLnR5cGU7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWU7XG4gIHJldHVybiBub2RlTmFtZSAmJiBub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnaW5wdXQnICYmICh0eXBlID09PSAnY2hlY2tib3gnIHx8IHR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFja2VyKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuX3ZhbHVlVHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gZGV0YWNoVHJhY2tlcihub2RlKSB7XG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldFZhbHVlRnJvbU5vZGUobm9kZSkge1xuICB2YXIgdmFsdWUgPSAnJztcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzQ2hlY2thYmxlKG5vZGUpKSB7XG4gICAgdmFsdWUgPSBub2RlLmNoZWNrZWQgPyAndHJ1ZScgOiAnZmFsc2UnO1xuICB9IGVsc2Uge1xuICAgIHZhbHVlID0gbm9kZS52YWx1ZTtcbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdHJhY2tWYWx1ZU9uTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZUZpZWxkID0gaXNDaGVja2FibGUobm9kZSkgPyAnY2hlY2tlZCcgOiAndmFsdWUnO1xuICB2YXIgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iobm9kZS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHZhbHVlRmllbGQpO1xuXG4gIHZhciBjdXJyZW50VmFsdWUgPSAnJyArIG5vZGVbdmFsdWVGaWVsZF07XG5cbiAgLy8gaWYgc29tZW9uZSBoYXMgYWxyZWFkeSBkZWZpbmVkIGEgdmFsdWUgb3IgU2FmYXJpLCB0aGVuIGJhaWxcbiAgLy8gYW5kIGRvbid0IHRyYWNrIHZhbHVlIHdpbGwgY2F1c2Ugb3ZlciByZXBvcnRpbmcgb2YgY2hhbmdlcyxcbiAgLy8gYnV0IGl0J3MgYmV0dGVyIHRoZW4gYSBoYXJkIGZhaWx1cmVcbiAgLy8gKG5lZWRlZCBmb3IgY2VydGFpbiB0ZXN0cyB0aGF0IHNweU9uIGlucHV0IHZhbHVlcyBhbmQgU2FmYXJpKVxuICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eSh2YWx1ZUZpZWxkKSB8fCB0eXBlb2YgZGVzY3JpcHRvci5nZXQgIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGRlc2NyaXB0b3Iuc2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG5vZGUsIHZhbHVlRmllbGQsIHtcbiAgICBlbnVtZXJhYmxlOiBkZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGRlc2NyaXB0b3IuZ2V0LmNhbGwodGhpcyk7XG4gICAgfSxcbiAgICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgY3VycmVudFZhbHVlID0gJycgKyB2YWx1ZTtcbiAgICAgIGRlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgdmFyIHRyYWNrZXIgPSB7XG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50VmFsdWU7XG4gICAgfSxcbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH0sXG4gICAgc3RvcFRyYWNraW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICBkZXRhY2hUcmFja2VyKG5vZGUpO1xuICAgICAgZGVsZXRlIG5vZGVbdmFsdWVGaWVsZF07XG4gICAgfVxuICB9O1xuICByZXR1cm4gdHJhY2tlcjtcbn1cblxuZnVuY3Rpb24gdHJhY2sobm9kZSkge1xuICBpZiAoZ2V0VHJhY2tlcihub2RlKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIFRPRE86IE9uY2UgaXQncyBqdXN0IEZpYmVyIHdlIGNhbiBtb3ZlIHRoaXMgdG8gbm9kZS5fd3JhcHBlclN0YXRlXG4gIG5vZGUuX3ZhbHVlVHJhY2tlciA9IHRyYWNrVmFsdWVPbk5vZGUobm9kZSk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVZhbHVlSWZDaGFuZ2VkKG5vZGUpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHRyYWNrZXIgPSBnZXRUcmFja2VyKG5vZGUpO1xuICAvLyBpZiB0aGVyZSBpcyBubyB0cmFja2VyIGF0IHRoaXMgcG9pbnQgaXQncyB1bmxpa2VseVxuICAvLyB0aGF0IHRyeWluZyBhZ2FpbiB3aWxsIHN1Y2NlZWRcbiAgaWYgKCF0cmFja2VyKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB2YXIgbGFzdFZhbHVlID0gdHJhY2tlci5nZXRWYWx1ZSgpO1xuICB2YXIgbmV4dFZhbHVlID0gZ2V0VmFsdWVGcm9tTm9kZShub2RlKTtcbiAgaWYgKG5leHRWYWx1ZSAhPT0gbGFzdFZhbHVlKSB7XG4gICAgdHJhY2tlci5zZXRWYWx1ZShuZXh0VmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGV2ZW50VHlwZXMkMSA9IHtcbiAgY2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNoYW5nZScsXG4gICAgICBjYXB0dXJlZDogJ29uQ2hhbmdlQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENoYW5nZScsICd0b3BDbGljaycsICd0b3BGb2N1cycsICd0b3BJbnB1dCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChpbnN0LCBuYXRpdmVFdmVudCwgdGFyZ2V0KSB7XG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMS5jaGFuZ2UsIGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpO1xuICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gIC8vIEZsYWcgdGhpcyBldmVudCBsb29wIGFzIG5lZWRpbmcgc3RhdGUgcmVzdG9yZS5cbiAgZW5xdWV1ZVN0YXRlUmVzdG9yZSh0YXJnZXQpO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuLyoqXG4gKiBGb3IgSUUgc2hpbXNcbiAqL1xudmFyIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0ID0gbnVsbDtcblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNoYW5nZWAgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2hhbmdlRXZlbnQoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnc2VsZWN0JyB8fCBub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICdmaWxlJztcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoYWN0aXZlRWxlbWVudEluc3QsIG5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkpO1xuXG4gIC8vIElmIGNoYW5nZSBhbmQgcHJvcGVydHljaGFuZ2UgYnViYmxlZCwgd2UnZCBqdXN0IGJpbmQgdG8gaXQgbGlrZSBhbGwgdGhlXG4gIC8vIG90aGVyIGV2ZW50cyBhbmQgaGF2ZSBpdCBnbyB0aHJvdWdoIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci4gU2luY2UgaXRcbiAgLy8gZG9lc24ndCwgd2UgbWFudWFsbHkgbGlzdGVuIGZvciB0aGUgZXZlbnRzIGFuZCBzbyB3ZSBoYXZlIHRvIGVucXVldWUgYW5kXG4gIC8vIHByb2Nlc3MgdGhlIGFic3RyYWN0IGV2ZW50IG1hbnVhbGx5LlxuICAvL1xuICAvLyBCYXRjaGluZyBpcyBuZWNlc3NhcnkgaGVyZSBpbiBvcmRlciB0byBlbnN1cmUgdGhhdCBhbGwgZXZlbnQgaGFuZGxlcnMgcnVuXG4gIC8vIGJlZm9yZSB0aGUgbmV4dCByZXJlbmRlciAoaW5jbHVkaW5nIGV2ZW50IGhhbmRsZXJzIGF0dGFjaGVkIHRvIGFuY2VzdG9yXG4gIC8vIGVsZW1lbnRzIGluc3RlYWQgb2YgZGlyZWN0bHkgb24gdGhlIGlucHV0KS4gV2l0aG91dCB0aGlzLCBjb250cm9sbGVkXG4gIC8vIGNvbXBvbmVudHMgZG9uJ3Qgd29yayBwcm9wZXJseSBpbiBjb25qdW5jdGlvbiB3aXRoIGV2ZW50IGJ1YmJsaW5nIGJlY2F1c2VcbiAgLy8gdGhlIGNvbXBvbmVudCBpcyByZXJlbmRlcmVkIGFuZCB0aGUgdmFsdWUgcmV2ZXJ0ZWQgYmVmb3JlIGFsbCB0aGUgZXZlbnRcbiAgLy8gaGFuZGxlcnMgY2FuIHJ1bi4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzA4LlxuICBiYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnQpO1xuICBwcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KSB7XG4gIHZhciB0YXJnZXROb2RlID0gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpO1xuICBpZiAodXBkYXRlVmFsdWVJZkNoYW5nZWQodGFyZ2V0Tm9kZSkpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIHRhcmdldEluc3Q7XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGlucHV0YCBldmVudFxuICovXG52YXIgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIElFOSBjbGFpbXMgdG8gc3VwcG9ydCB0aGUgaW5wdXQgZXZlbnQgYnV0IGZhaWxzIHRvIHRyaWdnZXIgaXQgd2hlblxuICAvLyBkZWxldGluZyB0ZXh0LCBzbyB3ZSBpZ25vcmUgaXRzIGlucHV0IGV2ZW50cy5cbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoIWRvY3VtZW50LmRvY3VtZW50TW9kZSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA5KTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBhY3RpdmVFbGVtZW50ID0gdGFyZ2V0O1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IHRhcmdldEluc3Q7XG4gIGFjdGl2ZUVsZW1lbnQuYXR0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIFJlbW92ZXMgdGhlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBjdXJyZW50bHktdHJhY2tlZCBlbGVtZW50LFxuICogaWYgYW55IGV4aXN0cy5cbiAqL1xuZnVuY3Rpb24gc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKSB7XG4gIGlmICghYWN0aXZlRWxlbWVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBIYW5kbGVzIGEgcHJvcGVydHljaGFuZ2UgZXZlbnQsIHNlbmRpbmcgYSBgY2hhbmdlYCBldmVudCBpZlxuICogdGhlIHZhbHVlIG9mIHRoZSBhY3RpdmUgZWxlbWVudCBoYXMgY2hhbmdlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlUHJvcGVydHlDaGFuZ2UobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LnByb3BlcnR5TmFtZSAhPT0gJ3ZhbHVlJykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KSkge1xuICAgIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbCh0b3BMZXZlbFR5cGUsIHRhcmdldCwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wRm9jdXMnKSB7XG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0YXJnZXQsIHRhcmdldEluc3QpO1xuICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgc3RvcFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UoKTtcbiAgfVxufVxuXG4vLyBGb3IgSUU4IGFuZCBJRTkuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wU2VsZWN0aW9uQ2hhbmdlJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlVcCcgfHwgdG9wTGV2ZWxUeXBlID09PSAndG9wS2V5RG93bicpIHtcbiAgICAvLyBPbiB0aGUgc2VsZWN0aW9uY2hhbmdlIGV2ZW50LCB0aGUgdGFyZ2V0IGlzIGp1c3QgZG9jdW1lbnQgd2hpY2ggaXNuJ3RcbiAgICAvLyBoZWxwZnVsIGZvciB1cyBzbyBqdXN0IGNoZWNrIGFjdGl2ZUVsZW1lbnQgaW5zdGVhZC5cbiAgICAvL1xuICAgIC8vIDk5JSBvZiB0aGUgdGltZSwga2V5ZG93biBhbmQga2V5dXAgYXJlbid0IG5lY2Vzc2FyeS4gSUU4IGZhaWxzIHRvIGZpcmVcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBvbiB0aGUgZmlyc3QgaW5wdXQgZXZlbnQgYWZ0ZXIgc2V0dGluZyBgdmFsdWVgIGZyb20gYVxuICAgIC8vIHNjcmlwdCBhbmQgZmlyZXMgb25seSBrZXlkb3duLCBrZXlwcmVzcywga2V5dXAuIENhdGNoaW5nIGtleXVwIHVzdWFsbHlcbiAgICAvLyBnZXRzIGl0IGFuZCBjYXRjaGluZyBrZXlkb3duIGxldHMgdXMgZmlyZSBhbiBldmVudCBmb3IgdGhlIGZpcnN0XG4gICAgLy8ga2V5c3Ryb2tlIGlmIHVzZXIgZG9lcyBhIGtleSByZXBlYXQgKGl0J2xsIGJlIGEgbGl0dGxlIGRlbGF5ZWQ6IHJpZ2h0XG4gICAgLy8gYmVmb3JlIHRoZSBzZWNvbmQga2V5c3Ryb2tlKS4gT3RoZXIgaW5wdXQgbWV0aG9kcyAoZS5nLiwgcGFzdGUpIHNlZW0gdG9cbiAgICAvLyBmaXJlIHNlbGVjdGlvbmNoYW5nZSBub3JtYWxseS5cbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKGFjdGl2ZUVsZW1lbnRJbnN0KTtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2xpY2tgIGV2ZW50XG4gKi9cbmZ1bmN0aW9uIHNob3VsZFVzZUNsaWNrRXZlbnQoZWxlbSkge1xuICAvLyBVc2UgdGhlIGBjbGlja2AgZXZlbnQgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gY2hlY2tib3ggYW5kIHJhZGlvIGlucHV0cy5cbiAgLy8gVGhpcyBhcHByb2FjaCB3b3JrcyBhY3Jvc3MgYWxsIGJyb3dzZXJzLCB3aGVyZWFzIGBjaGFuZ2VgIGRvZXMgbm90IGZpcmVcbiAgLy8gdW50aWwgYGJsdXJgIGluIElFOC5cbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKGVsZW0udHlwZSA9PT0gJ2NoZWNrYm94JyB8fCBlbGVtLnR5cGUgPT09ICdyYWRpbycpO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENsaWNrJykge1xuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQodGFyZ2V0SW5zdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0SW5zdEZvcklucHV0T3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcElucHV0JyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BDaGFuZ2UnKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKGluc3QsIG5vZGUpIHtcbiAgLy8gVE9ETzogSW4gSUUsIGluc3QgaXMgb2NjYXNpb25hbGx5IG51bGwuIFdoeT9cbiAgaWYgKGluc3QgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZpYmVyIGFuZCBSZWFjdERPTSBrZWVwIHdyYXBwZXIgc3RhdGUgaW4gc2VwYXJhdGUgcGxhY2VzXG4gIHZhciBzdGF0ZSA9IGluc3QuX3dyYXBwZXJTdGF0ZSB8fCBub2RlLl93cmFwcGVyU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZSB8fCAhc3RhdGUuY29udHJvbGxlZCB8fCBub2RlLnR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgY29udHJvbGxlZCwgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgdmFsdWUgb24gYmx1clxuICB2YXIgdmFsdWUgPSAnJyArIG5vZGUudmFsdWU7XG4gIGlmIChub2RlLmdldEF0dHJpYnV0ZSgndmFsdWUnKSAhPT0gdmFsdWUpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCB2YWx1ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvbkNoYW5nZWAgZXZlbnQgdGhhdCBub3JtYWxpemVzIGNoYW5nZSBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLiBUaGlzIGV2ZW50IGZpcmVzIGF0IGEgdGltZSB3aGVuIGl0J3MgcG9zc2libGUgdG9cbiAqIGNoYW5nZSB0aGUgZWxlbWVudCdzIHZhbHVlIHdpdGhvdXQgc2VlaW5nIGEgZmxpY2tlci5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBzZWxlY3RcbiAqL1xudmFyIENoYW5nZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDEsXG5cbiAgX2lzSW5wdXRFdmVudFN1cHBvcnRlZDogaXNJbnB1dEV2ZW50U3VwcG9ydGVkLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHZhciBnZXRUYXJnZXRJbnN0RnVuYywgaGFuZGxlRXZlbnRGdW5jO1xuICAgIGlmIChzaG91bGRVc2VDaGFuZ2VFdmVudCh0YXJnZXROb2RlKSkge1xuICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQ7XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGlmIChpc0lucHV0RXZlbnRTdXBwb3J0ZWQpIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2V0VGFyZ2V0SW5zdEZ1bmMgPSBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRFdmVudFBvbHlmaWxsO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJbnN0RnVuYykge1xuICAgICAgdmFyIGluc3QgPSBnZXRUYXJnZXRJbnN0RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpO1xuICAgICAgaWYgKGluc3QpIHtcbiAgICAgICAgdmFyIGV2ZW50ID0gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0YXJnZXROb2RlLCB0YXJnZXRJbnN0KTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIGJsdXJyaW5nLCBzZXQgdGhlIHZhbHVlIGF0dHJpYnV0ZSBmb3IgbnVtYmVyIGlucHV0c1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BCbHVyJykge1xuICAgICAgaGFuZGxlQ29udHJvbGxlZElucHV0Qmx1cih0YXJnZXRJbnN0LCB0YXJnZXROb2RlKTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogTW9kdWxlIHRoYXQgaXMgaW5qZWN0YWJsZSBpbnRvIGBFdmVudFBsdWdpbkh1YmAsIHRoYXQgc3BlY2lmaWVzIGFcbiAqIGRldGVybWluaXN0aWMgb3JkZXJpbmcgb2YgYEV2ZW50UGx1Z2luYHMuIEEgY29udmVuaWVudCB3YXkgdG8gcmVhc29uIGFib3V0XG4gKiBwbHVnaW5zLCB3aXRob3V0IGhhdmluZyB0byBwYWNrYWdlIGV2ZXJ5IG9uZSBvZiB0aGVtLiBUaGlzIGlzIGJldHRlciB0aGFuXG4gKiBoYXZpbmcgcGx1Z2lucyBiZSBvcmRlcmVkIGluIHRoZSBzYW1lIG9yZGVyIHRoYXQgdGhleSBhcmUgaW5qZWN0ZWQgYmVjYXVzZVxuICogdGhhdCBvcmRlcmluZyB3b3VsZCBiZSBpbmZsdWVuY2VkIGJ5IHRoZSBwYWNrYWdpbmcgb3JkZXIuXG4gKiBgUmVzcG9uZGVyRXZlbnRQbHVnaW5gIG11c3Qgb2NjdXIgYmVmb3JlIGBTaW1wbGVFdmVudFBsdWdpbmAgc28gdGhhdFxuICogcHJldmVudGluZyBkZWZhdWx0IG9uIGV2ZW50cyBpcyBjb252ZW5pZW50IGluIGBTaW1wbGVFdmVudFBsdWdpbmAgaGFuZGxlcnMuXG4gKi9cbnZhciBET01FdmVudFBsdWdpbk9yZGVyID0gWydSZXNwb25kZXJFdmVudFBsdWdpbicsICdTaW1wbGVFdmVudFBsdWdpbicsICdUYXBFdmVudFBsdWdpbicsICdFbnRlckxlYXZlRXZlbnRQbHVnaW4nLCAnQ2hhbmdlRXZlbnRQbHVnaW4nLCAnU2VsZWN0RXZlbnRQbHVnaW4nLCAnQmVmb3JlSW5wdXRFdmVudFBsdWdpbiddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVUlFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBVSUV2ZW50SW50ZXJmYWNlID0ge1xuICB2aWV3OiBudWxsLFxuICBkZXRhaWw6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNVSUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNVSUV2ZW50LCBVSUV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIG1vZGlmaWVyIGtleSB0byB0aGUgYXNzb2NpYXRlZCBwcm9wZXJ0eSBpbiB0aGUgZXZlbnQuXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8ja2V5cy1Nb2RpZmllcnNcbiAqL1xuXG52YXIgbW9kaWZpZXJLZXlUb1Byb3AgPSB7XG4gIEFsdDogJ2FsdEtleScsXG4gIENvbnRyb2w6ICdjdHJsS2V5JyxcbiAgTWV0YTogJ21ldGFLZXknLFxuICBTaGlmdDogJ3NoaWZ0S2V5J1xufTtcblxuLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBnZXRNb2RpZmllclN0YXRlIHNvIHdlIHNpbXBseSBtYXAgaXQgdG8gdGhlIG9ubHlcbi8vIG1vZGlmaWVyIGtleXMgZXhwb3NlZCBieSB0aGUgZXZlbnQgaXRzZWxmLCBkb2VzIG5vdCBzdXBwb3J0IExvY2sta2V5cy5cbi8vIEN1cnJlbnRseSwgYWxsIG1ham9yIGJyb3dzZXJzIGV4Y2VwdCBDaHJvbWUgc2VlbXMgdG8gc3VwcG9ydCBMb2NrLWtleXMuXG5mdW5jdGlvbiBtb2RpZmllclN0YXRlR2V0dGVyKGtleUFyZykge1xuICB2YXIgc3ludGhldGljRXZlbnQgPSB0aGlzO1xuICB2YXIgbmF0aXZlRXZlbnQgPSBzeW50aGV0aWNFdmVudC5uYXRpdmVFdmVudDtcbiAgaWYgKG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUpIHtcbiAgICByZXR1cm4gbmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZShrZXlBcmcpO1xuICB9XG4gIHZhciBrZXlQcm9wID0gbW9kaWZpZXJLZXlUb1Byb3Bba2V5QXJnXTtcbiAgcmV0dXJuIGtleVByb3AgPyAhIW5hdGl2ZUV2ZW50W2tleVByb3BdIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldEV2ZW50TW9kaWZpZXJTdGF0ZShuYXRpdmVFdmVudCkge1xuICByZXR1cm4gbW9kaWZpZXJTdGF0ZUdldHRlcjtcbn1cblxuLyoqXG4gKiBAaW50ZXJmYWNlIE1vdXNlRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgTW91c2VFdmVudEludGVyZmFjZSA9IHtcbiAgc2NyZWVuWDogbnVsbCxcbiAgc2NyZWVuWTogbnVsbCxcbiAgY2xpZW50WDogbnVsbCxcbiAgY2xpZW50WTogbnVsbCxcbiAgcGFnZVg6IG51bGwsXG4gIHBhZ2VZOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIGJ1dHRvbjogbnVsbCxcbiAgYnV0dG9uczogbnVsbCxcbiAgcmVsYXRlZFRhcmdldDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgKGV2ZW50LmZyb21FbGVtZW50ID09PSBldmVudC5zcmNFbGVtZW50ID8gZXZlbnQudG9FbGVtZW50IDogZXZlbnQuZnJvbUVsZW1lbnQpO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNNb3VzZUV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNNb3VzZUV2ZW50LCBNb3VzZUV2ZW50SW50ZXJmYWNlKTtcblxudmFyIGV2ZW50VHlwZXMkMiA9IHtcbiAgbW91c2VFbnRlcjoge1xuICAgIHJlZ2lzdHJhdGlvbk5hbWU6ICdvbk1vdXNlRW50ZXInLFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BNb3VzZU91dCcsICd0b3BNb3VzZU92ZXInXVxuICB9LFxuICBtb3VzZUxlYXZlOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VMZWF2ZScsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH1cbn07XG5cbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMixcblxuICAvKipcbiAgICogRm9yIGFsbW9zdCBldmVyeSBpbnRlcmFjdGlvbiB3ZSBjYXJlIGFib3V0LCB0aGVyZSB3aWxsIGJlIGJvdGggYSB0b3AtbGV2ZWxcbiAgICogYG1vdXNlb3ZlcmAgYW5kIGBtb3VzZW91dGAgZXZlbnQgdGhhdCBvY2N1cnMuIE9ubHkgdXNlIGBtb3VzZW91dGAgc28gdGhhdFxuICAgKiB3ZSBkbyBub3QgZXh0cmFjdCBkdXBsaWNhdGUgZXZlbnRzLiBIb3dldmVyLCBtb3ZpbmcgdGhlIG1vdXNlIGludG8gdGhlXG4gICAqIGJyb3dzZXIgZnJvbSBvdXRzaWRlIHdpbGwgbm90IGZpcmUgYSBgbW91c2VvdXRgIGV2ZW50LiBJbiB0aGlzIGNhc2UsIHdlIHVzZVxuICAgKiB0aGUgYG1vdXNlb3ZlcmAgdG9wLWxldmVsIGV2ZW50LlxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcE1vdXNlT3ZlcicgJiYgKG5hdGl2ZUV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgbmF0aXZlRXZlbnQuZnJvbUVsZW1lbnQpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3V0JyAmJiB0b3BMZXZlbFR5cGUgIT09ICd0b3BNb3VzZU92ZXInKSB7XG4gICAgICAvLyBNdXN0IG5vdCBiZSBhIG1vdXNlIGluIG9yIG1vdXNlIG91dCAtIGlnbm9yaW5nLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHdpbjtcbiAgICBpZiAobmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgICAgLy8gYG5hdGl2ZUV2ZW50VGFyZ2V0YCBpcyBwcm9iYWJseSBhIHdpbmRvdyBvYmplY3QuXG4gICAgICB3aW4gPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICBpZiAoZG9jKSB7XG4gICAgICAgIHdpbiA9IGRvYy5kZWZhdWx0VmlldyB8fCBkb2MucGFyZW50V2luZG93O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2luID0gd2luZG93O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBmcm9tO1xuICAgIHZhciB0bztcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdXQnKSB7XG4gICAgICBmcm9tID0gdGFyZ2V0SW5zdDtcbiAgICAgIHZhciByZWxhdGVkID0gbmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC50b0VsZW1lbnQ7XG4gICAgICB0byA9IHJlbGF0ZWQgPyBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyZWxhdGVkKSA6IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmluZyB0byBhIG5vZGUgZnJvbSBvdXRzaWRlIHRoZSB3aW5kb3cuXG4gICAgICBmcm9tID0gbnVsbDtcbiAgICAgIHRvID0gdGFyZ2V0SW5zdDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBmcm9tTm9kZSA9IGZyb20gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMShmcm9tKTtcbiAgICB2YXIgdG9Ob2RlID0gdG8gPT0gbnVsbCA/IHdpbiA6IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0byk7XG5cbiAgICB2YXIgbGVhdmUgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VMZWF2ZSwgZnJvbSwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBsZWF2ZS50eXBlID0gJ21vdXNlbGVhdmUnO1xuICAgIGxlYXZlLnRhcmdldCA9IGZyb21Ob2RlO1xuICAgIGxlYXZlLnJlbGF0ZWRUYXJnZXQgPSB0b05vZGU7XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzJDIubW91c2VFbnRlciwgdG8sIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0b05vZGU7XG4gICAgZW50ZXIucmVsYXRlZFRhcmdldCA9IGZyb21Ob2RlO1xuXG4gICAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbSwgdG8pO1xuXG4gICAgcmV0dXJuIFtsZWF2ZSwgZW50ZXJdO1xuICB9XG59O1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cblxuLyoqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICogdHJhbnNmb3JtIHRoZXNlIHRvIHN0cmluZ3MgZm9yIElFIHN1cHBvcnQuIFdoZW4gdGhpcyB0cmFuc2Zvcm0gaXMgZnVsbHlcbiAqIHN1cHBvcnRlZCB3ZSBjYW4gcmVuYW1lIGl0LlxuICovXG5cblxuZnVuY3Rpb24gZ2V0KGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXI7XG59XG5cbmZ1bmN0aW9uIGhhcyhrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNldChrZXksIHZhbHVlKSB7XG4gIGtleS5fcmVhY3RJbnRlcm5hbEZpYmVyID0gdmFsdWU7XG59XG5cbnZhciBSZWFjdEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikge1xuICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gRG9uJ3QgY2hhbmdlIHRoZXNlIHR3byB2YWx1ZXM6XG52YXIgTm9FZmZlY3QgPSAwOyAvLyAgICAgICAgICAgMGIwMDAwMDAwMFxudmFyIFBlcmZvcm1lZFdvcmsgPSAxOyAvLyAgICAgIDBiMDAwMDAwMDFcblxuLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG52YXIgUGxhY2VtZW50ID0gMjsgLy8gICAgICAgICAgMGIwMDAwMDAxMFxudmFyIFVwZGF0ZSA9IDQ7IC8vICAgICAgICAgICAgIDBiMDAwMDAxMDBcbnZhciBQbGFjZW1lbnRBbmRVcGRhdGUgPSA2OyAvLyAwYjAwMDAwMTEwXG52YXIgRGVsZXRpb24gPSA4OyAvLyAgICAgICAgICAgMGIwMDAwMTAwMFxudmFyIENvbnRlbnRSZXNldCA9IDE2OyAvLyAgICAgIDBiMDAwMTAwMDBcbnZhciBDYWxsYmFjayA9IDMyOyAvLyAgICAgICAgICAwYjAwMTAwMDAwXG52YXIgRXJyID0gNjQ7IC8vICAgICAgICAgICAgICAgMGIwMTAwMDAwMFxudmFyIFJlZiA9IDEyODsgLy8gICAgICAgICAgICAgIDBiMTAwMDAwMDBcblxudmFyIE1PVU5USU5HID0gMTtcbnZhciBNT1VOVEVEID0gMjtcbnZhciBVTk1PVU5URUQgPSAzO1xuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICByZXR1cm4gTU9VTlRJTkc7XG4gICAgfVxuICAgIHdoaWxlIChub2RlWydyZXR1cm4nXSkge1xuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgaWYgKChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkgIT09IE5vRWZmZWN0KSB7XG4gICAgICAgIHJldHVybiBNT1VOVElORztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBNT1VOVEVEO1xuICB9XG4gIC8vIElmIHdlIGRpZG4ndCBoaXQgdGhlIHJvb3QsIHRoYXQgbWVhbnMgdGhhdCB3ZSdyZSBpbiBhbiBkaXNjb25uZWN0ZWQgdHJlZVxuICAvLyB0aGF0IGhhcyBiZWVuIHVubW91bnRlZC5cbiAgcmV0dXJuIFVOTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNGaWJlck1vdW50ZWQoZmliZXIpIHtcbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIHdhcm5pbmcoaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyLCAnJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG4gIGlmICghZmliZXIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQ7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICAhKGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikgPT09IE1PVU5URUQpID8gaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgc3RhdGUgPSBpc0ZpYmVyTW91bnRlZEltcGwoZmliZXIpO1xuICAgICEoc3RhdGUgIT09IFVOTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gICAgaWYgKHN0YXRlID09PSBNT1VOVElORykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBJZiB3ZSBoYXZlIHR3byBwb3NzaWJsZSBicmFuY2hlcywgd2UnbGwgd2FsayBiYWNrd2FyZHMgdXAgdG8gdGhlIHJvb3RcbiAgLy8gdG8gc2VlIHdoYXQgcGF0aCB0aGUgcm9vdCBwb2ludHMgdG8uIE9uIHRoZSB3YXkgd2UgbWF5IGhpdCBvbmUgb2YgdGhlXG4gIC8vIHNwZWNpYWwgY2FzZXMgYW5kIHdlJ2xsIGRlYWwgd2l0aCB0aGVtLlxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB2YXIgcGFyZW50QSA9IGFbJ3JldHVybiddO1xuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QSA/IHBhcmVudEEuYWx0ZXJuYXRlIDogbnVsbDtcbiAgICBpZiAoIXBhcmVudEEgfHwgIXBhcmVudEIpIHtcbiAgICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgLy8gSWYgYm90aCBjb3BpZXMgb2YgdGhlIHBhcmVudCBmaWJlciBwb2ludCB0byB0aGUgc2FtZSBjaGlsZCwgd2UgY2FuXG4gICAgLy8gYXNzdW1lIHRoYXQgdGhlIGNoaWxkIGlzIGN1cnJlbnQuIFRoaXMgaGFwcGVucyB3aGVuIHdlIGJhaWxvdXQgb24gbG93XG4gICAgLy8gcHJpb3JpdHk6IHRoZSBiYWlsZWQgb3V0IGZpYmVyJ3MgY2hpbGQgcmV1c2VzIHRoZSBjdXJyZW50IGNoaWxkLlxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYSkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICAvLyBXZSBzaG91bGQgbmV2ZXIgaGF2ZSBhbiBhbHRlcm5hdGUgZm9yIGFueSBtb3VudGluZyBub2RlLiBTbyB0aGUgb25seVxuICAgICAgLy8gd2F5IHRoaXMgY291bGQgcG9zc2libHkgaGFwcGVuIGlzIGlmIHRoaXMgd2FzIHVubW91bnRlZCwgaWYgYXQgYWxsLlxuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH1cblxuICAgIGlmIChhWydyZXR1cm4nXSAhPT0gYlsncmV0dXJuJ10pIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlciBvZiBBIGFuZCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgQiBwb2ludCB0byBkaWZmZXJlbnRcbiAgICAgIC8vIGZpYmVycy4gV2UgYXNzdW1lIHRoYXQgcmV0dXJuIHBvaW50ZXJzIG5ldmVyIGNyaXNzLWNyb3NzLCBzbyBBIG11c3RcbiAgICAgIC8vIGJlbG9uZyB0byB0aGUgY2hpbGQgc2V0IG9mIEEucmV0dXJuLCBhbmQgQiBtdXN0IGJlbG9uZyB0byB0aGUgY2hpbGRcbiAgICAgIC8vIHNldCBvZiBCLnJldHVybi5cbiAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgYiA9IHBhcmVudEI7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSByZXR1cm4gcG9pbnRlcnMgcG9pbnQgdG8gdGhlIHNhbWUgZmliZXIuIFdlJ2xsIGhhdmUgdG8gdXNlIHRoZVxuICAgICAgLy8gZGVmYXVsdCwgc2xvdyBwYXRoOiBzY2FuIHRoZSBjaGlsZCBzZXRzIG9mIGVhY2ggcGFyZW50IGFsdGVybmF0ZSB0byBzZWVcbiAgICAgIC8vIHdoaWNoIGNoaWxkIGJlbG9uZ3MgdG8gd2hpY2ggc2V0LlxuICAgICAgLy9cbiAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQSdzIGNoaWxkIHNldFxuICAgICAgdmFyIGRpZEZpbmRDaGlsZCA9IGZhbHNlO1xuICAgICAgdmFyIF9jaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBiKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuICAgICAgICAhZGlkRmluZENoaWxkID8gaW52YXJpYW50KGZhbHNlLCAnQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QgcmVsYXRlZCB0byB0aGUgcmV0dXJuIHBvaW50ZXIuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH1cblxuICAgICEoYS5hbHRlcm5hdGUgPT09IGIpID8gaW52YXJpYW50KGZhbHNlLCAnUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzXFwnIGFsdGVybmF0ZXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gIH1cbiAgLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuICAhKGEudGFnID09PSBIb3N0Um9vdCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG4gIGlmIChhLnN0YXRlTm9kZS5jdXJyZW50ID09PSBhKSB7XG4gICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgIHJldHVybiBmaWJlcjtcbiAgfVxuICAvLyBPdGhlcndpc2UgQiBoYXMgdG8gYmUgY3VycmVudCBicmFuY2guXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIGlmICghY3VycmVudFBhcmVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIG5vZGUgPSBjdXJyZW50UGFyZW50O1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAmJiBub2RlLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUgPT09IGN1cnJlbnRQYXJlbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB3aGlsZSAoIW5vZGUuc2libGluZykge1xuICAgICAgaWYgKCFub2RlWydyZXR1cm4nXSB8fCBub2RlWydyZXR1cm4nXSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgLy8gRmxvdyBuZWVkcyB0aGUgcmV0dXJuIG51bGwgaGVyZSwgYnV0IEVTTGludCBjb21wbGFpbnMgYWJvdXQgaXQuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSA9IDEwO1xudmFyIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sID0gW107XG5cbi8qKlxuICogRmluZCB0aGUgZGVlcGVzdCBSZWFjdCBjb21wb25lbnQgY29tcGxldGVseSBjb250YWluaW5nIHRoZSByb290IG9mIHRoZVxuICogcGFzc2VkLWluIGluc3RhbmNlIChmb3IgdXNlIHdoZW4gZW50aXJlIFJlYWN0IHRyZWVzIGFyZSBuZXN0ZWQgd2l0aGluIGVhY2hcbiAqIG90aGVyKS4gSWYgUmVhY3QgdHJlZXMgYXJlIG5vdCBuZXN0ZWQsIHJldHVybnMgbnVsbC5cbiAqL1xuZnVuY3Rpb24gZmluZFJvb3RDb250YWluZXJOb2RlKGluc3QpIHtcbiAgLy8gVE9ETzogSXQgbWF5IGJlIGEgZ29vZCBpZGVhIHRvIGNhY2hlIHRoaXMgdG8gcHJldmVudCB1bm5lY2Vzc2FyeSBET01cbiAgLy8gdHJhdmVyc2FsLCBidXQgY2FjaGluZyBpcyBkaWZmaWN1bHQgdG8gZG8gY29ycmVjdGx5IHdpdGhvdXQgdXNpbmcgYVxuICAvLyBtdXRhdGlvbiBvYnNlcnZlciB0byBsaXN0ZW4gZm9yIGFsbCBET00gY2hhbmdlcy5cbiAgd2hpbGUgKGluc3RbJ3JldHVybiddKSB7XG4gICAgaW5zdCA9IGluc3RbJ3JldHVybiddO1xuICB9XG4gIGlmIChpbnN0LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgd2UncmUgaW4gYSBkZXRhY2hlZCB0cmVlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBpbnN0LnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGFuY2VzdG9yIGhpZXJhcmNoeSBpbiB0b3AgbGV2ZWwgY2FsbGJhY2tcbmZ1bmN0aW9uIGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KSB7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wb3AoKTtcbiAgICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSB0b3BMZXZlbFR5cGU7XG4gICAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBuYXRpdmVFdmVudDtcbiAgICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0b3BMZXZlbFR5cGU6IHRvcExldmVsVHlwZSxcbiAgICBuYXRpdmVFdmVudDogbmF0aXZlRXZlbnQsXG4gICAgdGFyZ2V0SW5zdDogdGFyZ2V0SW5zdCxcbiAgICBhbmNlc3RvcnM6IFtdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgaW5zdGFuY2UubmF0aXZlRXZlbnQgPSBudWxsO1xuICBpbnN0YW5jZS50YXJnZXRJbnN0ID0gbnVsbDtcbiAgaW5zdGFuY2UuYW5jZXN0b3JzLmxlbmd0aCA9IDA7XG4gIGlmIChjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5sZW5ndGggPCBDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUpIHtcbiAgICBjYWxsYmFja0Jvb2trZWVwaW5nUG9vbC5wdXNoKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbEltcGwoYm9va0tlZXBpbmcpIHtcbiAgdmFyIHRhcmdldEluc3QgPSBib29rS2VlcGluZy50YXJnZXRJbnN0O1xuXG4gIC8vIExvb3AgdGhyb3VnaCB0aGUgaGllcmFyY2h5LCBpbiBjYXNlIHRoZXJlJ3MgYW55IG5lc3RlZCBjb21wb25lbnRzLlxuICAvLyBJdCdzIGltcG9ydGFudCB0aGF0IHdlIGJ1aWxkIHRoZSBhcnJheSBvZiBhbmNlc3RvcnMgYmVmb3JlIGNhbGxpbmcgYW55XG4gIC8vIGV2ZW50IGhhbmRsZXJzLCBiZWNhdXNlIGV2ZW50IGhhbmRsZXJzIGNhbiBtb2RpZnkgdGhlIERPTSwgbGVhZGluZyB0b1xuICAvLyBpbmNvbnNpc3RlbmNpZXMgd2l0aCBSZWFjdE1vdW50J3Mgbm9kZSBjYWNoZS4gU2VlICMxMTA1LlxuICB2YXIgYW5jZXN0b3IgPSB0YXJnZXRJbnN0O1xuICBkbyB7XG4gICAgaWYgKCFhbmNlc3Rvcikge1xuICAgICAgYm9va0tlZXBpbmcuYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciByb290ID0gZmluZFJvb3RDb250YWluZXJOb2RlKGFuY2VzdG9yKTtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZShyb290KTtcbiAgfSB3aGlsZSAoYW5jZXN0b3IpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLmFuY2VzdG9yc1tpXTtcbiAgICBfaGFuZGxlVG9wTGV2ZWwoYm9va0tlZXBpbmcudG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKTtcbiAgfVxufVxuXG4vLyBUT0RPOiBjYW4gd2Ugc3RvcCBleHBvcnRpbmcgdGhlc2U/XG52YXIgX2VuYWJsZWQgPSB0cnVlO1xudmFyIF9oYW5kbGVUb3BMZXZlbCA9IHZvaWQgMDtcblxuZnVuY3Rpb24gc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpIHtcbiAgX2hhbmRsZVRvcExldmVsID0gaGFuZGxlVG9wTGV2ZWw7XG59XG5cbmZ1bmN0aW9uIHNldEVuYWJsZWQoZW5hYmxlZCkge1xuICBfZW5hYmxlZCA9ICEhZW5hYmxlZDtcbn1cblxuZnVuY3Rpb24gaXNFbmFibGVkKCkge1xuICByZXR1cm4gX2VuYWJsZWQ7XG59XG5cbi8qKlxuICogVHJhcHMgdG9wLWxldmVsIGV2ZW50cyBieSB1c2luZyBldmVudCBidWJibGluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIubGlzdGVuKGVsZW1lbnQsIGhhbmRsZXJCYXNlTmFtZSwgZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xufVxuXG4vKipcbiAqIFRyYXBzIGEgdG9wLWxldmVsIGV2ZW50IGJ5IHVzaW5nIGV2ZW50IGNhcHR1cmluZy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudCBFbGVtZW50IG9uIHdoaWNoIHRvIGF0dGFjaCBsaXN0ZW5lci5cbiAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICogICAgICAgICAgICAgICAgICByZW1vdmUgdGhlIGxpc3RlbmVyLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBlbGVtZW50KSB7XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBFdmVudExpc3RlbmVyLmNhcHR1cmUoZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoRXZlbnQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBpZiAoIV9lbmFibGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5hdGl2ZUV2ZW50VGFyZ2V0ID0gZ2V0RXZlbnRUYXJnZXQobmF0aXZlRXZlbnQpO1xuICB2YXIgdGFyZ2V0SW5zdCA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgaWYgKHRhcmdldEluc3QgIT09IG51bGwgJiYgdHlwZW9mIHRhcmdldEluc3QudGFnID09PSAnbnVtYmVyJyAmJiAhaXNGaWJlck1vdW50ZWQodGFyZ2V0SW5zdCkpIHtcbiAgICAvLyBJZiB3ZSBnZXQgYW4gZXZlbnQgKGV4OiBpbWcgb25sb2FkKSBiZWZvcmUgY29tbWl0dGluZyB0aGF0XG4gICAgLy8gY29tcG9uZW50J3MgbW91bnQsIGlnbm9yZSBpdCBmb3Igbm93ICh0aGF0IGlzLCB0cmVhdCBpdCBhcyBpZiBpdCB3YXMgYW5cbiAgICAvLyBldmVudCBvbiBhIG5vbi1SZWFjdCB0cmVlKS4gV2UgbWlnaHQgYWxzbyBjb25zaWRlciBxdWV1ZWluZyBldmVudHMgYW5kXG4gICAgLy8gZGlzcGF0Y2hpbmcgdGhlbSBhZnRlciB0aGUgbW91bnQuXG4gICAgdGFyZ2V0SW5zdCA9IG51bGw7XG4gIH1cblxuICB2YXIgYm9va0tlZXBpbmcgPSBnZXRUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCwgdGFyZ2V0SW5zdCk7XG5cbiAgdHJ5IHtcbiAgICAvLyBFdmVudCBxdWV1ZSBiZWluZyBwcm9jZXNzZWQgaW4gdGhlIHNhbWUgY3ljbGUgYWxsb3dzXG4gICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICBiYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICByZWxlYXNlVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKGJvb2tLZWVwaW5nKTtcbiAgfVxufVxuXG52YXIgUmVhY3RET01FdmVudExpc3RlbmVyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGdldCBfZW5hYmxlZCAoKSB7IHJldHVybiBfZW5hYmxlZDsgfSxcblx0Z2V0IF9oYW5kbGVUb3BMZXZlbCAoKSB7IHJldHVybiBfaGFuZGxlVG9wTGV2ZWw7IH0sXG5cdHNldEhhbmRsZVRvcExldmVsOiBzZXRIYW5kbGVUb3BMZXZlbCxcblx0c2V0RW5hYmxlZDogc2V0RW5hYmxlZCxcblx0aXNFbmFibGVkOiBpc0VuYWJsZWQsXG5cdHRyYXBCdWJibGVkRXZlbnQ6IHRyYXBCdWJibGVkRXZlbnQsXG5cdHRyYXBDYXB0dXJlZEV2ZW50OiB0cmFwQ2FwdHVyZWRFdmVudCxcblx0ZGlzcGF0Y2hFdmVudDogZGlzcGF0Y2hFdmVudFxufSk7XG5cbi8qKlxuICogR2VuZXJhdGUgYSBtYXBwaW5nIG9mIHN0YW5kYXJkIHZlbmRvciBwcmVmaXhlcyB1c2luZyB0aGUgZGVmaW5lZCBzdHlsZSBwcm9wZXJ0eSBhbmQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3R5bGVQcm9wXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYWtlUHJlZml4TWFwKHN0eWxlUHJvcCwgZXZlbnROYW1lKSB7XG4gIHZhciBwcmVmaXhlcyA9IHt9O1xuXG4gIHByZWZpeGVzW3N0eWxlUHJvcC50b0xvd2VyQ2FzZSgpXSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICBwcmVmaXhlc1snV2Via2l0JyArIHN0eWxlUHJvcF0gPSAnd2Via2l0JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ01veicgKyBzdHlsZVByb3BdID0gJ21veicgKyBldmVudE5hbWU7XG4gIHByZWZpeGVzWydtcycgKyBzdHlsZVByb3BdID0gJ01TJyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ08nICsgc3R5bGVQcm9wXSA9ICdvJyArIGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuXG4gIHJldHVybiBwcmVmaXhlcztcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgZXZlbnQgbmFtZXMgdG8gYSBjb25maWd1cmFibGUgbGlzdCBvZiB2ZW5kb3IgcHJlZml4ZXMuXG4gKi9cbnZhciB2ZW5kb3JQcmVmaXhlcyA9IHtcbiAgYW5pbWF0aW9uZW5kOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uRW5kJyksXG4gIGFuaW1hdGlvbml0ZXJhdGlvbjogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvbkl0ZXJhdGlvbicpLFxuICBhbmltYXRpb25zdGFydDogbWFrZVByZWZpeE1hcCgnQW5pbWF0aW9uJywgJ0FuaW1hdGlvblN0YXJ0JyksXG4gIHRyYW5zaXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ1RyYW5zaXRpb24nLCAnVHJhbnNpdGlvbkVuZCcpXG59O1xuXG4vKipcbiAqIEV2ZW50IG5hbWVzIHRoYXQgaGF2ZSBhbHJlYWR5IGJlZW4gZGV0ZWN0ZWQgYW5kIHByZWZpeGVkIChpZiBhcHBsaWNhYmxlKS5cbiAqL1xudmFyIHByZWZpeGVkRXZlbnROYW1lcyA9IHt9O1xuXG4vKipcbiAqIEVsZW1lbnQgdG8gY2hlY2sgZm9yIHByZWZpeGVzIG9uLlxuICovXG52YXIgc3R5bGUgPSB7fTtcblxuLyoqXG4gKiBCb290c3RyYXAgaWYgYSBET00gZXhpc3RzLlxuICovXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG5cbiAgLy8gT24gc29tZSBwbGF0Zm9ybXMsIGluIHBhcnRpY3VsYXIgc29tZSByZWxlYXNlcyBvZiBBbmRyb2lkIDQueCxcbiAgLy8gdGhlIHVuLXByZWZpeGVkIFwiYW5pbWF0aW9uXCIgYW5kIFwidHJhbnNpdGlvblwiIHByb3BlcnRpZXMgYXJlIGRlZmluZWQgb24gdGhlXG4gIC8vIHN0eWxlIG9iamVjdCBidXQgdGhlIGV2ZW50cyB0aGF0IGZpcmUgd2lsbCBzdGlsbCBiZSBwcmVmaXhlZCwgc28gd2UgbmVlZFxuICAvLyB0byBjaGVjayBpZiB0aGUgdW4tcHJlZml4ZWQgZXZlbnRzIGFyZSB1c2FibGUsIGFuZCBpZiBub3QgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgbWFwLlxuICBpZiAoISgnQW5pbWF0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uZW5kLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uaXRlcmF0aW9uLmFuaW1hdGlvbjtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMuYW5pbWF0aW9uc3RhcnQuYW5pbWF0aW9uO1xuICB9XG5cbiAgLy8gU2FtZSBhcyBhYm92ZVxuICBpZiAoISgnVHJhbnNpdGlvbkV2ZW50JyBpbiB3aW5kb3cpKSB7XG4gICAgZGVsZXRlIHZlbmRvclByZWZpeGVzLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbjtcbiAgfVxufVxuXG4vKipcbiAqIEF0dGVtcHRzIHRvIGRldGVybWluZSB0aGUgY29ycmVjdCB2ZW5kb3IgcHJlZml4ZWQgZXZlbnQgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnROYW1lXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZShldmVudE5hbWUpIHtcbiAgaWYgKHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIHByZWZpeGVkRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICB9IGVsc2UgaWYgKCF2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdKSB7XG4gICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgfVxuXG4gIHZhciBwcmVmaXhNYXAgPSB2ZW5kb3JQcmVmaXhlc1tldmVudE5hbWVdO1xuXG4gIGZvciAodmFyIHN0eWxlUHJvcCBpbiBwcmVmaXhNYXApIHtcbiAgICBpZiAocHJlZml4TWFwLmhhc093blByb3BlcnR5KHN0eWxlUHJvcCkgJiYgc3R5bGVQcm9wIGluIHN0eWxlKSB7XG4gICAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSBwcmVmaXhNYXBbc3R5bGVQcm9wXTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogVHlwZXMgb2YgcmF3IHNpZ25hbHMgZnJvbSB0aGUgYnJvd3NlciBjYXVnaHQgYXQgdGhlIHRvcCBsZXZlbC5cbiAqXG4gKiBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2VcbiAqIHRyYXAgYXQgYSBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZFxuICogY2F1c2UgZHVwbGljYXRlIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZS5cbiAqL1xudmFyIHRvcExldmVsVHlwZXMkMSA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEFuaW1hdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbmVuZCcpIHx8ICdhbmltYXRpb25lbmQnLFxuICB0b3BBbmltYXRpb25JdGVyYXRpb246IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25pdGVyYXRpb24nKSB8fCAnYW5pbWF0aW9uaXRlcmF0aW9uJyxcbiAgdG9wQW5pbWF0aW9uU3RhcnQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCdhbmltYXRpb25zdGFydCcpIHx8ICdhbmltYXRpb25zdGFydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuY2VsOiAnY2FuY2VsJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENsb3NlOiAnY2xvc2UnLFxuICB0b3BDb21wb3NpdGlvbkVuZDogJ2NvbXBvc2l0aW9uZW5kJyxcbiAgdG9wQ29tcG9zaXRpb25TdGFydDogJ2NvbXBvc2l0aW9uc3RhcnQnLFxuICB0b3BDb21wb3NpdGlvblVwZGF0ZTogJ2NvbXBvc2l0aW9udXBkYXRlJyxcbiAgdG9wQ29udGV4dE1lbnU6ICdjb250ZXh0bWVudScsXG4gIHRvcENvcHk6ICdjb3B5JyxcbiAgdG9wQ3V0OiAnY3V0JyxcbiAgdG9wRG91YmxlQ2xpY2s6ICdkYmxjbGljaycsXG4gIHRvcERyYWc6ICdkcmFnJyxcbiAgdG9wRHJhZ0VuZDogJ2RyYWdlbmQnLFxuICB0b3BEcmFnRW50ZXI6ICdkcmFnZW50ZXInLFxuICB0b3BEcmFnRXhpdDogJ2RyYWdleGl0JyxcbiAgdG9wRHJhZ0xlYXZlOiAnZHJhZ2xlYXZlJyxcbiAgdG9wRHJhZ092ZXI6ICdkcmFnb3ZlcicsXG4gIHRvcERyYWdTdGFydDogJ2RyYWdzdGFydCcsXG4gIHRvcERyb3A6ICdkcm9wJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BGb2N1czogJ2ZvY3VzJyxcbiAgdG9wSW5wdXQ6ICdpbnB1dCcsXG4gIHRvcEtleURvd246ICdrZXlkb3duJyxcbiAgdG9wS2V5UHJlc3M6ICdrZXlwcmVzcycsXG4gIHRvcEtleVVwOiAna2V5dXAnLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWQ6ICdsb2FkJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG9nZ2xlOiAndG9nZ2xlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFRyYW5zaXRpb25FbmQ6IGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKCd0cmFuc2l0aW9uZW5kJykgfHwgJ3RyYW5zaXRpb25lbmQnLFxuICB0b3BWb2x1bWVDaGFuZ2U6ICd2b2x1bWVjaGFuZ2UnLFxuICB0b3BXYWl0aW5nOiAnd2FpdGluZycsXG4gIHRvcFdoZWVsOiAnd2hlZWwnXG59O1xuXG52YXIgQnJvd3NlckV2ZW50Q29uc3RhbnRzID0ge1xuICB0b3BMZXZlbFR5cGVzOiB0b3BMZXZlbFR5cGVzJDFcbn07XG5cbmZ1bmN0aW9uIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cykge1xuICBlbnF1ZXVlRXZlbnRzKGV2ZW50cyk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuLyoqXG4gKiBTdHJlYW1zIGEgZmlyZWQgdG9wLWxldmVsIGV2ZW50IHRvIGBFdmVudFBsdWdpbkh1YmAgd2hlcmUgcGx1Z2lucyBoYXZlIHRoZVxuICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqL1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cyA9IGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICBydW5FdmVudFF1ZXVlSW5CYXRjaChldmVudHMpO1xufVxuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEJyb3dzZXJFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vKipcbiAqIFN1bW1hcnkgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgZXZlbnQgaGFuZGxpbmc6XG4gKlxuICogIC0gVG9wLWxldmVsIGRlbGVnYXRpb24gaXMgdXNlZCB0byB0cmFwIG1vc3QgbmF0aXZlIGJyb3dzZXIgZXZlbnRzLiBUaGlzXG4gKiAgICBtYXkgb25seSBvY2N1ciBpbiB0aGUgbWFpbiB0aHJlYWQgYW5kIGlzIHRoZSByZXNwb25zaWJpbGl0eSBvZlxuICogICAgUmVhY3RET01FdmVudExpc3RlbmVyLCB3aGljaCBpcyBpbmplY3RlZCBhbmQgY2FuIHRoZXJlZm9yZSBzdXBwb3J0XG4gKiAgICBwbHVnZ2FibGUgZXZlbnQgc291cmNlcy4gVGhpcyBpcyB0aGUgb25seSB3b3JrIHRoYXQgb2NjdXJzIGluIHRoZSBtYWluXG4gKiAgICB0aHJlYWQuXG4gKlxuICogIC0gV2Ugbm9ybWFsaXplIGFuZCBkZS1kdXBsaWNhdGUgZXZlbnRzIHRvIGFjY291bnQgZm9yIGJyb3dzZXIgcXVpcmtzLiBUaGlzXG4gKiAgICBtYXkgYmUgZG9uZSBpbiB0aGUgd29ya2VyIHRocmVhZC5cbiAqXG4gKiAgLSBGb3J3YXJkIHRoZXNlIG5hdGl2ZSBldmVudHMgKHdpdGggdGhlIGFzc29jaWF0ZWQgdG9wLWxldmVsIHR5cGUgdXNlZCB0b1xuICogICAgdHJhcCBpdCkgdG8gYEV2ZW50UGx1Z2luSHViYCwgd2hpY2ggaW4gdHVybiB3aWxsIGFzayBwbHVnaW5zIGlmIHRoZXkgd2FudFxuICogICAgdG8gZXh0cmFjdCBhbnkgc3ludGhldGljIGV2ZW50cy5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB3aWxsIHRoZW4gcHJvY2VzcyBlYWNoIGV2ZW50IGJ5IGFubm90YXRpbmcgdGhlbSB3aXRoXG4gKiAgICBcImRpc3BhdGNoZXNcIiwgYSBzZXF1ZW5jZSBvZiBsaXN0ZW5lcnMgYW5kIElEcyB0aGF0IGNhcmUgYWJvdXQgdGhhdCBldmVudC5cbiAqXG4gKiAgLSBUaGUgYEV2ZW50UGx1Z2luSHViYCB0aGVuIGRpc3BhdGNoZXMgdGhlIGV2ZW50cy5cbiAqXG4gKiBPdmVydmlldyBvZiBSZWFjdCBhbmQgdGhlIGV2ZW50IHN5c3RlbTpcbiAqXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8ICAgIERPTSAgICAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiAgICAgICB8ICAgICAgICAgICAuXG4gKiAgICAgICB2ICAgICAgICAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuXG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuXG4gKiB8ICBMaXN0ZW5lciAgfCAgICAuXG4gKiArLS0tLS0tLS0tLS0tKyAgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICArLS0tLS0tLS0rfFNpbXBsZUV2ZW50fFxuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgIHwgICAgICAgICB8UGx1Z2luICAgICB8XG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgdiAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tKyAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fEV2ZW50UGx1Z2luSHVifCAgICAgICAgICAgICAgICAgICAgfCAgICBFdmVudCAgIHxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCBQcm9wYWdhdG9yc3xcbiAqIHwgUmVhY3RFdmVudCB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgfFRhcEV2ZW50ICAgfCAgfC0tLS0tLS0tLS0tLXxcbiAqIHwgIEVtaXR0ZXIgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfDwtLS0rfFBsdWdpbiAgICAgfCAgfG90aGVyIHBsdWdpbnxcbiAqIHwgICAgICAgICAgICB8ICAgIC4gICAgfCAgICAgICAgICAgICAgfCAgICAgKy0tLS0tLS0tLS0tKyAgfCAgdXRpbGl0aWVzIHxcbiAqIHwgICAgICstLS0tLS0tLS0tLS4tLS0+fCAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tLStcbiAqIHwgICAgIHwgICAgICB8ICAgIC4gICAgKy0tLS0tLS0tLS0tLS0tK1xuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICBeICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgIHwgICAgICAgIHxFbnRlci9MZWF2ZXxcbiAqICAgICAgICsgICAgICAgICAgIC4gICAgICAgICAgICAgICAgKy0tLS0tLS0rfFBsdWdpbiAgICAgfFxuICogKy0tLS0tLS0tLS0tLS0rICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8IGFwcGxpY2F0aW9uIHwgICAuXG4gKiB8LS0tLS0tLS0tLS0tLXwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiB8ICAgICAgICAgICAgIHwgICAuXG4gKiArLS0tLS0tLS0tLS0tLSsgICAuXG4gKiAgICAgICAgICAgICAgICAgICAuXG4gKiAgICBSZWFjdCBDb3JlICAgICAuICBHZW5lcmFsIFB1cnBvc2UgRXZlbnQgUGx1Z2luIFN5c3RlbVxuICovXG5cbnZhciBhbHJlYWR5TGlzdGVuaW5nVG8gPSB7fTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vKipcbiAqIFRvIGVuc3VyZSBubyBjb25mbGljdHMgd2l0aCBvdGhlciBwb3RlbnRpYWwgUmVhY3QgaW5zdGFuY2VzIG9uIHRoZSBwYWdlXG4gKi9cbnZhciB0b3BMaXN0ZW5lcnNJREtleSA9ICdfcmVhY3RMaXN0ZW5lcnNJRCcgKyAoJycgKyBNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICpcbiAqIEZpcmVmb3ggdjguMDEgKGFuZCBwb3NzaWJseSBvdGhlcnMpIGV4aGliaXRlZCBzdHJhbmdlIGJlaGF2aW9yIHdoZW5cbiAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gKiBlbGVtZW50LiBUaGUgc3ltcHRvbXMgd2VyZSB0aGF0IGlmIHlvdXIgbW91c2UgaXMgbm90IG1vdmluZyBvdmVyIHNvbWV0aGluZ1xuICogY29udGFpbmVkIHdpdGhpbiB0aGF0IG1vdW50IHBvaW50IChmb3IgZXhhbXBsZSBvbiB0aGUgYmFja2dyb3VuZCkgdGhlXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gKiByZWdpc3RlciB0aGUgYG1vdXNlbW92ZWAgb24gdGhlIGRvY3VtZW50IG9iamVjdCwgdGhlbiBpdCB3aWxsIG9mIGNvdXJzZVxuICogY2F0Y2ggYWxsIGBtb3VzZW1vdmVgcy4gVGhpcyBhbG9uZyB3aXRoIGlPUyBxdWlya3MsIGp1c3RpZmllcyByZXN0cmljdGluZ1xuICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICogbW92ZW1lbnQgdHlwZXMgb2YgZXZlbnRzIGFuZCBwb3NzaWJseSBhbGwgZXZlbnRzLlxuICpcbiAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAqXG4gKiBBbHNvLCBga2V5dXBgL2BrZXlwcmVzc2AvYGtleWRvd25gIGRvIG5vdCBidWJibGUgdG8gdGhlIHdpbmRvdyBvbiBJRSwgYnV0XG4gKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICovXG5mdW5jdGlvbiBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgdmFyIG1vdW50QXQgPSBjb250ZW50RG9jdW1lbnRIYW5kbGU7XG4gIHZhciBpc0xpc3RlbmluZyA9IGdldExpc3RlbmluZ0ZvckRvY3VtZW50KG1vdW50QXQpO1xuICB2YXIgZGVwZW5kZW5jaWVzID0gcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llc1tyZWdpc3RyYXRpb25OYW1lXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BXaGVlbCcpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ3doZWVsJykpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICd3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ21vdXNld2hlZWwnKSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ21vdXNld2hlZWwnLCBtb3VudEF0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9kb20vZXZlbnRzL3Rlc3RzL3Njcm9sbC5odG1sXG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wV2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wU2Nyb2xsJykge1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wU2Nyb2xsJywgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wRm9jdXMnIHx8IGRlcGVuZGVuY3kgPT09ICd0b3BCbHVyJykge1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wRm9jdXMnLCAnZm9jdXMnLCBtb3VudEF0KTtcbiAgICAgICAgdHJhcENhcHR1cmVkRXZlbnQoJ3RvcEJsdXInLCAnYmx1cicsIG1vdW50QXQpO1xuXG4gICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICBpc0xpc3RlbmluZy50b3BCbHVyID0gdHJ1ZTtcbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wRm9jdXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSAndG9wQ2FuY2VsJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2FuY2VsJywgdHJ1ZSkpIHtcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2FuY2VsJywgJ2NhbmNlbCcsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENhbmNlbCA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDbG9zZScpIHtcbiAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2Nsb3NlJywgdHJ1ZSkpIHtcbiAgICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQ2xvc2UnLCAnY2xvc2UnLCBtb3VudEF0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xpc3RlbmluZy50b3BDbG9zZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHRvcExldmVsVHlwZXMuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChkZXBlbmRlbmN5LCB0b3BMZXZlbFR5cGVzW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgIH1cblxuICAgICAgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0gPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKHJlZ2lzdHJhdGlvbk5hbWUsIG1vdW50QXQpIHtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGRlcGVuZGVuY2llcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jaWVzW2ldO1xuICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIG5vZGVFbmQgPSBub2RlU3RhcnQgKyBub2RlLnRleHRDb250ZW50Lmxlbmd0aDtcblxuICAgICAgaWYgKG5vZGVTdGFydCA8PSBvZmZzZXQgJiYgbm9kZUVuZCA+PSBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0IC0gbm9kZVN0YXJ0XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIG5vZGVTdGFydCA9IG5vZGVFbmQ7XG4gICAgfVxuXG4gICAgbm9kZSA9IGdldExlYWZOb2RlKGdldFNpYmxpbmdOb2RlKG5vZGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb3V0ZXJOb2RlXG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRPZmZzZXRzKG91dGVyTm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbiAmJiB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG5cbiAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBhbmNob3JOb2RlID0gc2VsZWN0aW9uLmFuY2hvck5vZGU7XG4gIHZhciBhbmNob3JPZmZzZXQgPSBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0O1xuICB2YXIgZm9jdXNOb2RlJCQxID0gc2VsZWN0aW9uLmZvY3VzTm9kZTtcbiAgdmFyIGZvY3VzT2Zmc2V0ID0gc2VsZWN0aW9uLmZvY3VzT2Zmc2V0O1xuXG4gIC8vIEluIEZpcmVmb3gsIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBjYW4gYmUgXCJhbm9ueW1vdXMgZGl2c1wiLCBlLmcuIHRoZVxuICAvLyB1cC9kb3duIGJ1dHRvbnMgb24gYW4gPGlucHV0IHR5cGU9XCJudW1iZXJcIj4uIEFub255bW91cyBkaXZzIGRvIG5vdCBzZWVtIHRvXG4gIC8vIGV4cG9zZSBwcm9wZXJ0aWVzLCB0cmlnZ2VyaW5nIGEgXCJQZXJtaXNzaW9uIGRlbmllZCBlcnJvclwiIGlmIGFueSBvZiBpdHNcbiAgLy8gcHJvcGVydGllcyBhcmUgYWNjZXNzZWQuIFRoZSBvbmx5IHNlZW1pbmdseSBwb3NzaWJsZSB3YXkgdG8gYXZvaWQgZXJyb3JpbmdcbiAgLy8gaXMgdG8gYWNjZXNzIGEgcHJvcGVydHkgdGhhdCB0eXBpY2FsbHkgd29ya3MgZm9yIG5vbi1hbm9ueW1vdXMgZGl2cyBhbmRcbiAgLy8gY2F0Y2ggYW55IGVycm9yIHRoYXQgbWF5IG90aGVyd2lzZSBhcmlzZS4gU2VlXG4gIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTIwODQyN1xuICB0cnkge1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICAgIGFuY2hvck5vZGUubm9kZVR5cGU7XG4gICAgZm9jdXNOb2RlJCQxLm5vZGVUeXBlO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB7c3RhcnQsIGVuZH0gd2hlcmUgYHN0YXJ0YCBpcyB0aGUgY2hhcmFjdGVyL2NvZGVwb2ludCBpbmRleCBvZlxuICogKGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCkgd2l0aGluIHRoZSB0ZXh0Q29udGVudCBvZiBgb3V0ZXJOb2RlYCwgYW5kXG4gKiBgZW5kYCBpcyB0aGUgaW5kZXggb2YgKGZvY3VzTm9kZSwgZm9jdXNPZmZzZXQpLlxuICpcbiAqIFJldHVybnMgbnVsbCBpZiB5b3UgcGFzcyBpbiBnYXJiYWdlIGlucHV0IGJ1dCB3ZSBzaG91bGQgcHJvYmFibHkganVzdCBjcmFzaC5cbiAqXG4gKiBFeHBvcnRlZCBvbmx5IGZvciB0ZXN0aW5nLlxuICovXG5mdW5jdGlvbiBnZXRNb2Rlcm5PZmZzZXRzRnJvbVBvaW50cyhvdXRlck5vZGUsIGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCwgZm9jdXNOb2RlJCQxLCBmb2N1c09mZnNldCkge1xuICB2YXIgbGVuZ3RoID0gMDtcbiAgdmFyIHN0YXJ0ID0gLTE7XG4gIHZhciBlbmQgPSAtMTtcbiAgdmFyIGluZGV4V2l0aGluQW5jaG9yID0gMDtcbiAgdmFyIGluZGV4V2l0aGluRm9jdXMgPSAwO1xuICB2YXIgbm9kZSA9IG91dGVyTm9kZTtcbiAgdmFyIHBhcmVudE5vZGUgPSBudWxsO1xuXG4gIG91dGVyOiB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBuZXh0ID0gbnVsbDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZSA9PT0gYW5jaG9yTm9kZSAmJiAoYW5jaG9yT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgc3RhcnQgPSBsZW5ndGggKyBhbmNob3JPZmZzZXQ7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZm9jdXNOb2RlJCQxICYmIChmb2N1c09mZnNldCA9PT0gMCB8fCBub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpKSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aCArIGZvY3VzT2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIGxlbmd0aCArPSBub2RlLm5vZGVWYWx1ZS5sZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIGlmICgobmV4dCA9IG5vZGUuZmlyc3RDaGlsZCkgPT09IG51bGwpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIGZpcnN0IGNoaWxkIGBuZXh0YC5cbiAgICAgIHBhcmVudE5vZGUgPSBub2RlO1xuICAgICAgbm9kZSA9IG5leHQ7XG4gICAgfVxuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBvdXRlck5vZGUpIHtcbiAgICAgICAgLy8gSWYgYG91dGVyTm9kZWAgaGFzIGNoaWxkcmVuLCB0aGlzIGlzIGFsd2F5cyB0aGUgc2Vjb25kIHRpbWUgdmlzaXRpbmdcbiAgICAgICAgLy8gaXQuIElmIGl0IGhhcyBubyBjaGlsZHJlbiwgdGhpcyBpcyBzdGlsbCB0aGUgZmlyc3QgbG9vcCwgYW5kIHRoZSBvbmx5XG4gICAgICAgIC8vIHZhbGlkIHNlbGVjdGlvbiBpcyBhbmNob3JOb2RlIGFuZCBmb2N1c05vZGUgYm90aCBlcXVhbCB0byB0aGlzIG5vZGVcbiAgICAgICAgLy8gYW5kIGJvdGggb2Zmc2V0cyAwLCBpbiB3aGljaCBjYXNlIHdlIHdpbGwgaGF2ZSBoYW5kbGVkIGFib3ZlLlxuICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBhbmNob3JOb2RlICYmICsraW5kZXhXaXRoaW5BbmNob3IgPT09IGFuY2hvck9mZnNldCkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChwYXJlbnROb2RlID09PSBmb2N1c05vZGUkJDEgJiYgKytpbmRleFdpdGhpbkZvY3VzID09PSBmb2N1c09mZnNldCkge1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoKG5leHQgPSBub2RlLm5leHRTaWJsaW5nKSAhPT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIG5vZGUgPSBwYXJlbnROb2RlO1xuICAgICAgcGFyZW50Tm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBNb3ZpbmcgZnJvbSBgbm9kZWAgdG8gaXRzIG5leHQgc2libGluZyBgbmV4dGAuXG4gICAgbm9kZSA9IG5leHQ7XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCA9PT0gLTEpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW4uIChXb3VsZCBoYXBwZW4gaWYgdGhlIGFuY2hvci9mb2N1cyBub2RlcyBhcmVuJ3RcbiAgICAvLyBhY3R1YWxseSBpbnNpZGUgdGhlIHBhc3NlZC1pbiBub2RlLilcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtbWF0aWNhbGx5IGNyZWF0ZSBhIGJhY2t3YXJkIHNlbGVjdGlvbi4gVGh1cywgZm9yIGFsbCBJRVxuICogdmVyc2lvbnMsIHdlIHVzZSB0aGUgb2xkIElFIEFQSSB0byBjcmVhdGUgb3VyIHNlbGVjdGlvbnMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRPZmZzZXRzKG5vZGUsIG9mZnNldHMpIHtcbiAgaWYgKCF3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgdmFyIGxlbmd0aCA9IG5vZGVbZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpXS5sZW5ndGg7XG4gIHZhciBzdGFydCA9IE1hdGgubWluKG9mZnNldHMuc3RhcnQsIGxlbmd0aCk7XG4gIHZhciBlbmQgPSBvZmZzZXRzLmVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBNYXRoLm1pbihvZmZzZXRzLmVuZCwgbGVuZ3RoKTtcblxuICAvLyBJRSAxMSB1c2VzIG1vZGVybiBzZWxlY3Rpb24sIGJ1dCBkb2Vzbid0IHN1cHBvcnQgdGhlIGV4dGVuZCBtZXRob2QuXG4gIC8vIEZsaXAgYmFja3dhcmQgc2VsZWN0aW9ucywgc28gd2UgY2FuIHNldCB3aXRoIGEgc2luZ2xlIHJhbmdlLlxuICBpZiAoIXNlbGVjdGlvbi5leHRlbmQgJiYgc3RhcnQgPiBlbmQpIHtcbiAgICB2YXIgdGVtcCA9IGVuZDtcbiAgICBlbmQgPSBzdGFydDtcbiAgICBzdGFydCA9IHRlbXA7XG4gIH1cblxuICB2YXIgc3RhcnRNYXJrZXIgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KG5vZGUsIHN0YXJ0KTtcbiAgdmFyIGVuZE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgZW5kKTtcblxuICBpZiAoc3RhcnRNYXJrZXIgJiYgZW5kTWFya2VyKSB7XG4gICAgaWYgKHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAxICYmIHNlbGVjdGlvbi5hbmNob3JOb2RlID09PSBzdGFydE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5hbmNob3JPZmZzZXQgPT09IHN0YXJ0TWFya2VyLm9mZnNldCAmJiBzZWxlY3Rpb24uZm9jdXNOb2RlID09PSBlbmRNYXJrZXIubm9kZSAmJiBzZWxlY3Rpb24uZm9jdXNPZmZzZXQgPT09IGVuZE1hcmtlci5vZmZzZXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICByYW5nZS5zZXRTdGFydChzdGFydE1hcmtlci5ub2RlLCBzdGFydE1hcmtlci5vZmZzZXQpO1xuICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcblxuICAgIGlmIChzdGFydCA+IGVuZCkge1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgIHNlbGVjdGlvbi5leHRlbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZS5zZXRFbmQoZW5kTWFya2VyLm5vZGUsIGVuZE1hcmtlci5vZmZzZXQpO1xuICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xuXG5mdW5jdGlvbiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZWxlbSkge1xuICB2YXIgbm9kZU5hbWUgPSBlbGVtICYmIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgKG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ3RleHQnIHx8IG5vZGVOYW1lID09PSAndGV4dGFyZWEnIHx8IGVsZW0uY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpO1xufVxuXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbigpIHtcbiAgdmFyIGZvY3VzZWRFbGVtID0gZ2V0QWN0aXZlRWxlbWVudCgpO1xuICByZXR1cm4ge1xuICAgIGZvY3VzZWRFbGVtOiBmb2N1c2VkRWxlbSxcbiAgICBzZWxlY3Rpb25SYW5nZTogaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IGdldFNlbGVjdGlvbiQxKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAqIHJlc3RvcmUgaXQuIFRoaXMgaXMgdXNlZnVsIHdoZW4gcGVyZm9ybWluZyBvcGVyYXRpb25zIHRoYXQgY291bGQgcmVtb3ZlIGRvbVxuICogbm9kZXMgYW5kIHBsYWNlIHRoZW0gYmFjayBpbiwgcmVzdWx0aW5nIGluIGZvY3VzIGJlaW5nIGxvc3QuXG4gKi9cbmZ1bmN0aW9uIHJlc3RvcmVTZWxlY3Rpb24ocHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbikge1xuICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHZhciBwcmlvckZvY3VzZWRFbGVtID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5mb2N1c2VkRWxlbTtcbiAgdmFyIHByaW9yU2VsZWN0aW9uUmFuZ2UgPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLnNlbGVjdGlvblJhbmdlO1xuICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgaWYgKGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhwcmlvckZvY3VzZWRFbGVtKSkge1xuICAgICAgc2V0U2VsZWN0aW9uKHByaW9yRm9jdXNlZEVsZW0sIHByaW9yU2VsZWN0aW9uUmFuZ2UpO1xuICAgIH1cblxuICAgIC8vIEZvY3VzaW5nIGEgbm9kZSBjYW4gY2hhbmdlIHRoZSBzY3JvbGwgcG9zaXRpb24sIHdoaWNoIGlzIHVuZGVzaXJhYmxlXG4gICAgdmFyIGFuY2VzdG9ycyA9IFtdO1xuICAgIHZhciBhbmNlc3RvciA9IHByaW9yRm9jdXNlZEVsZW07XG4gICAgd2hpbGUgKGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZSkge1xuICAgICAgaWYgKGFuY2VzdG9yLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgICAgYW5jZXN0b3JzLnB1c2goe1xuICAgICAgICAgIGVsZW1lbnQ6IGFuY2VzdG9yLFxuICAgICAgICAgIGxlZnQ6IGFuY2VzdG9yLnNjcm9sbExlZnQsXG4gICAgICAgICAgdG9wOiBhbmNlc3Rvci5zY3JvbGxUb3BcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9jdXNOb2RlKHByaW9yRm9jdXNlZEVsZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpbmZvID0gYW5jZXN0b3JzW2ldO1xuICAgICAgaW5mby5lbGVtZW50LnNjcm9sbExlZnQgPSBpbmZvLmxlZnQ7XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsVG9wID0gaW5mby50b3A7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGdldFNlbGVjdGlvbjogR2V0cyB0aGUgc2VsZWN0aW9uIGJvdW5kcyBvZiBhIGZvY3VzZWQgdGV4dGFyZWEsIGlucHV0IG9yXG4gKiBjb250ZW50RWRpdGFibGUgbm9kZS5cbiAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gKiAtQHJldHVybiB7c3RhcnQ6IHNlbGVjdGlvblN0YXJ0LCBlbmQ6IHNlbGVjdGlvbkVuZH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uJDEoaW5wdXQpIHtcbiAgdmFyIHNlbGVjdGlvbiA9IHZvaWQgMDtcblxuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0ge1xuICAgICAgc3RhcnQ6IGlucHV0LnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIENvbnRlbnQgZWRpdGFibGUgb3Igb2xkIElFIHRleHRhcmVhLlxuICAgIHNlbGVjdGlvbiA9IGdldE9mZnNldHMoaW5wdXQpO1xuICB9XG5cbiAgcmV0dXJuIHNlbGVjdGlvbiB8fCB7IHN0YXJ0OiAwLCBlbmQ6IDAgfTtcbn1cblxuLyoqXG4gKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAqIHRoZSBpbnB1dC5cbiAqIC1AaW5wdXQgICAgIFNldCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXQgb3IgdGV4dGFyZWFcbiAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAqL1xuZnVuY3Rpb24gc2V0U2VsZWN0aW9uKGlucHV0LCBvZmZzZXRzKSB7XG4gIHZhciBzdGFydCA9IG9mZnNldHMuc3RhcnQsXG4gICAgICBlbmQgPSBvZmZzZXRzLmVuZDtcblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSBzdGFydDtcbiAgfVxuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICBpbnB1dC5zZWxlY3Rpb25FbmQgPSBNYXRoLm1pbihlbmQsIGlucHV0LnZhbHVlLmxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgc2V0T2Zmc2V0cyhpbnB1dCwgb2Zmc2V0cyk7XG4gIH1cbn1cblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzJDMgPSB7XG4gIHNlbGVjdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25TZWxlY3QnLFxuICAgICAgY2FwdHVyZWQ6ICdvblNlbGVjdENhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb250ZXh0TWVudScsICd0b3BGb2N1cycsICd0b3BLZXlEb3duJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93bicsICd0b3BNb3VzZVVwJywgJ3RvcFNlbGVjdGlvbkNoYW5nZSddXG4gIH1cbn07XG5cbnZhciBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xudmFyIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xudmFyIG1vdXNlRG93biA9IGZhbHNlO1xuXG4vKipcbiAqIEdldCBhbiBvYmplY3Qgd2hpY2ggaXMgYSB1bmlxdWUgcmVwcmVzZW50YXRpb24gb2YgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWUgd2lsbCBub3QgYmUgY29uc2lzdGVudCBhY3Jvc3Mgbm9kZXMgb3IgYnJvd3NlcnMsIGJ1dFxuICogdHdvIGlkZW50aWNhbCBzZWxlY3Rpb25zIG9uIHRoZSBzYW1lIG5vZGUgd2lsbCByZXR1cm4gaWRlbnRpY2FsIG9iamVjdHMuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbihub2RlKSB7XG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIG5vZGUgJiYgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQb2xsIHNlbGVjdGlvbiB0byBzZWUgd2hldGhlciBpdCdzIGNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAvLyBFbnN1cmUgd2UgaGF2ZSB0aGUgcmlnaHQgZWxlbWVudCwgYW5kIHRoYXQgdGhlIHVzZXIgaXMgbm90IGRyYWdnaW5nIGFcbiAgLy8gc2VsZWN0aW9uICh0aGlzIG1hdGNoZXMgbmF0aXZlIGBzZWxlY3RgIGV2ZW50IGJlaGF2aW9yKS4gSW4gSFRNTDUsIHNlbGVjdFxuICAvLyBmaXJlcyBvbmx5IG9uIGlucHV0IGFuZCB0ZXh0YXJlYSB0aHVzIGlmIHRoZXJlJ3Mgbm8gZm9jdXNlZCBlbGVtZW50IHdlXG4gIC8vIHdvbid0IGRpc3BhdGNoLlxuICBpZiAobW91c2VEb3duIHx8IGFjdGl2ZUVsZW1lbnQkMSA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQkMSAhPT0gZ2V0QWN0aXZlRWxlbWVudCgpKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBPbmx5IGZpcmUgd2hlbiBzZWxlY3Rpb24gaGFzIGFjdHVhbGx5IGNoYW5nZWQuXG4gIHZhciBjdXJyZW50U2VsZWN0aW9uID0gZ2V0U2VsZWN0aW9uKGFjdGl2ZUVsZW1lbnQkMSk7XG4gIGlmICghbGFzdFNlbGVjdGlvbiB8fCAhc2hhbGxvd0VxdWFsKGxhc3RTZWxlY3Rpb24sIGN1cnJlbnRTZWxlY3Rpb24pKSB7XG4gICAgbGFzdFNlbGVjdGlvbiA9IGN1cnJlbnRTZWxlY3Rpb247XG5cbiAgICB2YXIgc3ludGhldGljRXZlbnQgPSBTeW50aGV0aWNFdmVudCQxLmdldFBvb2xlZChldmVudFR5cGVzJDMuc2VsZWN0LCBhY3RpdmVFbGVtZW50SW5zdCQxLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQkMTtcblxuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDMsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRvYyA9IG5hdGl2ZUV2ZW50VGFyZ2V0LndpbmRvdyA9PT0gbmF0aXZlRXZlbnRUYXJnZXQgPyBuYXRpdmVFdmVudFRhcmdldC5kb2N1bWVudCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gbmF0aXZlRXZlbnRUYXJnZXQgOiBuYXRpdmVFdmVudFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgIC8vIFRyYWNrIHdoZXRoZXIgYWxsIGxpc3RlbmVycyBleGlzdHMgZm9yIHRoaXMgcGx1Z2luLiBJZiBub25lIGV4aXN0LCB3ZSBkb1xuICAgIC8vIG5vdCBleHRyYWN0IGV2ZW50cy4gU2VlICMzNjM5LlxuICAgIGlmICghZG9jIHx8ICFpc0xpc3RlbmluZ1RvQWxsRGVwZW5kZW5jaWVzKCdvblNlbGVjdCcsIGRvYykpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB0YXJnZXROb2RlID0gdGFyZ2V0SW5zdCA/IGdldE5vZGVGcm9tSW5zdGFuY2UkMSh0YXJnZXRJbnN0KSA6IHdpbmRvdztcblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSB8fCB0YXJnZXROb2RlLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKSB7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudCQxID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gdGFyZ2V0SW5zdDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcEJsdXInOlxuICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSBudWxsO1xuICAgICAgICBhY3RpdmVFbGVtZW50SW5zdCQxID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gRG9uJ3QgZmlyZSB0aGUgZXZlbnQgd2hpbGUgdGhlIHVzZXIgaXMgZHJhZ2dpbmcuIFRoaXMgbWF0Y2hlcyB0aGVcbiAgICAgIC8vIHNlbWFudGljcyBvZiB0aGUgbmF0aXZlIHNlbGVjdCBldmVudC5cbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICAgIG1vdXNlRG93biA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAgIG1vdXNlRG93biA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgIC8vIENocm9tZSBhbmQgSUUgZmlyZSBub24tc3RhbmRhcmQgZXZlbnQgd2hlbiBzZWxlY3Rpb24gaXMgY2hhbmdlZCAoYW5kXG4gICAgICAvLyBzb21ldGltZXMgd2hlbiBpdCBoYXNuJ3QpLiBJRSdzIGV2ZW50IGZpcmVzIG91dCBvZiBvcmRlciB3aXRoIHJlc3BlY3RcbiAgICAgIC8vIHRvIGtleSBhbmQgaW5wdXQgZXZlbnRzIG9uIGRlbGV0aW9uLCBzbyB3ZSBkaXNjYXJkIGl0LlxuICAgICAgLy9cbiAgICAgIC8vIEZpcmVmb3ggZG9lc24ndCBzdXBwb3J0IHNlbGVjdGlvbmNoYW5nZSwgc28gY2hlY2sgc2VsZWN0aW9uIHN0YXR1c1xuICAgICAgLy8gYWZ0ZXIgZWFjaCBrZXkgZW50cnkuIFRoZSBzZWxlY3Rpb24gY2hhbmdlcyBhZnRlciBrZXlkb3duIGFuZCBiZWZvcmVcbiAgICAgIC8vIGtleXVwLCBidXQgd2UgY2hlY2sgb24ga2V5ZG93biBhcyB3ZWxsIGluIHRoZSBjYXNlIG9mIGhvbGRpbmcgZG93biBhXG4gICAgICAvLyBrZXksIHdoZW4gbXVsdGlwbGUga2V5ZG93biBldmVudHMgYXJlIGZpcmVkIGJ1dCBvbmx5IG9uZSBrZXl1cCBpcy5cbiAgICAgIC8vIFRoaXMgaXMgYWxzbyBvdXIgYXBwcm9hY2ggZm9yIElFIGhhbmRsaW5nLCBmb3IgdGhlIHJlYXNvbiBhYm92ZS5cbiAgICAgIGNhc2UgJ3RvcFNlbGVjdGlvbkNoYW5nZSc6XG4gICAgICAgIGlmIChza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgLy8gZmFsbHMgdGhyb3VnaFxuICAgICAgY2FzZSAndG9wS2V5RG93bic6XG4gICAgICBjYXNlICd0b3BLZXlVcCc6XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1hbmltYXRpb25zLyNBbmltYXRpb25FdmVudC1pbnRlcmZhY2VcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0FuaW1hdGlvbkV2ZW50XG4gKi9cbnZhciBBbmltYXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgYW5pbWF0aW9uTmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNBbmltYXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQW5pbWF0aW9uRXZlbnQsIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDbGlwYm9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRm9jdXNFdmVudCwgRm9jdXNFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogYGNoYXJDb2RlYCByZXByZXNlbnRzIHRoZSBhY3R1YWwgXCJjaGFyYWN0ZXIgY29kZVwiIGFuZCBpcyBzYWZlIHRvIHVzZSB3aXRoXG4gKiBgU3RyaW5nLmZyb21DaGFyQ29kZWAuIEFzIHN1Y2gsIG9ubHkga2V5cyB0aGF0IGNvcnJlc3BvbmQgdG8gcHJpbnRhYmxlXG4gKiBjaGFyYWN0ZXJzIHByb2R1Y2UgYSB2YWxpZCBgY2hhckNvZGVgLCB0aGUgb25seSBleGNlcHRpb24gdG8gdGhpcyBpcyBFbnRlci5cbiAqIFRoZSBUYWIta2V5IGlzIGNvbnNpZGVyZWQgbm9uLXByaW50YWJsZSBhbmQgZG9lcyBub3QgaGF2ZSBhIGBjaGFyQ29kZWAsXG4gKiBwcmVzdW1hYmx5IGJlY2F1c2UgaXQgZG9lcyBub3QgcHJvZHVjZSBhIHRhYi1jaGFyYWN0ZXIgaW4gYnJvd3NlcnMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7bnVtYmVyfSBOb3JtYWxpemVkIGBjaGFyQ29kZWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpIHtcbiAgdmFyIGNoYXJDb2RlO1xuICB2YXIga2V5Q29kZSA9IG5hdGl2ZUV2ZW50LmtleUNvZGU7XG5cbiAgaWYgKCdjaGFyQ29kZScgaW4gbmF0aXZlRXZlbnQpIHtcbiAgICBjaGFyQ29kZSA9IG5hdGl2ZUV2ZW50LmNoYXJDb2RlO1xuXG4gICAgLy8gRkYgZG9lcyBub3Qgc2V0IGBjaGFyQ29kZWAgZm9yIHRoZSBFbnRlci1rZXksIGNoZWNrIGFnYWluc3QgYGtleUNvZGVgLlxuICAgIGlmIChjaGFyQ29kZSA9PT0gMCAmJiBrZXlDb2RlID09PSAxMykge1xuICAgICAgY2hhckNvZGUgPSAxMztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSUU4IGRvZXMgbm90IGltcGxlbWVudCBgY2hhckNvZGVgLCBidXQgYGtleUNvZGVgIGhhcyB0aGUgY29ycmVjdCB2YWx1ZS5cbiAgICBjaGFyQ29kZSA9IGtleUNvZGU7XG4gIH1cblxuICAvLyBTb21lIG5vbi1wcmludGFibGUga2V5cyBhcmUgcmVwb3J0ZWQgaW4gYGNoYXJDb2RlYC9ga2V5Q29kZWAsIGRpc2NhcmQgdGhlbS5cbiAgLy8gTXVzdCBub3QgZGlzY2FyZCB0aGUgKG5vbi0pcHJpbnRhYmxlIEVudGVyLWtleS5cbiAgaWYgKGNoYXJDb2RlID49IDMyIHx8IGNoYXJDb2RlID09PSAxMykge1xuICAgIHJldHVybiBjaGFyQ29kZTtcbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6YXRpb24gb2YgZGVwcmVjYXRlZCBIVE1MNSBga2V5YCB2YWx1ZXNcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciBub3JtYWxpemVLZXkgPSB7XG4gIEVzYzogJ0VzY2FwZScsXG4gIFNwYWNlYmFyOiAnICcsXG4gIExlZnQ6ICdBcnJvd0xlZnQnLFxuICBVcDogJ0Fycm93VXAnLFxuICBSaWdodDogJ0Fycm93UmlnaHQnLFxuICBEb3duOiAnQXJyb3dEb3duJyxcbiAgRGVsOiAnRGVsZXRlJyxcbiAgV2luOiAnT1MnLFxuICBNZW51OiAnQ29udGV4dE1lbnUnLFxuICBBcHBzOiAnQ29udGV4dE1lbnUnLFxuICBTY3JvbGw6ICdTY3JvbGxMb2NrJyxcbiAgTW96UHJpbnRhYmxlS2V5OiAnVW5pZGVudGlmaWVkJ1xufTtcblxuLyoqXG4gKiBUcmFuc2xhdGlvbiBmcm9tIGxlZ2FjeSBga2V5Q29kZWAgdG8gSFRNTDUgYGtleWBcbiAqIE9ubHkgc3BlY2lhbCBrZXlzIHN1cHBvcnRlZCwgYWxsIG90aGVycyBkZXBlbmQgb24ga2V5Ym9hcmQgbGF5b3V0IG9yIGJyb3dzZXJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0tleWJvYXJkRXZlbnQjS2V5X25hbWVzXG4gKi9cbnZhciB0cmFuc2xhdGVUb0tleSA9IHtcbiAgJzgnOiAnQmFja3NwYWNlJyxcbiAgJzknOiAnVGFiJyxcbiAgJzEyJzogJ0NsZWFyJyxcbiAgJzEzJzogJ0VudGVyJyxcbiAgJzE2JzogJ1NoaWZ0JyxcbiAgJzE3JzogJ0NvbnRyb2wnLFxuICAnMTgnOiAnQWx0JyxcbiAgJzE5JzogJ1BhdXNlJyxcbiAgJzIwJzogJ0NhcHNMb2NrJyxcbiAgJzI3JzogJ0VzY2FwZScsXG4gICczMic6ICcgJyxcbiAgJzMzJzogJ1BhZ2VVcCcsXG4gICczNCc6ICdQYWdlRG93bicsXG4gICczNSc6ICdFbmQnLFxuICAnMzYnOiAnSG9tZScsXG4gICczNyc6ICdBcnJvd0xlZnQnLFxuICAnMzgnOiAnQXJyb3dVcCcsXG4gICczOSc6ICdBcnJvd1JpZ2h0JyxcbiAgJzQwJzogJ0Fycm93RG93bicsXG4gICc0NSc6ICdJbnNlcnQnLFxuICAnNDYnOiAnRGVsZXRlJyxcbiAgJzExMic6ICdGMScsXG4gICcxMTMnOiAnRjInLFxuICAnMTE0JzogJ0YzJyxcbiAgJzExNSc6ICdGNCcsXG4gICcxMTYnOiAnRjUnLFxuICAnMTE3JzogJ0Y2JyxcbiAgJzExOCc6ICdGNycsXG4gICcxMTknOiAnRjgnLFxuICAnMTIwJzogJ0Y5JyxcbiAgJzEyMSc6ICdGMTAnLFxuICAnMTIyJzogJ0YxMScsXG4gICcxMjMnOiAnRjEyJyxcbiAgJzE0NCc6ICdOdW1Mb2NrJyxcbiAgJzE0NSc6ICdTY3JvbGxMb2NrJyxcbiAgJzIyNCc6ICdNZXRhJ1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IE5vcm1hbGl6ZWQgYGtleWAgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIGdldEV2ZW50S2V5KG5hdGl2ZUV2ZW50KSB7XG4gIGlmIChuYXRpdmVFdmVudC5rZXkpIHtcbiAgICAvLyBOb3JtYWxpemUgaW5jb25zaXN0ZW50IHZhbHVlcyByZXBvcnRlZCBieSBicm93c2VycyBkdWUgdG9cbiAgICAvLyBpbXBsZW1lbnRhdGlvbnMgb2YgYSB3b3JraW5nIGRyYWZ0IHNwZWNpZmljYXRpb24uXG5cbiAgICAvLyBGaXJlRm94IGltcGxlbWVudHMgYGtleWAgYnV0IHJldHVybnMgYE1velByaW50YWJsZUtleWAgZm9yIGFsbFxuICAgIC8vIHByaW50YWJsZSBjaGFyYWN0ZXJzIChub3JtYWxpemVkIHRvIGBVbmlkZW50aWZpZWRgKSwgaWdub3JlIGl0LlxuICAgIHZhciBrZXkgPSBub3JtYWxpemVLZXlbbmF0aXZlRXZlbnQua2V5XSB8fCBuYXRpdmVFdmVudC5rZXk7XG4gICAgaWYgKGtleSAhPT0gJ1VuaWRlbnRpZmllZCcpIHtcbiAgICAgIHJldHVybiBrZXk7XG4gICAgfVxuICB9XG5cbiAgLy8gQnJvd3NlciBkb2VzIG5vdCBpbXBsZW1lbnQgYGtleWAsIHBvbHlmaWxsIGFzIG11Y2ggb2YgaXQgYXMgd2UgY2FuLlxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgIHZhciBjaGFyQ29kZSA9IGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpO1xuXG4gICAgLy8gVGhlIGVudGVyLWtleSBpcyB0ZWNobmljYWxseSBib3RoIHByaW50YWJsZSBhbmQgbm9uLXByaW50YWJsZSBhbmQgY2FuXG4gICAgLy8gdGh1cyBiZSBjYXB0dXJlZCBieSBga2V5cHJlc3NgLCBubyBvdGhlciBub24tcHJpbnRhYmxlIGtleSBzaG91bGQuXG4gICAgcmV0dXJuIGNoYXJDb2RlID09PSAxMyA/ICdFbnRlcicgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoYXJDb2RlKTtcbiAgfVxuICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAvLyBXaGlsZSB1c2VyIGtleWJvYXJkIGxheW91dCBkZXRlcm1pbmVzIHRoZSBhY3R1YWwgbWVhbmluZyBvZiBlYWNoXG4gICAgLy8gYGtleUNvZGVgIHZhbHVlLCBhbG1vc3QgYWxsIGZ1bmN0aW9uIGtleXMgaGF2ZSBhIHVuaXZlcnNhbCB2YWx1ZS5cbiAgICByZXR1cm4gdHJhbnNsYXRlVG9LZXlbbmF0aXZlRXZlbnQua2V5Q29kZV0gfHwgJ1VuaWRlbnRpZmllZCc7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgS2V5Ym9hcmRFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBLZXlib2FyZEV2ZW50SW50ZXJmYWNlID0ge1xuICBrZXk6IGdldEV2ZW50S2V5LFxuICBsb2NhdGlvbjogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgcmVwZWF0OiBudWxsLFxuICBsb2NhbGU6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgLy8gTGVnYWN5IEludGVyZmFjZVxuICBjaGFyQ29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGNoYXJDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5UHJlc3MgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gdGhlIGFjdHVhbCBwcmludGFibGUgY2hhcmFjdGVyLlxuXG4gICAgLy8gS2V5UHJlc3MgaXMgZGVwcmVjYXRlZCwgYnV0IGl0cyByZXBsYWNlbWVudCBpcyBub3QgeWV0IGZpbmFsIGFuZCBub3RcbiAgICAvLyBpbXBsZW1lbnRlZCBpbiBhbnkgbWFqb3IgYnJvd3Nlci4gT25seSBLZXlQcmVzcyBoYXMgY2hhckNvZGUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIGtleUNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBrZXlDb2RlYCBpcyB0aGUgcmVzdWx0IG9mIGEgS2V5RG93bi9VcCBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyBwaHlzaWNhbCBrZXlib2FyZCBrZXkuXG5cbiAgICAvLyBUaGUgYWN0dWFsIG1lYW5pbmcgb2YgdGhlIHZhbHVlIGRlcGVuZHMgb24gdGhlIHVzZXJzJyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyB3aGljaCBjYW5ub3QgYmUgZGV0ZWN0ZWQuIEFzc3VtaW5nIHRoYXQgaXQgaXMgYSBVUyBrZXlib2FyZCBsYXlvdXRcbiAgICAvLyBwcm92aWRlcyBhIHN1cnByaXNpbmdseSBhY2N1cmF0ZSBtYXBwaW5nIGZvciBVUyBhbmQgRXVyb3BlYW4gdXNlcnMuXG4gICAgLy8gRHVlIHRvIHRoaXMsIGl0IGlzIGxlZnQgdG8gdGhlIHVzZXIgdG8gaW1wbGVtZW50IGF0IHRoaXMgdGltZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAgd2hpY2g6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGB3aGljaGAgaXMgYW4gYWxpYXMgZm9yIGVpdGhlciBga2V5Q29kZWAgb3IgYGNoYXJDb2RlYCBkZXBlbmRpbmcgb24gdGhlXG4gICAgLy8gdHlwZSBvZiB0aGUgZXZlbnQuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICAgIHJldHVybiBnZXRFdmVudENoYXJDb2RlKGV2ZW50KTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0tleWJvYXJkRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0RyYWdFdmVudCwgRHJhZ0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFRvdWNoRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzL1xuICovXG52YXIgVG91Y2hFdmVudEludGVyZmFjZSA9IHtcbiAgdG91Y2hlczogbnVsbCxcbiAgdGFyZ2V0VG91Y2hlczogbnVsbCxcbiAgY2hhbmdlZFRvdWNoZXM6IG51bGwsXG4gIGFsdEtleTogbnVsbCxcbiAgbWV0YUtleTogbnVsbCxcbiAgY3RybEtleTogbnVsbCxcbiAgc2hpZnRLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVG91Y2hFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljVG91Y2hFdmVudCwgVG91Y2hFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDA5L1dELWNzczMtdHJhbnNpdGlvbnMtMjAwOTAzMjAvI3RyYW5zaXRpb24tZXZlbnRzLVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvVHJhbnNpdGlvbkV2ZW50XG4gKi9cbnZhciBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHByb3BlcnR5TmFtZTogbnVsbCxcbiAgZWxhcHNlZFRpbWU6IG51bGwsXG4gIHBzZXVkb0VsZW1lbnQ6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY0V2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUcmFuc2l0aW9uRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCwgVHJhbnNpdGlvbkV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVhgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAocmlnaHQgaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWCcgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVggOiAwO1xuICB9LFxuICBkZWx0YVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFZJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWSA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWWAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChkb3duIGlzIHBvc2l0aXZlKS5cbiAgICAnd2hlZWxEZWx0YVknIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNNb3VzZUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNNb3VzZUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNXaGVlbEV2ZW50LCBXaGVlbEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBUdXJuc1xuICogWydhYm9ydCcsIC4uLl1cbiAqIGludG9cbiAqIGV2ZW50VHlwZXMgPSB7XG4gKiAgICdhYm9ydCc6IHtcbiAqICAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICogICAgICAgYnViYmxlZDogJ29uQWJvcnQnLFxuICogICAgICAgY2FwdHVyZWQ6ICdvbkFib3J0Q2FwdHVyZScsXG4gKiAgICAgfSxcbiAqICAgICBkZXBlbmRlbmNpZXM6IFsndG9wQWJvcnQnXSxcbiAqICAgfSxcbiAqICAgLi4uXG4gKiB9O1xuICogdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICogICAndG9wQWJvcnQnOiB7IHNhbWVDb25maWcgfVxuICogfTtcbiAqL1xudmFyIGV2ZW50VHlwZXMkNCA9IHt9O1xudmFyIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZyA9IHt9O1xuWydhYm9ydCcsICdhbmltYXRpb25FbmQnLCAnYW5pbWF0aW9uSXRlcmF0aW9uJywgJ2FuaW1hdGlvblN0YXJ0JywgJ2JsdXInLCAnY2FuY2VsJywgJ2NhblBsYXknLCAnY2FuUGxheVRocm91Z2gnLCAnY2xpY2snLCAnY2xvc2UnLCAnY29udGV4dE1lbnUnLCAnY29weScsICdjdXQnLCAnZG91YmxlQ2xpY2snLCAnZHJhZycsICdkcmFnRW5kJywgJ2RyYWdFbnRlcicsICdkcmFnRXhpdCcsICdkcmFnTGVhdmUnLCAnZHJhZ092ZXInLCAnZHJhZ1N0YXJ0JywgJ2Ryb3AnLCAnZHVyYXRpb25DaGFuZ2UnLCAnZW1wdGllZCcsICdlbmNyeXB0ZWQnLCAnZW5kZWQnLCAnZXJyb3InLCAnZm9jdXMnLCAnaW5wdXQnLCAnaW52YWxpZCcsICdrZXlEb3duJywgJ2tleVByZXNzJywgJ2tleVVwJywgJ2xvYWQnLCAnbG9hZGVkRGF0YScsICdsb2FkZWRNZXRhZGF0YScsICdsb2FkU3RhcnQnLCAnbW91c2VEb3duJywgJ21vdXNlTW92ZScsICdtb3VzZU91dCcsICdtb3VzZU92ZXInLCAnbW91c2VVcCcsICdwYXN0ZScsICdwYXVzZScsICdwbGF5JywgJ3BsYXlpbmcnLCAncHJvZ3Jlc3MnLCAncmF0ZUNoYW5nZScsICdyZXNldCcsICdzY3JvbGwnLCAnc2Vla2VkJywgJ3NlZWtpbmcnLCAnc3RhbGxlZCcsICdzdWJtaXQnLCAnc3VzcGVuZCcsICd0aW1lVXBkYXRlJywgJ3RvZ2dsZScsICd0b3VjaENhbmNlbCcsICd0b3VjaEVuZCcsICd0b3VjaE1vdmUnLCAndG91Y2hTdGFydCcsICd0cmFuc2l0aW9uRW5kJywgJ3ZvbHVtZUNoYW5nZScsICd3YWl0aW5nJywgJ3doZWVsJ10uZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgdmFyIGNhcGl0YWxpemVkRXZlbnQgPSBldmVudFswXS50b1VwcGVyQ2FzZSgpICsgZXZlbnQuc2xpY2UoMSk7XG4gIHZhciBvbkV2ZW50ID0gJ29uJyArIGNhcGl0YWxpemVkRXZlbnQ7XG4gIHZhciB0b3BFdmVudCA9ICd0b3AnICsgY2FwaXRhbGl6ZWRFdmVudDtcblxuICB2YXIgdHlwZSA9IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogb25FdmVudCxcbiAgICAgIGNhcHR1cmVkOiBvbkV2ZW50ICsgJ0NhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BFdmVudF1cbiAgfTtcbiAgZXZlbnRUeXBlcyQ0W2V2ZW50XSA9IHR5cGU7XG4gIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BFdmVudF0gPSB0eXBlO1xufSk7XG5cbi8vIE9ubHkgdXNlZCBpbiBERVYgZm9yIGV4aGF1c3RpdmVuZXNzIHZhbGlkYXRpb24uXG52YXIga25vd25IVE1MVG9wTGV2ZWxUeXBlcyA9IFsndG9wQWJvcnQnLCAndG9wQ2FuY2VsJywgJ3RvcENhblBsYXknLCAndG9wQ2FuUGxheVRocm91Z2gnLCAndG9wQ2xvc2UnLCAndG9wRHVyYXRpb25DaGFuZ2UnLCAndG9wRW1wdGllZCcsICd0b3BFbmNyeXB0ZWQnLCAndG9wRW5kZWQnLCAndG9wRXJyb3InLCAndG9wSW5wdXQnLCAndG9wSW52YWxpZCcsICd0b3BMb2FkJywgJ3RvcExvYWRlZERhdGEnLCAndG9wTG9hZGVkTWV0YWRhdGEnLCAndG9wTG9hZFN0YXJ0JywgJ3RvcFBhdXNlJywgJ3RvcFBsYXknLCAndG9wUGxheWluZycsICd0b3BQcm9ncmVzcycsICd0b3BSYXRlQ2hhbmdlJywgJ3RvcFJlc2V0JywgJ3RvcFNlZWtlZCcsICd0b3BTZWVraW5nJywgJ3RvcFN0YWxsZWQnLCAndG9wU3VibWl0JywgJ3RvcFN1c3BlbmQnLCAndG9wVGltZVVwZGF0ZScsICd0b3BUb2dnbGUnLCAndG9wVm9sdW1lQ2hhbmdlJywgJ3RvcFdhaXRpbmcnXTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzJDQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGRpc3BhdGNoQ29uZmlnID0gdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcExldmVsVHlwZV07XG4gICAgaWYgKCFkaXNwYXRjaENvbmZpZykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBFdmVudENvbnN0cnVjdG9yO1xuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICBjYXNlICd0b3BLZXlQcmVzcyc6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGtleXByZXNzIGV2ZW50IGZvciBmdW5jdGlvbiBrZXlzIHRvby4gVGhpcyByZW1vdmVzXG4gICAgICAgIC8vIHRoZSB1bndhbnRlZCBrZXlwcmVzcyBldmVudHMuIEVudGVyIGlzIGhvd2V2ZXIgYm90aCBwcmludGFibGUgYW5kXG4gICAgICAgIC8vIG5vbi1wcmludGFibGUuIE9uZSB3b3VsZCBleHBlY3QgVGFiIHRvIGJlIGFzIHdlbGwgKGJ1dCBpdCBpc24ndCkuXG4gICAgICAgIGlmIChnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KSA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICBjYXNlICd0b3BGb2N1cyc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENsaWNrJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEgY2xpY2sgZXZlbnQgb24gcmlnaHQgbW91c2UgY2xpY2tzLiBUaGlzIHJlbW92ZXMgdGhlXG4gICAgICAgIC8vIHVud2FudGVkIGNsaWNrIGV2ZW50cy5cbiAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmJ1dHRvbiA9PT0gMikge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BEb3VibGVDbGljayc6XG4gICAgICBjYXNlICd0b3BNb3VzZURvd24nOlxuICAgICAgY2FzZSAndG9wTW91c2VNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlVXAnOlxuICAgICAgLy8gVE9ETzogRGlzYWJsZWQgZWxlbWVudHMgc2hvdWxkIG5vdCByZXNwb25kIHRvIG1vdXNlIGV2ZW50c1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSAndG9wTW91c2VPdXQnOlxuICAgICAgY2FzZSAndG9wTW91c2VPdmVyJzpcbiAgICAgIGNhc2UgJ3RvcENvbnRleHRNZW51JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY01vdXNlRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wRHJhZyc6XG4gICAgICBjYXNlICd0b3BEcmFnRW5kJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbnRlcic6XG4gICAgICBjYXNlICd0b3BEcmFnRXhpdCc6XG4gICAgICBjYXNlICd0b3BEcmFnTGVhdmUnOlxuICAgICAgY2FzZSAndG9wRHJhZ092ZXInOlxuICAgICAgY2FzZSAndG9wRHJhZ1N0YXJ0JzpcbiAgICAgIGNhc2UgJ3RvcERyb3AnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRHJhZ0V2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRvdWNoQ2FuY2VsJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoRW5kJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoTW92ZSc6XG4gICAgICBjYXNlICd0b3BUb3VjaFN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uRW5kJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvbkl0ZXJhdGlvbic6XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25TdGFydCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNBbmltYXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BUcmFuc2l0aW9uRW5kJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BTY3JvbGwnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVUlFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BXaGVlbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNXaGVlbEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcENvcHknOlxuICAgICAgY2FzZSAndG9wQ3V0JzpcbiAgICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoa25vd25IVE1MVG9wTGV2ZWxUeXBlcy5pbmRleE9mKHRvcExldmVsVHlwZSkgPT09IC0xKSB7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU2ltcGxlRXZlbnRQbHVnaW46IFVuaGFuZGxlZCBldmVudCB0eXBlLCBgJXNgLiBUaGlzIHdhcm5pbmcgJyArICdpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCB0b3BMZXZlbFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIVE1MIEV2ZW50c1xuICAgICAgICAvLyBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L2luZGV4Lmh0bWwjZXZlbnRzLTBcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0V2ZW50JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgZXZlbnQgPSBFdmVudENvbnN0cnVjdG9yLmdldFBvb2xlZChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH1cbn07XG5cbnNldEhhbmRsZVRvcExldmVsKGhhbmRsZVRvcExldmVsKTtcblxuLyoqXG4gKiBJbmplY3QgbW9kdWxlcyBmb3IgcmVzb2x2aW5nIERPTSBoaWVyYXJjaHkgYW5kIHBsdWdpbiBvcmRlcmluZy5cbiAqL1xuaW5qZWN0aW9uJDEuaW5qZWN0RXZlbnRQbHVnaW5PcmRlcihET01FdmVudFBsdWdpbk9yZGVyKTtcbmluamVjdGlvbiQyLmluamVjdENvbXBvbmVudFRyZWUoUmVhY3RET01Db21wb25lbnRUcmVlKTtcblxuLyoqXG4gKiBTb21lIGltcG9ydGFudCBldmVudCBwbHVnaW5zIGluY2x1ZGVkIGJ5IGRlZmF1bHQgKHdpdGhvdXQgaGF2aW5nIHRvIHJlcXVpcmVcbiAqIHRoZW0pLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoe1xuICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gIEVudGVyTGVhdmVFdmVudFBsdWdpbjogRW50ZXJMZWF2ZUV2ZW50UGx1Z2luLFxuICBDaGFuZ2VFdmVudFBsdWdpbjogQ2hhbmdlRXZlbnRQbHVnaW4sXG4gIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgQmVmb3JlSW5wdXRFdmVudFBsdWdpbjogQmVmb3JlSW5wdXRFdmVudFBsdWdpblxufSk7XG5cbnZhciBlbmFibGVBc3luY1N1YnRyZWVBUEkgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jU2NoZWR1bGluZ0J5RGVmYXVsdEluUmVhY3RET00gPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3QuRnJhZ21lbnRcbnZhciBlbmFibGVSZWFjdEZyYWdtZW50ID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcbnZhciBlbmFibGVDcmVhdGVSb290ID0gZmFsc2U7XG52YXIgZW5hYmxlVXNlclRpbWluZ0FQSSA9IHRydWU7XG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxudmFyIGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciA9IHRydWU7XG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcbnZhciBlbmFibGVOb29wUmVjb25jaWxlciA9IGZhbHNlO1xuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxudmFyIGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyID0gZmFsc2U7XG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xuXG57XG4gIHZhciBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cblxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKGZpYmVyICE9PSBmaWJlclN0YWNrW2luZGV4XSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1VuZXhwZWN0ZWQgRmliZXIgcG9wcGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWVTdGFja1tpbmRleF07XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG5cbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHJlc2V0JDEoKSB7XG4gIHdoaWxlIChpbmRleCA+IC0xKSB7XG4gICAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gICAge1xuICAgICAgZmliZXJTdGFja1tpbmRleF0gPSBudWxsO1xuICAgIH1cblxuICAgIGluZGV4LS07XG4gIH1cbn1cblxudmFyIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUgPSBmdW5jdGlvbiAobmFtZSwgc291cmNlLCBvd25lck5hbWUpIHtcbiAgcmV0dXJuICdcXG4gICAgaW4gJyArIChuYW1lIHx8ICdVbmtub3duJykgKyAoc291cmNlID8gJyAoYXQgJyArIHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJykgKyAnOicgKyBzb3VyY2UubGluZU51bWJlciArICcpJyA6IG93bmVyTmFtZSA/ICcgKGNyZWF0ZWQgYnkgJyArIG93bmVyTmFtZSArICcpJyA6ICcnKTtcbn07XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgICB2YXIgc291cmNlID0gZmliZXIuX2RlYnVnU291cmNlO1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKTtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgc291cmNlLCBvd25lck5hbWUpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBjYW4gb25seSBiZSBjYWxsZWQgd2l0aCBhIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIgYW5kXG4vLyBvbmx5IGR1cmluZyBiZWdpbiBvciBjb21wbGV0ZSBwaGFzZS4gRG8gbm90IGNhbGwgaXQgdW5kZXIgYW55IG90aGVyXG4vLyBjaXJjdW1zdGFuY2VzLlxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcih3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaW5mbyA9ICcnO1xuICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzO1xuICBkbyB7XG4gICAgaW5mbyArPSBkZXNjcmliZUZpYmVyKG5vZGUpO1xuICAgIC8vIE90aGVyd2lzZSB0aGlzIHJldHVybiBwb2ludGVyIG1pZ2h0IHBvaW50IHRvIHRoZSB3cm9uZyB0cmVlOlxuICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgfSB3aGlsZSAobm9kZSk7XG4gIHJldHVybiBpbmZvO1xufVxuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUoKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIG93bmVyID0gZmliZXIuX2RlYnVnT3duZXI7XG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIHR5cGVvZiBvd25lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKG93bmVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQ7XG4gICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gU2FmZSBiZWNhdXNlIGlmIGN1cnJlbnQgZmliZXIgZXhpc3RzLCB3ZSBhcmUgcmVjb25jaWxpbmcsXG4gICAgLy8gYW5kIGl0IGlzIGd1YXJhbnRlZWQgdG8gYmUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdmVyc2lvbi5cbiAgICByZXR1cm4gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmaWJlcik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IG51bGw7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmN1cnJlbnQgPSBmaWJlcjtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRQaGFzZShwaGFzZSkge1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gcGhhc2U7XG59XG5cbnZhciBSZWFjdERlYnVnQ3VycmVudEZpYmVyID0ge1xuICBjdXJyZW50OiBudWxsLFxuICBwaGFzZTogbnVsbCxcbiAgcmVzZXRDdXJyZW50RmliZXI6IHJlc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50RmliZXI6IHNldEN1cnJlbnRGaWJlcixcbiAgc2V0Q3VycmVudFBoYXNlOiBzZXRDdXJyZW50UGhhc2UsXG4gIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZTogZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lLFxuICBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtOiBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtXG59O1xuXG4vLyBQcmVmaXggbWVhc3VyZW1lbnRzIHNvIHRoYXQgaXQncyBwb3NzaWJsZSB0byBmaWx0ZXIgdGhlbS5cbi8vIExvbmdlciBwcmVmaXhlcyBhcmUgaGFyZCB0byByZWFkIGluIERldlRvb2xzLlxudmFyIHJlYWN0RW1vamkgPSAnXFx1MjY5Qic7XG52YXIgd2FybmluZ0Vtb2ppID0gJ1xcdTI2RDQnO1xudmFyIHN1cHBvcnRzVXNlclRpbWluZyA9IHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1hcmsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLm1lYXN1cmUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMgPT09ICdmdW5jdGlvbic7XG5cbi8vIEtlZXAgdHJhY2sgb2YgY3VycmVudCBmaWJlciBzbyB0aGF0IHdlIGtub3cgdGhlIHBhdGggdG8gdW53aW5kIG9uIHBhdXNlLlxuLy8gVE9ETzogdGhpcyBsb29rcyB0aGUgc2FtZSBhcyBuZXh0VW5pdE9mV29yayBpbiBzY2hlZHVsZXIuIENhbiB3ZSB1bmlmeSB0aGVtP1xudmFyIGN1cnJlbnRGaWJlciA9IG51bGw7XG4vLyBJZiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIHVzZXIgY29kZSwgd2hpY2ggZmliZXIgYW5kIG1ldGhvZCBpcyBpdD9cbi8vIFJldXNpbmcgYGN1cnJlbnRGaWJlcmAgd291bGQgYmUgY29uZnVzaW5nIGZvciB0aGlzIGJlY2F1c2UgdXNlciBjb2RlIGZpYmVyXG4vLyBjYW4gY2hhbmdlIGR1cmluZyBjb21taXQgcGhhc2UgdG9vLCBidXQgd2UgZG9uJ3QgbmVlZCB0byB1bndpbmQgaXQgKHNpbmNlXG4vLyBsaWZlY3ljbGVzIGluIHRoZSBjb21taXQgcGhhc2UgZG9uJ3QgcmVzZW1ibGUgYSB0cmVlKS5cbnZhciBjdXJyZW50UGhhc2UgPSBudWxsO1xudmFyIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbi8vIERpZCBsaWZlY3ljbGUgaG9vayBzY2hlZHVsZSBhbiB1cGRhdGU/IFRoaXMgaXMgb2Z0ZW4gYSBwZXJmb3JtYW5jZSBwcm9ibGVtLFxuLy8gc28gd2Ugd2lsbCBrZWVwIHRyYWNrIG9mIGl0LCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVwb3J0LlxuLy8gVHJhY2sgY29tbWl0cyBjYXVzZWQgYnkgY2FzY2FkaW5nIHVwZGF0ZXMuXG52YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG52YXIgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbnZhciBjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID0gMDtcbnZhciBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4vLyBEdXJpbmcgY29tbWl0cywgd2Ugb25seSBzaG93IGEgbWVhc3VyZW1lbnQgb25jZSBwZXIgbWV0aG9kIG5hbWVcbi8vIHRvIGF2b2lkIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSB3aXRoIG1lYXN1cmVtZW50IG92ZXJoZWFkLlxudmFyIGxhYmVsc0luQ3VycmVudENvbW1pdCA9IG5ldyBTZXQoKTtcblxudmFyIGZvcm1hdE1hcmtOYW1lID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHJldHVybiByZWFjdEVtb2ppICsgJyAnICsgbWFya05hbWU7XG59O1xuXG52YXIgZm9ybWF0TGFiZWwgPSBmdW5jdGlvbiAobGFiZWwsIHdhcm5pbmckJDEpIHtcbiAgdmFyIHByZWZpeCA9IHdhcm5pbmckJDEgPyB3YXJuaW5nRW1vamkgKyAnICcgOiByZWFjdEVtb2ppICsgJyAnO1xuICB2YXIgc3VmZml4ID0gd2FybmluZyQkMSA/ICcgV2FybmluZzogJyArIHdhcm5pbmckJDEgOiAnJztcbiAgcmV0dXJuICcnICsgcHJlZml4ICsgbGFiZWwgKyBzdWZmaXg7XG59O1xuXG52YXIgYmVnaW5NYXJrID0gZnVuY3Rpb24gKG1hcmtOYW1lKSB7XG4gIHBlcmZvcm1hbmNlLm1hcmsoZm9ybWF0TWFya05hbWUobWFya05hbWUpKTtcbn07XG5cbnZhciBjbGVhck1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGVuZE1hcmsgPSBmdW5jdGlvbiAobGFiZWwsIG1hcmtOYW1lLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBmb3JtYXR0ZWRNYXJrTmFtZSA9IGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKTtcbiAgdmFyIGZvcm1hdHRlZExhYmVsID0gZm9ybWF0TGFiZWwobGFiZWwsIHdhcm5pbmckJDEpO1xuICB0cnkge1xuICAgIHBlcmZvcm1hbmNlLm1lYXN1cmUoZm9ybWF0dGVkTGFiZWwsIGZvcm1hdHRlZE1hcmtOYW1lKTtcbiAgfSBjYXRjaCAoZXJyKSB7fVxuICAvLyBJZiBwcmV2aW91cyBtYXJrIHdhcyBtaXNzaW5nIGZvciBzb21lIHJlYXNvbiwgdGhpcyB3aWxsIHRocm93LlxuICAvLyBUaGlzIGNvdWxkIG9ubHkgaGFwcGVuIGlmIFJlYWN0IGNyYXNoZWQgaW4gYW4gdW5leHBlY3RlZCBwbGFjZSBlYXJsaWVyLlxuICAvLyBEb24ndCBwaWxlIG9uIHdpdGggbW9yZSBlcnJvcnMuXG5cbiAgLy8gQ2xlYXIgbWFya3MgaW1tZWRpYXRlbHkgdG8gYXZvaWQgZ3Jvd2luZyBidWZmZXIuXG4gIHBlcmZvcm1hbmNlLmNsZWFyTWFya3MoZm9ybWF0dGVkTWFya05hbWUpO1xuICBwZXJmb3JtYW5jZS5jbGVhck1lYXN1cmVzKGZvcm1hdHRlZExhYmVsKTtcbn07XG5cbnZhciBnZXRGaWJlck1hcmtOYW1lID0gZnVuY3Rpb24gKGxhYmVsLCBkZWJ1Z0lEKSB7XG4gIHJldHVybiBsYWJlbCArICcgKCMnICsgZGVidWdJRCArICcpJztcbn07XG5cbnZhciBnZXRGaWJlckxhYmVsID0gZnVuY3Rpb24gKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpIHtcbiAgaWYgKHBoYXNlID09PSBudWxsKSB7XG4gICAgLy8gVGhlc2UgYXJlIGNvbXBvc2l0ZSBjb21wb25lbnQgdG90YWwgdGltZSBtZWFzdXJlbWVudHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnIFsnICsgKGlzTW91bnRlZCA/ICd1cGRhdGUnIDogJ21vdW50JykgKyAnXSc7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcG9zaXRlIGNvbXBvbmVudCBtZXRob2RzLlxuICAgIHJldHVybiBjb21wb25lbnROYW1lICsgJy4nICsgcGhhc2U7XG4gIH1cbn07XG5cbnZhciBiZWdpbkZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG5cbiAgaWYgKGlzQ29tbWl0dGluZyAmJiBsYWJlbHNJbkN1cnJlbnRDb21taXQuaGFzKGxhYmVsKSkge1xuICAgIC8vIER1cmluZyB0aGUgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBzaG93IGR1cGxpY2F0ZSBsYWJlbHMgYmVjYXVzZVxuICAgIC8vIHRoZXJlIGlzIGEgZml4ZWQgb3ZlcmhlYWQgZm9yIGV2ZXJ5IG1lYXN1cmVtZW50LCBhbmQgd2UgZG9uJ3RcbiAgICAvLyB3YW50IHRvIHN0cmV0Y2ggdGhlIGNvbW1pdCBwaGFzZSBiZXlvbmQgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBsYWJlbHNJbkN1cnJlbnRDb21taXQuYWRkKGxhYmVsKTtcblxuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgYmVnaW5NYXJrKG1hcmtOYW1lKTtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgY2xlYXJGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgY2xlYXJNYXJrKG1hcmtOYW1lKTtcbn07XG5cbnZhciBlbmRGaWJlck1hcmsgPSBmdW5jdGlvbiAoZmliZXIsIHBoYXNlLCB3YXJuaW5nJCQxKSB7XG4gIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICB2YXIgZGVidWdJRCA9IGZpYmVyLl9kZWJ1Z0lEO1xuICB2YXIgaXNNb3VudGVkID0gZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsO1xuICB2YXIgbGFiZWwgPSBnZXRGaWJlckxhYmVsKGNvbXBvbmVudE5hbWUsIGlzTW91bnRlZCwgcGhhc2UpO1xuICB2YXIgbWFya05hbWUgPSBnZXRGaWJlck1hcmtOYW1lKGxhYmVsLCBkZWJ1Z0lEKTtcbiAgZW5kTWFyayhsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpO1xufTtcblxudmFyIHNob3VsZElnbm9yZUZpYmVyID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIC8vIEhvc3QgY29tcG9uZW50cyBzaG91bGQgYmUgc2tpcHBlZCBpbiB0aGUgdGltZWxpbmUuXG4gIC8vIFdlIGNvdWxkIGNoZWNrIHR5cGVvZiBmaWJlci50eXBlLCBidXQgZG9lcyB0aGlzIHdvcmsgd2l0aCBSTj9cbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxudmFyIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChjdXJyZW50UGhhc2UgIT09IG51bGwgJiYgY3VycmVudFBoYXNlRmliZXIgIT09IG51bGwpIHtcbiAgICBjbGVhckZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlKTtcbiAgfVxuICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gZmFsc2U7XG59O1xuXG52YXIgcGF1c2VUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFN0b3BzIGFsbCBjdXJyZW50bHkgYWN0aXZlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZXkgY2FuIGJlIHJlc3VtZWRcbiAgLy8gaWYgd2UgY29udGludWUgaW4gYSBsYXRlciBkZWZlcnJlZCBsb29wIGZyb20gdGhlIHNhbWUgdW5pdCBvZiB3b3JrLlxuICB2YXIgZmliZXIgPSBjdXJyZW50RmliZXI7XG4gIHdoaWxlIChmaWJlcikge1xuICAgIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgICB9XG4gICAgZmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnNSZWN1cnNpdmVseSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICBpZiAoZmliZXJbJ3JldHVybiddICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoZmliZXJbJ3JldHVybiddKTtcbiAgfVxuICBpZiAoZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICBiZWdpbkZpYmVyTWFyayhmaWJlciwgbnVsbCk7XG4gIH1cbn07XG5cbnZhciByZXN1bWVUaW1lcnMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlc3VtZXMgYWxsIG1lYXN1cmVtZW50cyB0aGF0IHdlcmUgYWN0aXZlIGR1cmluZyB0aGUgbGFzdCBkZWZlcnJlZCBsb29wLlxuICBpZiAoY3VycmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgcmVzdW1lVGltZXJzUmVjdXJzaXZlbHkoY3VycmVudEZpYmVyKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gcmVjb3JkRWZmZWN0KCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0Kys7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkU2NoZWR1bGVVcGRhdGUoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2UgIT09ICdjb21wb25lbnRXaWxsTW91bnQnICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCB0aGlzIGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FuY2VsV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFJlbWVtYmVyIHdlIHNob3VsZG4ndCBjb21wbGV0ZSBtZWFzdXJlbWVudCBmb3IgdGhpcyBmaWJlci5cbiAgICAvLyBPdGhlcndpc2UgZmxhbWVjaGFydCB3aWxsIGJlIGRlZXAgZXZlbiBmb3Igc21hbGwgdXBkYXRlcy5cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGNsZWFyRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcEZhaWxlZFdvcmtUaW1lcihmaWJlcikge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nIHx8IHNob3VsZElnbm9yZUZpYmVyKGZpYmVyKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBwYXVzZSwgaXRzIHBhcmVudCBpcyB0aGUgZmliZXIgdG8gdW53aW5kIGZyb20uXG4gICAgY3VycmVudEZpYmVyID0gZmliZXJbJ3JldHVybiddO1xuICAgIGlmICghZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZmliZXIuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICB2YXIgd2FybmluZyQkMSA9ICdBbiBlcnJvciB3YXMgdGhyb3duIGluc2lkZSB0aGlzIGVycm9yIGJvdW5kYXJ5JztcbiAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgcGhhc2UpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGVhclBlbmRpbmdQaGFzZU1lYXN1cmVtZW50KCk7XG4gICAgaWYgKCFiZWdpbkZpYmVyTWFyayhmaWJlciwgcGhhc2UpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZUZpYmVyID0gZmliZXI7XG4gICAgY3VycmVudFBoYXNlID0gcGhhc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcFBoYXNlVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgICAgdmFyIHdhcm5pbmckJDEgPSBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA/ICdTY2hlZHVsZWQgYSBjYXNjYWRpbmcgdXBkYXRlJyA6IG51bGw7XG4gICAgICBlbmRGaWJlck1hcmsoY3VycmVudFBoYXNlRmliZXIsIGN1cnJlbnRQaGFzZSwgd2FybmluZyQkMSk7XG4gICAgfVxuICAgIGN1cnJlbnRQaGFzZSA9IG51bGw7XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yaykge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGN1cnJlbnRGaWJlciA9IG5leHRVbml0T2ZXb3JrO1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFRoaXMgaXMgdG9wIGxldmVsIGNhbGwuXG4gICAgLy8gQW55IG90aGVyIG1lYXN1cmVtZW50cyBhcmUgcGVyZm9ybWVkIHdpdGhpbi5cbiAgICBiZWdpbk1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScpO1xuICAgIC8vIFJlc3VtZSBhbnkgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBpbiBwcm9ncmVzcyBkdXJpbmcgdGhlIGxhc3QgbG9vcC5cbiAgICByZXN1bWVUaW1lcnMoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wV29ya0xvb3BUaW1lcihpbnRlcnJ1cHRlZEJ5KSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChpbnRlcnJ1cHRlZEJ5ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaW50ZXJydXB0ZWRCeS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgIHdhcm5pbmckJDEgPSAnQSB0b3AtbGV2ZWwgdXBkYXRlIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGludGVycnVwdGVkQnkpIHx8ICdVbmtub3duJztcbiAgICAgICAgd2FybmluZyQkMSA9ICdBbiB1cGRhdGUgdG8gJyArIGNvbXBvbmVudE5hbWUgKyAnIGludGVycnVwdGVkIHRoZSBwcmV2aW91cyByZW5kZXInO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDEpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnVGhlcmUgd2VyZSBjYXNjYWRpbmcgdXBkYXRlcyc7XG4gICAgfVxuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xuICAgIC8vIFBhdXNlIGFueSBtZWFzdXJlbWVudHMgdW50aWwgdGhlIG5leHQgbG9vcC5cbiAgICBwYXVzZVRpbWVycygpO1xuICAgIGVuZE1hcmsoJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsICcoUmVhY3QgVHJlZSBSZWNvbmNpbGlhdGlvbiknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgbGFiZWxzSW5DdXJyZW50Q29tbWl0LmNsZWFyKCk7XG4gICAgYmVnaW5NYXJrKCcoQ29tbWl0dGluZyBDaGFuZ2VzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nJCQxID0gbnVsbDtcbiAgICBpZiAoaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0KSB7XG4gICAgICB3YXJuaW5nJCQxID0gJ0xpZmVjeWNsZSBob29rIHNjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnO1xuICAgIH0gZWxzZSBpZiAoY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA+IDApIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnQ2F1c2VkIGJ5IGEgY2FzY2FkaW5nIHVwZGF0ZSBpbiBlYXJsaWVyIGNvbW1pdCc7XG4gICAgfVxuICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudENvbW1pdCA9IGZhbHNlO1xuICAgIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3ArKztcbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcblxuICAgIGVuZE1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJywgJyhDb21taXR0aW5nIENoYW5nZXMpJywgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzOiAnICsgY291bnQgKyAnIFRvdGFsKScsICcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHMpJywgbnVsbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY291bnQgPSBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdDtcbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgZW5kTWFyaygnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDYWxsaW5nIExpZmVjeWNsZSBNZXRob2RzKScsIG51bGwpO1xuICB9XG59XG5cbntcbiAgdmFyIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCA9IHt9O1xufVxuXG4vLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihlbXB0eU9iamVjdCk7XG4vLyBBIGN1cnNvciB0byBhIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBjb250ZXh0IGhhcyBjaGFuZ2VkLlxudmFyIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoZmFsc2UpO1xuLy8gS2VlcCB0cmFjayBvZiB0aGUgcHJldmlvdXMgY29udGV4dCBvYmplY3QgdGhhdCB3YXMgb24gdGhlIHN0YWNrLlxuLy8gV2UgdXNlIHRoaXMgdG8gZ2V0IGFjY2VzcyB0byB0aGUgcGFyZW50IGNvbnRleHQgYWZ0ZXIgd2UgaGF2ZSBhbHJlYWR5XG4vLyBwdXNoZWQgdGhlIG5leHQgY29udGV4dCBwcm92aWRlciwgYW5kIG5vdyBuZWVkIHRvIG1lcmdlIHRoZWlyIGNvbnRleHRzLlxudmFyIHByZXZpb3VzQ29udGV4dCA9IGVtcHR5T2JqZWN0O1xuXG5mdW5jdGlvbiBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgdmFyIGhhc093bkNvbnRleHQgPSBpc0NvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIGlmIChoYXNPd25Db250ZXh0KSB7XG4gICAgLy8gSWYgdGhlIGZpYmVyIGlzIGEgY29udGV4dCBwcm92aWRlciBpdHNlbGYsIHdoZW4gd2UgcmVhZCBpdHMgY29udGV4dFxuICAgIC8vIHdlIGhhdmUgYWxyZWFkeSBwdXNoZWQgaXRzIG93biBjaGlsZCBjb250ZXh0IG9uIHRoZSBzdGFjay4gQSBjb250ZXh0XG4gICAgLy8gcHJvdmlkZXIgc2hvdWxkIG5vdCBcInNlZVwiIGl0cyBvd24gY2hpbGQgY29udGV4dC4gVGhlcmVmb3JlIHdlIHJlYWQgdGhlXG4gICAgLy8gcHJldmlvdXMgKHBhcmVudCkgY29udGV4dCBpbnN0ZWFkIGZvciBhIGNvbnRleHQgcHJvdmlkZXIuXG4gICAgcmV0dXJuIHByZXZpb3VzQ29udGV4dDtcbiAgfVxuICByZXR1cm4gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBtYXNrZWRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9IHVubWFza2VkQ29udGV4dDtcbiAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQgPSBtYXNrZWRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgY29udGV4dFR5cGVzID0gdHlwZS5jb250ZXh0VHlwZXM7XG4gIGlmICghY29udGV4dFR5cGVzKSB7XG4gICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICB9XG5cbiAgLy8gQXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgdW5tYXNrZWQgY29udGV4dCBoYXMgY2hhbmdlZC5cbiAgLy8gRmFpbGluZyB0byBkbyB0aGlzIHdpbGwgcmVzdWx0IGluIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuXG4gIC8vIFRoaXMgbWF5IHRyaWdnZXIgaW5maW5pdGUgbG9vcHMgaWYgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyBjYWxscyBzZXRTdGF0ZS5cbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpZiAoaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRVbm1hc2tlZENoaWxkQ29udGV4dCA9PT0gdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNvbnRleHQgPSB7fTtcbiAgZm9yICh2YXIga2V5IGluIGNvbnRleHRUeXBlcykge1xuICAgIGNvbnRleHRba2V5XSA9IHVubWFza2VkQ29udGV4dFtrZXldO1xuICB9XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNvbnRleHRUeXBlcywgY29udGV4dCwgJ2NvbnRleHQnLCBuYW1lLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICB9XG5cbiAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAvLyBDb250ZXh0IGlzIGNyZWF0ZWQgYmVmb3JlIHRoZSBjbGFzcyBjb21wb25lbnQgaXMgaW5zdGFudGlhdGVkIHNvIGNoZWNrIGZvciBpbnN0YW5jZS5cbiAgaWYgKGluc3RhbmNlKSB7XG4gICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICByZXR1cm4gZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRDb25zdW1lcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNvbnRleHRUeXBlcyAhPSBudWxsO1xufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikge1xuICByZXR1cm4gZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHBvcENvbnRleHRQcm92aWRlcihmaWJlcikge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyKSB7XG4gIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcHVzaFRvcExldmVsQ29udGV4dE9iamVjdChmaWJlciwgY29udGV4dCwgZGlkQ2hhbmdlKSB7XG4gICEoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnNvciA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1VuZXhwZWN0ZWQgY29udGV4dCBmb3VuZCBvbiBzdGFjay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSB7XG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIGNoaWxkQ29udGV4dFR5cGVzID0gZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcztcblxuICAvLyBUT0RPIChidmF1Z2huKSBSZXBsYWNlIHRoaXMgYmVoYXZpb3Igd2l0aCBhbiBpbnZhcmlhbnQoKSBpbiB0aGUgZnV0dXJlLlxuICAvLyBJdCBoYXMgb25seSBiZWVuIGFkZGVkIGluIEZpYmVyIHRvIG1hdGNoIHRoZSAodW5pbnRlbnRpb25hbCkgYmVoYXZpb3IgaW4gU3RhY2suXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIHdhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dFtjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcy5jaGlsZENvbnRleHRUeXBlcyBpcyBzcGVjaWZpZWQgYnV0IHRoZXJlIGlzIG5vIGdldENoaWxkQ29udGV4dCgpIG1ldGhvZCAnICsgJ29uIHRoZSBpbnN0YW5jZS4gWW91IGNhbiBlaXRoZXIgZGVmaW5lIGdldENoaWxkQ29udGV4dCgpIG9uICVzIG9yIHJlbW92ZSAnICsgJ2NoaWxkQ29udGV4dFR5cGVzIGZyb20gaXQuJywgY29tcG9uZW50TmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgdmFyIGNoaWxkQ29udGV4dCA9IHZvaWQgMDtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdnZXRDaGlsZENvbnRleHQnKTtcbiAgfVxuICBzdGFydFBoYXNlVGltZXIoZmliZXIsICdnZXRDaGlsZENvbnRleHQnKTtcbiAgY2hpbGRDb250ZXh0ID0gaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0KCk7XG4gIHN0b3BQaGFzZVRpbWVyKCk7XG4gIHtcbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgfVxuICBmb3IgKHZhciBjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dCkge1xuICAgICEoY29udGV4dEtleSBpbiBjaGlsZENvbnRleHRUeXBlcykgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bicsIGNvbnRleHRLZXkpIDogdm9pZCAwO1xuICB9XG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgICBjaGVja1Byb3BUeXBlcyhjaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCAnY2hpbGQgY29udGV4dCcsIG5hbWUsXG4gICAgLy8gSW4gcHJhY3RpY2UsIHRoZXJlIGlzIG9uZSBjYXNlIGluIHdoaWNoIHdlIHdvbid0IGdldCBhIHN0YWNrLiBJdCdzIHdoZW5cbiAgICAvLyBzb21lYm9keSBjYWxscyB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcigpIGFuZCB3ZSBwcm9jZXNzXG4gICAgLy8gY29udGV4dCBmcm9tIHRoZSBwYXJlbnQgY29tcG9uZW50IGluc3RhbmNlLiBUaGUgc3RhY2sgd2lsbCBiZSBtaXNzaW5nXG4gICAgLy8gYmVjYXVzZSBpdCdzIG91dHNpZGUgb2YgdGhlIHJlY29uY2lsaWF0aW9uLCBhbmQgc28gdGhlIHBvaW50ZXIgaGFzIG5vdFxuICAgIC8vIGJlZW4gc2V0LiBUaGlzIGlzIHJhcmUgYW5kIGRvZXNuJ3QgbWF0dGVyLiBXZSdsbCBhbHNvIHJlbW92ZSB0aGF0IEFQSS5cbiAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0pO1xuICB9XG5cbiAgcmV0dXJuIF9hc3NpZ24oe30sIHBhcmVudENvbnRleHQsIGNoaWxkQ29udGV4dCk7XG59XG5cbmZ1bmN0aW9uIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKCFpc0NvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vIFdlIHB1c2ggdGhlIGNvbnRleHQgYXMgZWFybHkgYXMgcG9zc2libGUgdG8gZW5zdXJlIHN0YWNrIGludGVncml0eS5cbiAgLy8gSWYgdGhlIGluc3RhbmNlIGRvZXMgbm90IGV4aXN0IHlldCwgd2Ugd2lsbCBwdXNoIG51bGwgYXQgZmlyc3QsXG4gIC8vIGFuZCByZXBsYWNlIGl0IG9uIHRoZSBzdGFjayBsYXRlciB3aGVuIGludmFsaWRhdGluZyB0aGUgY29udGV4dC5cbiAgdmFyIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gaW5zdGFuY2UgJiYgaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gUmVtZW1iZXIgdGhlIHBhcmVudCBjb250ZXh0IHNvIHdlIGNhbiBtZXJnZSB3aXRoIGl0IGxhdGVyLlxuICAvLyBJbmhlcml0IHRoZSBwYXJlbnQncyBkaWQtcGVyZm9ybS13b3JrIHZhbHVlIHRvIGF2b2lkIGluYWR2ZXJ0ZW50bHkgYmxvY2tpbmcgdXBkYXRlcy5cbiAgcHJldmlvdXNDb250ZXh0ID0gY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBkaWRDaGFuZ2UpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAhaW5zdGFuY2UgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBoYXZlIGFuIGluc3RhbmNlIGJ5IHRoaXMgcG9pbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGRpZENoYW5nZSkge1xuICAgIC8vIE1lcmdlIHBhcmVudCBhbmQgb3duIGNvbnRleHQuXG4gICAgLy8gU2tpcCB0aGlzIGlmIHdlJ3JlIG5vdCB1cGRhdGluZyBkdWUgdG8gc0NVLlxuICAgIC8vIFRoaXMgYXZvaWRzIHVubmVjZXNzYXJpbHkgcmVjb21wdXRpbmcgbWVtb2l6ZWQgdmFsdWVzLlxuICAgIHZhciBtZXJnZWRDb250ZXh0ID0gcHJvY2Vzc0NoaWxkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldmlvdXNDb250ZXh0KTtcbiAgICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCA9IG1lcmdlZENvbnRleHQ7XG5cbiAgICAvLyBSZXBsYWNlIHRoZSBvbGQgKG9yIGVtcHR5KSBjb250ZXh0IHdpdGggdGhlIG5ldyBvbmUuXG4gICAgLy8gSXQgaXMgaW1wb3J0YW50IHRvIHVud2luZCB0aGUgY29udGV4dCBpbiB0aGUgcmV2ZXJzZSBvcmRlci5cbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICAvLyBOb3cgcHVzaCB0aGUgbmV3IGNvbnRleHQgYW5kIG1hcmsgdGhhdCBpdCBoYXMgY2hhbmdlZC5cbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbWVyZ2VkQ29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSB7XG4gICAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGRpZENoYW5nZSwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q29udGV4dCgpIHtcbiAgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG4gIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gZW1wdHlPYmplY3Q7XG4gIGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IuY3VycmVudCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICAvLyBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IHVzZWQgd2l0aCByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjsgbm90IHN1cmUgaWYgaXRcbiAgLy8gbWFrZXMgc2Vuc2UgZWxzZXdoZXJlXG4gICEoaXNGaWJlck1vdW50ZWQoZmliZXIpICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgc3VidHJlZSBwYXJlbnQgdG8gYmUgYSBtb3VudGVkIGNsYXNzIGNvbXBvbmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICB2YXIgbm9kZSA9IGZpYmVyO1xuICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGUuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ7XG4gICAgfVxuICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAhcGFyZW50ID8gaW52YXJpYW50KGZhbHNlLCAnRm91bmQgdW5leHBlY3RlZCBkZXRhY2hlZCBzdWJ0cmVlIHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICBub2RlID0gcGFyZW50O1xuICB9XG4gIHJldHVybiBub2RlLnN0YXRlTm9kZS5jb250ZXh0O1xufVxuXG52YXIgTm9Xb3JrID0gMDsgLy8gVE9ETzogVXNlIGFuIG9wYXF1ZSB0eXBlIG9uY2UgRVNMaW50IGV0IGFsIHN1cHBvcnQgdGhlIHN5bnRheFxuXG52YXIgU3luYyA9IDE7XG52YXIgTmV2ZXIgPSAyMTQ3NDgzNjQ3OyAvLyBNYXggaW50MzI6IE1hdGgucG93KDIsIDMxKSAtIDFcblxudmFyIFVOSVRfU0laRSA9IDEwO1xudmFyIE1BR0lDX05VTUJFUl9PRkZTRVQgPSAyO1xuXG4vLyAxIHVuaXQgb2YgZXhwaXJhdGlvbiB0aW1lIHJlcHJlc2VudHMgMTBtcy5cbmZ1bmN0aW9uIG1zVG9FeHBpcmF0aW9uVGltZShtcykge1xuICAvLyBBbHdheXMgYWRkIGFuIG9mZnNldCBzbyB0aGF0IHdlIGRvbid0IGNsYXNoIHdpdGggdGhlIG1hZ2ljIG51bWJlciBmb3IgTm9Xb3JrLlxuICByZXR1cm4gKG1zIC8gVU5JVF9TSVpFIHwgMCkgKyBNQUdJQ19OVU1CRVJfT0ZGU0VUO1xufVxuXG5mdW5jdGlvbiBjZWlsaW5nKG51bSwgcHJlY2lzaW9uKSB7XG4gIHJldHVybiAoKG51bSAvIHByZWNpc2lvbiB8IDApICsgMSkgKiBwcmVjaXNpb247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uSW5NcywgYnVja2V0U2l6ZU1zKSB7XG4gIHJldHVybiBjZWlsaW5nKGN1cnJlbnRUaW1lICsgZXhwaXJhdGlvbkluTXMgLyBVTklUX1NJWkUsIGJ1Y2tldFNpemVNcyAvIFVOSVRfU0laRSk7XG59XG5cbnZhciBOb0NvbnRleHQgPSAwO1xudmFyIEFzeW5jVXBkYXRlcyA9IDE7XG5cbntcbiAgdmFyIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG4gIHRyeSB7XG4gICAgdmFyIG5vbkV4dGVuc2libGVPYmplY3QgPSBPYmplY3QucHJldmVudEV4dGVuc2lvbnMoe30pO1xuICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLW5ldyAqL1xuICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbi8vIEEgRmliZXIgaXMgd29yayBvbiBhIENvbXBvbmVudCB0aGF0IG5lZWRzIHRvIGJlIGRvbmUgb3Igd2FzIGRvbmUuIFRoZXJlIGNhblxuLy8gYmUgbW9yZSB0aGFuIG9uZSBwZXIgY29tcG9uZW50LlxuXG5cbntcbiAgdmFyIGRlYnVnQ291bnRlciA9IDE7XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy50eXBlID0gbnVsbDtcbiAgdGhpcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIC8vIEZpYmVyXG4gIHRoaXNbJ3JldHVybiddID0gbnVsbDtcbiAgdGhpcy5jaGlsZCA9IG51bGw7XG4gIHRoaXMuc2libGluZyA9IG51bGw7XG4gIHRoaXMuaW5kZXggPSAwO1xuXG4gIHRoaXMucmVmID0gbnVsbDtcblxuICB0aGlzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuXG4gIHRoaXMuaW50ZXJuYWxDb250ZXh0VGFnID0gaW50ZXJuYWxDb250ZXh0VGFnO1xuXG4gIC8vIEVmZmVjdHNcbiAgdGhpcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgdGhpcy5uZXh0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICB0aGlzLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIHRoaXMuYWx0ZXJuYXRlID0gbnVsbDtcblxuICB7XG4gICAgdGhpcy5fZGVidWdJRCA9IGRlYnVnQ291bnRlcisrO1xuICAgIHRoaXMuX2RlYnVnU291cmNlID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgaWYgKCFoYXNCYWRNYXBQb2x5ZmlsbCAmJiB0eXBlb2YgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBPYmplY3QucHJldmVudEV4dGVuc2lvbnModGhpcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgaXMgYSBjb25zdHJ1Y3RvciBmdW5jdGlvbiwgcmF0aGVyIHRoYW4gYSBQT0pPIGNvbnN0cnVjdG9yLCBzdGlsbFxuLy8gcGxlYXNlIGVuc3VyZSB3ZSBkbyB0aGUgZm9sbG93aW5nOlxuLy8gMSkgTm9ib2R5IHNob3VsZCBhZGQgYW55IGluc3RhbmNlIG1ldGhvZHMgb24gdGhpcy4gSW5zdGFuY2UgbWV0aG9kcyBjYW4gYmVcbi8vICAgIG1vcmUgZGlmZmljdWx0IHRvIHByZWRpY3Qgd2hlbiB0aGV5IGdldCBvcHRpbWl6ZWQgYW5kIHRoZXkgYXJlIGFsbW9zdFxuLy8gICAgbmV2ZXIgaW5saW5lZCBwcm9wZXJseSBpbiBzdGF0aWMgY29tcGlsZXJzLlxuLy8gMikgTm9ib2R5IHNob3VsZCByZWx5IG9uIGBpbnN0YW5jZW9mIEZpYmVyYCBmb3IgdHlwZSB0ZXN0aW5nLiBXZSBzaG91bGRcbi8vICAgIGFsd2F5cyBrbm93IHdoZW4gaXQgaXMgYSBmaWJlci5cbi8vIDMpIFdlIG1pZ2h0IHdhbnQgdG8gZXhwZXJpbWVudCB3aXRoIHVzaW5nIG51bWVyaWMga2V5cyBzaW5jZSB0aGV5IGFyZSBlYXNpZXJcbi8vICAgIHRvIG9wdGltaXplIGluIGEgbm9uLUpJVCBlbnZpcm9ubWVudC5cbi8vIDQpIFdlIGNhbiBlYXNpbHkgZ28gZnJvbSBhIGNvbnN0cnVjdG9yIHRvIGEgY3JlYXRlRmliZXIgb2JqZWN0IGxpdGVyYWwgaWYgdGhhdFxuLy8gICAgaXMgZmFzdGVyLlxuLy8gNSkgSXQgc2hvdWxkIGJlIGVhc3kgdG8gcG9ydCB0aGlzIHRvIGEgQyBzdHJ1Y3QgYW5kIGtlZXAgYSBDIGltcGxlbWVudGF0aW9uXG4vLyAgICBjb21wYXRpYmxlLlxudmFyIGNyZWF0ZUZpYmVyID0gZnVuY3Rpb24gKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gJEZsb3dGaXhNZTogdGhlIHNoYXBlcyBhcmUgZXhhY3QgaGVyZSBidXQgRmxvdyBkb2Vzbid0IGxpa2UgY29uc3RydWN0b3JzXG4gIHJldHVybiBuZXcgRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICByZXR1cm4gISEoQ29tcG9uZW50LnByb3RvdHlwZSAmJiBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG4vLyBUaGlzIGlzIHVzZWQgdG8gY3JlYXRlIGFuIGFsdGVybmF0ZSBmaWJlciB0byBkbyB3b3JrIG9uLlxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSB7XG4gICAgLy8gV2UgdXNlIGEgZG91YmxlIGJ1ZmZlcmluZyBwb29saW5nIHRlY2huaXF1ZSBiZWNhdXNlIHdlIGtub3cgdGhhdCB3ZSdsbFxuICAgIC8vIG9ubHkgZXZlciBuZWVkIGF0IG1vc3QgdHdvIHZlcnNpb25zIG9mIGEgdHJlZS4gV2UgcG9vbCB0aGUgXCJvdGhlclwiIHVudXNlZFxuICAgIC8vIG5vZGUgdGhhdCB3ZSdyZSBmcmVlIHRvIHJldXNlLiBUaGlzIGlzIGxhemlseSBjcmVhdGVkIHRvIGF2b2lkIGFsbG9jYXRpbmdcbiAgICAvLyBleHRyYSBvYmplY3RzIGZvciB0aGluZ3MgdGhhdCBhcmUgbmV2ZXIgdXBkYXRlZC4gSXQgYWxzbyBhbGxvdyB1cyB0b1xuICAgIC8vIHJlY2xhaW0gdGhlIGV4dHJhIG1lbW9yeSBpZiBuZWVkZWQuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjcmVhdGVGaWJlcihjdXJyZW50LnRhZywgY3VycmVudC5rZXksIGN1cnJlbnQuaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCA9IGN1cnJlbnQuX2RlYnVnSUQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2UgPSBjdXJyZW50Ll9kZWJ1Z1NvdXJjZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcblxuICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBpcyBubyBsb25nZXIgdmFsaWQuXG4gICAgd29ya0luUHJvZ3Jlc3MubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKCkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgZmliZXIgPSB2b2lkIDA7XG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlLFxuICAgICAga2V5ID0gZWxlbWVudC5rZXk7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZmliZXIgPSBzaG91bGRDb25zdHJ1Y3QodHlwZSkgPyBjcmVhdGVGaWJlcihDbGFzc0NvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIDogY3JlYXRlRmliZXIoSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIGZpYmVyLnR5cGUgPSB0eXBlO1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnQucHJvcHM7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0Q29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiB0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgLy8gQ3VycmVudGx5IGFzc3VtZWQgdG8gYmUgYSBjb250aW51YXRpb24gYW5kIHRoZXJlZm9yZSBpcyBhIGZpYmVyIGFscmVhZHkuXG4gICAgLy8gVE9ETzogVGhlIHlpZWxkIHN5c3RlbSBpcyBjdXJyZW50bHkgYnJva2VuIGZvciB1cGRhdGVzIGluIHNvbWUgY2FzZXMuXG4gICAgLy8gVGhlIHJlaWZpZWQgeWllbGQgc3RvcmVzIGEgZmliZXIsIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZpYmVyIHRoYXQgaXM7XG4gICAgLy8gdGhlIGN1cnJlbnQgb3IgYSB3b3JrSW5Qcm9ncmVzcz8gV2hlbiB0aGUgY29udGludWF0aW9uIGdldHMgcmVuZGVyZWQgaGVyZVxuICAgIC8vIHdlIGRvbid0IGtub3cgaWYgd2UgY2FuIHJldXNlIHRoYXQgZmliZXIgb3IgaWYgd2UgbmVlZCB0byBjbG9uZSBpdC5cbiAgICAvLyBUaGVyZSBpcyBwcm9iYWJseSBhIGNsZXZlciB3YXkgdG8gcmVzdHJ1Y3R1cmUgdGhpcy5cbiAgICBmaWJlciA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4uXCI7XG4gICAgICB9XG4gICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lKG93bmVyKSA6IG51bGw7XG4gICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB7XG4gICAgZmliZXIuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50cztcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UZXh0KGNvbnRlbnQsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIG51bGwsIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvbnRlbnQ7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIG51bGwsIE5vQ29udGV4dCk7XG4gIGZpYmVyLnR5cGUgPSAnREVMRVRFRCc7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKENhbGxDb21wb25lbnQsIGNhbGwua2V5LCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci50eXBlID0gY2FsbC5oYW5kbGVyO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjYWxsO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFJldHVybkNvbXBvbmVudCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBpbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBvcnRhbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiB8fCBbXTtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgZmliZXIuc3RhdGVOb2RlID0ge1xuICAgIGNvbnRhaW5lckluZm86IHBvcnRhbC5jb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCwgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpIHtcbiAgLy8gQ3ljbGljIGNvbnN0cnVjdGlvbi4gVGhpcyBjaGVhdHMgdGhlIHR5cGUgc3lzdGVtIHJpZ2h0IG5vdyBiZWNhdXNlXG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG4gIHZhciB1bmluaXRpYWxpemVkRmliZXIgPSBjcmVhdGVIb3N0Um9vdEZpYmVyKCk7XG4gIHZhciByb290ID0ge1xuICAgIGN1cnJlbnQ6IHVuaW5pdGlhbGl6ZWRGaWJlcixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIHBlbmRpbmdDaGlsZHJlbjogbnVsbCxcbiAgICByZW1haW5pbmdFeHBpcmF0aW9uVGltZTogTm9Xb3JrLFxuICAgIGlzUmVhZHlGb3JDb21taXQ6IGZhbHNlLFxuICAgIGZpbmlzaGVkV29yazogbnVsbCxcbiAgICBjb250ZXh0OiBudWxsLFxuICAgIHBlbmRpbmdDb250ZXh0OiBudWxsLFxuICAgIGh5ZHJhdGU6IGh5ZHJhdGUsXG4gICAgbmV4dFNjaGVkdWxlZFJvb3Q6IG51bGxcbiAgfTtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG4gIHJldHVybiByb290O1xufVxuXG52YXIgb25Db21taXRGaWJlclJvb3QgPSBudWxsO1xudmFyIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjYXRjaEVycm9ycyhmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKGFyZykge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYXJnKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmICh0cnVlICYmICFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50ZXJuYWxzKGludGVybmFscykge1xuICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBObyBEZXZUb29sc1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWYgKCFob29rLnN1cHBvcnRzRmliZXIpIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGluc3RhbGxlZCB2ZXJzaW9uIG9mIFJlYWN0IERldlRvb2xzIGlzIHRvbyBvbGQgYW5kIHdpbGwgbm90IHdvcmsgJyArICd3aXRoIHRoZSBjdXJyZW50IHZlcnNpb24gb2YgUmVhY3QuIFBsZWFzZSB1cGRhdGUgUmVhY3QgRGV2VG9vbHMuICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgIH1cbiAgICAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTtcbiAgICAvLyBXZSBoYXZlIHN1Y2Nlc3NmdWxseSBpbmplY3RlZCwgc28gbm93IGl0IGlzIHNhZmUgdG8gc2V0IHVwIGhvb2tzLlxuICAgIG9uQ29tbWl0RmliZXJSb290ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKHJvb3QpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0pO1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50ID0gY2F0Y2hFcnJvcnMoZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICByZXR1cm4gaG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBEZXZUb29scyBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMuJywgZXJyKTtcbiAgICB9XG4gIH1cbiAgLy8gRGV2VG9vbHMgZXhpc3RzXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFJvb3Qocm9vdCkge1xuICBpZiAodHlwZW9mIG9uQ29tbWl0RmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgb25Db21taXRGaWJlclJvb3Qocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyVW5tb3VudChmaWJlcik7XG4gIH1cbn1cblxue1xuICB2YXIgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IGZhbHNlO1xufVxuXG4vLyBDYWxsYmFja3MgYXJlIG5vdCB2YWxpZGF0ZWQgdW50aWwgaW52b2NhdGlvblxuXG5cbi8vIFNpbmdseSBsaW5rZWQtbGlzdCBvZiB1cGRhdGVzLiBXaGVuIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQsIGl0IGlzIGFkZGVkIHRvXG4vLyB0aGUgcXVldWUgb2YgdGhlIGN1cnJlbnQgZmliZXIgYW5kIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGUgdHdvIHF1ZXVlc1xuLy8gYXJlIHNlcGFyYXRlIGJ1dCB0aGV5IHNoYXJlIGEgcGVyc2lzdGVudCBzdHJ1Y3R1cmUuXG4vL1xuLy8gRHVyaW5nIHJlY29uY2lsaWF0aW9uLCB1cGRhdGVzIGFyZSByZW1vdmVkIGZyb20gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIsXG4vLyBidXQgdGhleSByZW1haW4gb24gdGhlIGN1cnJlbnQgZmliZXIuIFRoYXQgZW5zdXJlcyB0aGF0IGlmIGEgd29yay1pbi1wcm9ncmVzc1xuLy8gaXMgYWJvcnRlZCwgdGhlIGFib3J0ZWQgdXBkYXRlcyBhcmUgcmVjb3ZlcmVkIGJ5IGNsb25pbmcgZnJvbSBjdXJyZW50LlxuLy9cbi8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGFsd2F5cyBhIHN1YnNldCBvZiB0aGUgY3VycmVudCBxdWV1ZS5cbi8vXG4vLyBXaGVuIHRoZSB0cmVlIGlzIGNvbW1pdHRlZCwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgYmVjb21lcyB0aGUgY3VycmVudC5cblxuXG5mdW5jdGlvbiBjcmVhdGVVcGRhdGVRdWV1ZShiYXNlU3RhdGUpIHtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIGJhc2VTdGF0ZTogYmFzZVN0YXRlLFxuICAgIGV4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgZmlyc3Q6IG51bGwsXG4gICAgbGFzdDogbnVsbCxcbiAgICBjYWxsYmFja0xpc3Q6IG51bGwsXG4gICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlLFxuICAgIGlzSW5pdGlhbGl6ZWQ6IGZhbHNlXG4gIH07XG4gIHtcbiAgICBxdWV1ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gcXVldWU7XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gIGlmIChxdWV1ZS5sYXN0ID09PSBudWxsKSB7XG4gICAgLy8gUXVldWUgaXMgZW1wdHlcbiAgICBxdWV1ZS5maXJzdCA9IHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgcXVldWUubGFzdC5uZXh0ID0gdXBkYXRlO1xuICAgIHF1ZXVlLmxhc3QgPSB1cGRhdGU7XG4gIH1cbiAgaWYgKHF1ZXVlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgcXVldWUuZXhwaXJhdGlvblRpbWUgPiB1cGRhdGUuZXhwaXJhdGlvblRpbWUpIHtcbiAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSkge1xuICAvLyBXZSdsbCBoYXZlIGF0IGxlYXN0IG9uZSBhbmQgYXQgbW9zdCB0d28gZGlzdGluY3QgdXBkYXRlIHF1ZXVlcy5cbiAgdmFyIGFsdGVybmF0ZUZpYmVyID0gZmliZXIuYWx0ZXJuYXRlO1xuICB2YXIgcXVldWUxID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmIChxdWV1ZTEgPT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAgIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gICAgLy8gYmFzZSBzdGF0ZSwgdGhlbiBzZXQgdG8gdGhlIG1lbW9pemVkU3RhdGUgd2hlbiByZW5kZXJpbmcuIE5vdCBzdXBlclxuICAgIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgICBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICB9XG5cbiAgdmFyIHF1ZXVlMiA9IHZvaWQgMDtcbiAgaWYgKGFsdGVybmF0ZUZpYmVyICE9PSBudWxsKSB7XG4gICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWU7XG4gICAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgICAgcXVldWUyID0gYWx0ZXJuYXRlRmliZXIudXBkYXRlUXVldWUgPSBjcmVhdGVVcGRhdGVRdWV1ZShudWxsKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcXVldWUyID0gbnVsbDtcbiAgfVxuICBxdWV1ZTIgPSBxdWV1ZTIgIT09IHF1ZXVlMSA/IHF1ZXVlMiA6IG51bGw7XG5cbiAgLy8gV2FybiBpZiBhbiB1cGRhdGUgaXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGFuIHVwZGF0ZXIgZnVuY3Rpb24uXG4gIHtcbiAgICBpZiAoKHF1ZXVlMS5pc1Byb2Nlc3NpbmcgfHwgcXVldWUyICE9PSBudWxsICYmIHF1ZXVlMi5pc1Byb2Nlc3NpbmcpICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLicpO1xuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gSWYgdGhlcmUncyBvbmx5IG9uZSBxdWV1ZSwgYWRkIHRoZSB1cGRhdGUgdG8gdGhhdCBxdWV1ZSBhbmQgZXhpdC5cbiAgaWYgKHF1ZXVlMiA9PT0gbnVsbCkge1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgZWl0aGVyIHF1ZXVlIGlzIGVtcHR5LCB3ZSBuZWVkIHRvIGFkZCB0byBib3RoIHF1ZXVlcy5cbiAgaWYgKHF1ZXVlMS5sYXN0ID09PSBudWxsIHx8IHF1ZXVlMi5sYXN0ID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUyLCB1cGRhdGUpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIElmIGJvdGggbGlzdHMgYXJlIG5vdCBlbXB0eSwgdGhlIGxhc3QgdXBkYXRlIGlzIHRoZSBzYW1lIGZvciBib3RoIGxpc3RzXG4gIC8vIGJlY2F1c2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLiBTbywgd2Ugc2hvdWxkIG9ubHkgYXBwZW5kIHRvIG9uZSBvZlxuICAvLyB0aGUgbGlzdHMuXG4gIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTEsIHVwZGF0ZSk7XG4gIC8vIEJ1dCB3ZSBzdGlsbCBuZWVkIHRvIHVwZGF0ZSB0aGUgYGxhc3RgIHBvaW50ZXIgb2YgcXVldWUyLlxuICBxdWV1ZTIubGFzdCA9IHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0VXBkYXRlRXhwaXJhdGlvblRpbWUoZmliZXIpIHtcbiAgaWYgKGZpYmVyLnRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgZmliZXIudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiBOb1dvcms7XG4gIH1cbiAgcmV0dXJuIHVwZGF0ZVF1ZXVlLmV4cGlyYXRpb25UaW1lO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcykge1xuICB2YXIgcGFydGlhbFN0YXRlID0gdXBkYXRlLnBhcnRpYWxTdGF0ZTtcbiAgaWYgKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdXBkYXRlRm4gPSBwYXJ0aWFsU3RhdGU7XG4gICAgcmV0dXJuIHVwZGF0ZUZuLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgcHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwYXJ0aWFsU3RhdGU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnVwZGF0ZVF1ZXVlID09PSBxdWV1ZSkge1xuICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIGEgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgYnkgY2xvbmluZyB0aGUgY3VycmVudCBxdWV1ZS5cbiAgICB2YXIgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBjdXJyZW50UXVldWUuZXhwaXJhdGlvblRpbWUsXG4gICAgICBmaXJzdDogY3VycmVudFF1ZXVlLmZpcnN0LFxuICAgICAgbGFzdDogY3VycmVudFF1ZXVlLmxhc3QsXG4gICAgICBpc0luaXRpYWxpemVkOiBjdXJyZW50UXVldWUuaXNJbml0aWFsaXplZCxcbiAgICAgIC8vIFRoZXNlIGZpZWxkcyBhcmUgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2UgdGhleSB3ZXJlIGFscmVhZHkgY29tbWl0dGVkLlxuICAgICAgLy8gUmVzZXQgdGhlbS5cbiAgICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICAgIGhhc0ZvcmNlVXBkYXRlOiBmYWxzZVxuICAgIH07XG4gIH1cblxuICB7XG4gICAgLy8gU2V0IHRoaXMgZmxhZyBzbyB3ZSBjYW4gd2FybiBpZiBzZXRTdGF0ZSBpcyBjYWxsZWQgaW5zaWRlIHRoZSB1cGRhdGVcbiAgICAvLyBmdW5jdGlvbiBvZiBhbm90aGVyIHNldFN0YXRlLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gIH1cblxuICAvLyBSZXNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS4gSWYgd2Ugc2tpcCBvdmVyIGFueSB1cGRhdGVzLCB3ZSdsbFxuICAvLyBpbmNyZWFzZSB0aGlzIGFjY29yZGluZ2x5LlxuICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUT0RPOiBXZSBkb24ndCBrbm93IHdoYXQgdGhlIGJhc2Ugc3RhdGUgd2lsbCBiZSB1bnRpbCB3ZSBiZWdpbiB3b3JrLlxuICAvLyBJdCBkZXBlbmRzIG9uIHdoaWNoIGZpYmVyIGlzIHRoZSBuZXh0IGN1cnJlbnQuIEluaXRpYWxpemUgd2l0aCBhbiBlbXB0eVxuICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gIC8vIGhhcHB5IHdpdGggdGhpcyBhcHByb2FjaC5cbiAgdmFyIHN0YXRlID0gdm9pZCAwO1xuICBpZiAocXVldWUuaXNJbml0aWFsaXplZCkge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlID0gcXVldWUuYmFzZVN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICBxdWV1ZS5pc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgfVxuICB2YXIgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gIHZhciB1cGRhdGUgPSBxdWV1ZS5maXJzdDtcbiAgdmFyIGRpZFNraXAgPSBmYWxzZTtcbiAgd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIHZhciB1cGRhdGVFeHBpcmF0aW9uVGltZSA9IHVwZGF0ZS5leHBpcmF0aW9uVGltZTtcbiAgICBpZiAodXBkYXRlRXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBub3QgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LiBTa2lwIGl0LlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcXVldWUuZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA+IHVwZGF0ZUV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZS5cbiAgICAgICAgcXVldWUuZXhwaXJhdGlvblRpbWUgPSB1cGRhdGVFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmICghZGlkU2tpcCkge1xuICAgICAgICBkaWRTa2lwID0gdHJ1ZTtcbiAgICAgICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gICAgICB9XG4gICAgICAvLyBDb250aW51ZSB0byB0aGUgbmV4dCB1cGRhdGUuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuXG4gICAgLy8gSWYgbm8gcHJldmlvdXMgdXBkYXRlcyB3ZXJlIHNraXBwZWQsIGRyb3AgdGhpcyB1cGRhdGUgZnJvbSB0aGUgcXVldWUgYnlcbiAgICAvLyBhZHZhbmNpbmcgdGhlIGhlYWQgb2YgdGhlIGxpc3QuXG4gICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICBxdWV1ZS5maXJzdCA9IHVwZGF0ZS5uZXh0O1xuICAgICAgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLmxhc3QgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFByb2Nlc3MgdGhlIHVwZGF0ZVxuICAgIHZhciBfcGFydGlhbFN0YXRlID0gdm9pZCAwO1xuICAgIGlmICh1cGRhdGUuaXNSZXBsYWNlKSB7XG4gICAgICBzdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgZG9udE11dGF0ZVByZXZTdGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9wYXJ0aWFsU3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUodXBkYXRlLCBpbnN0YW5jZSwgc3RhdGUsIHByb3BzKTtcbiAgICAgIGlmIChfcGFydGlhbFN0YXRlKSB7XG4gICAgICAgIGlmIChkb250TXV0YXRlUHJldlN0YXRlKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZTogSWRrIGhvdyB0byB0eXBlIHRoaXMgcHJvcGVybHkuXG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHt9LCBzdGF0ZSwgX3BhcnRpYWxTdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RhdGUgPSBfYXNzaWduKHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh1cGRhdGUuaXNGb3JjZWQpIHtcbiAgICAgIHF1ZXVlLmhhc0ZvcmNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5jYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgLy8gQXBwZW5kIHRvIGxpc3Qgb2YgY2FsbGJhY2tzLlxuICAgICAgdmFyIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3Q7XG4gICAgICBpZiAoX2NhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgICAgICBfY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0ID0gW107XG4gICAgICB9XG4gICAgICBfY2FsbGJhY2tMaXN0LnB1c2godXBkYXRlKTtcbiAgICB9XG4gICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gIH1cblxuICBpZiAocXVldWUuY2FsbGJhY2tMaXN0ICE9PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IENhbGxiYWNrO1xuICB9IGVsc2UgaWYgKHF1ZXVlLmZpcnN0ID09PSBudWxsICYmICFxdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgIC8vIFRoZSBxdWV1ZSBpcyBlbXB0eS4gV2UgY2FuIHJlc2V0IGl0LlxuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgfVxuXG4gIGlmICghZGlkU2tpcCkge1xuICAgIGRpZFNraXAgPSB0cnVlO1xuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IHN0YXRlO1xuICB9XG5cbiAge1xuICAgIC8vIE5vIGxvbmdlciBwcm9jZXNzaW5nLlxuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlO1xufVxuXG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3MocXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgaWYgKGNhbGxiYWNrTGlzdCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBTZXQgdGhlIGxpc3QgdG8gbnVsbCB0byBtYWtlIHN1cmUgdGhleSBkb24ndCBnZXQgY2FsbGVkIG1vcmUgdGhhbiBvbmNlLlxuICBxdWV1ZS5jYWxsYmFja0xpc3QgPSBudWxsO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbGxiYWNrTGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB1cGRhdGUgPSBjYWxsYmFja0xpc3RbaV07XG4gICAgdmFyIF9jYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcbiAgICAvLyBUaGlzIHVwZGF0ZSBtaWdodCBiZSBwcm9jZXNzZWQgYWdhaW4uIENsZWFyIHRoZSBjYWxsYmFjayBzbyBpdCdzIG9ubHlcbiAgICAvLyBjYWxsZWQgb25jZS5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBudWxsO1xuICAgICEodHlwZW9mIF9jYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHBhc3NlZCBhcyBjYWxsYmFjay4gRXhwZWN0ZWQgYSBmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMnLCBfY2FsbGJhY2spIDogdm9pZCAwO1xuICAgIF9jYWxsYmFjay5jYWxsKGNvbnRleHQpO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2Fybk9uSW52YWxpZENhbGxiYWNrID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICclcyguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGVyTmFtZSwgY2FsbGJhY2spO1xuICB9O1xuXG4gIC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYXZhaWxhYmxlIGluIFJlYWN0IDE2Ky4gVGhpcyBsaWtlbHkgbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0IGEgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc25cXCd0IHN1cHBvcnRlZC4gVHJ5IHRvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoIHRvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbnZhciBSZWFjdEZpYmVyQ2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLCBtZW1vaXplUHJvcHMsIG1lbW9pemVTdGF0ZSkge1xuICAvLyBDbGFzcyBjb21wb25lbnQgc3RhdGUgdXBkYXRlclxuICB2YXIgdXBkYXRlciA9IHtcbiAgICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgcGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbiAgICAgIH1cbiAgICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgICBwYXJ0aWFsU3RhdGU6IHBhcnRpYWxTdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBzdGF0ZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ3JlcGxhY2VTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogc3RhdGUsXG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgaXNSZXBsYWNlOiB0cnVlLFxuICAgICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICAgIG5leHRDYWxsYmFjazogbnVsbCxcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKTtcbiAgICAgIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH0sXG4gICAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogbnVsbCxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgICBpc0ZvcmNlZDogdHJ1ZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV3Q29udGV4dCkge1xuICAgIGlmIChvbGRQcm9wcyA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSkge1xuICAgICAgLy8gSWYgdGhlIHdvcmtJblByb2dyZXNzIGFscmVhZHkgaGFzIGFuIFVwZGF0ZSBlZmZlY3QsIHJldHVybiB0cnVlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdzaG91bGRDb21wb25lbnRVcGRhdGUnKTtcbiAgICAgIHZhciBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhzaG91bGRVcGRhdGUgIT09IHVuZGVmaW5lZCwgJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgICByZXR1cm4gIXNoYWxsb3dFcXVhbChvbGRQcm9wcywgbmV3UHJvcHMpIHx8ICFzaGFsbG93RXF1YWwob2xkU3RhdGUsIG5ld1N0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgICBpZiAoIXJlbmRlclByZXNlbnQpIHtcbiAgICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG5vR2V0SW5pdGlhbFN0YXRlT25FUzYgPSAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlIHx8IGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCB8fCBpbnN0YW5jZS5zdGF0ZTtcbiAgICAgIHdhcm5pbmcobm9HZXRJbml0aWFsU3RhdGVPbkVTNiwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICAgIHZhciBub0dldERlZmF1bHRQcm9wc09uRVM2ID0gIWluc3RhbmNlLmdldERlZmF1bHRQcm9wcyB8fCBpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQ7XG4gICAgICB3YXJuaW5nKG5vR2V0RGVmYXVsdFByb3BzT25FUzYsICdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlUHJvcFR5cGVzID0gIWluc3RhbmNlLnByb3BUeXBlcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZVByb3BUeXBlcywgJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VDb250ZXh0VHlwZXMgPSAhaW5zdGFuY2UuY29udGV4dFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlQ29udGV4dFR5cGVzLCAnY29udGV4dFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnRTaG91bGRVcGRhdGUgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFNob3VsZFVwZGF0ZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIG5hbWUpO1xuICAgICAgaWYgKHR5cGUucHJvdG90eXBlICYmIHR5cGUucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQSBwdXJlIGNvbXBvbmVudCcpO1xuICAgICAgfVxuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkVW5tb3VudCA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFVubW91bnQsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzKCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnSWYgeW91IG1lYW50IHRvIHVwZGF0ZSB0aGUgc3RhdGUgaW4gcmVzcG9uc2UgdG8gY2hhbmdpbmcgcHJvcHMsICcgKyAndXNlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKS4gSWYgeW91IG1lYW50IHRvIGZldGNoIGRhdGEgb3IgJyArICdydW4gc2lkZS1lZmZlY3RzIG9yIG11dGF0aW9ucyBhZnRlciBSZWFjdCBoYXMgdXBkYXRlZCB0aGUgVUksIHVzZSBjb21wb25lbnREaWRVcGRhdGUoKS4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyAhPT0gJ2Z1bmN0aW9uJztcbiAgICAgIHdhcm5pbmcobm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5wcm9wcyA9PT0gdW5kZWZpbmVkIHx8ICFoYXNNdXRhdGVkUHJvcHMsICclcyguLi4pOiBXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSwgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZURlZmF1bHRQcm9wcyA9ICFpbnN0YW5jZS5kZWZhdWx0UHJvcHM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VEZWZhdWx0UHJvcHMsICdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0Q2hpbGRDb250ZXh0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAhKHR5cGVvZiB3b3JrSW5Qcm9ncmVzcy50eXBlLmNoaWxkQ29udGV4dFR5cGVzID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvIHVzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlLnByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UudXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuICAgIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBwcm9wcykge1xuICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmVlZHNDb250ZXh0ID0gaXNDb250ZXh0Q29uc3VtZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gbmVlZHNDb250ZXh0ID8gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KSA6IGVtcHR5T2JqZWN0O1xuICAgIHZhciBpbnN0YW5jZSA9IG5ldyBjdG9yKHByb3BzLCBjb250ZXh0KTtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cbiAgICAvLyBSZWFjdEZpYmVyQ29udGV4dCB1c3VhbGx5IHVwZGF0ZXMgdGhpcyBjYWNoZSBidXQgY2FuJ3QgZm9yIG5ld2x5LWNyZWF0ZWQgaW5zdGFuY2VzLlxuICAgIGlmIChuZWVkc0NvbnRleHQpIHtcbiAgICAgIGNhY2hlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0LCBjb250ZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxNb3VudCcpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuXG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSk7XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXdDb250ZXh0KSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpO1xuICAgIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG5cbiAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IG9sZFN0YXRlKSB7XG4gICAgICB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG4gICAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKTogQXNzaWduaW5nIGRpcmVjdGx5IHRvICcgKyBcInRoaXMuc3RhdGUgaXMgZGVwcmVjYXRlZCAoZXhjZXB0IGluc2lkZSBhIGNvbXBvbmVudCdzIFwiICsgJ2NvbnN0cnVjdG9yKS4gVXNlIHNldFN0YXRlIGluc3RlYWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuICBmdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICB7XG4gICAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSB8fCBudWxsO1xuXG4gICAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICFwcm9wcyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIG11c3QgYmUgcGVuZGluZyBwcm9wcyBmb3IgYW4gaW5pdGlhbCBtb3VudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaW5zdGFuY2UucHJvcHMgPSBwcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBzdGF0ZTtcbiAgICBpbnN0YW5jZS5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIHdvcmtJblByb2dyZXNzLnR5cGUgIT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy50eXBlLnByb3RvdHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuaW50ZXJuYWxDb250ZXh0VGFnIHw9IEFzeW5jVXBkYXRlcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgICAgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgICAgLy8gcHJvY2VzcyB0aGVtIG5vdy5cbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIGluc3RhbmNlLnN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgaW5zdGFuY2UsIHByb3BzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsbGVkIG9uIGEgcHJlZXhpc3RpbmcgY2xhc3MgaW5zdGFuY2UuIFJldHVybnMgZmFsc2UgaWYgYSByZXN1bWVkIHJlbmRlclxuICAvLyBjb3VsZCBiZSByZXVzZWQuXG4gIC8vIGZ1bmN0aW9uIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZShcbiAgLy8gICB3b3JrSW5Qcm9ncmVzczogRmliZXIsXG4gIC8vICAgcHJpb3JpdHlMZXZlbDogUHJpb3JpdHlMZXZlbCxcbiAgLy8gKTogYm9vbGVhbiB7XG4gIC8vICAgY29uc3QgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIC8vICAgcmVzZXRJbnB1dFBvaW50ZXJzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG5cbiAgLy8gICBsZXQgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAvLyAgIGxldCBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgLy8gICBpZiAoIW5ld1Byb3BzKSB7XG4gIC8vICAgICAvLyBJZiB0aGVyZSBpc24ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgLy8gICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAvLyAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAvLyAgICAgaW52YXJpYW50KFxuICAvLyAgICAgICBuZXdQcm9wcyAhPSBudWxsLFxuICAvLyAgICAgICAnVGhlcmUgc2hvdWxkIGFsd2F5cyBiZSBwZW5kaW5nIG9yIG1lbW9pemVkIHByb3BzLiBUaGlzIGVycm9yIGlzICcgK1xuICAvLyAgICAgICAgICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG4gIC8vICAgY29uc3QgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgLy8gICBjb25zdCBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAvLyAgIGNvbnN0IG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAvLyAgIGNvbnN0IG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcblxuICAvLyAgIGlmIChcbiAgLy8gICAgIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmXG4gIC8vICAgICAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5ld0NvbnRleHQpXG4gIC8vICAgKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdQcm9wcyxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgICk7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlIGJlZm9yZSBjYWxsaW5nIHNob3VsZENvbXBvbmVudFVwZGF0ZVxuICAvLyAgIGNvbnN0IHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHVwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICBpbnN0YW5jZSxcbiAgLy8gICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBwcmlvcml0eUxldmVsLFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBUT0RPOiBTaG91bGQgd2UgZGVhbCB3aXRoIGEgc2V0U3RhdGUgdGhhdCBoYXBwZW5lZCBhZnRlciB0aGUgbGFzdFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgYmVmb3JlIHRoaXMgY29tcG9uZW50V2lsbE1vdW50PyBQcm9iYWJseVxuICAvLyAgIC8vIHVuc3VwcG9ydGVkIGFueXdheS5cblxuICAvLyAgIGlmIChcbiAgLy8gICAgICFjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZShcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3Q29udGV4dCxcbiAgLy8gICAgIClcbiAgLy8gICApIHtcbiAgLy8gICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gICAgIC8vIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dC5cbiAgLy8gICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG4gIC8vICAgICByZXR1cm4gZmFsc2U7XG4gIC8vICAgfVxuXG4gIC8vICAgLy8gVXBkYXRlIHRoZSBpbnB1dCBwb2ludGVycyBub3cgc28gdGhhdCB0aGV5IGFyZSBjb3JyZWN0IHdoZW4gd2UgY2FsbFxuICAvLyAgIC8vIGNvbXBvbmVudFdpbGxNb3VudFxuICAvLyAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIC8vICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgLy8gICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAvLyAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIC8vICAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgbWF5IGhhdmUgY2FsbGVkIHNldFN0YXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gIC8vICAgICBjb25zdCBuZXdVcGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAvLyAgICAgaWYgKG5ld1VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gIC8vICAgICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICAgIHdvcmtJblByb2dyZXNzLFxuICAvLyAgICAgICAgIG5ld1VwZGF0ZVF1ZXVlLFxuICAvLyAgICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICAgICk7XG4gIC8vICAgICB9XG4gIC8vICAgfVxuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgLy8gICB9XG5cbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuXG4gIC8vICAgcmV0dXJuIHRydWU7XG4gIC8vIH1cblxuICAvLyBJbnZva2VzIHRoZSB1cGRhdGUgbGlmZS1jeWNsZXMgYW5kIHJldHVybnMgZmFsc2UgaWYgaXQgc2hvdWxkbid0IHJlcmVuZGVyLlxuICBmdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAgIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZW4ndCBhbnkgbmV3IHByb3BzLCB0aGVuIHdlJ2xsIHJldXNlIHRoZSBtZW1vaXplZCBwcm9wcy5cbiAgICAgIC8vIFRoaXMgY291bGQgYmUgZnJvbSBhbHJlYWR5IGNvbXBsZXRlZCB3b3JrLlxuICAgICAgbmV3UHJvcHMgPSBvbGRQcm9wcztcbiAgICAgICEobmV3UHJvcHMgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgICB2YXIgbmV3VW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgbmV3Q29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIG5ld1VubWFza2VkQ29udGV4dCk7XG5cbiAgICAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gICAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgICAvLyBkdXJpbmcgY29tcG9uZW50RGlkVXBkYXRlIHdlIHBhc3MgdGhlIFwiY3VycmVudFwiIHByb3BzLlxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dCkpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpO1xuICAgIH1cblxuICAgIC8vIENvbXB1dGUgdGhlIG5leHQgc3RhdGUgdXNpbmcgdGhlIG1lbW9pemVkIHN0YXRlIGFuZCB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgLy8gVE9ETzogUHJldmlvdXMgc3RhdGUgY2FuIGJlIG51bGwuXG4gICAgdmFyIG5ld1N0YXRlID0gdm9pZCAwO1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgbmV3UHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3RhdGUgPSBvbGRTdGF0ZTtcbiAgICB9XG5cbiAgICBpZiAob2xkUHJvcHMgPT09IG5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSkge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsVXBkYXRlJyk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXdDb250ZXh0KTtcbiAgICAgICAgc3RvcFBoYXNlVGltZXIoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGlmIChvbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzKTtcbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IG5ld0NvbnRleHQ7XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBhZG9wdENsYXNzSW5zdGFuY2U6IGFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlOiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlLFxuICAgIG1vdW50Q2xhc3NJbnN0YW5jZTogbW91bnRDbGFzc0luc3RhbmNlLFxuICAgIC8vIHJlc3VtZU1vdW50Q2xhc3NJbnN0YW5jZSxcbiAgICB1cGRhdGVDbGFzc0luc3RhbmNlOiB1cGRhdGVDbGFzc0luc3RhbmNlXG4gIH07XG59O1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBzcGVjaWFsIFJlYWN0IHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QucG9ydGFsJykgfHwgMHhlYWNhO1xuXG5mdW5jdGlvbiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVySW5mbyxcbi8vIFRPRE86IGZpZ3VyZSBvdXQgdGhlIEFQSSBmb3IgY3Jvc3MtcmVuZGVyZXIgaW1wbGVtZW50YXRpb24uXG5pbXBsZW1lbnRhdGlvbikge1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuICB2YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG4gIHZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcblxuICB2YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNoaWxkLl9zdG9yZSB8fCBjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICEodHlwZW9mIGNoaWxkLl9zdG9yZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSB0cnVlO1xuXG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gICAgd2FybmluZyhmYWxzZSwgJ0VhY2ggY2hpbGQgaW4gYW4gYXJyYXkgb3IgaXRlcmF0b3Igc2hvdWxkIGhhdmUgYSB1bmlxdWUgJyArICdcImtleVwiIHByb3AuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgJyArICdtb3JlIGluZm9ybWF0aW9uLiVzJywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICB9O1xufVxuXG52YXIgaXNBcnJheSQxID0gQXJyYXkuaXNBcnJheTtcblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLiBJZiB0aGVyZSBpcyBubyBuYXRpdmUgU3ltYm9sXG4vLyBub3IgcG9seWZpbGwsIHRoZW4gYSBwbGFpbiBudW1iZXIgaXMgdXNlZCBmb3IgcGVyZm9ybWFuY2UuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFO1xudmFyIFJFQUNUX0NBTExfVFlQRTtcbnZhciBSRUFDVF9SRVRVUk5fVFlQRTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSkge1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50Jyk7XG4gIFJFQUNUX0NBTExfVFlQRSA9IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmNhbGwnKTtcbiAgUkVBQ1RfUkVUVVJOX1RZUEUgPSBTeW1ib2xbJ2ZvciddKCdyZWFjdC5yZXR1cm4nKTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmZyYWdtZW50Jyk7XG59IGVsc2Uge1xuICBSRUFDVF9FTEVNRU5UX1RZUEUgPSAweGVhYzc7XG4gIFJFQUNUX0NBTExfVFlQRSA9IDB4ZWFjODtcbiAgUkVBQ1RfUkVUVVJOX1RZUEUgPSAweGVhYzk7XG4gIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSAweGVhY2I7XG59XG5cbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB2YXIgaXRlcmF0b3JGbiA9IElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCkge1xuICB2YXIgbWl4ZWRSZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKG1peGVkUmVmICE9PSBudWxsICYmIHR5cGVvZiBtaXhlZFJlZiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChlbGVtZW50Ll9vd25lcikge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgaW5zdCA9IHZvaWQgMDtcbiAgICAgIGlmIChvd25lcikge1xuICAgICAgICB2YXIgb3duZXJGaWJlciA9IG93bmVyO1xuICAgICAgICAhKG93bmVyRmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgaGF2ZSByZWZzLicpIDogdm9pZCAwO1xuICAgICAgICBpbnN0ID0gb3duZXJGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgICAhaW5zdCA/IGludmFyaWFudChmYWxzZSwgJ01pc3Npbmcgb3duZXIgZm9yIHN0cmluZyByZWYgJXMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgICAgdmFyIHN0cmluZ1JlZiA9ICcnICsgbWl4ZWRSZWY7XG4gICAgICAvLyBDaGVjayBpZiBwcmV2aW91cyBzdHJpbmcgcmVmIG1hdGNoZXMgbmV3IHN0cmluZyByZWZcbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsICYmIGN1cnJlbnQucmVmLl9zdHJpbmdSZWYgPT09IHN0cmluZ1JlZikge1xuICAgICAgICByZXR1cm4gY3VycmVudC5yZWY7XG4gICAgICB9XG4gICAgICB2YXIgcmVmID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciByZWZzID0gaW5zdC5yZWZzID09PSBlbXB0eU9iamVjdCA/IGluc3QucmVmcyA9IHt9IDogaW5zdC5yZWZzO1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICBkZWxldGUgcmVmc1tzdHJpbmdSZWZdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZnNbc3RyaW5nUmVmXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcmVmLl9zdHJpbmdSZWYgPSBzdHJpbmdSZWY7XG4gICAgICByZXR1cm4gcmVmO1xuICAgIH0gZWxzZSB7XG4gICAgICAhKHR5cGVvZiBtaXhlZFJlZiA9PT0gJ3N0cmluZycpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmcuJykgOiB2b2lkIDA7XG4gICAgICAhZWxlbWVudC5fb3duZXIgPyBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHJlZiB3YXMgc3BlY2lmaWVkIGFzIGEgc3RyaW5nICglcykgYnV0IG5vIG93bmVyIHdhcyBzZXQuIFlvdSBtYXkgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgbG9hZGVkLiAoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJywgbWl4ZWRSZWYpIDogdm9pZCAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbWl4ZWRSZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKHJldHVybkZpYmVyLnR5cGUgIT09ICd0ZXh0YXJlYScpIHtcbiAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICB7XG4gICAgICBhZGRlbmR1bSA9ICcgSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4sIHVzZSBhbiBhcnJheSAnICsgJ2luc3RlYWQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ09iamVjdHMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkIChmb3VuZDogJXMpLiVzJywgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogbmV3Q2hpbGQsIGFkZGVuZHVtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUoKSB7XG4gIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gYSBDb21wb25lbnQgaW5zdGVhZCBvZiA8Q29tcG9uZW50IC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LicgKyAoZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkgfHwgJycpO1xuXG4gIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICB3YXJuaW5nKGZhbHNlLCAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG59XG5cbi8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5mdW5jdGlvbiBDaGlsZFJlY29uY2lsZXIoc2hvdWxkQ2xvbmUsIHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghc2hvdWxkQ2xvbmUpIHtcbiAgICAgIC8vIFdoZW4gd2UncmUgcmVjb25jaWxpbmcgaW4gcGxhY2Ugd2UgaGF2ZSBhIHdvcmsgaW4gcHJvZ3Jlc3MgY29weS4gV2VcbiAgICAgIC8vIGFjdHVhbGx5IHdhbnQgdGhlIGN1cnJlbnQgY29weS4gSWYgdGhlcmUgaXMgbm8gY3VycmVudCBjb3B5LCB0aGVuIHdlXG4gICAgICAvLyBkb24ndCBuZWVkIHRvIHRyYWNrIGRlbGV0aW9uIHNpZGUtZWZmZWN0cy5cbiAgICAgIGlmIChjaGlsZFRvRGVsZXRlLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5hbHRlcm5hdGU7XG4gICAgfVxuICAgIC8vIERlbGV0aW9ucyBhcmUgYWRkZWQgaW4gcmV2ZXJzZWQgb3JkZXIgc28gd2UgYWRkIGl0IHRvIHRoZSBmcm9udC5cbiAgICAvLyBBdCB0aGlzIHBvaW50LCB0aGUgcmV0dXJuIGZpYmVyJ3MgZWZmZWN0IGxpc3QgaXMgZW1wdHkgZXhjZXB0IGZvclxuICAgIC8vIGRlbGV0aW9ucywgc28gd2UgY2FuIGp1c3QgYXBwZW5kIHRoZSBkZWxldGlvbiB0byB0aGUgbGlzdC4gVGhlIHJlbWFpbmluZ1xuICAgIC8vIGVmZmVjdHMgYXJlbid0IGFkZGVkIHVudGlsIHRoZSBjb21wbGV0ZSBwaGFzZS4gT25jZSB3ZSBpbXBsZW1lbnRcbiAgICAvLyByZXN1bWluZywgdGhpcyBtYXkgbm90IGJlIHRydWUuXG4gICAgdmFyIGxhc3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0O1xuICAgIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgICBsYXN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICAgIGNoaWxkVG9EZWxldGUubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuICAgICAgZXhpc3RpbmdDaGlsZCA9IGV4aXN0aW5nQ2hpbGQuc2libGluZztcbiAgICB9XG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICBpZiAoc2hvdWxkQ2xvbmUpIHtcbiAgICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICAgIGNsb25lLnNpYmxpbmcgPSBudWxsO1xuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSBvdmVycmlkZSB0aGUgZXhwaXJhdGlvbiB0aW1lIGV2ZW4gaWYgaXQgaXMgZWFybGllciwgYmVjYXVzZSBpZlxuICAgICAgLy8gd2UncmUgcmVjb25jaWxpbmcgYXQgYSBsYXRlciB0aW1lIHRoYXQgbWVhbnMgdGhhdCB0aGlzIHdhc1xuICAgICAgLy8gZG93bi1wcmlvcml0aXplZC5cbiAgICAgIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBmaWJlci5lZmZlY3RUYWcgPSBOb0VmZmVjdDtcbiAgICAgIGZpYmVyLmluZGV4ID0gMDtcbiAgICAgIGZpYmVyLnNpYmxpbmcgPSBudWxsO1xuICAgICAgZmliZXIucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzO1xuICAgICAgcmV0dXJuIGZpYmVyO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SW5kZXgpIHtcbiAgICBuZXdGaWJlci5pbmRleCA9IG5ld0luZGV4O1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuICAgICAgaWYgKG9sZEluZGV4IDwgbGFzdFBsYWNlZEluZGV4KSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBtb3ZlLlxuICAgICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGl0ZW0gY2FuIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgIHJldHVybiBvbGRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24uXG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBsYWNlU2luZ2xlQ2hpbGQobmV3RmliZXIpIHtcbiAgICAvLyBUaGlzIGlzIHNpbXBsZXIgZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS4gV2Ugb25seSBuZWVkIHRvIGRvIGFcbiAgICAvLyBwbGFjZW1lbnQgZm9yIGluc2VydGluZyBuZXcgY2hpbGRyZW4uXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMgJiYgbmV3RmliZXIuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICBuZXdGaWJlci5lZmZlY3RUYWcgPSBQbGFjZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmcucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnJlZiA9IGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRPRE86IFNob3VsZCB0aGlzIGFsc28gY29tcGFyZSBoYW5kbGVyIHRvIGRldGVybWluZSB3aGV0aGVyIHRvIHJldXNlP1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50LCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBmcmFnbWVudCwgZXhwaXJhdGlvblRpbWUsIGtleSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCcnICsgbmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgICBfY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkMiA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDIucmVmID0gY29lcmNlUmVmKG51bGwsIG5ld0NoaWxkKTtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQyWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQzID0gY3JlYXRlRmliZXJGcm9tQ2FsbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDNbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4obmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0LnR5cGUgPSBuZXdDaGlsZC52YWx1ZTtcbiAgICAgICAgICAgIF9jcmVhdGVkNFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNSA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ1O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkNiA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgICAgX2NyZWF0ZWQ2WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gX2NyZWF0ZWQ2O1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cblxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICBpZiAobmV3Q2hpbGQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuLCBleHBpcmF0aW9uVGltZSwga2V5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAgICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGFcbiAgICAgICAgICAgIC8vIHlpZWxkLlxuICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUmV0dXJuKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsICcnICsgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlciA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBuZXdDaGlsZC5rZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVDYWxsKHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyMiwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9SRVRVUk5fVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBSZXR1cm5zIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAgICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgcmV0dXJucywgdGhleSBtYXRjaC5cbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyNCA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI0LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkkMShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI1ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXI1LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIFdhcm5zIGlmIHRoZXJlIGlzIGEgZHVwbGljYXRlIG9yIG1pc3Npbmcga2V5XG4gICAqL1xuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgd2FybkZvck1pc3NpbmdLZXkoY2hpbGQpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0VuY291bnRlcmVkIHR3byBjaGlsZHJlbiB3aXRoIHRoZSBzYW1lIGtleSwgYCVzYC4gJyArICdLZXlzIHNob3VsZCBiZSB1bmlxdWUgc28gdGhhdCBjb21wb25lbnRzIG1haW50YWluIHRoZWlyIGlkZW50aXR5ICcgKyAnYWNyb3NzIHVwZGF0ZXMuIE5vbi11bmlxdWUga2V5cyBtYXkgY2F1c2UgY2hpbGRyZW4gdG8gYmUgJyArICdkdXBsaWNhdGVkIGFuZC9vciBvbWl0dGVkIOKAlCB0aGUgYmVoYXZpb3IgaXMgdW5zdXBwb3J0ZWQgYW5kICcgKyAnY291bGQgY2hhbmdlIGluIGEgZnV0dXJlIHZlcnNpb24uJXMnLCBrZXksIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGFsZ29yaXRobSBjYW4ndCBvcHRpbWl6ZSBieSBzZWFyY2hpbmcgZnJvbSBib3RocyBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cblxuICAgIC8vIEV2ZW4gd2l0aCBhIHR3byBlbmRlZCBvcHRpbWl6YXRpb24sIHdlJ2Qgd2FudCB0byBvcHRpbWl6ZSBmb3IgdGhlIGNhc2VcbiAgICAvLyB3aGVyZSB0aGVyZSBhcmUgZmV3IGNoYW5nZXMgYW5kIGJydXRlIGZvcmNlIHRoZSBjb21wYXJpc29uIGluc3RlYWQgb2ZcbiAgICAvLyBnb2luZyBmb3IgdGhlIE1hcC4gSXQnZCBsaWtlIHRvIGV4cGxvcmUgaGl0dGluZyB0aGF0IHBhdGggZmlyc3QgaW5cbiAgICAvLyBmb3J3YXJkLW9ubHkgbW9kZSBhbmQgb25seSBnbyBmb3IgdGhlIE1hcCBvbmNlIHdlIG5vdGljZSB0aGF0IHdlIG5lZWRcbiAgICAvLyBsb3RzIG9mIGxvb2sgYWhlYWQuIFRoaXMgZG9lc24ndCBoYW5kbGUgcmV2ZXJzYWwgYXMgd2VsbCBhcyB0d28gZW5kZWRcbiAgICAvLyBzZWFyY2ggYnV0IHRoYXQncyB1bnVzdWFsLiBCZXNpZGVzLCBmb3IgdGhlIHR3byBlbmRlZCBvcHRpbWl6YXRpb24gdG9cbiAgICAvLyB3b3JrIG9uIEl0ZXJhYmxlcywgd2UnZCBuZWVkIHRvIGNvcHkgdGhlIHdob2xlIHNldC5cblxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuXG4gICAge1xuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcblxuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICBpZiAob2xkRmliZXIuaW5kZXggPiBuZXdJZHgpIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXI7XG4gICAgICAgIG9sZEZpYmVyID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKG5ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgYnJlYWtzIG9uIGVtcHR5IHNsb3RzIGxpa2UgbnVsbCBjaGlsZHJlbi4gVGhhdCdzXG4gICAgICAgIC8vIHVuZm9ydHVuYXRlIGJlY2F1c2UgaXQgdHJpZ2dlcnMgdGhlIHNsb3cgcGF0aCBhbGwgdGhlIHRpbWUuIFdlIG5lZWRcbiAgICAgICAgLy8gYSBiZXR0ZXIgd2F5IHRvIGNvbW11bmljYXRlIHdoZXRoZXIgdGhpcyB3YXMgYSBtaXNzIG9yIG51bGwsXG4gICAgICAgIC8vIGJvb2xlYW4sIHVuZGVmaW5lZCwgZXRjLlxuICAgICAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoIV9uZXdGaWJlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIHZhciBfbmV3RmliZXIyID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoX25ld0ZpYmVyMikge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW5bJ2RlbGV0ZSddKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW5JdGVyYWJsZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG5cbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgISh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAge1xuICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkcmVuSXRlcmFibGUuZW50cmllcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgcG9zc2libGVNYXAgPSBuZXdDaGlsZHJlbkl0ZXJhYmxlO1xuICAgICAgICBpZiAocG9zc2libGVNYXAuZW50cmllcyA9PT0gaXRlcmF0b3JGbikge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRmlyc3QsIHZhbGlkYXRlIGtleXMuXG4gICAgICAvLyBXZSdsbCBnZXQgYSBkaWZmZXJlbnQgaXRlcmF0b3IgbGF0ZXIgZm9yIHRoZSBtYWluIHBhc3MuXG4gICAgICB2YXIgX25ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICAgaWYgKF9uZXdDaGlsZHJlbikge1xuICAgICAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICAgICAgdmFyIF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKTtcbiAgICAgICAgZm9yICg7ICFfc3RlcC5kb25lOyBfc3RlcCA9IF9uZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgICB2YXIgY2hpbGQgPSBfc3RlcC52YWx1ZTtcbiAgICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuICAgICEobmV3Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJykgOiB2b2lkIDA7XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmICghb2xkRmliZXIpIHtcbiAgICAgICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCkpIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX25ld0ZpYmVyMyA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIzO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXI0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjQuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyNC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXI0LmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIGNoZWNrIGZvciBrZXlzIG9uIHRleHQgbm9kZXMgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhXG4gICAgLy8gd2F5IHRvIGRlZmluZSB0aGVtLlxuICAgIGlmIChjdXJyZW50Rmlyc3RDaGlsZCAhPT0gbnVsbCAmJiBjdXJyZW50Rmlyc3RDaGlsZC50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gZXhpc3Rpbmcgbm9kZSBzbyBsZXQncyBqdXN0IHVwZGF0ZSBpdCBhbmQgZGVsZXRlXG4gICAgICAvLyB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZC5zaWJsaW5nKTtcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIC8vIFRoZSBleGlzdGluZyBmaXJzdCBjaGlsZCBpcyBub3QgYSB0ZXh0IG5vZGUgc28gd2UgbmVlZCB0byBjcmVhdGUgb25lXG4gICAgLy8gYW5kIGRlbGV0ZSB0aGUgZXhpc3Rpbmcgb25lcy5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCA/IGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSA6IGNoaWxkLnR5cGUgPT09IGVsZW1lbnQudHlwZSkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFID8gZWxlbWVudC5wcm9wcy5jaGlsZHJlbiA6IGVsZW1lbnQucHJvcHMsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY2hpbGQsIGVsZW1lbnQpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z1NvdXJjZSA9IGVsZW1lbnQuX3NvdXJjZTtcbiAgICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwgZWxlbWVudC5rZXkpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ3ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIF9jcmVhdGVkNy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQpO1xuICAgICAgX2NyZWF0ZWQ3WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIF9jcmVhdGVkNztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gY2FsbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gQ2FsbENvbXBvbmVudCkge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgY2FsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tQ2FsbChjYWxsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcmV0dXJuTm9kZSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24geWllbGRzIHNpbmNlIHRoZXkncmUgc3RhdGVsZXNzLlxuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGNoaWxkLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgZXhpc3RpbmcudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHBvcnRhbCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgbm90IHJlY3Vyc2l2ZS5cbiAgICAvLyBJZiB0aGUgdG9wIGxldmVsIGl0ZW0gaXMgYW4gYXJyYXksIHdlIHRyZWF0IGl0IGFzIGEgc2V0IG9mIGNoaWxkcmVuLFxuICAgIC8vIG5vdCBhcyBhIGZyYWdtZW50LiBOZXN0ZWQgYXJyYXlzIG9uIHRoZSBvdGhlciBoYW5kIHdpbGwgYmUgdHJlYXRlZCBhc1xuICAgIC8vIGZyYWdtZW50IG5vZGVzLiBSZWN1cnNpb24gaGFwcGVucyBhdCB0aGUgbm9ybWFsIGZsb3cuXG5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgaWYgKGVuYWJsZVJlYWN0RnJhZ21lbnQgJiYgdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbCkge1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG4gICAgdmFyIGlzT2JqZWN0ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbDtcblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlQ2FsbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVJldHVybihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcbiAgICB9XG5cbiAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmIChpc09iamVjdCkge1xuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHRoZSBuZXcgY2hpbGQgaXMgdW5kZWZpbmVkLCBhbmQgdGhlIHJldHVybiBmaWJlciBpcyBhIGNvbXBvc2l0ZVxuICAgICAgLy8gY29tcG9uZW50LCB0aHJvdyBhbiBlcnJvci4gSWYgRmliZXIgcmV0dXJuIHR5cGVzIGFyZSBkaXNhYmxlZCxcbiAgICAgIC8vIHdlIGFscmVhZHkgdGhyZXcgYWJvdmUuXG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBpZiAoaW5zdGFuY2UucmVuZGVyLl9pc01vY2tGdW5jdGlvbikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGFsbG93IGF1dG8tbW9ja3MgdG8gcHJvY2VlZCBhcyBpZiB0aGV5J3JlIHJldHVybmluZyBudWxsLlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCB0byB0aGUgbmV4dCBjYXNlLCB3aGljaCBoYW5kbGVzIGJvdGhcbiAgICAgICAgLy8gZnVuY3Rpb25zIGFuZCBjbGFzc2VzXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZWQgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBDb21wb25lbnQgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnJXMoLi4uKTogTm90aGluZyB3YXMgcmV0dXJuZWQgZnJvbSByZW5kZXIuIFRoaXMgdXN1YWxseSBtZWFucyBhIHJldHVybiBzdGF0ZW1lbnQgaXMgbWlzc2luZy4gT3IsIHRvIHJlbmRlciBub3RoaW5nLCByZXR1cm4gbnVsbC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuICAgIHJldHVybiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICB9XG5cbiAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzO1xufVxuXG52YXIgcmVjb25jaWxlQ2hpbGRGaWJlcnMgPSBDaGlsZFJlY29uY2lsZXIodHJ1ZSwgdHJ1ZSk7XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVyc0luUGxhY2UgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UsIHRydWUpO1xuXG52YXIgbW91bnRDaGlsZEZpYmVyc0luUGxhY2UgPSBDaGlsZFJlY29uY2lsZXIoZmFsc2UsIGZhbHNlKTtcblxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAhKGN1cnJlbnQgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPT09IGN1cnJlbnQuY2hpbGQpID8gaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpIDogdm9pZCAwO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzLCBjdXJyZW50Q2hpbGQuZXhwaXJhdGlvblRpbWUpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuXG4gIG5ld0NoaWxkWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gICAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59XG5cbntcbiAgdmFyIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmcyA9IHt9O1xufVxuXG52YXIgUmVhY3RGaWJlckJlZ2luV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlID0gY29uZmlnLnNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU7XG4gIHZhciBwdXNoSG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5wdXNoSG9zdENvbnRleHQsXG4gICAgICBwdXNoSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGFpbmVyO1xuICB2YXIgZW50ZXJIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQuZW50ZXJIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ2xhc3NDb21wbyA9IFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudChzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSxcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5hZG9wdENsYXNzSW5zdGFuY2UsXG4gICAgICBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgICBtb3VudENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8ubW91bnRDbGFzc0luc3RhbmNlLFxuICAgICAgdXBkYXRlQ2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby51cGRhdGVDbGFzc0luc3RhbmNlO1xuXG4gIC8vIFRPRE86IFJlbW92ZSB0aGlzIGFuZCB1c2UgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIGRpcmVjdGx5LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbikge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAgIC8vIHdlIHdpbGwgYWRkIHRoZW0gYWxsIHRvIHRoZSBjaGlsZCBiZWZvcmUgaXQgZ2V0cyByZW5kZXJlZC4gVGhhdCBtZWFuc1xuICAgICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSBpZiAoY3VycmVudC5jaGlsZCA9PT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAgIC8vIElmIHRoZSBjdXJyZW50IGNoaWxkIGlzIHRoZSBzYW1lIGFzIHRoZSB3b3JrIGluIHByb2dyZXNzLCBpdCBtZWFucyB0aGF0XG4gICAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cblxuICAgICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYsIG9uIHRoZSBvdGhlciBoYW5kLCBpdCBpcyBhbHJlYWR5IHVzaW5nIGEgY2xvbmUsIHRoYXQgbWVhbnMgd2UndmVcbiAgICAgIC8vIGFscmVhZHkgYmVndW4gc29tZSB3b3JrIG9uIHRoaXMgdHJlZSBhbmQgd2UgY2FuIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnRcbiAgICAgIC8vIG9mZiBieSByZWNvbmNpbGluZyBhZ2FpbnN0IHRoZSBleGlzdGluZyBjaGlsZHJlbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBpZiAocmVmICE9PSBudWxsICYmICghY3VycmVudCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKSkge1xuICAgICAgLy8gU2NoZWR1bGUgYSBSZWYgZWZmZWN0XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZ1bmN0aW9uYWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICB2YXIgbWVtb2l6ZWRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dFByb3BzID0gbWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCB8fCBtZW1vaXplZFByb3BzID09PSBuZXh0UHJvcHMpIHtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgLy8gVE9ETzogY29uc2lkZXIgYnJpbmdpbmcgZm4uc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkgYmFjay5cbiAgICAgIC8vIEl0IHVzZWQgdG8gYmUgaGVyZS5cbiAgICB9XG5cbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gZm4obmV4dFByb3BzLCBjb250ZXh0KTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgZWFybHkgdG8gcHJldmVudCBjb250ZXh0IHN0YWNrIG1pc21hdGNoZXMuXG4gICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICB2YXIgaGFzQ29udGV4dCA9IHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IHZvaWQgMDtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgaWYgKCF3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUpIHtcbiAgICAgICAgLy8gSW4gdGhlIGluaXRpYWwgcGFzcyB3ZSBtaWdodCBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgaW5zdGFuY2UuXG4gICAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICAgICAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICAgICAgLy8gc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCkge1xuICAgIC8vIFJlZnMgc2hvdWxkIHVwZGF0ZSBldmVuIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoIXNob3VsZFVwZGF0ZSkge1xuICAgICAgLy8gQ29udGV4dCBwcm92aWRlcnMgc2hvdWxkIGRlZmVyIHRvIHNDVSBmb3IgcmVuZGVyaW5nXG4gICAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBmYWxzZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAvLyBSZXJlbmRlclxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gdm9pZCAwO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKCdyZW5kZXInKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAvLyBNZW1vaXplIHByb3BzIGFuZCBzdGF0ZSB1c2luZyB0aGUgdmFsdWVzIHdlIGp1c3QgdXNlZCB0byByZW5kZXIuXG4gICAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG4gICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5zdGF0ZSk7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZS5wcm9wcyk7XG5cbiAgICAvLyBUaGUgY29udGV4dCBtaWdodCBoYXZlIGNoYW5nZWQgc28gd2UgbmVlZCB0byByZWNhbGN1bGF0ZSBpdC5cbiAgICBpZiAoaGFzQ29udGV4dCkge1xuICAgICAgaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChyb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LnBlbmRpbmdDb250ZXh0LCByb290LnBlbmRpbmdDb250ZXh0ICE9PSByb290LmNvbnRleHQpO1xuICAgIH0gZWxzZSBpZiAocm9vdC5jb250ZXh0KSB7XG4gICAgICAvLyBTaG91bGQgYWx3YXlzIGJlIHNldFxuICAgICAgcHVzaFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250ZXh0LCBmYWxzZSk7XG4gICAgfVxuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBzdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUXVldWUsIG51bGwsIG51bGwsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChwcmV2U3RhdGUgPT09IHN0YXRlKSB7XG4gICAgICAgIC8vIElmIHRoZSBzdGF0ZSBpcyB0aGUgc2FtZSBhcyBiZWZvcmUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB3ZSBoYWRcbiAgICAgICAgLy8gbm8gd29yayB0aGF0IGV4cGlyZXMgYXQgdGhpcyB0aW1lLlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudDtcbiAgICAgIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgaWYgKChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpICYmIHJvb3QuaHlkcmF0ZSAmJiBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBjdXJyZW50IGNoaWxkcmVuIHRoaXMgbWlnaHQgYmUgdGhlIGZpcnN0IHBhc3MuXG4gICAgICAgIC8vIFdlIGFsd2F5cyB0cnkgdG8gaHlkcmF0ZS4gSWYgdGhpcyBpc24ndCBhIGh5ZHJhdGlvbiBwYXNzIHRoZXJlIHdvbid0XG4gICAgICAgIC8vIGJlIGFueSBjaGlsZHJlbiB0byBoeWRyYXRlIHdoaWNoIGlzIGVmZmVjdGl2ZWx5IHRoZSBzYW1lIHRoaW5nIGFzXG4gICAgICAgIC8vIG5vdCBoeWRyYXRpbmcuXG5cbiAgICAgICAgLy8gVGhpcyBpcyBhIGJpdCBvZiBhIGhhY2suIFdlIHRyYWNrIHRoZSBob3N0IHJvb3QgYXMgYSBwbGFjZW1lbnQgdG9cbiAgICAgICAgLy8ga25vdyB0aGF0IHdlJ3JlIGN1cnJlbnRseSBpbiBhIG1vdW50aW5nIHN0YXRlLiBUaGF0IHdheSBpc01vdW50ZWRcbiAgICAgICAgLy8gd29ya3MgYXMgZXhwZWN0ZWQuIFdlIG11c3QgcmVzZXQgdGhpcyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcblxuICAgICAgICAvLyBFbnN1cmUgdGhhdCBjaGlsZHJlbiBtb3VudCBpbnRvIHRoaXMgcm9vdCB3aXRob3V0IHRyYWNraW5nXG4gICAgICAgIC8vIHNpZGUtZWZmZWN0cy4gVGhpcyBlbnN1cmVzIHRoYXQgd2UgZG9uJ3Qgc3RvcmUgUGxhY2VtZW50IGVmZmVjdHMgb25cbiAgICAgICAgLy8gbm9kZXMgdGhhdCB3aWxsIGJlIGh5ZHJhdGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgZWxlbWVudCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlIHJlc2V0IGh5ZHJhdGlvbiBzdGF0ZSBpbiBjYXNlIHdlIGFib3J0ZWQgYW5kIHJlc3VtZWQgYW5vdGhlclxuICAgICAgICAvLyByb290LlxuICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgc3RhdGUpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gdXBkYXRlIHF1ZXVlLCB0aGF0J3MgYSBiYWlsb3V0IGJlY2F1c2UgdGhlIHJvb3QgaGFzIG5vIHByb3BzLlxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IG1lbW9pemVkUHJvcHM7XG4gICAgICAhKG5leHRQcm9wcyAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIH1cbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG5cbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICAgIGlmIChpc0RpcmVjdFRleHRDaGlsZCkge1xuICAgICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAgIC8vIHRoaXMgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQgdGhhdCBhbHNvIGhhdmUgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgICAgLy8gYXZvaWRzIGFsbG9jYXRpbmcgYW5vdGhlciBIb3N0VGV4dCBmaWJlciBhbmQgdHJhdmVyc2luZyBpdC5cbiAgICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChwcmV2UHJvcHMgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgICAgLy8gSWYgd2UncmUgc3dpdGNoaW5nIGZyb20gYSBkaXJlY3QgdGV4dCBjaGlsZCB0byBhIG5vcm1hbCBjaGlsZCwgb3IgdG9cbiAgICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ29udGVudFJlc2V0O1xuICAgIH1cblxuICAgIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gQ2hlY2sgdGhlIGhvc3QgY29uZmlnIHRvIHNlZSBpZiB0aGUgY2hpbGRyZW4gYXJlIG9mZnNjcmVlbi9oaWRkZW4uXG4gICAgaWYgKHJlbmRlckV4cGlyYXRpb25UaW1lICE9PSBOZXZlciAmJiAhdXNlU3luY1NjaGVkdWxpbmcgJiYgc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSh0eXBlLCBuZXh0UHJvcHMpKSB7XG4gICAgICAvLyBEb3duLXByaW9yaXRpemUgdGhlIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPSBOZXZlcjtcbiAgICAgIC8vIEJhaWxvdXQgYW5kIGNvbWUgYmFjayB0byB0aGlzIGZpYmVyIGxhdGVyLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAobmV4dFByb3BzID09PSBudWxsKSB7XG4gICAgICBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH1cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gICAgLy8gaW1tZWRpYXRlbHkgYWZ0ZXIuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgIShjdXJyZW50ID09PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBuZXZlciBoYXZlIG1vdW50ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgdmFyIGZuID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgdmFyIHZhbHVlO1xuXG4gICAge1xuICAgICAgaWYgKGZuLnByb3RvdHlwZSAmJiB0eXBlb2YgZm4ucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCBcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgIHZhbHVlID0gZm4ocHJvcHMsIGNvbnRleHQpO1xuICAgIH1cbiAgICAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGNsYXNzIGluc3RhbmNlXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAgIC8vIER1cmluZyBtb3VudGluZyB3ZSBkb24ndCBrbm93IHRoZSBjaGlsZCBjb250ZXh0IHlldCBhcyB0aGUgaW5zdGFuY2UgZG9lc24ndCBleGlzdC5cbiAgICAgIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cbiAgICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBhZG9wdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0cnVlLCBoYXNDb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUHJvY2VlZCB1bmRlciB0aGUgYXNzdW1wdGlvbiB0aGF0IHRoaXMgaXMgYSBmdW5jdGlvbmFsIGNvbXBvbmVudFxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25hbENvbXBvbmVudDtcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKENvbXBvbmVudCkge1xuICAgICAgICAgIHdhcm5pbmcoIUNvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgJyVzKC4uLik6IGNoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb25hbCBjb21wb25lbnQuJywgQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IENvbXBvbmVudC5uYW1lIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgICB2YXIgb3duZXJOYW1lID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWUoKTtcbiAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICBpbmZvICs9ICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHdhcm5pbmdLZXkgPSBvd25lck5hbWUgfHwgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSUQgfHwgJyc7XG4gICAgICAgICAgdmFyIGRlYnVnU291cmNlID0gd29ya0luUHJvZ3Jlc3MuX2RlYnVnU291cmNlO1xuICAgICAgICAgIGlmIChkZWJ1Z1NvdXJjZSkge1xuICAgICAgICAgICAgd2FybmluZ0tleSA9IGRlYnVnU291cmNlLmZpbGVOYW1lICsgJzonICsgZGVidWdTb3VyY2UubGluZU51bWJlcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF3YXJuZWRBYm91dFN0YXRlbGVzc1JlZnNbd2FybmluZ0tleV0pIHtcbiAgICAgICAgICAgIHdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4lcyVzJywgaW5mbywgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHZhbHVlKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgcHJvcHMpO1xuICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENhbGwgPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENhbGwgPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2FsbCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENhbGwgPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENhbGwpIHtcbiAgICAgIG5leHRDYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIC8vIFRPRE86IFdoZW4gYmFpbGluZyBvdXQsIHdlIG1pZ2h0IG5lZWQgdG8gcmV0dXJuIHRoZSBzdGF0ZU5vZGUgaW5zdGVhZFxuICAgICAgLy8gb2YgdGhlIGNoaWxkLiBUbyBjaGVjayBpdCBmb3Igd29yay5cbiAgICAgIC8vIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dENhbGwuY2hpbGRyZW47XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGEgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgYnV0IHVzaW5nXG4gICAgLy8gc3RhdGVOb2RlIHRvIHN0b3JlIHRoZSBjaGlsZC5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbW91bnRDaGlsZEZpYmVyc0luUGxhY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LmNoaWxkID09PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG5cbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDYWxsKTtcbiAgICAvLyBUaGlzIGRvZXNuJ3QgdGFrZSBhcmJpdHJhcnkgdGltZSBzbyB3ZSBjb3VsZCBzeW5jaHJvbm91c2x5IGp1c3QgYmVnaW5cbiAgICAvLyBlYWdlcmx5IGRvIHRoZSB3b3JrIG9mIHdvcmtJblByb2dyZXNzLmNoaWxkIGFzIGFuIG9wdGltaXphdGlvbi5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2hpbGRyZW4gPSBjdXJyZW50ICYmIGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgIShuZXh0Q2hpbGRyZW4gIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBzaG91bGQgYWx3YXlzIGhhdmUgcGVuZGluZyBvciBjdXJyZW50IHByb3BzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPT09IG5leHRDaGlsZHJlbikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgICAgLy8gZmxvdyBkb2Vzbid0IGRvIGR1cmluZyBtb3VudC4gVGhpcyBkb2Vzbid0IGhhcHBlbiBhdCB0aGUgcm9vdCBiZWNhdXNlXG4gICAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICB9XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgLypcbiAgZnVuY3Rpb24gcmV1c2VDaGlsZHJlbkVmZmVjdHMocmV0dXJuRmliZXIgOiBGaWJlciwgZmlyc3RDaGlsZCA6IEZpYmVyKSB7XG4gICAgbGV0IGNoaWxkID0gZmlyc3RDaGlsZDtcbiAgICBkbyB7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgZmlyc3QgYW5kIGxhc3QgZWZmZWN0IG9mIHRoZSBwYXJlbnQgY29ycmVzcG9uZHNcbiAgICAgIC8vIHRvIHRoZSBjaGlsZHJlbidzIGZpcnN0IGFuZCBsYXN0IGVmZmVjdC5cbiAgICAgIGlmICghcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgIH1cbiAgICAgIGlmIChjaGlsZC5sYXN0RWZmZWN0KSB7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0KSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGQuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkLmxhc3RFZmZlY3Q7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hpbGQgPSBjaGlsZC5zaWJsaW5nKTtcbiAgfVxuICAqL1xuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBjYW5jZWxXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgLy8gVE9ETzogV2Ugc2hvdWxkIGlkZWFsbHkgYmUgYWJsZSB0byBiYWlsIG91dCBlYXJseSBpZiB0aGUgY2hpbGRyZW4gaGF2ZSBub1xuICAgIC8vIG1vcmUgd29yayB0byBkby4gSG93ZXZlciwgc2luY2Ugd2UgZG9uJ3QgaGF2ZSBhIHNlcGFyYXRpb24gb2YgdGhpc1xuICAgIC8vIEZpYmVyJ3MgcHJpb3JpdHkgYW5kIGl0cyBjaGlsZHJlbiB5ZXQgLSB3ZSBkb24ndCBrbm93IHdpdGhvdXQgZG9pbmcgbG90c1xuICAgIC8vIG9mIHRoZSBzYW1lIHdvcmsgd2UgZG8gYW55d2F5LiBPbmNlIHdlIGhhdmUgdGhhdCBzZXBhcmF0aW9uIHdlIGNhbiBqdXN0XG4gICAgLy8gYmFpbCBvdXQgaGVyZSBpZiB0aGUgY2hpbGRyZW4gaGFzIG5vIG1vcmUgd29yayBhdCB0aGlzIHByaW9yaXR5IGxldmVsLlxuICAgIC8vIGlmICh3b3JrSW5Qcm9ncmVzcy5wcmlvcml0eU9mQ2hpbGRyZW4gPD0gcHJpb3JpdHlMZXZlbCkge1xuICAgIC8vICAgLy8gSWYgdGhlcmUgYXJlIHNpZGUtZWZmZWN0cyBpbiB0aGVzZSBjaGlsZHJlbiB0aGF0IGhhdmUgbm90IHlldCBiZWVuXG4gICAgLy8gICAvLyBjb21taXR0ZWQgd2UgbmVlZCB0byBlbnN1cmUgdGhhdCB0aGV5IGdldCBwcm9wZXJseSB0cmFuc2ZlcnJlZCB1cC5cbiAgICAvLyAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQuY2hpbGQgIT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgLy8gICAgIHJldXNlQ2hpbGRyZW5FZmZlY3RzKHdvcmtJblByb2dyZXNzLCBjaGlsZCk7XG4gICAgLy8gICB9XG4gICAgLy8gICByZXR1cm4gbnVsbDtcbiAgICAvLyB9XG5cbiAgICBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBIYW5kbGUgSG9zdENvbXBvbmVudCB0YWdzIGhlcmUgYXMgd2VsbCBhbmQgY2FsbCBwdXNoSG9zdENvbnRleHQoKT9cbiAgICAvLyBTZWUgUFIgODU5MCBkaXNjdXNzaW9uIGZvciBjb250ZXh0XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIC8vIFRPRE86IFdoYXQgaWYgdGhpcyBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3M/XG4gICAgLy8gSG93IGNhbiB0aGF0IGhhcHBlbj8gSG93IGlzIHRoaXMgbm90IGJlaW5nIGNsb25lZD9cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIFRPRE86IERlbGV0ZSBtZW1vaXplUHJvcHMvU3RhdGUgYW5kIG1vdmUgdG8gcmVjb25jaWxlL2JhaWxvdXQgaW5zdGVhZFxuICBmdW5jdGlvbiBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcykge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXh0UHJvcHM7XG4gIH1cblxuICBmdW5jdGlvbiBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgLy8gRG9uJ3QgcmVzZXQgdGhlIHVwZGF0ZVF1ZXVlLCBpbiBjYXNlIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIFJlc2V0dGluZ1xuICAgIC8vIGlzIGhhbmRsZWQgYnkgcHJvY2Vzc1VwZGF0ZVF1ZXVlLlxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2FsbEhhbmRsZXJQaGFzZTpcbiAgICAgICAgLy8gVGhpcyBpcyBhIHJlc3RhcnQuIFJlc2V0IHRoZSB0YWcgdG8gdGhlIGluaXRpYWwgcGhhc2UuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAvLyBJbnRlbnRpb25hbGx5IGZhbGwgdGhyb3VnaCBzaW5jZSB0aGlzIGlzIG5vdyB0aGUgc2FtZS5cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgICAgICAvLyBBIHJldHVybiBjb21wb25lbnQgaXMganVzdCBhIHBsYWNlaG9sZGVyLCB3ZSBjYW4ganVzdCBydW4gdGhyb3VnaCB0aGVcbiAgICAgICAgLy8gbmV4dCBvbmUgaW1tZWRpYXRlbHkuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBjb250ZXh0IG1pc21hdGNoLlxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgYW4gZXJyb3IgZWZmZWN0IHNvIHdlIGNhbiBoYW5kbGUgdGhlIGVycm9yIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IEVycjtcblxuICAgIC8vIFRoaXMgaXMgYSB3ZWlyZCBjYXNlIHdoZXJlIHdlIGRvIFwicmVzdW1lXCIgd29yayDigJQgd29yayB0aGF0IGZhaWxlZCBvblxuICAgIC8vIG91ciBmaXJzdCBhdHRlbXB0LiBCZWNhdXNlIHdlIG5vIGxvbmdlciBoYXZlIGEgbm90aW9uIG9mIFwicHJvZ3Jlc3NlZFxuICAgIC8vIGRlbGV0aW9ucyxcIiByZXNldCB0aGUgY2hpbGQgdG8gdGhlIGN1cnJlbnQgY2hpbGQgdG8gbWFrZSBzdXJlIHdlIGRlbGV0ZVxuICAgIC8vIGl0IGFnYWluLiBUT0RPOiBGaW5kIGEgYmV0dGVyIHdheSB0byBoYW5kbGUgdGhpcywgcGVyaGFwcyBkdXJpbmcgYSBtb3JlXG4gICAgLy8gZ2VuZXJhbCBvdmVyaGF1bCBvZiBlcnJvciBoYW5kbGluZy5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uTG93UHJpb3JpdHkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIElmIHdlIGRvbid0IGJhaWwgb3V0LCB3ZSdyZSBnb2luZyBiZSByZWNvbXB1dGluZyBvdXIgY2hpbGRyZW4gc28gd2UgbmVlZFxuICAgIC8vIHRvIGRyb3Agb3VyIGVmZmVjdCBsaXN0LlxuICAgIHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0ID0gbnVsbDtcblxuICAgIC8vIFVubW91bnQgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYXMgaWYgdGhlIGNvbXBvbmVudCByZW5kZXJlZCBudWxsXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gaW5zdGFuY2UucHJvcHM7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZWdpbldvcms6IGJlZ2luV29yayxcbiAgICBiZWdpbkZhaWxlZFdvcms6IGJlZ2luRmFpbGVkV29ya1xuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJDb21wbGV0ZVdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCkge1xuICB2YXIgY3JlYXRlSW5zdGFuY2UgPSBjb25maWcuY3JlYXRlSW5zdGFuY2UsXG4gICAgICBjcmVhdGVUZXh0SW5zdGFuY2UgPSBjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlLFxuICAgICAgYXBwZW5kSW5pdGlhbENoaWxkID0gY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZCxcbiAgICAgIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuLFxuICAgICAgcHJlcGFyZVVwZGF0ZSA9IGNvbmZpZy5wcmVwYXJlVXBkYXRlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcbiAgdmFyIGdldFJvb3RIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQuZ2V0Um9vdEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgZ2V0SG9zdENvbnRleHQgPSBob3N0Q29udGV4dC5nZXRIb3N0Q29udGV4dCxcbiAgICAgIHBvcEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5wb3BIb3N0Q29udGFpbmVyO1xuICB2YXIgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSA9IGh5ZHJhdGlvbkNvbnRleHQucHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5wb3BIeWRyYXRpb25TdGF0ZTtcblxuXG4gIGZ1bmN0aW9uIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gICAgLy8gYW4gVXBkYXRlQW5kUGxhY2VtZW50LlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBtYXJrUmVmKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFJlZjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGVuZEFsbFJldHVybnMocmV0dXJucywgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICBpZiAobm9kZSkge1xuICAgICAgbm9kZVsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQSBjYWxsIGNhbm5vdCBoYXZlIGhvc3QgY29tcG9uZW50IGNoaWxkcmVuLicpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gUmV0dXJuQ29tcG9uZW50KSB7XG4gICAgICAgIHJldHVybnMucHVzaChub2RlLnR5cGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY2FsbCA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgIWNhbGwgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgYmUgcmVzb2x2ZWQgYnkgbm93LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgLy8gRmlyc3Qgc3RlcCBvZiB0aGUgY2FsbCBoYXMgY29tcGxldGVkLiBOb3cgd2UgbmVlZCB0byBkbyB0aGUgc2Vjb25kLlxuICAgIC8vIFRPRE86IEl0IHdvdWxkIGJlIG5pY2UgdG8gaGF2ZSBhIG11bHRpIHN0YWdlIGNhbGwgcmVwcmVzZW50ZWQgYnkgYVxuICAgIC8vIHNpbmdsZSBjb21wb25lbnQsIG9yIGF0IGxlYXN0IHRhaWwgY2FsbCBvcHRpbWl6ZSBuZXN0ZWQgb25lcy4gQ3VycmVudGx5XG4gICAgLy8gdGhhdCByZXF1aXJlcyBhZGRpdGlvbmFsIGZpZWxkcyB0aGF0IHdlIGRvbid0IHdhbnQgdG8gYWRkIHRvIHRoZSBmaWJlci5cbiAgICAvLyBTbyB0aGlzIHJlcXVpcmVzIG5lc3RlZCBoYW5kbGVycy5cbiAgICAvLyBOb3RlOiBUaGlzIGRvZXNuJ3QgbXV0YXRlIHRoZSBhbHRlcm5hdGUgbm9kZS4gSSBkb24ndCB0aGluayBpdCBuZWVkcyB0b1xuICAgIC8vIHNpbmNlIHRoaXMgc3RhZ2UgaXMgcmVzZXQgZm9yIGV2ZXJ5IHBhc3MuXG4gICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbEhhbmRsZXJQaGFzZTtcblxuICAgIC8vIEJ1aWxkIHVwIHRoZSByZXR1cm5zLlxuICAgIC8vIFRPRE86IENvbXBhcmUgdGhpcyB0byBhIGdlbmVyYXRvciBvciBvcGFxdWUgaGVscGVycyBsaWtlIENoaWxkcmVuLlxuICAgIHZhciByZXR1cm5zID0gW107XG4gICAgYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGZuID0gY2FsbC5oYW5kbGVyO1xuICAgIHZhciBwcm9wcyA9IGNhbGwucHJvcHM7XG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IGZuKHByb3BzLCByZXR1cm5zKTtcblxuICAgIHZhciBjdXJyZW50Rmlyc3RDaGlsZCA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50LmNoaWxkIDogbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvcnRhbCBjaGlsZCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlSG9zdENvbnRhaW5lciA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RDb21wb25lbnQgPSB2b2lkIDA7XG4gIHZhciB1cGRhdGVIb3N0VGV4dCA9IHZvaWQgMDtcbiAgaWYgKG11dGF0aW9uKSB7XG4gICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlcikge1xuICAgICAgLy8gTXV0YXRpb24gbW9kZVxuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAgICAgLy8gSWYgdGhlIHVwZGF0ZSBwYXlsb2FkIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIGEgY2hhbmdlIG9yIGlmIHRoZXJlXG4gICAgICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaXMgZG9uZSBpbiBjb21taXRXb3JrLlxuICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHRleHQgZGlmZmVycywgbWFyayBpdCBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpbiBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ011dGF0aW5nIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBQZXJzaXN0ZW50IGhvc3QgdHJlZSBtb2RlXG4gICAgICB2YXIgY2xvbmVJbnN0YW5jZSA9IHBlcnNpc3RlbmNlLmNsb25lSW5zdGFuY2UsXG4gICAgICAgICAgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5jcmVhdGVDb250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSBwZXJzaXN0ZW5jZS5hcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQsXG4gICAgICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG5cbiAgICAgIC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG4gICAgICB2YXIgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciA9IGZ1bmN0aW9uIChjb250YWluZXJDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAgICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkKSB7XG4gICAgICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IHBvcnRhbE9yUm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lcik7XG4gICAgICAgICAgaWYgKGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVyLCBuZXdDaGlsZFNldCkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7XG4gICAgICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhlIGNvbnRhaW5lciB0byBzd2FwIG91dCB0aGUgY29udGFpbmVyLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIGVmZmVjdHMgYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm9kZSwgdGhlbiBub25lIG9mIG91ciBjaGlsZHJlbiBoYWQgYW55IHVwZGF0ZXMuXG4gICAgICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cbiAgICAgICAgdmFyIGNoaWxkcmVuVW5jaGFuZ2VkID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPT09IG51bGw7XG4gICAgICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgaWYgKGNoaWxkcmVuVW5jaGFuZ2VkICYmIHVwZGF0ZVBheWxvYWQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciByZWN5Y2xhYmxlSW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld0luc3RhbmNlID0gY2xvbmVJbnN0YW5jZShjdXJyZW50SW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgd29ya0luUHJvZ3Jlc3MsIGNoaWxkcmVuVW5jaGFuZ2VkLCByZWN5Y2xhYmxlSW5zdGFuY2UpO1xuICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkpIHtcbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcbiAgICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBvdGhlciBlZmZlY3RzIGluIHRoaXMgdHJlZSwgd2UgbmVlZCB0byBmbGFnIHRoaXMgbm9kZSBhcyBoYXZpbmcgb25lLlxuICAgICAgICAgICAgLy8gRXZlbiB0aG91Z2ggd2UncmUgbm90IGdvaW5nIHRvIHVzZSBpdCBmb3IgYW55dGhpbmcuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgcGFyZW50cyB3b24ndCBrbm93IHRoYXQgdGhlcmUgYXJlIG5ldyBjaGlsZHJlbiB0byBwcm9wYWdhdGUgdXB3YXJkcy5cbiAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihuZXdJbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIE5vIGhvc3Qgb3BlcmF0aW9uc1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lciA9IGZ1bmN0aW9uICh3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdENvbXBvbmVudCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICAgIHVwZGF0ZUhvc3RUZXh0ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ05vb3AgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gR2V0IHRoZSBsYXRlc3QgcHJvcHMuXG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXdQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgIT09IE5ldmVyIHx8IHJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gUmVzZXQgdGhlIHBlbmRpbmcgcHJvcHMsIHVubGVzcyB0aGlzIHdhcyBhIGRvd24tcHJpb3JpdGl6YXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGFyZSBsZWF2aW5nIHRoaXMgc3VidHJlZSwgc28gcG9wIGNvbnRleHQgaWYgYW55LlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBwb3BUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciBmaWJlclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgICBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGh5ZHJhdGVkLCBwb3Agc28gdGhhdCB3ZSBjYW4gZGVsZXRlIGFueSByZW1haW5pbmcgY2hpbGRyZW5cbiAgICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICAgIHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIC8vIFRoaXMgcmVzZXRzIHRoZSBoYWNreSBzdGF0ZSB0byBmaXggaXNNb3VudGVkIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAgICAgLy8gVE9ETzogRGVsZXRlIHRoaXMgd2hlbiB3ZSBkZWxldGUgaXNNb3VudGVkIGFuZCBmaW5kRE9NTm9kZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBnZXQgdXBkYXRlZCBiZWNhdXNlIG9uZSBvZiBvdXIgY2hpbGRyZW4gdXBkYXRlZCwgd2UgZG9uJ3RcbiAgICAgICAgICAgIC8vIGhhdmUgbmV3UHJvcHMgc28gd2UnbGwgaGF2ZSB0byByZXVzZSB0aGVtLlxuICAgICAgICAgICAgLy8gVE9ETzogU3BsaXQgdGhlIHVwZGF0ZSBBUEkgYXMgc2VwYXJhdGUgZm9yIHRoZSBwcm9wcyB2cy4gY2hpbGRyZW4uXG4gICAgICAgICAgICAvLyBFdmVuIGJldHRlciB3b3VsZCBiZSBpZiBjaGlsZHJlbiB3ZXJlbid0IHNwZWNpYWwgY2FzZWQgYXQgYWxsIHRoby5cbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZVBheWxvYWQgPSBwcmVwYXJlVXBkYXRlKGluc3RhbmNlLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudC5yZWYgIT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgICAvLyBvciBjb21wbGV0ZVdvcmsgZGVwZW5kaW5nIG9uIHdlIHdhbnQgdG8gYWRkIHRoZW4gdG9wLT5kb3duIG9yXG4gICAgICAgICAgICAvLyBib3R0b20tPnVwLiBUb3AtPmRvd24gaXMgZmFzdGVyIGluIElFMTEuXG4gICAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgY2hhbmdlcyB0byB0aGUgaHlkcmF0ZWQgbm9kZSBuZWVkcyB0byBiZSBhcHBsaWVkIGF0IHRoZVxuICAgICAgICAgICAgICAgIC8vIGNvbW1pdC1waGFzZSB3ZSBtYXJrIHRoaXMgYXMgc3VjaC5cbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IGNyZWF0ZUluc3RhbmNlKHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UsIHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICAvLyBDZXJ0YWluIHJlbmRlcmVycyByZXF1aXJlIGNvbW1pdC10aW1lIGVmZmVjdHMgZm9yIGluaXRpYWwgbW91bnQuXG4gICAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuICAgICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnJlZiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIHJlZiBvbiBhIGhvc3Qgbm9kZSB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgbWFya1JlZih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcbiAgICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAhKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdXZSBtdXN0IGhhdmUgbmV3IHByb3BzIGZvciBuZXcgbW91bnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgICAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgaWYgKF93YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICBpZiAocHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0Miwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW92ZUNhbGxUb0hhbmRsZXJQaGFzZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBSZXNldCB0aGUgdGFnIHRvIG5vdyBiZSBhIGZpcnN0IHBoYXNlIGNhbGwuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENhbGxDb21wb25lbnQ7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIERvZXMgbm90aGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEZyYWdtZW50OlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIC8vIEVycm9yIGNhc2VzXG4gICAgICBjYXNlIEluZGV0ZXJtaW5hdGVDb21wb25lbnQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0FuIGluZGV0ZXJtaW5hdGUgY29tcG9uZW50IHNob3VsZCBoYXZlIGJlY29tZSBkZXRlcm1pbmF0ZSBiZWZvcmUgY29tcGxldGluZy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5rbm93biB1bml0IG9mIHdvcmsgdGFnLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcGxldGVXb3JrOiBjb21wbGV0ZVdvcmtcbiAgfTtcbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5oYXNDYXVnaHRFcnJvcjtcbnZhciBjbGVhckNhdWdodEVycm9yJDEgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG52YXIgUmVhY3RGaWJlckNvbW1pdFdvcmsgPSBmdW5jdGlvbiAoY29uZmlnLCBjYXB0dXJlRXJyb3IpIHtcbiAgdmFyIGdldFB1YmxpY0luc3RhbmNlID0gY29uZmlnLmdldFB1YmxpY0luc3RhbmNlLFxuICAgICAgbXV0YXRpb24gPSBjb25maWcubXV0YXRpb24sXG4gICAgICBwZXJzaXN0ZW5jZSA9IGNvbmZpZy5wZXJzaXN0ZW5jZTtcblxuXG4gIHZhciBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIgPSBmdW5jdGlvbiAoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgICBzdGFydFBoYXNlVGltZXIoY3VycmVudCwgJ2NvbXBvbmVudFdpbGxVbm1vdW50Jyk7XG4gICAgaW5zdGFuY2UucHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuICB9O1xuXG4gIC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG4gIGZ1bmN0aW9uIHNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQyKG51bGwsIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciwgbnVsbCwgY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICB2YXIgdW5tb3VudEVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCB1bm1vdW50RXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50KSB7XG4gICAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgcmVmLCBudWxsLCBudWxsKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yJDEoKSkge1xuICAgICAgICAgIHZhciByZWZFcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IkMSgpO1xuICAgICAgICAgIGNhcHR1cmVFcnJvcihjdXJyZW50LCByZWZFcnJvcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN0YXJ0UGhhc2VUaW1lcihmaW5pc2hlZFdvcmssICdjb21wb25lbnREaWRNb3VudCcpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZFVwZGF0ZScpO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5wcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5zdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF91cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAoX3VwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsID8gZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSA6IG51bGw7XG4gICAgICAgICAgICBjb21taXRDYWxsYmFja3MoX3VwZGF0ZVF1ZXVlLCBfaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgIC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgbWF5IHNjaGVkdWxlIGF1dG8tZm9jdXMgZm9yIGlucHV0cyBhbmQgZm9ybSBjb250cm9scykuXG4gICAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZpbmlzaGVkV29yay5lZmZlY3RUYWcgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIGNvbW1pdE1vdW50KF9pbnN0YW5jZTIsIHR5cGUsIHByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHRleHQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIG5vIGxpZmUtY3ljbGVzIGFzc29jaWF0ZWQgd2l0aCBwb3J0YWxzLlxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICAgIHZhciByZWYgPSBmaW5pc2hlZFdvcmsucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHJlZihnZXRQdWJsaWNJbnN0YW5jZShpbnN0YW5jZSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJlZihpbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgY3VycmVudFJlZiA9IGN1cnJlbnQucmVmO1xuICAgIGlmIChjdXJyZW50UmVmICE9PSBudWxsKSB7XG4gICAgICBjdXJyZW50UmVmKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVzZXItb3JpZ2luYXRpbmcgZXJyb3JzIChsaWZlY3ljbGVzIGFuZCByZWZzKSBzaG91bGQgbm90IGludGVycnVwdFxuICAvLyBkZWxldGlvbiwgc28gZG9uJ3QgbGV0IHRoZW0gdGhyb3cuIEhvc3Qtb3JpZ2luYXRpbmcgZXJyb3JzIHNob3VsZFxuICAvLyBpbnRlcnJ1cHQgZGVsZXRpb24sIHNvIGl0J3Mgb2theVxuICBmdW5jdGlvbiBjb21taXRVbm1vdW50KGN1cnJlbnQpIHtcbiAgICBpZiAodHlwZW9mIG9uQ29tbWl0VW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgb25Db21taXRVbm1vdW50KGN1cnJlbnQpO1xuICAgIH1cblxuICAgIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBjb21taXROZXN0ZWRVbm1vdW50cyhjdXJyZW50LnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUT0RPOiB0aGlzIGlzIHJlY3Vyc2l2ZS5cbiAgICAgICAgICAvLyBXZSBhcmUgYWxzbyBub3QgdXNpbmcgdGhpcyBwYXJlbnQgYmVjYXVzZVxuICAgICAgICAgIC8vIHRoZSBwb3J0YWwgd2lsbCBnZXQgcHVzaGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIgJiYgbXV0YXRpb24pIHtcbiAgICAgICAgICAgIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyICYmIHBlcnNpc3RlbmNlKSB7XG4gICAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0TmVzdGVkVW5tb3VudHMocm9vdCkge1xuICAgIC8vIFdoaWxlIHdlJ3JlIGluc2lkZSBhIHJlbW92ZWQgaG9zdCBub2RlIHdlIGRvbid0IHdhbnQgdG8gY2FsbFxuICAgIC8vIHJlbW92ZUNoaWxkIG9uIHRoZSBpbm5lciBub2RlcyBiZWNhdXNlIHRoZXkncmUgcmVtb3ZlZCBieSB0aGUgdG9wXG4gICAgLy8gY2FsbCBhbnl3YXkuIFdlIGFsc28gd2FudCB0byBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50IG9uIGFsbFxuICAgIC8vIGNvbXBvc2l0ZXMgYmVmb3JlIHRoaXMgaG9zdCBub2RlIGlzIHJlbW92ZWQgZnJvbSB0aGUgdHJlZS4gVGhlcmVmb3JlXG4gICAgdmFyIG5vZGUgPSByb290O1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB0aGV5IG1heSBjb250YWluIG1vcmUgY29tcG9zaXRlIG9yIGhvc3Qgbm9kZXMuXG4gICAgICAvLyBTa2lwIHBvcnRhbHMgYmVjYXVzZSBjb21taXRVbm1vdW50KCkgY3VycmVudGx5IHZpc2l0cyB0aGVtIHJlY3Vyc2l2ZWx5LlxuICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwgJiYgKFxuICAgICAgLy8gSWYgd2UgdXNlIG11dGF0aW9uIHdlIGRyaWxsIGRvd24gaW50byBwb3J0YWxzIHVzaW5nIGNvbW1pdFVubW91bnQgYWJvdmUuXG4gICAgICAvLyBJZiB3ZSBkb24ndCB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgaGVyZSBpbnN0ZWFkLlxuICAgICAgIW11dGF0aW9uIHx8IG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSByb290KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSByb290KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZGV0YWNoRmliZXIoY3VycmVudCkge1xuICAgIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVycyB0byBkaXNjb25uZWN0IGl0IGZyb20gdGhlIHRyZWUuIElkZWFsbHksIHdlXG4gICAgLy8gc2hvdWxkIGNsZWFyIHRoZSBjaGlsZCBwb2ludGVyIG9mIHRoZSBwYXJlbnQgYWx0ZXJuYXRlIHRvIGxldCB0aGlzXG4gICAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAgIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLiBUaGlzIGNoaWxkXG4gICAgLy8gaXRzZWxmIHdpbGwgYmUgR0M6ZWQgd2hlbiB0aGUgcGFyZW50IHVwZGF0ZXMgdGhlIG5leHQgdGltZS5cbiAgICBjdXJyZW50WydyZXR1cm4nXSA9IG51bGw7XG4gICAgY3VycmVudC5jaGlsZCA9IG51bGw7XG4gICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlKSB7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZS5jaGlsZCA9IG51bGw7XG4gICAgICBjdXJyZW50LmFsdGVybmF0ZVsncmV0dXJuJ10gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGlmICghbXV0YXRpb24pIHtcbiAgICB2YXIgY29tbWl0Q29udGFpbmVyID0gdm9pZCAwO1xuICAgIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgdmFyIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbiA9IHBlcnNpc3RlbmNlLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbixcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0O1xuXG4gICAgICB2YXIgZW1wdHlQb3J0YWxDb250YWluZXIgPSBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIGVtcHR5Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldChjb250YWluZXJJbmZvKTtcbiAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xuICAgICAgfTtcbiAgICAgIGNvbW1pdENvbnRhaW5lciA9IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm8sXG4gICAgICAgICAgICAgICAgICBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsT3JSb290LnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgfHwgZW5hYmxlTm9vcFJlY29uY2lsZXIpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXRQbGFjZW1lbnQ6IGZ1bmN0aW9uIChmaW5pc2hlZFdvcmspIHt9LFxuICAgICAgICBjb21taXREZWxldGlvbjogZnVuY3Rpb24gKGN1cnJlbnQpIHtcbiAgICAgICAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQpO1xuICAgICAgICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBjb21taXRXb3JrOiBmdW5jdGlvbiAoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgY29tbWl0Q29udGFpbmVyKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY29tbWl0TGlmZUN5Y2xlczogY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ1BlcnNpc3RlbnQgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuICB2YXIgY29tbWl0TW91bnQgPSBtdXRhdGlvbi5jb21taXRNb3VudCxcbiAgICAgIGNvbW1pdFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFVwZGF0ZSxcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQgPSBtdXRhdGlvbi5yZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0VGV4dFVwZGF0ZSA9IG11dGF0aW9uLmNvbW1pdFRleHRVcGRhdGUsXG4gICAgICBhcHBlbmRDaGlsZCA9IG11dGF0aW9uLmFwcGVuZENoaWxkLFxuICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciA9IG11dGF0aW9uLmFwcGVuZENoaWxkVG9Db250YWluZXIsXG4gICAgICBpbnNlcnRCZWZvcmUgPSBtdXRhdGlvbi5pbnNlcnRCZWZvcmUsXG4gICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9IG11dGF0aW9uLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuICAgICAgcmVtb3ZlQ2hpbGQgPSBtdXRhdGlvbi5yZW1vdmVDaGlsZCxcbiAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9IG11dGF0aW9uLnJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjtcblxuXG4gIGZ1bmN0aW9uIGdldEhvc3RQYXJlbnRGaWJlcihmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgICByZXR1cm4gZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QgfHwgZmliZXIudGFnID09PSBIb3N0UG9ydGFsO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byBzZWFyY2ggZm9yd2FyZCBpbnRvIHRoZSB0cmVlIHVudGlsIHdlIGZpbmQgYSBzaWJsaW5nIGhvc3RcbiAgICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55dGhpbmcsIGxldCdzIHRyeSB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGVbJ3JldHVybiddKSkge1xuICAgICAgICAgIC8vIElmIHdlIHBvcCBvdXQgb2YgdGhlIHJvb3Qgb3IgaGl0IHRoZSBwYXJlbnQgdGhlIGZpYmVyIHdlIGFyZSB0aGVcbiAgICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdENvbXBvbmVudCAmJiBub2RlLnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICAgIGlmIChub2RlLmVmZmVjdFRhZyAmIFBsYWNlbWVudCkge1xuICAgICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgICAvLyBXZSBhbHNvIHNraXAgcG9ydGFscyBiZWNhdXNlIHRoZXkgYXJlIG5vdCBwYXJ0IG9mIHRoaXMgaG9zdCB0cmVlLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cbiAgICAgIGlmICghKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSkge1xuICAgICAgICAvLyBGb3VuZCBpdCFcbiAgICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuICAgIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuICAgIHZhciBwYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGlzQ29udGFpbmVyID0gdm9pZCAwO1xuICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgaXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgIGlzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgICBpZiAocGFyZW50RmliZXIuZWZmZWN0VGFnICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICByZXNldFRleHRDb250ZW50KHBhcmVudCk7XG4gICAgICAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuICAgICAgcGFyZW50RmliZXIuZWZmZWN0VGFnICY9IH5Db250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgdmFyIGJlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IGZpbmlzaGVkV29yaztcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoYmVmb3JlKSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBub2RlLnN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGlzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcHBlbmRDaGlsZChwYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gSWYgdGhlIGluc2VydGlvbiBpdHNlbGYgaXMgYSBwb3J0YWwsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAvLyBkb3duIGl0cyBjaGlsZHJlbi4gSW5zdGVhZCwgd2UnbGwgZ2V0IGluc2VydGlvbnMgZnJvbSBlYWNoIGNoaWxkIGluXG4gICAgICAgIC8vIHRoZSBwb3J0YWwgZGlyZWN0bHkuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICB2YXIgbm9kZSA9IGN1cnJlbnQ7XG5cbiAgICAvLyBFYWNoIGl0ZXJhdGlvbiwgY3VycmVudFBhcmVudCBpcyBwb3B1bGF0ZWQgd2l0aCBub2RlJ3MgaG9zdCBwYXJlbnQgaWYgbm90XG4gICAgLy8gY3VycmVudFBhcmVudElzVmFsaWQuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnQgPSB2b2lkIDA7XG4gICAgdmFyIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHZvaWQgMDtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAoIWN1cnJlbnRQYXJlbnRJc1ZhbGlkKSB7XG4gICAgICAgIHZhciBwYXJlbnQgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgZmluZFBhcmVudDogd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAhKHBhcmVudCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBjdXJyZW50UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFBhcmVudElzVmFsaWQgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKG5vZGUpO1xuICAgICAgICAvLyBBZnRlciBhbGwgdGhlIGNoaWxkcmVuIGhhdmUgdW5tb3VudGVkLCBpdCBpcyBub3cgc2FmZSB0byByZW1vdmUgdGhlXG4gICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgaWYgKGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGQoY3VycmVudFBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERvbid0IHZpc2l0IGNoaWxkcmVuIGJlY2F1c2Ugd2UgYWxyZWFkeSB2aXNpdGVkIHRoZW0uXG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgIC8vIFdoZW4gd2UgZ28gaW50byBhIHBvcnRhbCwgaXQgYmVjb21lcyB0aGUgcGFyZW50IHRvIHJlbW92ZSBmcm9tLlxuICAgICAgICAvLyBXZSB3aWxsIHJlYXNzaWduIGl0IGJhY2sgd2hlbiB3ZSBwb3AgdGhlIHBvcnRhbCBvbiB0aGUgd2F5IHVwLlxuICAgICAgICBjdXJyZW50UGFyZW50ID0gbm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSBwb3J0YWxzIG1pZ2h0IGNvbnRhaW4gaG9zdCBjb21wb25lbnRzLlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29tbWl0VW5tb3VudChub2RlKTtcbiAgICAgICAgLy8gVmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBtYXkgZmluZCBtb3JlIGhvc3QgY29tcG9uZW50cyBiZWxvdy5cbiAgICAgICAgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBjdXJyZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBvdXQgb2YgdGhlIHBvcnRhbCwgd2UgbmVlZCB0byByZXN0b3JlIHRoZSBwYXJlbnQuXG4gICAgICAgICAgLy8gU2luY2Ugd2UgZG9uJ3Qga2VlcCBhIHN0YWNrIG9mIHRoZW0sIHdlIHdpbGwgc2VhcmNoIGZvciBpdC5cbiAgICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uKGN1cnJlbnQpIHtcbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LlxuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgIGRldGFjaEZpYmVyKGN1cnJlbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0V29yayhjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKGluc3RhbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG4gICAgICAgICAgICAvLyBUT0RPOiBUeXBlIHRoZSB1cGRhdGVRdWV1ZSB0byBiZSBzcGVjaWZpYyB0byBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb21taXRVcGRhdGUoaW5zdGFuY2UsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgIShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG4gICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UmVzZXRUZXh0Q29udGVudChjdXJyZW50KSB7XG4gICAgcmVzZXRUZXh0Q29udGVudChjdXJyZW50LnN0YXRlTm9kZSk7XG4gIH1cblxuICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQ6IGNvbW1pdFJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRQbGFjZW1lbnQ6IGNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uOiBjb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcms6IGNvbW1pdFdvcmssXG4gICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmOiBjb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWY6IGNvbW1pdERldGFjaFJlZlxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgfVxufTtcblxudmFyIE5PX0NPTlRFWFQgPSB7fTtcblxudmFyIFJlYWN0RmliZXJIb3N0Q29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIGdldENoaWxkSG9zdENvbnRleHQgPSBjb25maWcuZ2V0Q2hpbGRIb3N0Q29udGV4dCxcbiAgICAgIGdldFJvb3RIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG5cblxuICB2YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuICB2YXIgY29udGV4dEZpYmVyU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcblxuICBmdW5jdGlvbiByZXF1aXJlZENvbnRleHQoYykge1xuICAgICEoYyAhPT0gTk9fQ09OVEVYVCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBob3N0IGNvbnRleHQgdG8gZXhpc3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcmV0dXJuIGM7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiByb290SW5zdGFuY2U7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAgIC8vIFB1c2ggY3VycmVudCByb290IGluc3RhbmNlIG9udG8gdGhlIHN0YWNrO1xuICAgIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gICAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpO1xuXG4gICAgdmFyIG5leHRSb290Q29udGV4dCA9IGdldFJvb3RIb3N0Q29udGV4dChuZXh0Um9vdEluc3RhbmNlKTtcblxuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dFJvb3RDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gICAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gICAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgdmFyIG5leHRDb250ZXh0ID0gZ2V0Q2hpbGRIb3N0Q29udGV4dChjb250ZXh0LCBmaWJlci50eXBlLCByb290SW5zdGFuY2UpO1xuXG4gICAgLy8gRG9uJ3QgcHVzaCB0aGlzIEZpYmVyJ3MgY29udGV4dCB1bmxlc3MgaXQncyB1bmlxdWUuXG4gICAgaWYgKGNvbnRleHQgPT09IG5leHRDb250ZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Q29udGV4dCwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRIb3N0Q29udGFpbmVyKCkge1xuICAgIGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgICByb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50ID0gTk9fQ09OVEVYVDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZ2V0SG9zdENvbnRleHQ6IGdldEhvc3RDb250ZXh0LFxuICAgIGdldFJvb3RIb3N0Q29udGFpbmVyOiBnZXRSb290SG9zdENvbnRhaW5lcixcbiAgICBwb3BIb3N0Q29udGFpbmVyOiBwb3BIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250ZXh0OiBwb3BIb3N0Q29udGV4dCxcbiAgICBwdXNoSG9zdENvbnRhaW5lcjogcHVzaEhvc3RDb250YWluZXIsXG4gICAgcHVzaEhvc3RDb250ZXh0OiBwdXNoSG9zdENvbnRleHQsXG4gICAgcmVzZXRIb3N0Q29udGFpbmVyOiByZXNldEhvc3RDb250YWluZXJcbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dCA9IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgdmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50LFxuICAgICAgaHlkcmF0aW9uID0gY29uZmlnLmh5ZHJhdGlvbjtcblxuICAvLyBJZiB0aGlzIGRvZXNuJ3QgaGF2ZSBoeWRyYXRpb24gbW9kZS5cblxuICBpZiAoIWh5ZHJhdGlvbikge1xuICAgIHJldHVybiB7XG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0sXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH0sXG4gICAgICBwb3BIeWRyYXRpb25TdGF0ZTogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgdmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5jYW5IeWRyYXRlSW5zdGFuY2UsXG4gICAgICBjYW5IeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcgPSBoeWRyYXRpb24uZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLFxuICAgICAgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSBoeWRyYXRpb24uZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQsXG4gICAgICBoeWRyYXRlSW5zdGFuY2UgPSBoeWRyYXRpb24uaHlkcmF0ZUluc3RhbmNlLFxuICAgICAgaHlkcmF0ZVRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RIeWRyYXRlSW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UsXG4gICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlO1xuXG4gIC8vIFRoZSBkZWVwZXN0IEZpYmVyIG9uIHRoZSBzdGFjayBpbnZvbHZlZCBpbiBhIGh5ZHJhdGlvbiBjb250ZXh0LlxuICAvLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG4gIHZhciBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIHZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChwYXJlbnRJbnN0YW5jZSk7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UocmV0dXJuRmliZXIsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UocmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8sIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZShyZXR1cm5GaWJlci50eXBlLCByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzLCByZXR1cm5GaWJlci5zdGF0ZU5vZGUsIGluc3RhbmNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uKCk7XG4gICAgY2hpbGRUb0RlbGV0ZS5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICBjaGlsZFRvRGVsZXRlWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIGNoaWxkVG9EZWxldGUuZWZmZWN0VGFnID0gRGVsZXRpb247XG5cbiAgICAvLyBUaGlzIG1pZ2h0IHNlZW0gbGlrZSBpdCBiZWxvbmdzIG9uIHByb2dyZXNzZWRGaXJzdERlbGV0aW9uLiBIb3dldmVyLFxuICAgIC8vIHRoZXNlIGNoaWxkcmVuIGFyZSBub3QgcGFydCBvZiB0aGUgcmVjb25jaWxpYXRpb24gbGlzdCBvZiBjaGlsZHJlbi5cbiAgICAvLyBFdmVuIGlmIHdlIGFib3J0IGFuZCByZXJlY29uY2lsZSB0aGUgY2hpbGRyZW4sIHRoYXQgd2lsbCB0cnkgdG8gaHlkcmF0ZVxuICAgIC8vIGFnYWluIGFuZCB0aGUgbm9kZXMgYXJlIHN0aWxsIGluIHRoZSBob3N0IHRyZWUgc28gdGhlc2Ugd2lsbCBiZVxuICAgIC8vIHJlY3JlYXRlZC5cbiAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UocmV0dXJuRmliZXIsIGZpYmVyKSB7XG4gICAgZmliZXIuZWZmZWN0VGFnIHw9IFBsYWNlbWVudDtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRDb250YWluZXIgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgICAgICAgICAgdmFyIHRleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnRUeXBlID0gcmV0dXJuRmliZXIudHlwZTtcbiAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgICAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdHlwZSwgX3Byb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgX3RleHQgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBfdGV4dCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbkh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHJldHVybiBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICByZXR1cm4gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgIGlmICghbmV4dEluc3RhbmNlKSB7XG4gICAgICAvLyBOb3RoaW5nIHRvIGh5ZHJhdGUuIE1ha2UgaXQgYW4gaW5zZXJ0aW9uLlxuICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2FuSHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgICAgLy8gSWYgd2UgY2FuJ3QgaHlkcmF0ZSB0aGlzIGluc3RhbmNlIGxldCdzIHRyeSB0aGUgbmV4dCBvbmUuXG4gICAgICAvLyBXZSB1c2UgdGhpcyBhcyBhIGhldXJpc3RpYy4gSXQncyBiYXNlZCBvbiBpbnR1aXRpb24gYW5kIG5vdCBkYXRhIHNvIGl0XG4gICAgICAvLyBtaWdodCBiZSBmbGF3ZWQgb3IgdW5uZWNlc3NhcnkuXG4gICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIGlmICghbmV4dEluc3RhbmNlIHx8ICFjYW5IeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICAgIGluc2VydE5vbkh5ZHJhdGVkSW5zdGFuY2UoaHlkcmF0aW9uUGFyZW50RmliZXIsIGZpYmVyKTtcbiAgICAgICAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gV2UgbWF0Y2hlZCB0aGUgbmV4dCBvbmUsIHdlJ2xsIG5vdyBhc3N1bWUgdGhhdCB0aGUgZmlyc3Qgb25lIHdhc1xuICAgICAgLy8gc3VwZXJmbHVvdXMgYW5kIHdlJ2xsIGRlbGV0ZSBpdC4gU2luY2Ugd2UgY2FuJ3QgZWFnZXJseSBkZWxldGUgaXRcbiAgICAgIC8vIHdlJ2xsIGhhdmUgdG8gc2NoZWR1bGUgYSBkZWxldGlvbi4gVG8gZG8gdGhhdCwgdGhpcyBub2RlIG5lZWRzIGEgZHVtbXlcbiAgICAgIC8vIGZpYmVyIGFzc29jaWF0ZWQgd2l0aCBpdC5cbiAgICAgIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSk7XG4gICAgfVxuICAgIGZpYmVyLnN0YXRlTm9kZSA9IG5leHRJbnN0YW5jZTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZChuZXh0SW5zdGFuY2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZShmaWJlciwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IGh5ZHJhdGVJbnN0YW5jZShpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgZmliZXIpO1xuICAgIC8vIFRPRE86IFR5cGUgdGhpcyBzcGVjaWZpYyB0byB0aGlzIHR5cGUgb2YgY29tcG9uZW50LlxuICAgIGZpYmVyLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUGF5bG9hZDtcbiAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAvLyBpcyBhIG5ldyByZWYgd2UgbWFyayB0aGlzIGFzIGFuIHVwZGF0ZS5cbiAgICBpZiAodXBkYXRlUGF5bG9hZCAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgIHZhciBzaG91bGRVcGRhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyKTtcbiAgICB7XG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gICAgICAgIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cbiAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG4gICAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEluc3RhbmNlID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICAgIHZhciBwYXJlbnQgPSBmaWJlclsncmV0dXJuJ107XG4gICAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCAmJiBwYXJlbnQudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIHBhcmVudC50YWcgIT09IEhvc3RSb290KSB7XG4gICAgICBwYXJlbnQgPSBwYXJlbnRbJ3JldHVybiddO1xuICAgIH1cbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IHBhcmVudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgICAgLy8gV2UncmUgZGVlcGVyIHRoYW4gdGhlIGN1cnJlbnQgaHlkcmF0aW9uIGNvbnRleHQsIGluc2lkZSBhbiBpbnNlcnRlZFxuICAgICAgLy8gdHJlZS5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgICAvLyBzaWJsaW5ncy5cbiAgICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uXG4gICAgLy8gVE9ETzogQmV0dGVyIGhldXJpc3RpYy5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHR5cGUgIT09ICdoZWFkJyAmJiB0eXBlICE9PSAnYm9keScgJiYgIXNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSB7XG4gICAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcbiAgICAgIHdoaWxlIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcobmV4dEluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRlckh5ZHJhdGlvblN0YXRlOiBlbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IHJlc2V0SHlkcmF0aW9uU3RhdGUsXG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlLFxuICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2U6IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBwb3BIeWRyYXRpb25TdGF0ZVxuICB9O1xufTtcblxuLy8gVGhpcyBsZXRzIHVzIGhvb2sgaW50byBGaWJlciB0byBkZWJ1ZyB3aGF0IGl0J3MgZG9pbmcuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvODAzMy5cbi8vIFRoaXMgaXMgbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEksIG5vdCBldmVuIGZvciBSZWFjdCBEZXZUb29scy5cbi8vIFlvdSBtYXkgb25seSBpbmplY3QgYSBkZWJ1Z1Rvb2wgaWYgeW91IHdvcmsgb24gUmVhY3QgRmliZXIgaXRzZWxmLlxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb24gPSB7XG4gIGRlYnVnVG9vbDogbnVsbFxufTtcblxudmFyIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSA9IFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb247XG5cbnZhciBkZWZhdWx0U2hvd0RpYWxvZyA9IGZ1bmN0aW9uIChjYXB0dXJlZEVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xufTtcblxudmFyIHNob3dEaWFsb2cgPSBkZWZhdWx0U2hvd0RpYWxvZztcblxuZnVuY3Rpb24gbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKSB7XG4gIHZhciBsb2dFcnJvciA9IHNob3dEaWFsb2coY2FwdHVyZWRFcnJvcik7XG5cbiAgLy8gQWxsb3cgaW5qZWN0ZWQgc2hvd0RpYWxvZygpIHRvIHByZXZlbnQgZGVmYXVsdCBjb25zb2xlLmVycm9yIGxvZ2dpbmcuXG4gIC8vIFRoaXMgZW5hYmxlcyByZW5kZXJlcnMgbGlrZSBSZWFjdE5hdGl2ZSB0byBiZXR0ZXIgbWFuYWdlIHJlZGJveCBiZWhhdmlvci5cbiAgaWYgKGxvZ0Vycm9yID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZCA9IGNhcHR1cmVkRXJyb3IuZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICB3aWxsUmV0cnkgPSBjYXB0dXJlZEVycm9yLndpbGxSZXRyeTtcblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDwnICsgY29tcG9uZW50TmFtZSArICc+IGNvbXBvbmVudDonIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzOic7XG5cbiAgICB2YXIgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLy8gZXJyb3JCb3VuZGFyeUZvdW5kIGNoZWNrIGlzIHN1ZmZpY2llbnQ7IGVycm9yQm91bmRhcnlOYW1lIGNoZWNrIGlzIHRvIHNhdGlzZnkgRmxvdy5cbiAgICBpZiAoZXJyb3JCb3VuZGFyeUZvdW5kICYmIGVycm9yQm91bmRhcnlOYW1lKSB7XG4gICAgICBpZiAod2lsbFJldHJ5KSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1JlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoICcgKyAoJ3VzaW5nIHRoZSBlcnJvciBib3VuZGFyeSB5b3UgcHJvdmlkZWQsICcgKyBlcnJvckJvdW5kYXJ5TmFtZSArICcuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdUaGlzIGVycm9yIHdhcyBpbml0aWFsbHkgaGFuZGxlZCBieSB0aGUgZXJyb3IgYm91bmRhcnkgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy5cXG4nICsgJ1JlY3JlYXRpbmcgdGhlIHRyZWUgZnJvbSBzY3JhdGNoIGZhaWxlZCBzbyBSZWFjdCB3aWxsIHVubW91bnQgdGhlIHRyZWUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnQ29uc2lkZXIgYWRkaW5nIGFuIGVycm9yIGJvdW5kYXJ5IHRvIHlvdXIgdHJlZSB0byBjdXN0b21pemUgZXJyb3IgaGFuZGxpbmcgYmVoYXZpb3IuXFxuJyArICdWaXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWVycm9yLWJvdW5kYXJpZXMgdG8gbGVhcm4gbW9yZSBhYm91dCBlcnJvciBib3VuZGFyaWVzLic7XG4gICAgfVxuICAgIHZhciBjb21iaW5lZE1lc3NhZ2UgPSAnJyArIGNvbXBvbmVudE5hbWVNZXNzYWdlICsgY29tcG9uZW50U3RhY2sgKyAnXFxuXFxuJyArICgnJyArIGVycm9yQm91bmRhcnlNZXNzYWdlKTtcblxuICAgIC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aXRoIGp1c3QgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAgICAvLyBXZSBkb24ndCBpbmNsdWRlIHRoZSBvcmlnaW5hbCBlcnJvciBtZXNzYWdlIGFuZCBKUyBzdGFjayBiZWNhdXNlIHRoZSBicm93c2VyXG4gICAgLy8gaGFzIGFscmVhZHkgcHJpbnRlZCBpdC4gRXZlbiBpZiB0aGUgYXBwbGljYXRpb24gc3dhbGxvd3MgdGhlIGVycm9yLCBpdCBpcyBzdGlsbFxuICAgIC8vIGRpc3BsYXllZCBieSB0aGUgYnJvd3NlciB0aGFua3MgdG8gdGhlIERFVi1vbmx5IGZha2UgZXZlbnQgdHJpY2sgaW4gUmVhY3RFcnJvclV0aWxzLlxuICAgIGNvbnNvbGUuZXJyb3IoY29tYmluZWRNZXNzYWdlKTtcbiAgfVxufVxuXG52YXIgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEgPSBSZWFjdEVycm9yVXRpbHMuaW52b2tlR3VhcmRlZENhbGxiYWNrO1xudmFyIGhhc0NhdWdodEVycm9yID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuY2xlYXJDYXVnaHRFcnJvcjtcblxuXG57XG4gIHZhciBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSBmYWxzZTtcbiAgdmFyIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbiAgdmFyIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvclVubW91bnRlZENvbXBvbmVudFtjb21wb25lbnROYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB3YXJuaW5nKGZhbHNlLCAnQ2FuIG9ubHkgdXBkYXRlIGEgbW91bnRlZCBvciBtb3VudGluZyAnICsgJ2NvbXBvbmVudC4gVGhpcyB1c3VhbGx5IG1lYW5zIHlvdSBjYWxsZWQgc2V0U3RhdGUsIHJlcGxhY2VTdGF0ZSwgJyArICdvciBmb3JjZVVwZGF0ZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LiBUaGlzIGlzIGEgbm8tb3AuXFxuXFxuUGxlYXNlICcgKyAnY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgfTtcblxuICB2YXIgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBzd2l0Y2ggKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UpIHtcbiAgICAgIGNhc2UgJ2dldENoaWxkQ29udGV4dCc6XG4gICAgICAgIGlmIChkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ3NldFN0YXRlKC4uLik6IENhbm5vdCBjYWxsIHNldFN0YXRlKCkgaW5zaWRlIGdldENoaWxkQ29udGV4dCgpJyk7XG4gICAgICAgIGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncmVuZGVyJzpcbiAgICAgICAgaWYgKGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnQ2Fubm90IHVwZGF0ZSBkdXJpbmcgYW4gZXhpc3Rpbmcgc3RhdGUgdHJhbnNpdGlvbiAoc3VjaCBhcyB3aXRoaW4gJyArIFwiYHJlbmRlcmAgb3IgYW5vdGhlciBjb21wb25lbnQncyBjb25zdHJ1Y3RvcikuIFJlbmRlciBtZXRob2RzIHNob3VsZCBcIiArICdiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyBjb25zdHJ1Y3RvciBzaWRlLWVmZmVjdHMgYXJlICcgKyAnYW4gYW50aS1wYXR0ZXJuLCBidXQgY2FuIGJlIG1vdmVkIHRvIGBjb21wb25lbnRXaWxsTW91bnRgLicpO1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24gPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH07XG59XG5cbnZhciBSZWFjdEZpYmVyU2NoZWR1bGVyID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgaG9zdENvbnRleHQgPSBSZWFjdEZpYmVySG9zdENvbnRleHQoY29uZmlnKTtcbiAgdmFyIGh5ZHJhdGlvbkNvbnRleHQgPSBSZWFjdEZpYmVySHlkcmF0aW9uQ29udGV4dChjb25maWcpO1xuICB2YXIgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXIsXG4gICAgICBwb3BIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250ZXh0LFxuICAgICAgcmVzZXRIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucmVzZXRIb3N0Q29udGFpbmVyO1xuXG4gIHZhciBfUmVhY3RGaWJlckJlZ2luV29yayA9IFJlYWN0RmliZXJCZWdpbldvcmsoY29uZmlnLCBob3N0Q29udGV4dCwgaHlkcmF0aW9uQ29udGV4dCwgc2NoZWR1bGVXb3JrLCBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKSxcbiAgICAgIGJlZ2luV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luV29yayxcbiAgICAgIGJlZ2luRmFpbGVkV29yayA9IF9SZWFjdEZpYmVyQmVnaW5Xb3JrLmJlZ2luRmFpbGVkV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21wbGV0ZVdvID0gUmVhY3RGaWJlckNvbXBsZXRlV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSxcbiAgICAgIGNvbXBsZXRlV29yayA9IF9SZWFjdEZpYmVyQ29tcGxldGVXby5jb21wbGV0ZVdvcms7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQ29tbWl0V29yayA9IFJlYWN0RmliZXJDb21taXRXb3JrKGNvbmZpZywgY2FwdHVyZUVycm9yKSxcbiAgICAgIGNvbW1pdFJlc2V0VGV4dENvbnRlbnQgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRQbGFjZW1lbnQsXG4gICAgICBjb21taXREZWxldGlvbiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZWxldGlvbixcbiAgICAgIGNvbW1pdFdvcmsgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXMgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0TGlmZUN5Y2xlcyxcbiAgICAgIGNvbW1pdEF0dGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRBdHRhY2hSZWYsXG4gICAgICBjb21taXREZXRhY2hSZWYgPSBfUmVhY3RGaWJlckNvbW1pdFdvcmsuY29tbWl0RGV0YWNoUmVmO1xuXG4gIHZhciBub3cgPSBjb25maWcubm93LFxuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrID0gY29uZmlnLnNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayxcbiAgICAgIHVzZVN5bmNTY2hlZHVsaW5nID0gY29uZmlnLnVzZVN5bmNTY2hlZHVsaW5nLFxuICAgICAgcHJlcGFyZUZvckNvbW1pdCA9IGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0LFxuICAgICAgcmVzZXRBZnRlckNvbW1pdCA9IGNvbmZpZy5yZXNldEFmdGVyQ29tbWl0O1xuXG4gIC8vIFJlcHJlc2VudHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtcy5cblxuICB2YXIgc3RhcnRUaW1lID0gbm93KCk7XG4gIHZhciBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUoMCk7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgZXhwaXJhdGlvbiB0aW1lIHRoYXQgaW5jb21pbmcgdXBkYXRlcyBzaG91bGQgdXNlLiAoSWYgdGhpc1xuICAvLyBpcyBOb1dvcmssIHVzZSB0aGUgZGVmYXVsdCBzdHJhdGVneTogYXN5bmMgdXBkYXRlcyBpbiBhc3luYyBtb2RlLCBzeW5jXG4gIC8vIHVwZGF0ZXMgaW4gc3luYyBtb2RlLilcbiAgdmFyIGV4cGlyYXRpb25Db250ZXh0ID0gTm9Xb3JrO1xuXG4gIHZhciBpc1dvcmtpbmcgPSBmYWxzZTtcblxuICAvLyBUaGUgbmV4dCB3b3JrIGluIHByb2dyZXNzIGZpYmVyIHRoYXQgd2UncmUgY3VycmVudGx5IHdvcmtpbmcgb24uXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gIHZhciBuZXh0Um9vdCA9IG51bGw7XG4gIC8vIFRoZSB0aW1lIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgd29yay5cbiAgdmFyIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcblxuICAvLyBUaGUgbmV4dCBmaWJlciB3aXRoIGFuIGVmZmVjdCB0aGF0IHdlJ3JlIGN1cnJlbnRseSBjb21taXR0aW5nLlxuICB2YXIgbmV4dEVmZmVjdCA9IG51bGw7XG5cbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBjYXB0dXJlZCBhbiBlcnJvciB0aGF0IG5lZWQgdG8gYmUgaGFuZGxlZC5cbiAgLy8gV29yayBpcyByZW1vdmVkIGZyb20gdGhpcyBjb2xsZWN0aW9uIGFmdGVyIGNvbXBvbmVudERpZENhdGNoIGlzIGNhbGxlZC5cbiAgdmFyIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgLy8gS2VlcCB0cmFjayBvZiB3aGljaCBmaWJlcnMgaGF2ZSBmYWlsZWQgZHVyaW5nIHRoZSBjdXJyZW50IGJhdGNoIG9mIHdvcmsuXG4gIC8vIFRoaXMgaXMgYSBkaWZmZXJlbnQgc2V0IHRoYW4gY2FwdHVyZWRFcnJvcnMsIGJlY2F1c2UgaXQgaXMgbm90IHJlc2V0IHVudGlsXG4gIC8vIHRoZSBlbmQgb2YgdGhlIGJhdGNoLiBUaGlzIGlzIG5lZWRlZCB0byBwcm9wYWdhdGUgZXJyb3JzIGNvcnJlY3RseSBpZiBhXG4gIC8vIHN1YnRyZWUgZmFpbHMgbW9yZSB0aGFuIG9uY2UuXG4gIHZhciBmYWlsZWRCb3VuZGFyaWVzID0gbnVsbDtcbiAgLy8gRXJyb3IgYm91bmRhcmllcyB0aGF0IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGUgY3VycmVudCBjb21taXQuXG4gIHZhciBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICB2YXIgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgdmFyIGRpZEZhdGFsID0gZmFsc2U7XG5cbiAgdmFyIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICB2YXIgaXNVbm1vdW50aW5nID0gZmFsc2U7XG5cbiAgLy8gVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuXG4gIHZhciBpbnRlcnJ1cHRlZEJ5ID0gbnVsbDtcblxuICBmdW5jdGlvbiByZXNldENvbnRleHRTdGFjaygpIHtcbiAgICAvLyBSZXNldCB0aGUgc3RhY2tcbiAgICByZXNldCQxKCk7XG4gICAgLy8gUmVzZXQgdGhlIGN1cnNvcnNcbiAgICByZXNldENvbnRleHQoKTtcbiAgICByZXNldEhvc3RDb250YWluZXIoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbEhvc3RFZmZlY3RzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKG5leHRFZmZlY3QpO1xuICAgICAgfVxuICAgICAgcmVjb3JkRWZmZWN0KCk7XG5cbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcbiAgICAgIGlmIChlZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudChuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIFJlZikge1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNvbW1pdERldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIHN3aXRjaCBzdGF0ZW1lbnQgaXMgb25seSBjb25jZXJuZWQgYWJvdXQgcGxhY2VtZW50LFxuICAgICAgLy8gdXBkYXRlcywgYW5kIGRlbGV0aW9ucy4gVG8gYXZvaWQgbmVlZGluZyB0byBhZGQgYSBjYXNlIGZvciBldmVyeVxuICAgICAgLy8gcG9zc2libGUgYml0bWFwIHZhbHVlLCB3ZSByZW1vdmUgdGhlIHNlY29uZGFyeSBlZmZlY3RzIGZyb20gdGhlXG4gICAgICAvLyBlZmZlY3QgdGFnIGFuZCBzd2l0Y2ggb24gdGhhdCB2YWx1ZS5cbiAgICAgIHZhciBwcmltYXJ5RWZmZWN0VGFnID0gZWZmZWN0VGFnICYgfihDYWxsYmFjayB8IEVyciB8IENvbnRlbnRSZXNldCB8IFJlZiB8IFBlcmZvcm1lZFdvcmspO1xuICAgICAgc3dpdGNoIChwcmltYXJ5RWZmZWN0VGFnKSB7XG4gICAgICAgIGNhc2UgUGxhY2VtZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZFxuICAgICAgICAgICAgLy8gZG9lcyBhbmQgaXNNb3VudGVkIGlzIGRlcHJlY2F0ZWQgYW55d2F5IHNvIHdlIHNob3VsZCBiZSBhYmxlXG4gICAgICAgICAgICAvLyB0byBraWxsIHRoaXMuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFBsYWNlbWVudEFuZFVwZGF0ZTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICAvLyBQbGFjZW1lbnRcbiAgICAgICAgICAgIGNvbW1pdFBsYWNlbWVudChuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBcInBsYWNlbWVudFwiIGZyb20gZWZmZWN0IHRhZyBzbyB0aGF0IHdlIGtub3cgdGhhdCB0aGlzIGlzIGluc2VydGVkLCBiZWZvcmVcbiAgICAgICAgICAgIC8vIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgICAgICAgICAgbmV4dEVmZmVjdC5lZmZlY3RUYWcgJj0gflBsYWNlbWVudDtcblxuICAgICAgICAgICAgLy8gVXBkYXRlXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIFVwZGF0ZTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgICAgICBjb21taXRXb3JrKF9jdXJyZW50MiwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgRGVsZXRpb246XG4gICAgICAgICAge1xuICAgICAgICAgICAgaXNVbm1vdW50aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbW1pdERlbGV0aW9uKG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgaXNVbm1vdW50aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgIH1cblxuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBbGxMaWZlQ3ljbGVzKCkge1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgZWZmZWN0VGFnID0gbmV4dEVmZmVjdC5lZmZlY3RUYWc7XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiAoVXBkYXRlIHwgQ2FsbGJhY2spKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICB2YXIgY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICBjb21taXRMaWZlQ3ljbGVzKGN1cnJlbnQsIG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHJlY29yZEVmZmVjdCgpO1xuICAgICAgICBjb21taXRBdHRhY2hSZWYobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBFcnIpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEVycm9ySGFuZGxpbmcobmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXh0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgY2xlYW4gdGhlc2UgdXAgc28gdGhhdCB3ZSBkb24ndCBhY2NpZGVudGFsbHkga2VlcCB0aGVtLlxuICAgICAgLy8gSSdtIG5vdCBhY3R1YWxseSBzdXJlIHRoaXMgbWF0dGVycyBiZWNhdXNlIHdlIGNhbid0IHJlc2V0IGZpcnN0RWZmZWN0XG4gICAgICAvLyBhbmQgbGFzdEVmZmVjdCBzaW5jZSB0aGV5J3JlIG9uIGV2ZXJ5IG5vZGUsIG5vdCBqdXN0IHRoZSBlZmZlY3RmdWxcbiAgICAgIC8vIG9uZXMuIFNvIHdlIGhhdmUgdG8gY2xlYW4gZXZlcnl0aGluZyBhcyB3ZSByZXVzZSBub2RlcyBhbnl3YXkuXG4gICAgICBuZXh0RWZmZWN0Lm5leHRFZmZlY3QgPSBudWxsO1xuICAgICAgLy8gRW5zdXJlIHRoYXQgd2UgcmVzZXQgdGhlIGVmZmVjdFRhZyBoZXJlIHNvIHRoYXQgd2UgY2FuIHJlbHkgb24gZWZmZWN0XG4gICAgICAvLyB0YWdzIHRvIHJlYXNvbiBhYm91dCB0aGUgY3VycmVudCBsaWZlLWN5Y2xlLlxuICAgICAgbmV4dEVmZmVjdCA9IG5leHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspIHtcbiAgICAvLyBXZSBrZWVwIHRyYWNrIG9mIHRoaXMgc28gdGhhdCBjYXB0dXJlRXJyb3IgY2FuIGNvbGxlY3QgYW55IGJvdW5kYXJpZXNcbiAgICAvLyB0aGF0IGNhcHR1cmUgYW4gZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIFRoZSByZWFzb24gdGhlc2UgYXJlbid0XG4gICAgLy8gbG9jYWwgdG8gdGhpcyBmdW5jdGlvbiBpcyBiZWNhdXNlIGVycm9ycyB0aGF0IG9jY3VyIGR1cmluZyBjV1UgYXJlXG4gICAgLy8gY2FwdHVyZWQgZWxzZXdoZXJlLCB0byBwcmV2ZW50IHRoZSB1bm1vdW50IGZyb20gYmVpbmcgaW50ZXJydXB0ZWQuXG4gICAgaXNXb3JraW5nID0gdHJ1ZTtcbiAgICBpc0NvbW1pdHRpbmcgPSB0cnVlO1xuICAgIHN0YXJ0Q29tbWl0VGltZXIoKTtcblxuICAgIHZhciByb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAhKHJvb3QuY3VycmVudCAhPT0gZmluaXNoZWRXb3JrKSA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgaXMgcHJvYmFibHkgYSBidWcgcmVsYXRlZCB0byB0aGUgcmV0dXJuIGZpZWxkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG4gICAgLy8gUmVzZXQgdGhpcyB0byBudWxsIGJlZm9yZSBjYWxsaW5nIGxpZmVjeWNsZXNcbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHZhciBmaXJzdEVmZmVjdCA9IHZvaWQgMDtcbiAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyA+IFBlcmZvcm1lZFdvcmspIHtcbiAgICAgIC8vIEEgZmliZXIncyBlZmZlY3QgbGlzdCBjb25zaXN0cyBvbmx5IG9mIGl0cyBjaGlsZHJlbiwgbm90IGl0c2VsZi4gU28gaWZcbiAgICAgIC8vIHRoZSByb290IGhhcyBhbiBlZmZlY3QsIHdlIG5lZWQgdG8gYWRkIGl0IHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuIFRoZVxuICAgICAgLy8gcmVzdWx0aW5nIGxpc3QgaXMgdGhlIHNldCB0aGF0IHdvdWxkIGJlbG9uZyB0byB0aGUgcm9vdCdzIHBhcmVudCwgaWZcbiAgICAgIC8vIGl0IGhhZCBvbmU7IHRoYXQgaXMsIGFsbCB0aGUgZWZmZWN0cyBpbiB0aGUgdHJlZSBpbmNsdWRpbmcgdGhlIHJvb3QuXG4gICAgICBpZiAoZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gZWZmZWN0IG9uIHRoZSByb290LlxuICAgICAgZmlyc3RFZmZlY3QgPSBmaW5pc2hlZFdvcmsuZmlyc3RFZmZlY3Q7XG4gICAgfVxuXG4gICAgcHJlcGFyZUZvckNvbW1pdCgpO1xuXG4gICAgLy8gQ29tbWl0IGFsbCB0aGUgc2lkZS1lZmZlY3RzIHdpdGhpbiBhIHRyZWUuIFdlJ2xsIGRvIHRoaXMgaW4gdHdvIHBhc3Nlcy5cbiAgICAvLyBUaGUgZmlyc3QgcGFzcyBwZXJmb3JtcyBhbGwgdGhlIGhvc3QgaW5zZXJ0aW9ucywgdXBkYXRlcywgZGVsZXRpb25zIGFuZFxuICAgIC8vIHJlZiB1bm1vdW50cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gICAgc3RhcnRDb21taXRIb3N0RWZmZWN0c1RpbWVyKCk7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvciA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsSG9zdEVmZmVjdHMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChkaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IpO1xuICAgICAgICAvLyBDbGVhbi11cFxuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgc3RvcENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQoKTtcblxuICAgIC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gICAgLy8gdGhlIGZpcnN0IHBhc3Mgb2YgdGhlIGNvbW1pdCBwaGFzZSwgc28gdGhhdCB0aGUgcHJldmlvdXMgdHJlZSBpcyBzdGlsbFxuICAgIC8vIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudFdpbGxVbm1vdW50LCBidXQgYmVmb3JlIHRoZSBzZWNvbmQgcGFzcywgc28gdGhhdFxuICAgIC8vIHRoZSBmaW5pc2hlZCB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7XG5cbiAgICAvLyBJbiB0aGUgc2Vjb25kIHBhc3Mgd2UnbGwgcGVyZm9ybSBhbGwgbGlmZS1jeWNsZXMgYW5kIHJlZiBjYWxsYmFja3MuXG4gICAgLy8gTGlmZS1jeWNsZXMgaGFwcGVuIGFzIGEgc2VwYXJhdGUgcGFzcyBzbyB0aGF0IGFsbCBwbGFjZW1lbnRzLCB1cGRhdGVzLFxuICAgIC8vIGFuZCBkZWxldGlvbnMgaW4gdGhlIGVudGlyZSB0cmVlIGhhdmUgYWxyZWFkeSBiZWVuIGludm9rZWQuXG4gICAgLy8gVGhpcyBwYXNzIGFsc28gdHJpZ2dlcnMgYW55IHJlbmRlcmVyLXNwZWNpZmljIGluaXRpYWwgZWZmZWN0cy5cbiAgICBuZXh0RWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG4gICAgc3RhcnRDb21taXRMaWZlQ3ljbGVzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9kaWRFcnJvciA9IGZhbHNlO1xuICAgICAgdmFyIF9lcnJvcjIgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIGNvbW1pdEFsbExpZmVDeWNsZXMsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIF9kaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgX2Vycm9yMiA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKF9kaWRFcnJvcikge1xuICAgICAgICAhKG5leHRFZmZlY3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgbmV4dCBlZmZlY3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgIGNhcHR1cmVFcnJvcihuZXh0RWZmZWN0LCBfZXJyb3IyKTtcbiAgICAgICAgaWYgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBuZXh0RWZmZWN0ID0gbmV4dEVmZmVjdC5uZXh0RWZmZWN0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gICAgaXNXb3JraW5nID0gZmFsc2U7XG4gICAgc3RvcENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHN0b3BDb21taXRUaW1lcigpO1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFJvb3QoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21taXRXb3JrKGZpbmlzaGVkV29yayk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgY2F1Z2h0IGFueSBlcnJvcnMgZHVyaW5nIHRoaXMgY29tbWl0LCBzY2hlZHVsZSB0aGVpciBib3VuZGFyaWVzXG4gICAgLy8gdG8gdXBkYXRlLlxuICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMpIHtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5mb3JFYWNoKHNjaGVkdWxlRXJyb3JSZWNvdmVyeSk7XG4gICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChmaXJzdFVuY2F1Z2h0RXJyb3IgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZXJyb3IzID0gZmlyc3RVbmNhdWdodEVycm9yO1xuICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcbiAgICAgIG9uVW5jYXVnaHRFcnJvcihfZXJyb3IzKTtcbiAgICB9XG5cbiAgICB2YXIgcmVtYWluaW5nVGltZSA9IHJvb3QuY3VycmVudC5leHBpcmF0aW9uVGltZTtcblxuICAgIGlmIChyZW1haW5pbmdUaW1lID09PSBOb1dvcmspIHtcbiAgICAgIGNhcHR1cmVkRXJyb3JzID0gbnVsbDtcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiByZW1haW5pbmdUaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVzZXRFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyVGltZSkge1xuICAgIGlmIChyZW5kZXJUaW1lICE9PSBOZXZlciAmJiB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTmV2ZXIpIHtcbiAgICAgIC8vIFRoZSBjaGlsZHJlbiBvZiB0aGlzIGNvbXBvbmVudCBhcmUgaGlkZGVuLiBEb24ndCBidWJibGUgdGhlaXJcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHBlbmRpbmcgdXBkYXRlcy5cbiAgICB2YXIgbmV3RXhwaXJhdGlvblRpbWUgPSBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBDYWxscyBuZWVkIHRvIHZpc2l0IHN0YXRlTm9kZVxuXG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgdmFyIGNoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQuZXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobmV3RXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXdFeHBpcmF0aW9uVGltZSA+IGNoaWxkLmV4cGlyYXRpb25UaW1lKSkge1xuICAgICAgICBuZXdFeHBpcmF0aW9uVGltZSA9IGNoaWxkLmV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IG5ld0V4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAgIC8vIHByb2dyZXNzLlxuICAgICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICAgIHZhciBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAge1xuICAgICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzWydyZXR1cm4nXTtcbiAgICAgIHZhciBzaWJsaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5zaWJsaW5nO1xuXG4gICAgICByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgICBzdG9wV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIGNvbXBsZXRpbmcgdGhpcyB3b3JrIHNwYXduZWQgbmV3IHdvcmssIGRvIHRoYXQgbmV4dC4gV2UnbGwgY29tZVxuICAgICAgICAvLyBiYWNrIGhlcmUgYWdhaW4uXG4gICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQXBwZW5kIGFsbCB0aGUgZWZmZWN0cyBvZiB0aGUgc3VidHJlZSBhbmQgdGhpcyBmaWJlciBvbnRvIHRoZSBlZmZlY3RcbiAgICAgICAgLy8gbGlzdCBvZiB0aGUgcGFyZW50LiBUaGUgY29tcGxldGlvbiBvcmRlciBvZiB0aGUgY2hpbGRyZW4gYWZmZWN0cyB0aGVcbiAgICAgICAgLy8gc2lkZS1lZmZlY3Qgb3JkZXIuXG4gICAgICAgIGlmIChyZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAocmV0dXJuRmliZXIubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5sYXN0RWZmZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBoYWQgc2lkZS1lZmZlY3RzLCB3ZSBhcHBlbmQgaXQgQUZURVIgdGhlIGNoaWxkcmVuJ3NcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBXZSBjYW4gcGVyZm9ybSBjZXJ0YWluIHNpZGUtZWZmZWN0cyBlYXJsaWVyIGlmXG4gICAgICAgIC8vIG5lZWRlZCwgYnkgZG9pbmcgbXVsdGlwbGUgcGFzc2VzIG92ZXIgdGhlIGVmZmVjdCBsaXN0LiBXZSBkb24ndCB3YW50XG4gICAgICAgIC8vIHRvIHNjaGVkdWxlIG91ciBvd24gc2lkZS1lZmZlY3Qgb24gb3VyIG93biBsaXN0IGJlY2F1c2UgaWYgZW5kIHVwXG4gICAgICAgIC8vIHJldXNpbmcgY2hpbGRyZW4gd2UnbGwgc2NoZWR1bGUgdGhpcyBlZmZlY3Qgb250byBpdHNlbGYgc2luY2Ugd2UncmVcbiAgICAgICAgLy8gYXQgdGhlIGVuZC5cbiAgICAgICAgdmFyIGVmZmVjdFRhZyA9IHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZztcbiAgICAgICAgLy8gU2tpcCBib3RoIE5vV29yayBhbmQgUGVyZm9ybWVkV29yayB0YWdzIHdoZW4gY3JlYXRpbmcgdGhlIGVmZmVjdCBsaXN0LlxuICAgICAgICAvLyBQZXJmb3JtZWRXb3JrIGVmZmVjdCBpcyByZWFkIGJ5IFJlYWN0IERldlRvb2xzIGJ1dCBzaG91bGRuJ3QgYmUgY29tbWl0dGVkLlxuICAgICAgICBpZiAoZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQ29tcGxldGVXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNpYmxpbmdGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgICByZXR1cm4gc2libGluZ0ZpYmVyO1xuICAgICAgfSBlbHNlIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIG1vcmUgd29yayBpbiB0aGlzIHJldHVybkZpYmVyLiBDb21wbGV0ZSB0aGUgcmV0dXJuRmliZXIuXG4gICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cbiAgICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IHRydWU7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFdpdGhvdXQgdGhpcyBleHBsaWNpdCBudWxsIHJldHVybiBGbG93IGNvbXBsYWlucyBvZiBpbnZhbGlkIHJldHVybiB0eXBlXG4gICAgLy8gVE9ETyBSZW1vdmUgdGhlIGFib3ZlIHdoaWxlKHRydWUpIGxvb3BcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuXG4gICAgLy8gSWRlYWxseSBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmVcbiAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgIC8vIHByb2dyZXNzLlxuICAgIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gICAgLy8gU2VlIGlmIGJlZ2lubmluZyB0aGlzIHdvcmsgc3Bhd25zIG1vcmUgd29yay5cbiAgICBzdGFydFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dCA9IGJlZ2luRmFpbGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuICAgIGlmICh0cnVlICYmIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25CZWdpbldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgICBuZXh0ID0gY29tcGxldGVVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcblxuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgZnVuY3Rpb24gd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGFyZSB1bmhhbmRsZWQgZXJyb3JzLCBzd2l0Y2ggdG8gdGhlIHNsb3cgd29yayBsb29wLlxuICAgICAgLy8gVE9ETzogSG93IHRvIGF2b2lkIHRoaXMgY2hlY2sgaW4gdGhlIGZhc3QgcGF0aD8gTWF5YmUgdGhlIHJlbmRlcmVyXG4gICAgICAvLyBjb3VsZCBrZWVwIHRyYWNrIG9mIHdoaWNoIHJvb3RzIGhhdmUgdW5oYW5kbGVkIGVycm9ycyBhbmQgY2FsbCBhXG4gICAgICAvLyBmb3JrZWQgdmVyc2lvbiBvZiByZW5kZXJSb290LlxuICAgICAgc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsoZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID4gZXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIDw9IG1vc3RSZWNlbnRDdXJyZW50VGltZSkge1xuICAgICAgLy8gRmx1c2ggYWxsIGV4cGlyZWQgd29yay5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoaGFzQ2FwdHVyZWRFcnJvcihuZXh0VW5pdE9mV29yaykpIHtcbiAgICAgICAgICAvLyBVc2UgYSBmb3JrZWQgdmVyc2lvbiBvZiBwZXJmb3JtVW5pdE9mV29ya1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jaHJvbm91cyB3b3JrIHVudGlsIHRoZSBkZWFkbGluZSBydW5zIG91dCBvZiB0aW1lLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsICYmICFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290Q2F0Y2hCbG9jayhyb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBXZSdyZSBnb2luZyB0byByZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvci5cbiAgICAvLyBDb25jZXB0dWFsbHksIHdlJ3JlIHVud2luZGluZyB0aGUgc3RhY2suIFdlIG5lZWQgdG8gdW53aW5kIHRoZVxuICAgIC8vIGNvbnRleHQgc3RhY2ssIHRvby5cbiAgICB1bndpbmRDb250ZXh0cyhmYWlsZWRXb3JrLCBib3VuZGFyeSk7XG5cbiAgICAvLyBSZXN0YXJ0IHRoZSBlcnJvciBib3VuZGFyeSB1c2luZyBhIGZvcmtlZCB2ZXJzaW9uIG9mXG4gICAgLy8gcGVyZm9ybVVuaXRPZldvcmsgdGhhdCBkZWxldGVzIHRoZSBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGUgZW50aXJlXG4gICAgLy8gZmFpbGVkIHN1YnJlZSB3aWxsIGJlIHVubW91bnRlZC4gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIGEgc3BlY2lhbFxuICAgIC8vIGxpZmVjeWNsZSBtZXRob2QgaXMgY2FsbGVkIG9uIHRoZSBlcnJvciBib3VuZGFyeSwgd2hpY2ggdHJpZ2dlcnNcbiAgICAvLyBhIHJlLXJlbmRlci5cbiAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKGJvdW5kYXJ5KTtcblxuICAgIC8vIENvbnRpbnVlIHdvcmtpbmcuXG4gICAgd29ya0xvb3AoZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgICEhaXNXb3JraW5nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyUm9vdCB3YXMgY2FsbGVkIHJlY3Vyc2l2ZWx5LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIGlzV29ya2luZyA9IHRydWU7XG5cbiAgICAvLyBXZSdyZSBhYm91dCB0byBtdXRhdGUgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZS4gSWYgdGhlIHJvb3Qgd2FzIHBlbmRpbmdcbiAgICAvLyBjb21taXQsIGl0IG5vIGxvbmdlciBpczogd2UnbGwgbmVlZCB0byBjb21wbGV0ZSBpdCBhZ2Fpbi5cbiAgICByb290LmlzUmVhZHlGb3JDb21taXQgPSBmYWxzZTtcblxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIHN0YXJ0aW5nIGZyb20gYSBmcmVzaCBzdGFjaywgb3IgaWYgd2UncmUgcmVzdW1pbmcgZnJvbVxuICAgIC8vIHByZXZpb3VzbHkgeWllbGRlZCB3b3JrLlxuICAgIGlmIChyb290ICE9PSBuZXh0Um9vdCB8fCBleHBpcmF0aW9uVGltZSAhPT0gbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lIHx8IG5leHRVbml0T2ZXb3JrID09PSBudWxsKSB7XG4gICAgICAvLyBSZXNldCB0aGUgc3RhY2sgYW5kIHN0YXJ0IHdvcmtpbmcgZnJvbSB0aGUgcm9vdC5cbiAgICAgIHJlc2V0Q29udGV4dFN0YWNrKCk7XG4gICAgICBuZXh0Um9vdCA9IHJvb3Q7XG4gICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIG5leHRVbml0T2ZXb3JrID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MobmV4dFJvb3QuY3VycmVudCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIHN0YXJ0V29ya0xvb3BUaW1lcihuZXh0VW5pdE9mV29yayk7XG5cbiAgICB2YXIgZGlkRXJyb3IgPSBmYWxzZTtcbiAgICB2YXIgZXJyb3IgPSBudWxsO1xuICAgIHtcbiAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHdvcmtMb29wLCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgIGVycm9yID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgd2hpbGUgKGRpZEVycm9yKSB7XG4gICAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgICAgLy8gVGhpcyB3YXMgYSBmYXRhbCBlcnJvci4gRG9uJ3QgYXR0ZW1wdCB0byByZWNvdmVyIGZyb20gaXQuXG4gICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIGZhaWxlZFdvcmsgPSBuZXh0VW5pdE9mV29yaztcbiAgICAgIGlmIChmYWlsZWRXb3JrID09PSBudWxsKSB7XG4gICAgICAgIC8vIEFuIGVycm9yIHdhcyB0aHJvd24gYnV0IHRoZXJlJ3Mgbm8gY3VycmVudCB1bml0IG9mIHdvcmsuIFRoaXMgY2FuXG4gICAgICAgIC8vIGhhcHBlbiBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSdzIGEgYnVnIGluIHRoZSByZW5kZXJlci5cbiAgICAgICAgZGlkRmF0YWwgPSB0cnVlO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgLy8gXCJDYXB0dXJlXCIgdGhlIGVycm9yIGJ5IGZpbmRpbmcgdGhlIG5lYXJlc3QgYm91bmRhcnkuIElmIHRoZXJlIGlzIG5vXG4gICAgICAvLyBlcnJvciBib3VuZGFyeSwgd2UgdXNlIHRoZSByb290LlxuICAgICAgdmFyIGJvdW5kYXJ5ID0gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKTtcbiAgICAgICEoYm91bmRhcnkgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGhhdmUgZm91bmQgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGUgZXJyb3Igd2UganVzdCBjYXB0dXJlZCB3YXMgYSBmYXRhbCBlcnJvci4gVGhpcyBoYXBwZW5zXG4gICAgICAgIC8vIHdoZW4gdGhlIGVycm9yIHByb3BhZ2F0ZXMgdG8gdGhlIHJvb3QgbW9yZSB0aGFuIG9uY2UuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgZXJyb3IgPSBudWxsO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCByZW5kZXJSb290Q2F0Y2hCbG9jaywgbnVsbCwgcm9vdCwgZmFpbGVkV29yaywgYm91bmRhcnksIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgICAgICBkaWRFcnJvciA9IHRydWU7XG4gICAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFdlJ3JlIGZpbmlzaGVkIHdvcmtpbmcuIEV4aXQgdGhlIGVycm9yIGxvb3AuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgdW5jYXVnaHRFcnJvciA9IGZpcnN0VW5jYXVnaHRFcnJvcjtcblxuICAgIC8vIFdlJ3JlIGRvbmUgcGVyZm9ybWluZyB3b3JrLiBUaW1lIHRvIGNsZWFuIHVwLlxuICAgIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpO1xuICAgIGludGVycnVwdGVkQnkgPSBudWxsO1xuICAgIGlzV29ya2luZyA9IGZhbHNlO1xuICAgIGRpZEZhdGFsID0gZmFsc2U7XG4gICAgZmlyc3RVbmNhdWdodEVycm9yID0gbnVsbDtcblxuICAgIGlmICh1bmNhdWdodEVycm9yICE9PSBudWxsKSB7XG4gICAgICBvblVuY2F1Z2h0RXJyb3IodW5jYXVnaHRFcnJvcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA/IHJvb3QuY3VycmVudC5hbHRlcm5hdGUgOiBudWxsO1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgYm91bmRhcnkgdGhhdCBjYXB0dXJlZCB0aGUgZXJyb3IsIG9yIG51bGwgaWYgdGhlIGVycm9yIGlzIGlnbm9yZWRcbiAgZnVuY3Rpb24gY2FwdHVyZUVycm9yKGZhaWxlZFdvcmssIGVycm9yKSB7XG4gICAgLy8gSXQgaXMgbm8gbG9uZ2VyIHZhbGlkIGJlY2F1c2Ugd2UgZXhpdGVkIHRoZSB1c2VyIGNvZGUuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cblxuICAgIC8vIFNlYXJjaCBmb3IgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkuXG4gICAgdmFyIGJvdW5kYXJ5ID0gbnVsbDtcblxuICAgIC8vIFBhc3NlZCB0byBsb2dDYXB0dXJlZEVycm9yKClcbiAgICB2YXIgZXJyb3JCb3VuZGFyeUZvdW5kID0gZmFsc2U7XG4gICAgdmFyIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG5cbiAgICAvLyBIb3N0IGNvbnRhaW5lcnMgYXJlIGEgc3BlY2lhbCBjYXNlLiBJZiB0aGUgZmFpbGVkIHdvcmsgaXRzZWxmIGlzIGEgaG9zdFxuICAgIC8vIGNvbnRhaW5lciwgdGhlbiBpdCBhY3RzIGFzIGl0cyBvd24gYm91bmRhcnkuIEluIGFsbCBvdGhlciBjYXNlcywgd2VcbiAgICAvLyBpZ25vcmUgdGhlIHdvcmsgaXRzZWxmIGFuZCBvbmx5IHNlYXJjaCB0aHJvdWdoIHRoZSBwYXJlbnRzLlxuICAgIGlmIChmYWlsZWRXb3JrLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGJvdW5kYXJ5ID0gZmFpbGVkV29yaztcblxuICAgICAgaWYgKGlzRmFpbGVkQm91bmRhcnkoZmFpbGVkV29yaykpIHtcbiAgICAgICAgLy8gSWYgdGhpcyByb290IGFscmVhZHkgZmFpbGVkLCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBhbiBlcnJvciB3aGVuXG4gICAgICAgIC8vIGF0dGVtcHRpbmcgdG8gdW5tb3VudCBpdC4gVGhpcyBpcyBhIHdvcnN0LWNhc2Ugc2NlbmFyaW8gYW5kXG4gICAgICAgIC8vIHNob3VsZCBvbmx5IGJlIHBvc3NpYmxlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBub2RlID0gZmFpbGVkV29ya1sncmV0dXJuJ107XG4gICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCAmJiBib3VuZGFyeSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShub2RlKTtcblxuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXJyb3IgYm91bmRhcnkhXG4gICAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgICAgICB3aWxsUmV0cnkgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICAvLyBUcmVhdCB0aGUgcm9vdCBsaWtlIGEgbm8tb3AgZXJyb3IgYm91bmRhcnlcbiAgICAgICAgICBib3VuZGFyeSA9IG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShub2RlKSkge1xuICAgICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgYWxyZWFkeSBpbiBhIGZhaWxlZCBzdGF0ZS5cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSB1bm1vdW50aW5nLCB0aGF0IG1lYW5zIHRoaXMgZXJyb3Igd2FzXG4gICAgICAgICAgLy8gdGhyb3duIHdoaWxlIHVubW91bnRpbmcgYSBmYWlsZWQgc3VidHJlZS4gV2Ugc2hvdWxkIGlnbm9yZVxuICAgICAgICAgIC8vIHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoaXNVbm1vdW50aW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBpbiB0aGUgY29tbWl0IHBoYXNlLCB3ZSBzaG91bGQgY2hlY2sgdG8gc2VlIGlmXG4gICAgICAgICAgLy8gdGhpcyBib3VuZGFyeSBhbHJlYWR5IGNhcHR1cmVkIGFuIGVycm9yIGR1cmluZyB0aGlzIGNvbW1pdC5cbiAgICAgICAgICAvLyBUaGlzIGNhc2UgZXhpc3RzIGJlY2F1c2UgbXVsdGlwbGUgZXJyb3JzIGNhbiBiZSB0aHJvd24gZHVyaW5nXG4gICAgICAgICAgLy8gYSBzaW5nbGUgY29tbWl0IHdpdGhvdXQgaW50ZXJydXB0aW9uLlxuICAgICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgIT09IG51bGwgJiYgKGNvbW1pdFBoYXNlQm91bmRhcmllcy5oYXMobm9kZSkgfHwgbm9kZS5hbHRlcm5hdGUgIT09IG51bGwgJiYgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlLmFsdGVybmF0ZSkpKSB7XG4gICAgICAgICAgICAvLyBJZiBzbywgd2Ugc2hvdWxkIGlnbm9yZSB0aGlzIGVycm9yLlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCBwcm9wYWdhdGUgdG8gdGhlIG5leHQgYm91bmRhcnkgLeKAlCB3ZSBrZWVwIGxvb2tpbmcuXG4gICAgICAgICAgYm91bmRhcnkgPSBudWxsO1xuICAgICAgICAgIHdpbGxSZXRyeSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChib3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgLy8gQWRkIHRvIHRoZSBjb2xsZWN0aW9uIG9mIGZhaWxlZCBib3VuZGFyaWVzLiBUaGlzIGxldHMgdXMga25vdyB0aGF0XG4gICAgICAvLyBzdWJzZXF1ZW50IGVycm9ycyBpbiB0aGlzIHN1YnRyZWUgc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeS5cbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG4gICAgICBmYWlsZWRCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG5cbiAgICAgIC8vIFRoaXMgbWV0aG9kIGlzIHVuc2FmZSBvdXRzaWRlIG9mIHRoZSBiZWdpbiBhbmQgY29tcGxldGUgcGhhc2VzLlxuICAgICAgLy8gV2UgbWlnaHQgYmUgaW4gdGhlIGNvbW1pdCBwaGFzZSB3aGVuIGFuIGVycm9yIGlzIGNhcHR1cmVkLlxuICAgICAgLy8gVGhlIHJpc2sgaXMgdGhhdCB0aGUgcmV0dXJuIHBhdGggZnJvbSB0aGlzIEZpYmVyIG1heSBub3QgYmUgYWNjdXJhdGUuXG4gICAgICAvLyBUaGF0IHJpc2sgaXMgYWNjZXB0YWJsZSBnaXZlbiB0aGUgYmVuZWZpdCBvZiBwcm92aWRpbmcgdXNlcnMgbW9yZSBjb250ZXh0LlxuICAgICAgdmFyIF9jb21wb25lbnRTdGFjayA9IGdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIoZmFpbGVkV29yayk7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZhaWxlZFdvcmspO1xuXG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgY2FwdHVyZWQgZXJyb3JzLiBUaGlzIGlzIHN0b3JlZCBhcyBhIGdsb2JhbFxuICAgICAgLy8gbWFwIG9mIGVycm9ycyBhbmQgdGhlaXIgY29tcG9uZW50IHN0YWNrIGxvY2F0aW9uIGtleWVkIGJ5IHRoZSBib3VuZGFyaWVzXG4gICAgICAvLyB0aGF0IGNhcHR1cmUgdGhlbS4gV2UgbW9zdGx5IHVzZSB0aGlzIE1hcCBhcyBhIFNldDsgaXQncyBhIE1hcCBvbmx5IHRvXG4gICAgICAvLyBhdm9pZCBhZGRpbmcgYSBmaWVsZCB0byBGaWJlciB0byBzdG9yZSB0aGUgZXJyb3IuXG4gICAgICBpZiAoY2FwdHVyZWRFcnJvcnMgPT09IG51bGwpIHtcbiAgICAgICAgY2FwdHVyZWRFcnJvcnMgPSBuZXcgTWFwKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjYXB0dXJlZEVycm9yID0ge1xuICAgICAgICBjb21wb25lbnROYW1lOiBfY29tcG9uZW50TmFtZSxcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IF9jb21wb25lbnRTdGFjayxcbiAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICBlcnJvckJvdW5kYXJ5OiBlcnJvckJvdW5kYXJ5Rm91bmQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgOiBudWxsLFxuICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQ6IGVycm9yQm91bmRhcnlGb3VuZCxcbiAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWU6IGVycm9yQm91bmRhcnlOYW1lLFxuICAgICAgICB3aWxsUmV0cnk6IHdpbGxSZXRyeVxuICAgICAgfTtcblxuICAgICAgY2FwdHVyZWRFcnJvcnMuc2V0KGJvdW5kYXJ5LCBjYXB0dXJlZEVycm9yKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgbG9nQ2FwdHVyZWRFcnJvcihjYXB0dXJlZEVycm9yKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gUHJldmVudCBjeWNsZSBpZiBsb2dDYXB0dXJlZEVycm9yKCkgdGhyb3dzLlxuICAgICAgICAvLyBBIGN5Y2xlIG1heSBzdGlsbCBvY2N1ciBpZiBsb2dDYXB0dXJlZEVycm9yIHJlbmRlcnMgYSBjb21wb25lbnQgdGhhdCB0aHJvd3MuXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIGRlZmVyIHNjaGVkdWxpbmcgYW4gdXBkYXRlIG9uIHRoZVxuICAgICAgLy8gYm91bmRhcnkgdW50aWwgYWZ0ZXIgdGhlIGNvbW1pdCBpcyBjb21wbGV0ZVxuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICBpZiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzID09PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcy5hZGQoYm91bmRhcnkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBzY2hlZHVsZSBhbiB1cGRhdGUgbm93LlxuICAgICAgICAvLyBUT0RPOiBJcyB0aGlzIGFjdHVhbGx5IG5lY2Vzc2FyeSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZT8gSXMgaXRcbiAgICAgICAgLy8gcG9zc2libGUgdG8gdW53aW5kIGFuZCBjb250aW51ZSByZW5kZXJpbmcgYXQgdGhlIHNhbWUgcHJpb3JpdHksXG4gICAgICAgIC8vIHdpdGhvdXQgY29ycnVwdGluZyBpbnRlcm5hbCBzdGF0ZT9cbiAgICAgICAgc2NoZWR1bGVFcnJvclJlY292ZXJ5KGJvdW5kYXJ5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBib3VuZGFyeTtcbiAgICB9IGVsc2UgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgbm8gYm91bmRhcnkgaXMgZm91bmQsIHdlJ2xsIG5lZWQgdG8gdGhyb3cgdGhlIGVycm9yXG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBoYXNDYXB0dXJlZEVycm9yKGZpYmVyKSB7XG4gICAgLy8gVE9ETzogY2FwdHVyZWRFcnJvcnMgc2hvdWxkIHN0b3JlIHRoZSBib3VuZGFyeSBpbnN0YW5jZSwgdG8gYXZvaWQgbmVlZGluZ1xuICAgIC8vIHRvIGNoZWNrIHRoZSBhbHRlcm5hdGUuXG4gICAgcmV0dXJuIGNhcHR1cmVkRXJyb3JzICE9PSBudWxsICYmIChjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjYXB0dXJlZEVycm9ycy5oYXMoZmliZXIuYWx0ZXJuYXRlKSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc0ZhaWxlZEJvdW5kYXJ5KGZpYmVyKSB7XG4gICAgLy8gVE9ETzogZmFpbGVkQm91bmRhcmllcyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZFxuICAgIC8vIG5lZWRpbmcgdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gZmFpbGVkQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEVycm9ySGFuZGxpbmcoZWZmZWN0ZnVsRmliZXIpIHtcbiAgICB2YXIgY2FwdHVyZWRFcnJvciA9IHZvaWQgMDtcbiAgICBpZiAoY2FwdHVyZWRFcnJvcnMgIT09IG51bGwpIHtcbiAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgIGlmIChjYXB0dXJlZEVycm9yID09IG51bGwpIHtcbiAgICAgICAgaWYgKGVmZmVjdGZ1bEZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGVmZmVjdGZ1bEZpYmVyID0gZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3IgPSBjYXB0dXJlZEVycm9ycy5nZXQoZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgICAgIGNhcHR1cmVkRXJyb3JzWydkZWxldGUnXShlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAhKGNhcHR1cmVkRXJyb3IgIT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdObyBlcnJvciBmb3IgZ2l2ZW4gdW5pdCBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgc3dpdGNoIChlZmZlY3RmdWxGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGVmZmVjdGZ1bEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICB2YXIgaW5mbyA9IHtcbiAgICAgICAgICBjb21wb25lbnRTdGFjazogY2FwdHVyZWRFcnJvci5jb21wb25lbnRTdGFja1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBib3VuZGFyeSB0byBoYW5kbGUgdGhlIGVycm9yLCB1c3VhbGx5IGJ5IHNjaGVkdWxpbmdcbiAgICAgICAgLy8gYW4gdXBkYXRlIHRvIGl0c2VsZlxuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaChjYXB0dXJlZEVycm9yLmVycm9yLCBpbmZvKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGNhcHR1cmVkRXJyb3IuZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnSW52YWxpZCB0eXBlIG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdW53aW5kQ29udGV4dHMoZnJvbSwgdG8pIHtcbiAgICB2YXIgbm9kZSA9IGZyb207XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICBwb3BDb250ZXh0UHJvdmlkZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dChub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgcG9wSG9zdENvbnRhaW5lcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSB0byB8fCBub2RlLmFsdGVybmF0ZSA9PT0gdG8pIHtcbiAgICAgICAgc3RvcEZhaWxlZFdvcmtUaW1lcihub2RlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdG9wV29ya1RpbWVyKG5vZGUpO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKSB7XG4gICAgLy8gR2l2ZW4gdGhlIGN1cnJlbnQgY2xvY2sgdGltZSwgcmV0dXJucyBhbiBleHBpcmF0aW9uIHRpbWUuIFdlIHVzZSByb3VuZGluZ1xuICAgIC8vIHRvIGJhdGNoIGxpa2UgdXBkYXRlcyB0b2dldGhlci5cbiAgICAvLyBTaG91bGQgY29tcGxldGUgd2l0aGluIH4xMDAwbXMuIDEyMDBtcyBtYXguXG4gICAgdmFyIGN1cnJlbnRUaW1lID0gcmVjYWxjdWxhdGVDdXJyZW50VGltZSgpO1xuICAgIHZhciBleHBpcmF0aW9uTXMgPSAxMDAwO1xuICAgIHZhciBidWNrZXRTaXplTXMgPSAyMDA7XG4gICAgcmV0dXJuIGNvbXB1dGVFeHBpcmF0aW9uQnVja2V0KGN1cnJlbnRUaW1lLCBleHBpcmF0aW9uTXMsIGJ1Y2tldFNpemVNcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gdm9pZCAwO1xuICAgIGlmIChleHBpcmF0aW9uQ29udGV4dCAhPT0gTm9Xb3JrKSB7XG4gICAgICAvLyBBbiBleHBsaWNpdCBleHBpcmF0aW9uIGNvbnRleHQgd2FzIHNldDtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfSBlbHNlIGlmIChpc1dvcmtpbmcpIHtcbiAgICAgIGlmIChpc0NvbW1pdHRpbmcpIHtcbiAgICAgICAgLy8gVXBkYXRlcyB0aGF0IG9jY3VyIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHNob3VsZCBoYXZlIHN5bmMgcHJpb3JpdHlcbiAgICAgICAgLy8gYnkgZGVmYXVsdC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXBkYXRlcyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSBzaG91bGQgZXhwaXJlIGF0IHRoZSBzYW1lIHRpbWUgYXNcbiAgICAgICAgLy8gdGhlIHdvcmsgdGhhdCBpcyBiZWluZyByZW5kZXJlZC5cbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0LCBhbmQgd2UncmUgbm90IGN1cnJlbnRseVxuICAgICAgLy8gcGVyZm9ybWluZyB3b3JrLiBDYWxjdWxhdGUgYSBuZXcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgaWYgKHVzZVN5bmNTY2hlZHVsaW5nICYmICEoZmliZXIuaW50ZXJuYWxDb250ZXh0VGFnICYgQXN5bmNVcGRhdGVzKSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBTeW5jO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBhc3luYyB1cGRhdGVcbiAgICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBleHBpcmF0aW9uVGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29yayhmaWJlciwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICByZXR1cm4gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGZhbHNlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlV29ya0ltcGwoZmliZXIsIGV4cGlyYXRpb25UaW1lLCBpc0Vycm9yUmVjb3ZlcnkpIHtcbiAgICByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpO1xuXG4gICAge1xuICAgICAgaWYgKCFpc0Vycm9yUmVjb3ZlcnkgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHdhcm5BYm91dEludmFsaWRVcGRhdGVzKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICAvLyBXYWxrIHRoZSBwYXJlbnQgcGF0aCB0byB0aGUgcm9vdCBhbmQgdXBkYXRlIGVhY2ggbm9kZSdzXG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAobm9kZS5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5vZGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICBub2RlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBpZiAobm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgIG5vZGUuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICAgICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoIWlzV29ya2luZyAmJiByb290ID09PSBuZXh0Um9vdCAmJiBleHBpcmF0aW9uVGltZSA8PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgICAgIC8vIFJlc3RhcnQgdGhlIHJvb3QgZnJvbSB0aGUgdG9wLlxuICAgICAgICAgICAgaWYgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZXJydXB0aW9uLiAoVXNlZCBmb3IgcGVyZm9ybWFuY2UgdHJhY2tpbmcuKVxuICAgICAgICAgICAgICBpbnRlcnJ1cHRlZEJ5ID0gZmliZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Um9vdCA9IG51bGw7XG4gICAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IG51bGw7XG4gICAgICAgICAgICBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAgIHdhcm5BYm91dFVwZGF0ZU9uVW5tb3VudGVkKGZpYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVFcnJvclJlY292ZXJ5KGZpYmVyKSB7XG4gICAgc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgU3luYywgdHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkge1xuICAgIC8vIFN1YnRyYWN0IGluaXRpYWwgdGltZSBzbyBpdCBmaXRzIGluc2lkZSAzMmJpdHNcbiAgICB2YXIgbXMgPSBub3coKSAtIHN0YXJ0VGltZTtcbiAgICBtb3N0UmVjZW50Q3VycmVudFRpbWUgPSBtc1RvRXhwaXJhdGlvblRpbWUobXMpO1xuICAgIHJldHVybiBtb3N0UmVjZW50Q3VycmVudFRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBkZWZlcnJlZFVwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZXhwaXJhdGlvbkNvbnRleHQgPSBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHN5bmNVcGRhdGVzKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICBleHBpcmF0aW9uQ29udGV4dCA9IFN5bmM7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogRXZlcnl0aGluZyBiZWxvdyB0aGlzIGlzIHdyaXR0ZW4gYXMgaWYgaXQgaGFzIGJlZW4gbGlmdGVkIHRvIHRoZVxuICAvLyByZW5kZXJlcnMuIEknbGwgZG8gdGhpcyBpbiBhIGZvbGxvdy11cC5cblxuICAvLyBMaW5rZWQtbGlzdCBvZiByb290c1xuICB2YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgdmFyIGxhc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcblxuICB2YXIgaXNDYWxsYmFja1NjaGVkdWxlZCA9IGZhbHNlO1xuICB2YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgdmFyIG5leHRGbHVzaGVkUm9vdCA9IG51bGw7XG4gIHZhciBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuICB2YXIgZGVhZGxpbmVEaWRFeHBpcmUgPSBmYWxzZTtcbiAgdmFyIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gIHZhciB1bmhhbmRsZWRFcnJvciA9IG51bGw7XG4gIHZhciBkZWFkbGluZSA9IG51bGw7XG5cbiAgdmFyIGlzQmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gIHZhciBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG5cbiAgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuICB2YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDEwMDA7XG4gIHZhciBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG5cbiAgdmFyIHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrID0gMTtcblxuICAvLyByZXF1ZXN0V29yayBpcyBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlciB3aGVuZXZlciBhIHJvb3QgcmVjZWl2ZXMgYW4gdXBkYXRlLlxuICAvLyBJdCdzIHVwIHRvIHRoZSByZW5kZXJlciB0byBjYWxsIHJlbmRlclJvb3QgYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLlxuICBmdW5jdGlvbiByZXF1ZXN0V29yayhyb290LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCByZXBlYXRlZGx5IGNhbGxzIHNldFN0YXRlIGluc2lkZSBjb21wb25lbnRXaWxsVXBkYXRlIG9yIGNvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgICB9XG5cbiAgICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlLlxuICAgIC8vIENoZWNrIGlmIHRoaXMgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIGlmIChyb290Lm5leHRTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgbm90IGFscmVhZHkgc2NoZWR1bGVkLiBBZGQgaXQuXG4gICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgc2NoZWR1bGVkLCBidXQgaXRzIHByaW9yaXR5IG1heSBoYXZlIGluY3JlYXNlZC5cbiAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBleHBpcmF0aW9uVGltZSA8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcHJpb3JpdHkuXG4gICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS4gUmVtYWluaW5nIHdvcmsgd2lsbCBiZSBzY2hlZHVsZWQgYXQgdGhlIGVuZCBvZlxuICAgICAgLy8gdGhlIGN1cnJlbnRseSByZW5kZXJpbmcgYmF0Y2guXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGlzQmF0Y2hpbmdVcGRhdGVzKSB7XG4gICAgICAvLyBGbHVzaCB3b3JrIGF0IHRoZSBlbmQgb2YgdGhlIGJhdGNoLlxuICAgICAgaWYgKGlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgICAgLy8gLi4udW5sZXNzIHdlJ3JlIGluc2lkZSB1bmJhdGNoZWRVcGRhdGVzLCBpbiB3aGljaCBjYXNlIHdlIHNob3VsZFxuICAgICAgICAvLyBmbHVzaCBpdCBub3cuXG4gICAgICAgIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIFN5bmMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFRPRE86IEdldCByaWQgb2YgU3luYyBhbmQgdXNlIGN1cnJlbnQgdGltZT9cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IFN5bmMpIHtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH0gZWxzZSBpZiAoIWlzQ2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICAgIGlzQ2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmspO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCkge1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlXb3JrID0gTm9Xb3JrO1xuICAgIHZhciBoaWdoZXN0UHJpb3JpdHlSb290ID0gbnVsbDtcblxuICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290O1xuICAgICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICBpZiAocmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPT09IE5vV29yaykge1xuICAgICAgICAgIC8vIFRoaXMgcm9vdCBubyBsb25nZXIgaGFzIHdvcmsuIFJlbW92ZSBpdCBmcm9tIHRoZSBzY2hlZHVsZXIuXG5cbiAgICAgICAgICAvLyBUT0RPOiBUaGlzIGNoZWNrIGlzIHJlZHVkYW50LCBidXQgRmxvdyBpcyBjb25mdXNlZCBieSB0aGUgYnJhbmNoXG4gICAgICAgICAgLy8gYmVsb3cgd2hlcmUgd2Ugc2V0IGxhc3RTY2hlZHVsZWRSb290IHRvIG51bGwsIGV2ZW4gdGhvdWdoIHdlIGJyZWFrXG4gICAgICAgICAgLy8gZnJvbSB0aGUgbG9vcCByaWdodCBhZnRlci5cbiAgICAgICAgICAhKHByZXZpb3VzU2NoZWR1bGVkUm9vdCAhPT0gbnVsbCAmJiBsYXN0U2NoZWR1bGVkUm9vdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBhIHByZXZpb3VzIGFuZCBsYXN0IHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgaWYgKHJvb3QgPT09IHJvb3QubmV4dFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBmaXJzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICB2YXIgbmV4dCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgbGFzdCByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2aW91c1NjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaGlnaGVzdFByaW9yaXR5V29yayA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lIDwgaGlnaGVzdFByaW9yaXR5V29yaykge1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eSwgaWYgaXQncyBoaWdoZXJcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSByZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgICAgICAgIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSByb290O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbGFzdFNjaGVkdWxlZFJvb3QpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwcmV2aW91c1NjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICAgIHJvb3QgPSByb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIG5leHQgcm9vdCBpcyB0aGUgc2FtZSBhcyB0aGUgcHJldmlvdXMgcm9vdCwgdGhpcyBpcyBhIG5lc3RlZFxuICAgIC8vIHVwZGF0ZS4gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBpbmNyZW1lbnQgdGhlIG5lc3RlZCB1cGRhdGUgY291bnQuXG4gICAgdmFyIHByZXZpb3VzRmx1c2hlZFJvb3QgPSBuZXh0Rmx1c2hlZFJvb3Q7XG4gICAgaWYgKHByZXZpb3VzRmx1c2hlZFJvb3QgIT09IG51bGwgJiYgcHJldmlvdXNGbHVzaGVkUm9vdCA9PT0gaGlnaGVzdFByaW9yaXR5Um9vdCkge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVzZXQgd2hlbmV2ZXIgd2Ugc3dpdGNoIHJvb3RzLlxuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cbiAgICBuZXh0Rmx1c2hlZFJvb3QgPSBoaWdoZXN0UHJpb3JpdHlSb290O1xuICAgIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBoaWdoZXN0UHJpb3JpdHlXb3JrO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUFzeW5jV29yayhkbCkge1xuICAgIHBlcmZvcm1Xb3JrKE5vV29yaywgZGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmsobWluRXhwaXJhdGlvblRpbWUsIGRsKSB7XG4gICAgZGVhZGxpbmUgPSBkbDtcblxuICAgIC8vIEtlZXAgd29ya2luZyBvbiByb290cyB1bnRpbCB0aGVyZSdzIG5vIG1vcmUgd29yaywgb3IgdW50aWwgdGhlIHdlIHJlYWNoXG4gICAgLy8gdGhlIGRlYWRsbmUuXG4gICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB3aGlsZSAobmV4dEZsdXNoZWRSb290ICE9PSBudWxsICYmIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgIT09IE5vV29yayAmJiAobWluRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lIDw9IG1pbkV4cGlyYXRpb25UaW1lKSAmJiAhZGVhZGxpbmVEaWRFeHBpcmUpIHtcbiAgICAgIHBlcmZvcm1Xb3JrT25Sb290KG5leHRGbHVzaGVkUm9vdCwgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSk7XG4gICAgICAvLyBGaW5kIHRoZSBuZXh0IGhpZ2hlc3QgcHJpb3JpdHkgd29yay5cbiAgICAgIGZpbmRIaWdoZXN0UHJpb3JpdHlSb290KCk7XG4gICAgfVxuXG4gICAgLy8gV2UncmUgZG9uZSBmbHVzaGluZyB3b3JrLiBFaXRoZXIgd2UgcmFuIG91dCBvZiB0aW1lIGluIHRoaXMgY2FsbGJhY2ssXG4gICAgLy8gb3IgdGhlcmUncyBubyBtb3JlIHdvcmsgbGVmdCB3aXRoIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBjYWxsYmFjaywgc2V0IHRoaXMgdG8gZmFsc2Ugc2luY2Ugd2UganVzdCBjb21wbGV0ZWQgaXQuXG4gICAgaWYgKGRlYWRsaW5lICE9PSBudWxsKSB7XG4gICAgICBpc0NhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIHRoZXJlJ3Mgd29yayBsZWZ0IG92ZXIsIHNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrLlxuICAgIGlmIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgIWlzQ2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICAgIGlzQ2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrKHBlcmZvcm1Bc3luY1dvcmspO1xuICAgIH1cblxuICAgIC8vIENsZWFuLXVwLlxuICAgIGRlYWRsaW5lID0gbnVsbDtcbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICAgIGlmIChoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgdmFyIF9lcnJvcjQgPSB1bmhhbmRsZWRFcnJvcjtcbiAgICAgIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgICAgIGhhc1VuaGFuZGxlZEVycm9yID0gZmFsc2U7XG4gICAgICB0aHJvdyBfZXJyb3I0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1Xb3JrT25Sb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ3BlcmZvcm1Xb3JrT25Sb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBpc1JlbmRlcmluZyA9IHRydWU7XG5cbiAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFzeW5jIHdvcmsgb3Igc3luYy9leHBpcmVkIHdvcmsuXG4gICAgLy8gVE9ETzogUGFzcyBjdXJyZW50IHRpbWUgYXMgYXJndW1lbnQgdG8gcmVuZGVyUm9vdCwgY29tbWl0Um9vdFxuICAgIGlmIChleHBpcmF0aW9uVGltZSA8PSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCkpIHtcbiAgICAgIC8vIEZsdXNoIHN5bmMgd29yay5cbiAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgZmluaXNoZWRXb3JrID0gcmVuZGVyUm9vdChyb290LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENvbW1pdCBpdC5cbiAgICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZsdXNoIGFzeW5jIHdvcmsuXG4gICAgICB2YXIgX2ZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyByb290IGlzIGFscmVhZHkgY29tcGxldGUuIFdlIGNhbiBjb21taXQgaXQuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gICAgICAgIF9maW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKF9maW5pc2hlZFdvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBjb21wbGV0ZWQgdGhlIHJvb3QuIENoZWNrIHRoZSBkZWFkbGluZSBvbmUgbW9yZSB0aW1lXG4gICAgICAgICAgLy8gYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgaWYgKCFzaG91bGRZaWVsZCgpKSB7XG4gICAgICAgICAgICAvLyBTdGlsbCB0aW1lIGxlZnQuIENvbW1pdCB0aGUgcm9vdC5cbiAgICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KF9maW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSdzIG5vIHRpbWUgbGVmdC4gTWFyayB0aGlzIHJvb3QgYXMgY29tcGxldGUuIFdlJ2xsIGNvbWVcbiAgICAgICAgICAgIC8vIGJhY2sgYW5kIGNvbW1pdCBpdCBsYXRlci5cbiAgICAgICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gX2ZpbmlzaGVkV29yaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLy8gV2hlbiB3b3JraW5nIG9uIGFzeW5jIHdvcmssIHRoZSByZWNvbmNpbGVyIGFza3MgdGhlIHJlbmRlcmVyIGlmIGl0IHNob3VsZFxuICAvLyB5aWVsZCBleGVjdXRpb24uIEZvciBET00sIHdlIGltcGxlbWVudCB0aGlzIHdpdGggcmVxdWVzdElkbGVDYWxsYmFjay5cbiAgZnVuY3Rpb24gc2hvdWxkWWllbGQoKSB7XG4gICAgaWYgKGRlYWRsaW5lID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChkZWFkbGluZS50aW1lUmVtYWluaW5nKCkgPiB0aW1lSGV1cmlzdGljRm9yVW5pdE9mV29yaykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBkZWFkbGluZURpZEV4cGlyZSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICAvLyBUT0RPOiBOb3QgaGFwcHkgYWJvdXQgdGhpcyBob29rLiBDb25jZXB0dWFsbHksIHJlbmRlclJvb3Qgc2hvdWxkIHJldHVybiBhXG4gIC8vIHR1cGxlIG9mIChpc1JlYWR5Rm9yQ29tbWl0LCBkaWRFcnJvciwgZXJyb3IpXG4gIGZ1bmN0aW9uIG9uVW5jYXVnaHRFcnJvcihlcnJvcikge1xuICAgICEobmV4dEZsdXNoZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSB3b3JraW5nIG9uIGEgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAvLyBVbnNjaGVkdWxlIHRoaXMgcm9vdCBzbyB3ZSBkb24ndCB3b3JrIG9uIGl0IGFnYWluIHVudGlsIHRoZXJlJ3NcbiAgICAvLyBhbm90aGVyIHVwZGF0ZS5cbiAgICBuZXh0Rmx1c2hlZFJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gICAgaWYgKCFoYXNVbmhhbmRsZWRFcnJvcikge1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSB0cnVlO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBlcnJvcjtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3QgaW5zaWRlXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICAgIHZhciBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzID0gaXNCYXRjaGluZ1VwZGF0ZXM7XG4gICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gZm4oYSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgIGlmICghaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzUmVuZGVyaW5nKSB7XG4gICAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIHVuYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMgJiYgIWlzVW5iYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpc1VuYmF0Y2hpbmdVcGRhdGVzID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbigpO1xuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IHdpdGhpblxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gZmx1c2hTeW5jKGZuKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBzeW5jVXBkYXRlcyhmbik7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcztcbiAgICAgICEhaXNSZW5kZXJpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdmbHVzaFN5bmMgd2FzIGNhbGxlZCBmcm9tIGluc2lkZSBhIGxpZmVjeWNsZSBtZXRob2QuIEl0IGNhbm5vdCBiZSBjYWxsZWQgd2hlbiBSZWFjdCBpcyBhbHJlYWR5IHJlbmRlcmluZy4nKSA6IHZvaWQgMDtcbiAgICAgIHBlcmZvcm1Xb3JrKFN5bmMsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY29tcHV0ZUFzeW5jRXhwaXJhdGlvbjogY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyOiBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgIHNjaGVkdWxlV29yazogc2NoZWR1bGVXb3JrLFxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcbiAgICB1bmJhdGNoZWRVcGRhdGVzOiB1bmJhdGNoZWRVcGRhdGVzLFxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzXG4gIH07XG59O1xuXG57XG4gIHZhciBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG59XG5cbi8vIDAgaXMgUFJPRCwgMSBpcyBERVYuXG4vLyBNaWdodCBhZGQgUFJPRklMRSBsYXRlci5cblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcik7XG4gIHJldHVybiBpc0NvbnRleHRQcm92aWRlcihmaWJlcikgPyBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBwYXJlbnRDb250ZXh0KSA6IHBhcmVudENvbnRleHQ7XG59XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQxID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG5cbiAgdmFyIF9SZWFjdEZpYmVyU2NoZWR1bGVyID0gUmVhY3RGaWJlclNjaGVkdWxlcihjb25maWcpLFxuICAgICAgY29tcHV0ZUFzeW5jRXhwaXJhdGlvbiA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmNvbXB1dGVBc3luY0V4cGlyYXRpb24sXG4gICAgICBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixcbiAgICAgIHNjaGVkdWxlV29yayA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLnNjaGVkdWxlV29yayxcbiAgICAgIGJhdGNoZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgICB1bmJhdGNoZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIudW5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIGZsdXNoU3luYyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmZsdXNoU3luYyxcbiAgICAgIGRlZmVycmVkVXBkYXRlcyA9IF9SZWFjdEZpYmVyU2NoZWR1bGVyLmRlZmVycmVkVXBkYXRlcztcblxuICBmdW5jdGlvbiBzY2hlZHVsZVRvcExldmVsVXBkYXRlKGN1cnJlbnQsIGVsZW1lbnQsIGNhbGxiYWNrKSB7XG4gICAge1xuICAgICAgaWYgKFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPT09ICdyZW5kZXInICYmIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlbmRlciBtZXRob2RzIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlOyAnICsgJ3RyaWdnZXJpbmcgbmVzdGVkIGNvbXBvbmVudCB1cGRhdGVzIGZyb20gcmVuZGVyIGlzIG5vdCBhbGxvd2VkLiAnICsgJ0lmIG5lY2Vzc2FyeSwgdHJpZ2dlciBuZXN0ZWQgdXBkYXRlcyBpbiBjb21wb25lbnREaWRVcGRhdGUuXFxuXFxuJyArICdDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBnZXRDb21wb25lbnROYW1lKFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAge1xuICAgICAgd2FybmluZyhjYWxsYmFjayA9PT0gbnVsbCB8fCB0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICdyZW5kZXIoLi4uKTogRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICB9XG5cbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRvcC1sZXZlbCBlbGVtZW50IGlzIGFuIGFzeW5jIHdyYXBwZXIgY29tcG9uZW50LiBJZiBzbyxcbiAgICAvLyB0cmVhdCB1cGRhdGVzIHRvIHRoZSByb290IGFzIGFzeW5jLiBUaGlzIGlzIGEgYml0IHdlaXJkIGJ1dCBsZXRzIHVzXG4gICAgLy8gYXZvaWQgYSBzZXBhcmF0ZSBgcmVuZGVyQXN5bmNgIEFQSS5cbiAgICBpZiAoZW5hYmxlQXN5bmNTdWJ0cmVlQVBJICYmIGVsZW1lbnQgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgZWxlbWVudC50eXBlLnByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPT09IHRydWUpIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoY3VycmVudCk7XG4gICAgfVxuXG4gICAgdmFyIHVwZGF0ZSA9IHtcbiAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgIHBhcnRpYWxTdGF0ZTogeyBlbGVtZW50OiBlbGVtZW50IH0sXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICBpc1JlcGxhY2U6IGZhbHNlLFxuICAgICAgaXNGb3JjZWQ6IGZhbHNlLFxuICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG4gICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGN1cnJlbnQsIHVwZGF0ZSk7XG4gICAgc2NoZWR1bGVXb3JrKGN1cnJlbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXIoZmliZXIpO1xuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgY3JlYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVySW5mbywgaHlkcmF0ZSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCBoeWRyYXRlKTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbnRhaW5lcjogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICAgICAgLy8gVE9ETzogSWYgdGhpcyBpcyBhIG5lc3RlZCBjb250YWluZXIsIHRoaXMgd29uJ3QgYmUgdGhlIHJvb3QuXG4gICAgICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gICAgICB7XG4gICAgICAgIGlmIChSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uTW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Vbm1vdW50Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25VcGRhdGVDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpO1xuICAgICAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgICAgIGNvbnRhaW5lci5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gICAgICB9XG5cbiAgICAgIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIH0sXG5cblxuICAgIGJhdGNoZWRVcGRhdGVzOiBiYXRjaGVkVXBkYXRlcyxcblxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgICBkZWZlcnJlZFVwZGF0ZXM6IGRlZmVycmVkVXBkYXRlcyxcblxuICAgIGZsdXNoU3luYzogZmx1c2hTeW5jLFxuXG4gICAgZ2V0UHVibGljUm9vdEluc3RhbmNlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcbiAgICAgIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmV0dXJuIGNvbnRhaW5lckZpYmVyLmNoaWxkLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICB9LFxuXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlOiBmaW5kSG9zdEluc3RhbmNlLFxuXG4gICAgZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG4gICAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG4gICAgfSxcbiAgICBpbmplY3RJbnRvRGV2VG9vbHM6IGZ1bmN0aW9uIChkZXZUb29sc0NvbmZpZykge1xuICAgICAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG5cbiAgICAgIHJldHVybiBpbmplY3RJbnRlcm5hbHMoX2Fzc2lnbih7fSwgZGV2VG9vbHNDb25maWcsIHtcbiAgICAgICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmaW5kSG9zdEluc3RhbmNlKGZpYmVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgICAgIGlmICghZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UpIHtcbiAgICAgICAgICAgIC8vIE1pZ2h0IG5vdCBiZSBpbXBsZW1lbnRlZCBieSB0aGUgcmVuZGVyZXIuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfTtcbn07XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDFcbn0pO1xuXG52YXIgUmVhY3RGaWJlclJlY29uY2lsZXIkMyA9ICggUmVhY3RGaWJlclJlY29uY2lsZXIkMiAmJiBSZWFjdEZpYmVyUmVjb25jaWxlciQxICkgfHwgUmVhY3RGaWJlclJlY29uY2lsZXIkMjtcblxuLy8gVE9ETzogYnVuZGxlIEZsb3cgdHlwZXMgd2l0aCB0aGUgcGFja2FnZS5cblxuXG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0UmVjb25jaWxlciA9IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RmliZXJSZWNvbmNpbGVyJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RmliZXJSZWNvbmNpbGVyJDM7XG5cbi8vIFRPRE86IHRoaXMgaXMgc3BlY2lhbCBiZWNhdXNlIGl0IGdldHMgaW1wb3J0ZWQgZHVyaW5nIGJ1aWxkLlxuXG52YXIgUmVhY3RWZXJzaW9uID0gJzE2LjEuMCc7XG5cbi8vIGEgcmVxdWVzdEFuaW1hdGlvbkZyYW1lLCBzdG9yaW5nIHRoZSB0aW1lIGZvciB0aGUgc3RhcnQgb2YgdGhlIGZyYW1lLCB0aGVuXG4vLyBzY2hlZHVsaW5nIGEgcG9zdE1lc3NhZ2Ugd2hpY2ggZ2V0cyBzY2hlZHVsZWQgYWZ0ZXIgcGFpbnQuIFdpdGhpbiB0aGVcbi8vIHBvc3RNZXNzYWdlIGhhbmRsZXIgZG8gYXMgbXVjaCB3b3JrIGFzIHBvc3NpYmxlIHVudGlsIHRpbWUgKyBmcmFtZSByYXRlLlxuLy8gQnkgc2VwYXJhdGluZyB0aGUgaWRsZSBjYWxsIGludG8gYSBzZXBhcmF0ZSBldmVudCB0aWNrIHdlIGVuc3VyZSB0aGF0XG4vLyBsYXlvdXQsIHBhaW50IGFuZCBvdGhlciBicm93c2VyIHdvcmsgaXMgY291bnRlZCBhZ2FpbnN0IHRoZSBhdmFpbGFibGUgdGltZS5cbi8vIFRoZSBmcmFtZSByYXRlIGlzIGR5bmFtaWNhbGx5IGFkanVzdGVkLlxuXG57XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkZXBlbmRzIG9uIHJlcXVlc3RBbmltYXRpb25GcmFtZS4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxudmFyIGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93ID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGVyZm9ybWFuY2Uubm93ID09PSAnZnVuY3Rpb24nO1xuXG52YXIgbm93ID0gdm9pZCAwO1xuaWYgKGhhc05hdGl2ZVBlcmZvcm1hbmNlTm93KSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGVyZm9ybWFuY2Uubm93KCk7XG4gIH07XG59IGVsc2Uge1xuICBub3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIERhdGUubm93KCk7XG4gIH07XG59XG5cbi8vIFRPRE86IFRoZXJlJ3Mgbm8gd2F5IHRvIGNhbmNlbCwgYmVjYXVzZSBGaWJlciBkb2Vzbid0IGF0bS5cbnZhciBySUMgPSB2b2lkIDA7XG5cbmlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHJJQyA9IGZ1bmN0aW9uIChmcmFtZUNhbGxiYWNrKSB7XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICBmcmFtZUNhbGxiYWNrKHtcbiAgICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBJbmZpbml0eTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIDA7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiByZXF1ZXN0SWRsZUNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gIC8vIFBvbHlmaWxsIHJlcXVlc3RJZGxlQ2FsbGJhY2suXG5cbiAgdmFyIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcblxuICB2YXIgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmUgPSAwO1xuICAvLyBXZSBzdGFydCBvdXQgYXNzdW1pbmcgdGhhdCB3ZSBydW4gYXQgMzBmcHMgYnV0IHRoZW4gdGhlIGhldXJpc3RpYyB0cmFja2luZ1xuICAvLyB3aWxsIGFkanVzdCB0aGlzIHZhbHVlIHRvIGEgZmFzdGVyIGZwcyBpZiB3ZSBnZXQgbW9yZSBmcmVxdWVudCBhbmltYXRpb25cbiAgLy8gZnJhbWVzLlxuICB2YXIgcHJldmlvdXNGcmFtZVRpbWUgPSAzMztcbiAgdmFyIGFjdGl2ZUZyYW1lVGltZSA9IDMzO1xuXG4gIHZhciBmcmFtZURlYWRsaW5lT2JqZWN0O1xuICBpZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgICBmcmFtZURlYWRsaW5lT2JqZWN0ID0ge1xuICAgICAgdGltZVJlbWFpbmluZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBXZSBhc3N1bWUgdGhhdCBpZiB3ZSBoYXZlIGEgcGVyZm9ybWFuY2UgdGltZXIgdGhhdCB0aGUgckFGIGNhbGxiYWNrXG4gICAgICAgIC8vIGdldHMgYSBwZXJmb3JtYW5jZSB0aW1lciB2YWx1ZS4gTm90IHN1cmUgaWYgdGhpcyBpcyBhbHdheXMgdHJ1ZS5cbiAgICAgICAgcmV0dXJuIGZyYW1lRGVhZGxpbmUgLSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIHRvIERhdGUubm93KClcbiAgICAgICAgcmV0dXJuIGZyYW1lRGVhZGxpbmUgLSBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvLyBXZSB1c2UgdGhlIHBvc3RNZXNzYWdlIHRyaWNrIHRvIGRlZmVyIGlkbGUgd29yayB1bnRpbCBhZnRlciB0aGUgcmVwYWludC5cbiAgdmFyIG1lc3NhZ2VLZXkgPSAnX19yZWFjdElkbGVDYWxsYmFjayQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG4gIHZhciBpZGxlVGljayA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChldmVudC5zb3VyY2UgIT09IHdpbmRvdyB8fCBldmVudC5kYXRhICE9PSBtZXNzYWdlS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlzSWRsZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgIHZhciBjYWxsYmFjayA9IHNjaGVkdWxlZFJJQ0NhbGxiYWNrO1xuICAgIHNjaGVkdWxlZFJJQ0NhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIGNhbGxiYWNrKGZyYW1lRGVhZGxpbmVPYmplY3QpO1xuICAgIH1cbiAgfTtcbiAgLy8gQXNzdW1lcyB0aGF0IHdlIGhhdmUgYWRkRXZlbnRMaXN0ZW5lciBpbiB0aGlzIGVudmlyb25tZW50LiBNaWdodCBuZWVkXG4gIC8vIHNvbWV0aGluZyBiZXR0ZXIgZm9yIG9sZCBJRS5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBpZGxlVGljaywgZmFsc2UpO1xuXG4gIHZhciBhbmltYXRpb25UaWNrID0gZnVuY3Rpb24gKHJhZlRpbWUpIHtcbiAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIG5leHRGcmFtZVRpbWUgPSByYWZUaW1lIC0gZnJhbWVEZWFkbGluZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAobmV4dEZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSAmJiBwcmV2aW91c0ZyYW1lVGltZSA8IGFjdGl2ZUZyYW1lVGltZSkge1xuICAgICAgaWYgKG5leHRGcmFtZVRpbWUgPCA4KSB7XG4gICAgICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFdlIGRvbid0IHN1cHBvcnQgaGlnaGVyIGZyYW1lIHJhdGVzIHRoYW4gMTIwaHouXG4gICAgICAgIC8vIElmIHdlIGdldCBsb3dlciB0aGFuIHRoYXQsIGl0IGlzIHByb2JhYmx5IGEgYnVnLlxuICAgICAgICBuZXh0RnJhbWVUaW1lID0gODtcbiAgICAgIH1cbiAgICAgIC8vIElmIG9uZSBmcmFtZSBnb2VzIGxvbmcsIHRoZW4gdGhlIG5leHQgb25lIGNhbiBiZSBzaG9ydCB0byBjYXRjaCB1cC5cbiAgICAgIC8vIElmIHR3byBmcmFtZXMgYXJlIHNob3J0IGluIGEgcm93LCB0aGVuIHRoYXQncyBhbiBpbmRpY2F0aW9uIHRoYXQgd2VcbiAgICAgIC8vIGFjdHVhbGx5IGhhdmUgYSBoaWdoZXIgZnJhbWUgcmF0ZSB0aGFuIHdoYXQgd2UncmUgY3VycmVudGx5IG9wdGltaXppbmcuXG4gICAgICAvLyBXZSBhZGp1c3Qgb3VyIGhldXJpc3RpYyBkeW5hbWljYWxseSBhY2NvcmRpbmdseS4gRm9yIGV4YW1wbGUsIGlmIHdlJ3JlXG4gICAgICAvLyBydW5uaW5nIG9uIDEyMGh6IGRpc3BsYXkgb3IgOTBoeiBWUiBkaXNwbGF5LlxuICAgICAgLy8gVGFrZSB0aGUgbWF4IG9mIHRoZSB0d28gaW4gY2FzZSBvbmUgb2YgdGhlbSB3YXMgYW4gYW5vbWFseSBkdWUgdG9cbiAgICAgIC8vIG1pc3NlZCBmcmFtZSBkZWFkbGluZXMuXG4gICAgICBhY3RpdmVGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lIDwgcHJldmlvdXNGcmFtZVRpbWUgPyBwcmV2aW91c0ZyYW1lVGltZSA6IG5leHRGcmFtZVRpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByZXZpb3VzRnJhbWVUaW1lID0gbmV4dEZyYW1lVGltZTtcbiAgICB9XG4gICAgZnJhbWVEZWFkbGluZSA9IHJhZlRpbWUgKyBhY3RpdmVGcmFtZVRpbWU7XG4gICAgaWYgKCFpc0lkbGVTY2hlZHVsZWQpIHtcbiAgICAgIGlzSWRsZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICB3aW5kb3cucG9zdE1lc3NhZ2UobWVzc2FnZUtleSwgJyonKTtcbiAgICB9XG4gIH07XG5cbiAgcklDID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2Ugb25seSBzY2hlZHVsZSBvbmUgY2FsbGJhY2sgYXQgYSB0aW1lIGJlY2F1c2UgdGhhdCdzXG4gICAgLy8gaG93IEZpYmVyIHVzZXMgaXQuXG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICBpZiAoIWlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQpIHtcbiAgICAgIC8vIElmIHJBRiBkaWRuJ3QgYWxyZWFkeSBzY2hlZHVsZSBvbmUsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBmcmFtZS5cbiAgICAgIC8vIFRPRE86IElmIHRoaXMgckFGIGRvZXNuJ3QgbWF0ZXJpYWxpemUgYmVjYXVzZSB0aGUgYnJvd3NlciB0aHJvdHRsZXMsIHdlXG4gICAgICAvLyBtaWdodCB3YW50IHRvIHN0aWxsIGhhdmUgc2V0VGltZW91dCB0cmlnZ2VyIHJJQyBhcyBhIGJhY2t1cCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgd2Uga2VlcCBwZXJmb3JtaW5nIHdvcmsuXG4gICAgICBpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRpb25UaWNrKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH07XG59IGVsc2Uge1xuICBySUMgPSByZXF1ZXN0SWRsZUNhbGxiYWNrO1xufVxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG4vLyBpc0F0dHJpYnV0ZU5hbWVTYWZlKCkgaXMgY3VycmVudGx5IGR1cGxpY2F0ZWQgaW4gRE9NTWFya3VwT3BlcmF0aW9ucy5cbi8vIFRPRE86IEZpbmQgYSBiZXR0ZXIgcGxhY2UgZm9yIHRoaXMuXG52YXIgVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVggPSBuZXcgUmVnRXhwKCdeWycgKyBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgJ11bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuZnVuY3Rpb24gaXNBdHRyaWJ1dGVOYW1lU2FmZShhdHRyaWJ1dGVOYW1lKSB7XG4gIGlmICh2YWxpZGF0ZWRBdHRyaWJ1dGVOYW1lQ2FjaGUuaGFzT3duUHJvcGVydHkoYXR0cmlidXRlTmFtZSkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgudGVzdChhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZVthdHRyaWJ1dGVOYW1lXSA9IHRydWU7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgbmFtZTogYCVzYCcsIGF0dHJpYnV0ZU5hbWUpO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLy8gc2hvdWxkSWdub3JlVmFsdWUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbmZ1bmN0aW9uIHNob3VsZElnbm9yZVZhbHVlKHByb3BlcnR5SW5mbywgdmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgfHwgcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSAmJiAhdmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSAmJiBpc05hTih2YWx1ZSkgfHwgcHJvcGVydHlJbmZvLmhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlICYmIHZhbHVlIDwgMSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gZmFsc2U7XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG5cblxuXG5cblxuLyoqXG4gKiBHZXQgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgXCJleHBlY3RlZFwiIGFyZ3VtZW50IGlzIHVzZWQgYXMgYSBoaW50IG9mIHdoYXQgdGhlIGV4cGVjdGVkIHZhbHVlIGlzLlxuICogU29tZSBwcm9wZXJ0aWVzIGhhdmUgbXVsdGlwbGUgZXF1aXZhbGVudCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kIHx8IHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuXG4gICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlKSB7XG4gICAgICAgICAgaWYgKG5vZGUuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICAgIC8vIFdlIGhhZCBhbiBhdHRyaWJ1dGUgYnV0IHNob3VsZG4ndCBoYXZlIGhhZCBvbmUsIHNvIHJlYWQgaXRcbiAgICAgICAgICAgIC8vIGZvciB0aGUgZXJyb3IgbWVzc2FnZS5cbiAgICAgICAgICAgIHJldHVybiBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgd2FzIGEgYm9vbGVhbiwgaXQgZG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgdmFsdWUgaXNcbiAgICAgICAgICAgIC8vIHRoZSBmYWN0IHRoYXQgd2UgaGF2ZSBpdCBpcyB0aGUgc2FtZSBhcyB0aGUgZXhwZWN0ZWQuXG4gICAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEV2ZW4gaWYgdGhpcyBwcm9wZXJ0eSB1c2VzIGEgbmFtZXNwYWNlIHdlIHVzZSBnZXRBdHRyaWJ1dGVcbiAgICAgICAgICAvLyBiZWNhdXNlIHdlIGFzc3VtZSBpdHMgbmFtZXNwYWNlZCBuYW1lIGlzIHRoZSBzYW1lIGFzIG91ciBjb25maWcuXG4gICAgICAgICAgLy8gVG8gdXNlIGdldEF0dHJpYnV0ZU5TIHdlIG5lZWQgdGhlIGxvY2FsIG5hbWUgd2hpY2ggd2UgZG9uJ3QgaGF2ZVxuICAgICAgICAgIC8vIGluIG91ciBjb25maWcgYXRtLlxuICAgICAgICAgIHN0cmluZ1ZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCBleHBlY3RlZCkpIHtcbiAgICAgICAgICByZXR1cm4gc3RyaW5nVmFsdWUgPT09IG51bGwgPyBleHBlY3RlZCA6IHN0cmluZ1ZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHN0cmluZ1ZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgYXR0cmlidXRlIG9uIGEgbm9kZS4gT25seSB1c2VkIGluIERFViBmb3IgU1NSIHZhbGlkYXRpb24uXG4gKiBUaGUgdGhpcmQgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuIFNvbWVcbiAqIGF0dHJpYnV0ZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgZXhwZWN0ZWQpIHtcbiAge1xuICAgIGlmICghaXNBdHRyaWJ1dGVOYW1lU2FmZShuYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIW5vZGUuaGFzQXR0cmlidXRlKG5hbWUpKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGw7XG4gICAgfVxuICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuICAgIGlmICh2YWx1ZSA9PT0gJycgKyBleHBlY3RlZCkge1xuICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHsqfSB2YWx1ZVxuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG5cbiAgaWYgKHByb3BlcnR5SW5mbyAmJiBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdmFsdWUpO1xuICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5KSB7XG4gICAgICAvLyBDb250cmFyeSB0byBgc2V0QXR0cmlidXRlYCwgb2JqZWN0IHByb3BlcnRpZXMgYXJlIHByb3Blcmx5XG4gICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICBub2RlW3Byb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWVdID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG4gICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgIC8vIGBzZXRBdHRyaWJ1dGVgIHdpdGggb2JqZWN0cyBiZWNvbWVzIG9ubHkgYFtvYmplY3RdYCBpbiBJRTgvOSxcbiAgICAgIC8vICgnJyArIHZhbHVlKSBtYWtlcyBpdCBvdXRwdXQgdGhlIGNvcnJlY3QgdG9TdHJpbmcoKS12YWx1ZS5cbiAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSB0cnVlKSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnICsgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpID8gdmFsdWUgOiBudWxsKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuZnVuY3Rpb24gc2V0VmFsdWVGb3JBdHRyaWJ1dGUobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gIH1cblxuICB7XG4gICAgXG4gIH1cbn1cblxuLyoqXG4gKiBEZWxldGVzIGFuIGF0dHJpYnV0ZXMgZnJvbSBhIG5vZGUuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICovXG5mdW5jdGlvbiBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lKSB7XG4gIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xufVxuXG4vKipcbiAqIERlbGV0ZXMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSkge1xuICB2YXIgcHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKG5hbWUpO1xuICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgbXV0YXRpb25NZXRob2Qobm9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIHZhciBwcm9wTmFtZSA9IHByb3BlcnR5SW5mby5wcm9wZXJ0eU5hbWU7XG4gICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSAnJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfVxufVxuXG52YXIgUmVhY3RDb250cm9sbGVkVmFsdWVQcm9wVHlwZXMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBudWxsXG59O1xuXG57XG4gIHZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAgIGJ1dHRvbjogdHJ1ZSxcbiAgICBjaGVja2JveDogdHJ1ZSxcbiAgICBpbWFnZTogdHJ1ZSxcbiAgICBoaWRkZW46IHRydWUsXG4gICAgcmFkaW86IHRydWUsXG4gICAgcmVzZXQ6IHRydWUsXG4gICAgc3VibWl0OiB0cnVlXG4gIH07XG5cbiAgdmFyIHByb3BUeXBlcyA9IHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgaGFzUmVhZE9ubHlWYWx1ZVtwcm9wcy50eXBlXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGB2YWx1ZWAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0VmFsdWVgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfSxcbiAgICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBwcm9wcy5vbkNoYW5nZSB8fCBwcm9wcy5yZWFkT25seSB8fCBwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ1lvdSBwcm92aWRlZCBhIGBjaGVja2VkYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRDaGVja2VkYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGxpbmtlZCBgdmFsdWVgIGF0dHJpYnV0ZSBmb3IgY29udHJvbGxlZCBmb3Jtcy4gWW91IHNob3VsZCBub3QgdXNlXG4gICAqIHRoaXMgb3V0c2lkZSBvZiB0aGUgUmVhY3RET00gY29udHJvbGxlZCBmb3JtIGNvbXBvbmVudHMuXG4gICAqL1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGZ1bmN0aW9uICh0YWdOYW1lLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIHByb3BzLCAncHJvcCcsIHRhZ05hbWUsIGdldFN0YWNrKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlID0gZmFsc2U7XG52YXIgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQgPSBmYWxzZTtcbnZhciBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGlzQ29udHJvbGxlZChwcm9wcykge1xuICB2YXIgdXNlc0NoZWNrZWQgPSBwcm9wcy50eXBlID09PSAnY2hlY2tib3gnIHx8IHByb3BzLnR5cGUgPT09ICdyYWRpbyc7XG4gIHJldHVybiB1c2VzQ2hlY2tlZCA/IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA6IHByb3BzLnZhbHVlICE9IG51bGw7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8aW5wdXQ+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgdGhlc2Ugb3B0aW9uYWxcbiAqIHByb3BzOiBgY2hlY2tlZGAsIGB2YWx1ZWAsIGBkZWZhdWx0Q2hlY2tlZGAsIGFuZCBgZGVmYXVsdFZhbHVlYC5cbiAqXG4gKiBJZiBgY2hlY2tlZGAgb3IgYHZhbHVlYCBhcmUgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9uc1xuICogdGhhdCBhZmZlY3QgdGhlIGNoZWNrZWQgc3RhdGUgb3IgdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgdGhleSBhcmUgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIG5vdFxuICogdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgcHJvcHMgbXVzdCBjaGFuZ2UgaW4gb3JkZXIgZm9yXG4gKiB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgYXMgdW5jaGVja2VkIChvciBgZGVmYXVsdENoZWNrZWRgKVxuICogd2l0aCBhbiBlbXB0eSB2YWx1ZSAob3IgYGRlZmF1bHRWYWx1ZWApLlxuICpcbiAqIFNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEyL1dELWh0bWw1LTIwMTIxMDI1L3RoZS1pbnB1dC1lbGVtZW50Lmh0bWxcbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuXG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHtcbiAgICAvLyBNYWtlIHN1cmUgd2Ugc2V0IC50eXBlIGJlZm9yZSBhbnkgb3RoZXIgcHJvcGVydGllcyAoc2V0dGluZyAudmFsdWVcbiAgICAvLyBiZWZvcmUgLnR5cGUgbWVhbnMgLnZhbHVlIGlzIGxvc3QgaW4gSUUxMSBhbmQgYmVsb3cpXG4gICAgdHlwZTogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnN0ZXAgYmVmb3JlIC52YWx1ZSAoc2V0dGluZyAudmFsdWUgYmVmb3JlIC5zdGVwXG4gICAgLy8gbWVhbnMgLnZhbHVlIGlzIHJvdW5kZWQgb24gbW91bnQsIGJhc2VkIHVwb24gc3RlcCBwcmVjaXNpb24pXG4gICAgc3RlcDogdW5kZWZpbmVkLFxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLm1pbiAmIC5tYXggYmVmb3JlIC52YWx1ZSAodG8gZW5zdXJlIHByb3BlciBvcmRlclxuICAgIC8vIGluIGNvcm5lciBjYXNlcyBzdWNoIGFzIG1pbiBvciBtYXggZGVyaXZpbmcgZnJvbSB2YWx1ZSwgZS5nLiBJc3N1ZSAjNzE3MClcbiAgICBtaW46IHVuZGVmaW5lZCxcbiAgICBtYXg6IHVuZGVmaW5lZFxuICB9LCBwcm9wcywge1xuICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgZGVmYXVsdFZhbHVlOiB1bmRlZmluZWQsXG4gICAgdmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsXG4gICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZFxuICB9KTtcblxuICByZXR1cm4gaG9zdFByb3BzO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlKGVsZW1lbnQsIHByb3BzKSB7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnaW5wdXQnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKTtcblxuICAgIGlmIChwcm9wcy5jaGVja2VkICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdENoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIGNoZWNrZWQgYW5kIGRlZmF1bHRDaGVja2VkIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSBjaGVja2VkIHByb3AsIG9yIHRoZSBkZWZhdWx0Q2hlY2tlZCBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGFuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMigpIHx8ICdBIGNvbXBvbmVudCcsIHByb3BzLnR5cGUpO1xuICAgICAgZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBjb250YWlucyBhbiBpbnB1dCBvZiB0eXBlICVzIHdpdGggYm90aCB2YWx1ZSBhbmQgZGVmYXVsdFZhbHVlIHByb3BzLiAnICsgJ0lucHV0IGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxDaGVja2VkOiBwcm9wcy5jaGVja2VkICE9IG51bGwgPyBwcm9wcy5jaGVja2VkIDogcHJvcHMuZGVmYXVsdENoZWNrZWQsXG4gICAgaW5pdGlhbFZhbHVlOiBwcm9wcy52YWx1ZSAhPSBudWxsID8gcHJvcHMudmFsdWUgOiBkZWZhdWx0VmFsdWUsXG4gICAgY29udHJvbGxlZDogaXNDb250cm9sbGVkKHByb3BzKVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIHZhciBjb250cm9sbGVkID0gaXNDb250cm9sbGVkKHByb3BzKTtcblxuICAgIGlmICghbm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgY29udHJvbGxlZCAmJiAhZGlkV2FyblVuY29udHJvbGxlZFRvQ29udHJvbGxlZCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0EgY29tcG9uZW50IGlzIGNoYW5naW5nIGFuIHVuY29udHJvbGxlZCBpbnB1dCBvZiB0eXBlICVzIHRvIGJlIGNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSB1bmNvbnRyb2xsZWQgdG8gY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuX3dyYXBwZXJTdGF0ZS5jb250cm9sbGVkICYmICFjb250cm9sbGVkICYmICFkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYSBjb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgdW5jb250cm9sbGVkLiAnICsgJ0lucHV0IGVsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gY29udHJvbGxlZCB0byB1bmNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLiAnICsgJ0RlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgaW5wdXQgJyArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4gTW9yZSBpbmZvOiBodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cyVzJywgcHJvcHMudHlwZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzKCkpO1xuICAgICAgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICBpZiAoY2hlY2tlZCAhPSBudWxsKSB7XG4gICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgaWYgKHZhbHVlID09PSAwICYmIG5vZGUudmFsdWUgPT09ICcnKSB7XG4gICAgICBub2RlLnZhbHVlID0gJzAnO1xuICAgICAgLy8gTm90ZTogSUU5IHJlcG9ydHMgYSBudW1iZXIgaW5wdXRzIGFzICd0ZXh0Jywgc28gY2hlY2sgcHJvcHMgaW5zdGVhZC5cbiAgICB9IGVsc2UgaWYgKHByb3BzLnR5cGUgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBTaW11bGF0ZSBgaW5wdXQudmFsdWVBc051bWJlcmAuIElFOSBkb2VzIG5vdCBzdXBwb3J0IGl0XG4gICAgICB2YXIgdmFsdWVBc051bWJlciA9IHBhcnNlRmxvYXQobm9kZS52YWx1ZSkgfHwgMDtcblxuICAgICAgaWYgKFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lXG4gICAgICB2YWx1ZSAhPSB2YWx1ZUFzTnVtYmVyIHx8XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlID09IHZhbHVlQXNOdW1iZXIgJiYgbm9kZS52YWx1ZSAhPSB2YWx1ZSkge1xuICAgICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS52YWx1ZSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIG5vZGUudmFsdWUgPSAnJyArIHZhbHVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAocHJvcHMudmFsdWUgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gSW4gQ2hyb21lLCBhc3NpZ25pbmcgZGVmYXVsdFZhbHVlIHRvIGNlcnRhaW4gaW5wdXQgdHlwZXMgdHJpZ2dlcnMgaW5wdXQgdmFsaWRhdGlvbi5cbiAgICAgIC8vIEZvciBudW1iZXIgaW5wdXRzLCB0aGUgZGlzcGxheSB2YWx1ZSBsb3NlcyB0cmFpbGluZyBkZWNpbWFsIHBvaW50cy4gRm9yIGVtYWlsIGlucHV0cyxcbiAgICAgIC8vIENocm9tZSByYWlzZXMgXCJUaGUgc3BlY2lmaWVkIHZhbHVlIDx4PiBpcyBub3QgYSB2YWxpZCBlbWFpbCBhZGRyZXNzXCIuXG4gICAgICAvL1xuICAgICAgLy8gSGVyZSB3ZSBjaGVjayB0byBzZWUgaWYgdGhlIGRlZmF1bHRWYWx1ZSBoYXMgYWN0dWFsbHkgY2hhbmdlZCwgYXZvaWRpbmcgdGhlc2UgcHJvYmxlbXNcbiAgICAgIC8vIHdoZW4gdGhlIHVzZXIgaXMgaW5wdXR0aW5nIHRleHRcbiAgICAgIC8vXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyNTNcbiAgICAgIGlmIChub2RlLmRlZmF1bHRWYWx1ZSAhPT0gJycgKyBwcm9wcy5kZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHByb3BzLmNoZWNrZWQgPT0gbnVsbCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRDaGVja2VkID0gISFwcm9wcy5kZWZhdWx0Q2hlY2tlZDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlcihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG5cbiAgLy8gRGV0YWNoIHZhbHVlIGZyb20gZGVmYXVsdFZhbHVlLiBXZSB3b24ndCBkbyBhbnl0aGluZyBpZiB3ZSdyZSB3b3JraW5nIG9uXG4gIC8vIHN1Ym1pdCBvciByZXNldCBpbnB1dHMgYXMgdGhvc2UgdmFsdWVzICYgZGVmYXVsdFZhbHVlcyBhcmUgbGlua2VkLiBUaGV5XG4gIC8vIGFyZSBub3QgcmVzZXRhYmxlIG5vZGVzIHNvIHRoaXMgb3BlcmF0aW9uIGRvZXNuJ3QgbWF0dGVyIGFuZCBhY3R1YWxseVxuICAvLyByZW1vdmVzIGJyb3dzZXItZGVmYXVsdCB2YWx1ZXMgKGVnIFwiU3VibWl0IFF1ZXJ5XCIpIHdoZW4gbm8gdmFsdWUgaXNcbiAgLy8gcHJvdmlkZWQuXG5cbiAgc3dpdGNoIChwcm9wcy50eXBlKSB7XG4gICAgY2FzZSAnc3VibWl0JzpcbiAgICBjYXNlICdyZXNldCc6XG4gICAgICBicmVhaztcbiAgICBjYXNlICdjb2xvcic6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUnOlxuICAgIGNhc2UgJ2RhdGV0aW1lLWxvY2FsJzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgY2FzZSAndGltZSc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgICAvLyBUaGlzIGZpeGVzIHRoZSBuby1zaG93IGlzc3VlIG9uIGlPUyBTYWZhcmkgYW5kIEFuZHJvaWQgQ2hyb21lOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjMzXG4gICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS5kZWZhdWx0VmFsdWU7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbm9kZS52YWx1ZSA9IG5vZGUudmFsdWU7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIC8vIE5vcm1hbGx5LCB3ZSdkIGp1c3QgZG8gYG5vZGUuY2hlY2tlZCA9IG5vZGUuY2hlY2tlZGAgdXBvbiBpbml0aWFsIG1vdW50LCBsZXNzIHRoaXMgYnVnXG4gIC8vIHRoaXMgaXMgbmVlZGVkIHRvIHdvcmsgYXJvdW5kIGEgY2hyb21lIGJ1ZyB3aGVyZSBzZXR0aW5nIGRlZmF1bHRDaGVja2VkXG4gIC8vIHdpbGwgc29tZXRpbWVzIGluZmx1ZW5jZSB0aGUgdmFsdWUgb2YgY2hlY2tlZCAoZXZlbiBhZnRlciBkZXRhY2htZW50KS5cbiAgLy8gUmVmZXJlbmNlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MDg0MTZcbiAgLy8gV2UgbmVlZCB0byB0ZW1wb3JhcmlseSB1bnNldCBuYW1lIHRvIGF2b2lkIGRpc3J1cHRpbmcgcmFkaW8gYnV0dG9uIGdyb3Vwcy5cbiAgdmFyIG5hbWUgPSBub2RlLm5hbWU7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9ICcnO1xuICB9XG4gIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhbm9kZS5kZWZhdWx0Q2hlY2tlZDtcbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBpZiAobmFtZSAhPT0gJycpIHtcbiAgICBub2RlLm5hbWUgPSBuYW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHVwZGF0ZVdyYXBwZXIobm9kZSwgcHJvcHMpO1xuICB1cGRhdGVOYW1lZENvdXNpbnMobm9kZSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVOYW1lZENvdXNpbnMocm9vdE5vZGUsIHByb3BzKSB7XG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHF1ZXJ5Um9vdCA9IHJvb3ROb2RlO1xuXG4gICAgd2hpbGUgKHF1ZXJ5Um9vdC5wYXJlbnROb2RlKSB7XG4gICAgICBxdWVyeVJvb3QgPSBxdWVyeVJvb3QucGFyZW50Tm9kZTtcbiAgICB9XG5cbiAgICAvLyBJZiBgcm9vdE5vZGUuZm9ybWAgd2FzIG5vbi1udWxsLCB0aGVuIHdlIGNvdWxkIHRyeSBgZm9ybS5lbGVtZW50c2AsXG4gICAgLy8gYnV0IHRoYXQgc29tZXRpbWVzIGJlaGF2ZXMgc3RyYW5nZWx5IGluIElFOC4gV2UgY291bGQgYWxzbyB0cnkgdXNpbmdcbiAgICAvLyBgZm9ybS5nZXRFbGVtZW50c0J5TmFtZWAsIGJ1dCB0aGF0IHdpbGwgb25seSByZXR1cm4gZGlyZWN0IGNoaWxkcmVuXG4gICAgLy8gYW5kIHdvbid0IGluY2x1ZGUgaW5wdXRzIHRoYXQgdXNlIHRoZSBIVE1MNSBgZm9ybT1gIGF0dHJpYnV0ZS4gU2luY2VcbiAgICAvLyB0aGUgaW5wdXQgbWlnaHQgbm90IGV2ZW4gYmUgaW4gYSBmb3JtLiBJdCBtaWdodCBub3QgZXZlbiBiZSBpbiB0aGVcbiAgICAvLyBkb2N1bWVudC4gTGV0J3MganVzdCB1c2UgdGhlIGxvY2FsIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3RcbiAgICAvLyBtaXNzIGFueXRoaW5nLlxuICAgIHZhciBncm91cCA9IHF1ZXJ5Um9vdC5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dFtuYW1lPScgKyBKU09OLnN0cmluZ2lmeSgnJyArIG5hbWUpICsgJ11bdHlwZT1cInJhZGlvXCJdJyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgb3RoZXJOb2RlID0gZ3JvdXBbaV07XG4gICAgICBpZiAob3RoZXJOb2RlID09PSByb290Tm9kZSB8fCBvdGhlck5vZGUuZm9ybSAhPT0gcm9vdE5vZGUuZm9ybSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBpZiByYWRpbyBidXR0b25zIHJlbmRlcmVkIGJ5IGRpZmZlcmVudCBjb3BpZXMgb2YgUmVhY3RcbiAgICAgIC8vIGFuZCB0aGUgc2FtZSBuYW1lIGFyZSByZW5kZXJlZCBpbnRvIHRoZSBzYW1lIGZvcm0gKHNhbWUgYXMgIzE5MzkpLlxuICAgICAgLy8gVGhhdCdzIHByb2JhYmx5IG9rYXk7IHdlIGRvbid0IHN1cHBvcnQgaXQganVzdCBhcyB3ZSBkb24ndCBzdXBwb3J0XG4gICAgICAvLyBtaXhpbmcgUmVhY3QgcmFkaW8gYnV0dG9ucyB3aXRoIG5vbi1SZWFjdCBvbmVzLlxuICAgICAgdmFyIG90aGVyUHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlJDEob3RoZXJOb2RlKTtcbiAgICAgICFvdGhlclByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogTWl4aW5nIFJlYWN0IGFuZCBub24tUmVhY3QgcmFkaW8gaW5wdXRzIHdpdGggdGhlIHNhbWUgYG5hbWVgIGlzIG5vdCBzdXBwb3J0ZWQuJykgOiB2b2lkIDA7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgY29udHJvbGxlZCByYWRpbyBidXR0b24gZ3JvdXAsIGZvcmNpbmcgdGhlIGlucHV0IHRoYXRcbiAgICAgIC8vIHdhcyBwcmV2aW91c2x5IGNoZWNrZWQgdG8gdXBkYXRlIHdpbGwgY2F1c2UgaXQgdG8gYmUgY29tZSByZS1jaGVja2VkXG4gICAgICAvLyBhcyBhcHByb3ByaWF0ZS5cbiAgICAgIHVwZGF0ZVdyYXBwZXIob3RoZXJOb2RlLCBvdGhlclByb3BzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gIC8vIGludmFsaWQgdHlwZXMgYXJlIGlnbm9yZWQuXG4gIC8vIFdlIGNhbiBzaWxlbnRseSBza2lwIHRoZW0gYmVjYXVzZSBpbnZhbGlkIERPTSBuZXN0aW5nIHdhcm5pbmdcbiAgLy8gY2F0Y2hlcyB0aGVzZSBjYXNlcyBpbiBGaWJlci5cbiAgUmVhY3QuQ2hpbGRyZW4uZm9yRWFjaChjaGlsZHJlbiwgZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgY29udGVudCArPSBjaGlsZDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYW4gPG9wdGlvbj4gaG9zdCBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcHMoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gIHtcbiAgICB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgLy8gdmFsdWU9XCJcIiBzaG91bGQgbWFrZSBhIHZhbHVlIGF0dHJpYnV0ZSAoIzYyMTkpXG4gIGlmIChwcm9wcy52YWx1ZSAhPSBudWxsKSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgcHJvcHMudmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBob3N0UHJvcHMgPSBfYXNzaWduKHsgY2hpbGRyZW46IHVuZGVmaW5lZCB9LCBwcm9wcyk7XG5cbiAgdmFyIGNvbnRlbnQgPSBmbGF0dGVuQ2hpbGRyZW4ocHJvcHMuY2hpbGRyZW4pO1xuXG4gIGlmIChjb250ZW50KSB7XG4gICAgaG9zdFByb3BzLmNoaWxkcmVuID0gY29udGVudDtcbiAgfVxuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxuXG57XG4gIHZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHZhciBvd25lck5hbWUgPSBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMygpO1xuICBpZiAob3duZXJOYW1lKSB7XG4gICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG93bmVyTmFtZSArICdgLic7XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICovXG5mdW5jdGlvbiBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcykge1xuICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygnc2VsZWN0JywgcHJvcHMsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB2YWx1ZVByb3BOYW1lcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wTmFtZSA9IHZhbHVlUHJvcE5hbWVzW2ldO1xuICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheShwcm9wc1twcm9wTmFtZV0pO1xuICAgIGlmIChwcm9wcy5tdWx0aXBsZSAmJiAhaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfSBlbHNlIGlmICghcHJvcHMubXVsdGlwbGUgJiYgaXNBcnJheSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKG5vZGUsIG11bHRpcGxlLCBwcm9wVmFsdWUsIHNldERlZmF1bHRTZWxlY3RlZCkge1xuICB2YXIgb3B0aW9ucyA9IG5vZGUub3B0aW9ucztcblxuICBpZiAobXVsdGlwbGUpIHtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZXMgPSBwcm9wVmFsdWU7XG4gICAgdmFyIHNlbGVjdGVkVmFsdWUgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBQcmVmaXggdG8gYXZvaWQgY2hhb3Mgd2l0aCBzcGVjaWFsIGtleXMuXG4gICAgICBzZWxlY3RlZFZhbHVlWyckJyArIHNlbGVjdGVkVmFsdWVzW2ldXSA9IHRydWU7XG4gICAgfVxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBvcHRpb25zLmxlbmd0aDsgX2krKykge1xuICAgICAgdmFyIHNlbGVjdGVkID0gc2VsZWN0ZWRWYWx1ZS5oYXNPd25Qcm9wZXJ0eSgnJCcgKyBvcHRpb25zW19pXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tfaV0uc2VsZWN0ZWQgIT09IHNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLnNlbGVjdGVkID0gc2VsZWN0ZWQ7XG4gICAgICB9XG4gICAgICBpZiAoc2VsZWN0ZWQgJiYgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gICAgICAgIG9wdGlvbnNbX2ldLmRlZmF1bHRTZWxlY3RlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIERvIG5vdCBzZXQgYHNlbGVjdC52YWx1ZWAgYXMgZXhhY3QgYmVoYXZpb3IgaXNuJ3QgY29uc2lzdGVudCBhY3Jvc3MgYWxsXG4gICAgLy8gYnJvd3NlcnMgZm9yIGFsbCBjYXNlcy5cbiAgICB2YXIgX3NlbGVjdGVkVmFsdWUgPSAnJyArIHByb3BWYWx1ZTtcbiAgICB2YXIgZGVmYXVsdFNlbGVjdGVkID0gbnVsbDtcbiAgICBmb3IgKHZhciBfaTIgPSAwOyBfaTIgPCBvcHRpb25zLmxlbmd0aDsgX2kyKyspIHtcbiAgICAgIGlmIChvcHRpb25zW19pMl0udmFsdWUgPT09IF9zZWxlY3RlZFZhbHVlKSB7XG4gICAgICAgIG9wdGlvbnNbX2kyXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgIGlmIChzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgICBvcHRpb25zW19pMl0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoZGVmYXVsdFNlbGVjdGVkID09PSBudWxsICYmICFvcHRpb25zW19pMl0uZGlzYWJsZWQpIHtcbiAgICAgICAgZGVmYXVsdFNlbGVjdGVkID0gb3B0aW9uc1tfaTJdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVmYXVsdFNlbGVjdGVkICE9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0U2VsZWN0ZWQuc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBob3N0IGNvbXBvbmVudCB0aGF0IGFsbG93cyBvcHRpb25hbGx5IHNldHRpbmcgdGhlXG4gKiBwcm9wcyBgdmFsdWVgIGFuZCBgZGVmYXVsdFZhbHVlYC4gSWYgYG11bHRpcGxlYCBpcyBmYWxzZSwgdGhlIHByb3AgbXVzdCBiZSBhXG4gKiBzdHJpbmdhYmxlLiBJZiBgbXVsdGlwbGVgIGlzIHRydWUsIHRoZSBwcm9wIG11c3QgYmUgYW4gYXJyYXkgb2Ygc3RyaW5nYWJsZXMuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgY2hhbmdlIHRoZVxuICogc2VsZWN0ZWQgb3B0aW9uIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICpcbiAqIElmIGl0IGlzIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIG9wdGlvbnMgd2lsbCBub3RcbiAqIHVwZGF0ZSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnMuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgb3B0aW9ucyB0byB1cGRhdGUuXG4gKlxuICogSWYgYGRlZmF1bHRWYWx1ZWAgaXMgcHJvdmlkZWQsIGFueSBvcHRpb25zIHdpdGggdGhlIHN1cHBsaWVkIHZhbHVlcyB3aWxsIGJlXG4gKiBzZWxlY3RlZC5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMihlbGVtZW50LCBwcm9wcykge1xuICByZXR1cm4gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBpbml0V3JhcHBlclN0YXRlJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgY2hlY2tTZWxlY3RQcm9wVHlwZXMocHJvcHMpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIG5vZGUuX3dyYXBwZXJTdGF0ZSA9IHtcbiAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICB3YXNNdWx0aXBsZTogISFwcm9wcy5tdWx0aXBsZVxuICB9O1xuXG4gIHtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdTZWxlY3QgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIHNlbGVjdCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycpO1xuICAgICAgZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlJDEgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLm11bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5kZWZhdWx0VmFsdWUsIHRydWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gIC8vIHRoaXMgdmFsdWUgZG93blxuICBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlID0gdW5kZWZpbmVkO1xuXG4gIHZhciB3YXNNdWx0aXBsZSA9IG5vZGUuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gISFwcm9wcy5tdWx0aXBsZTtcblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAod2FzTXVsdGlwbGUgIT09ICEhcHJvcHMubXVsdGlwbGUpIHtcbiAgICAvLyBGb3Igc2ltcGxpY2l0eSwgcmVhcHBseSBgZGVmYXVsdFZhbHVlYCBpZiBgbXVsdGlwbGVgIGlzIHRvZ2dsZWQuXG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJldmVydCB0aGUgc2VsZWN0IGJhY2sgdG8gaXRzIGRlZmF1bHQgdW5zZWxlY3RlZCBzdGF0ZS5cbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMubXVsdGlwbGUgPyBbXSA6ICcnLCBmYWxzZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuXG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCB2YWx1ZSwgZmFsc2UpO1xuICB9XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IGZhbHNlO1xuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8dGV4dGFyZWE+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xuXG5mdW5jdGlvbiBnZXRIb3N0UHJvcHMkMyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gICEocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIGRvZXMgbm90IG1ha2Ugc2Vuc2Ugb24gPHRleHRhcmVhPi4nKSA6IHZvaWQgMDtcblxuICAvLyBBbHdheXMgc2V0IGNoaWxkcmVuIHRvIHRoZSBzYW1lIHRoaW5nLiBJbiBJRTksIHRoZSBzZWxlY3Rpb24gcmFuZ2Ugd2lsbFxuICAvLyBnZXQgcmVzZXQgaWYgYHRleHRDb250ZW50YCBpcyBtdXRhdGVkLiAgV2UgY291bGQgYWRkIGEgY2hlY2sgaW4gc2V0VGV4dENvbnRlbnRcbiAgLy8gdG8gb25seSBzZXQgdGhlIHZhbHVlIGlmL3doZW4gdGhlIHZhbHVlIGRpZmZlcnMgZnJvbSB0aGUgbm9kZSB2YWx1ZSAod2hpY2ggd291bGRcbiAgLy8gY29tcGxldGVseSBzb2x2ZSB0aGlzIElFOSBidWcpLCBidXQgU2ViYXN0aWFuK1NvcGhpZSBzZWVtZWQgdG8gbGlrZSB0aGlzXG4gIC8vIHNvbHV0aW9uLiBUaGUgdmFsdWUgY2FuIGJlIGEgYm9vbGVhbiBvciBvYmplY3Qgc28gdGhhdCdzIHdoeSBpdCdzIGZvcmNlZFxuICAvLyB0byBiZSBhIHN0cmluZy5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe30sIHByb3BzLCB7XG4gICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICBjaGlsZHJlbjogJycgKyBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygndGV4dGFyZWEnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ1KTtcbiAgICBpZiAocHJvcHMudmFsdWUgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblZhbERlZmF1bHRWYWwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0YXJlYSBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgdGV4dGFyZWEgJyArICdhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsRGVmYXVsdFZhbCA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIHZhciBpbml0aWFsVmFsdWUgPSB2YWx1ZTtcblxuICAvLyBPbmx5IGJvdGhlciBmZXRjaGluZyBkZWZhdWx0IHZhbHVlIGlmIHdlJ3JlIGdvaW5nIHRvIHVzZSBpdFxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVXNlIHRoZSBgZGVmYXVsdFZhbHVlYCBvciBgdmFsdWVgIHByb3BzIGluc3RlYWQgb2Ygc2V0dGluZyAnICsgJ2NoaWxkcmVuIG9uIDx0ZXh0YXJlYT4uJyk7XG4gICAgICB9XG4gICAgICAhKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IHZvaWQgMDtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgICAhKGNoaWxkcmVuLmxlbmd0aCA8PSAxKSA/IGludmFyaWFudChmYWxzZSwgJzx0ZXh0YXJlYT4gY2FuIG9ubHkgaGF2ZSBhdCBtb3N0IG9uZSBjaGlsZC4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgaW5pdGlhbFZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICB9XG5cbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogJycgKyBpbml0aWFsVmFsdWVcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV3JhcHBlciQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAvLyBicm93c2VycyB0eXBpY2FsbHkgZG8gdGhpcyBhcyBuZWNlc3NhcnksIGpzZG9tIGRvZXNuJ3QuXG4gICAgdmFyIG5ld1ZhbHVlID0gJycgKyB2YWx1ZTtcblxuICAgIC8vIFRvIGF2b2lkIHNpZGUgZWZmZWN0cyAoc3VjaCBhcyBsb3NpbmcgdGV4dCBzZWxlY3Rpb24pLCBvbmx5IHNldCB2YWx1ZSBpZiBjaGFuZ2VkXG4gICAgaWYgKG5ld1ZhbHVlICE9PSBub2RlLnZhbHVlKSB7XG4gICAgICBub2RlLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgfVxuICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgbm9kZS5kZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdE1vdW50V3JhcHBlciQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgLy8gVGhpcyBpcyBpbiBwb3N0TW91bnQgYmVjYXVzZSB3ZSBuZWVkIGFjY2VzcyB0byB0aGUgRE9NIG5vZGUsIHdoaWNoIGlzIG5vdFxuICAvLyBhdmFpbGFibGUgdW50aWwgYWZ0ZXIgdGhlIGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgdmFyIHRleHRDb250ZW50ID0gbm9kZS50ZXh0Q29udGVudDtcblxuICAvLyBPbmx5IHNldCBub2RlLnZhbHVlIGlmIHRleHRDb250ZW50IGlzIGVxdWFsIHRvIHRoZSBleHBlY3RlZFxuICAvLyBpbml0aWFsIHZhbHVlLiBJbiBJRTEwL0lFMTEgdGhlcmUgaXMgYSBidWcgd2hlcmUgdGhlIHBsYWNlaG9sZGVyIGF0dHJpYnV0ZVxuICAvLyB3aWxsIHBvcHVsYXRlIHRleHRDb250ZW50IGFzIHdlbGwuXG4gIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEwMTUyNS9cbiAgaWYgKHRleHRDb250ZW50ID09PSBub2RlLl93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlKSB7XG4gICAgbm9kZS52YWx1ZSA9IHRleHRDb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBET00gY29tcG9uZW50IGlzIHN0aWxsIG1vdW50ZWQ7IHVwZGF0ZVxuICB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpO1xufVxuXG52YXIgSFRNTF9OQU1FU1BBQ0UkMSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sJztcbnZhciBNQVRIX05BTUVTUEFDRSA9ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJztcbnZhciBTVkdfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcblxudmFyIE5hbWVzcGFjZXMgPSB7XG4gIGh0bWw6IEhUTUxfTkFNRVNQQUNFJDEsXG4gIG1hdGhtbDogTUFUSF9OQU1FU1BBQ0UsXG4gIHN2ZzogU1ZHX05BTUVTUEFDRVxufTtcblxuLy8gQXNzdW1lcyB0aGVyZSBpcyBubyBwYXJlbnQgbmFtZXNwYWNlLlxuZnVuY3Rpb24gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3ZnJzpcbiAgICAgIHJldHVybiBTVkdfTkFNRVNQQUNFO1xuICAgIGNhc2UgJ21hdGgnOlxuICAgICAgcmV0dXJuIE1BVEhfTkFNRVNQQUNFO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gSFRNTF9OQU1FU1BBQ0UkMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpIHtcbiAgaWYgKHBhcmVudE5hbWVzcGFjZSA9PSBudWxsIHx8IHBhcmVudE5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UkMSkge1xuICAgIC8vIE5vIChvciBkZWZhdWx0KSBwYXJlbnQgbmFtZXNwYWNlOiBwb3RlbnRpYWwgZW50cnkgcG9pbnQuXG4gICAgcmV0dXJuIGdldEludHJpbnNpY05hbWVzcGFjZSh0eXBlKTtcbiAgfVxuICBpZiAocGFyZW50TmFtZXNwYWNlID09PSBTVkdfTkFNRVNQQUNFICYmIHR5cGUgPT09ICdmb3JlaWduT2JqZWN0Jykge1xuICAgIC8vIFdlJ3JlIGxlYXZpbmcgU1ZHLlxuICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG4gIC8vIEJ5IGRlZmF1bHQsIHBhc3MgbmFtZXNwYWNlIGJlbG93LlxuICByZXR1cm4gcGFyZW50TmFtZXNwYWNlO1xufVxuXG4vKiBnbG9iYWxzIE1TQXBwICovXG5cbi8qKlxuICogQ3JlYXRlIGEgZnVuY3Rpb24gd2hpY2ggaGFzICd1bnNhZmUnIHByaXZpbGVnZXMgKHJlcXVpcmVkIGJ5IHdpbmRvd3M4IGFwcHMpXG4gKi9cbnZhciBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uID0gZnVuY3Rpb24gKGZ1bmMpIHtcbiAgaWYgKHR5cGVvZiBNU0FwcCAhPT0gJ3VuZGVmaW5lZCcgJiYgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jO1xuICB9XG59O1xuXG4vLyBTVkcgdGVtcCBjb250YWluZXIgZm9yIElFIGxhY2tpbmcgaW5uZXJIVE1MXG52YXIgcmV1c2FibGVTVkdDb250YWluZXIgPSB2b2lkIDA7XG5cbi8qKlxuICogU2V0IHRoZSBpbm5lckhUTUwgcHJvcGVydHkgb2YgYSBub2RlXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBjcmVhdGVNaWNyb3NvZnRVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gIC8vIElFIGRvZXMgbm90IGhhdmUgaW5uZXJIVE1MIGZvciBTVkcgbm9kZXMsIHNvIGluc3RlYWQgd2UgaW5qZWN0IHRoZVxuICAvLyBuZXcgbWFya3VwIGluIGEgdGVtcCBub2RlIGFuZCB0aGVuIG1vdmUgdGhlIGNoaWxkIG5vZGVzIGFjcm9zcyBpbnRvXG4gIC8vIHRoZSB0YXJnZXQgbm9kZVxuXG4gIGlmIChub2RlLm5hbWVzcGFjZVVSSSA9PT0gTmFtZXNwYWNlcy5zdmcgJiYgISgnaW5uZXJIVE1MJyBpbiBub2RlKSkge1xuICAgIHJldXNhYmxlU1ZHQ29udGFpbmVyID0gcmV1c2FibGVTVkdDb250YWluZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIuaW5uZXJIVE1MID0gJzxzdmc+JyArIGh0bWwgKyAnPC9zdmc+JztcbiAgICB2YXIgc3ZnTm9kZSA9IHJldXNhYmxlU1ZHQ29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUuZmlyc3RDaGlsZCkge1xuICAgICAgbm9kZS5yZW1vdmVDaGlsZChub2RlLmZpcnN0Q2hpbGQpO1xuICAgIH1cbiAgICB3aGlsZSAoc3ZnTm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLmFwcGVuZENoaWxkKHN2Z05vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgfVxufSk7XG5cbi8vIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBtYXRjaEh0bWxSZWdFeHAgPSAvW1wiJyY8Pl0vO1xuXG4vKipcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxuICpcbiAqIEBwYXJhbSAge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gZXNjYXBlIGZvciBpbnNlcnRpbmcgaW50byBIVE1MXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlSHRtbChzdHJpbmcpIHtcbiAgdmFyIHN0ciA9ICcnICsgc3RyaW5nO1xuICB2YXIgbWF0Y2ggPSBtYXRjaEh0bWxSZWdFeHAuZXhlYyhzdHIpO1xuXG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG5cbiAgdmFyIGVzY2FwZTtcbiAgdmFyIGh0bWwgPSAnJztcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIGxhc3RJbmRleCA9IDA7XG5cbiAgZm9yIChpbmRleCA9IG1hdGNoLmluZGV4OyBpbmRleCA8IHN0ci5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBzd2l0Y2ggKHN0ci5jaGFyQ29kZUF0KGluZGV4KSkge1xuICAgICAgY2FzZSAzNDpcbiAgICAgICAgLy8gXCJcbiAgICAgICAgZXNjYXBlID0gJyZxdW90Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzODpcbiAgICAgICAgLy8gJlxuICAgICAgICBlc2NhcGUgPSAnJmFtcDsnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzk6XG4gICAgICAgIC8vICdcbiAgICAgICAgZXNjYXBlID0gJyYjeDI3Oyc7IC8vIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWw7IHVzZWQgdG8gYmUgJyYjMzknXG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MDpcbiAgICAgICAgLy8gPFxuICAgICAgICBlc2NhcGUgPSAnJmx0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA2MjpcbiAgICAgICAgLy8gPlxuICAgICAgICBlc2NhcGUgPSAnJmd0Oyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKGxhc3RJbmRleCAhPT0gaW5kZXgpIHtcbiAgICAgIGh0bWwgKz0gc3RyLnN1YnN0cmluZyhsYXN0SW5kZXgsIGluZGV4KTtcbiAgICB9XG5cbiAgICBsYXN0SW5kZXggPSBpbmRleCArIDE7XG4gICAgaHRtbCArPSBlc2NhcGU7XG4gIH1cblxuICByZXR1cm4gbGFzdEluZGV4ICE9PSBpbmRleCA/IGh0bWwgKyBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpIDogaHRtbDtcbn1cbi8vIGVuZCBjb2RlIGNvcGllZCBhbmQgbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbFxuXG4vKipcbiAqIEVzY2FwZXMgdGV4dCB0byBwcmV2ZW50IHNjcmlwdGluZyBhdHRhY2tzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBUZXh0IHZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSB7XG4gIGlmICh0eXBlb2YgdGV4dCA9PT0gJ2Jvb2xlYW4nIHx8IHR5cGVvZiB0ZXh0ID09PSAnbnVtYmVyJykge1xuICAgIC8vIHRoaXMgc2hvcnRjaXJjdWl0IGhlbHBzIHBlcmYgZm9yIHR5cGVzIHRoYXQgd2Uga25vdyB3aWxsIG5ldmVyIGhhdmVcbiAgICAvLyBzcGVjaWFsIGNoYXJhY3RlcnMsIGVzcGVjaWFsbHkgZ2l2ZW4gdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIHVzZWQgb2Z0ZW5cbiAgICAvLyBmb3IgbnVtZXJpYyBkb20gaWRzLlxuICAgIHJldHVybiAnJyArIHRleHQ7XG4gIH1cbiAgcmV0dXJuIGVzY2FwZUh0bWwodGV4dCk7XG59XG5cbi8qKlxuICogU2V0IHRoZSB0ZXh0Q29udGVudCBwcm9wZXJ0eSBvZiBhIG5vZGUsIGVuc3VyaW5nIHRoYXQgd2hpdGVzcGFjZSBpcyBwcmVzZXJ2ZWRcbiAqIGV2ZW4gaW4gSUU4LiBpbm5lclRleHQgaXMgYSBwb29yIHN1YnN0aXR1dGUgZm9yIHRleHRDb250ZW50IGFuZCwgYW1vbmcgbWFueVxuICogaXNzdWVzLCBpbnNlcnRzIDxicj4gaW5zdGVhZCBvZiB0aGUgbGl0ZXJhbCBuZXdsaW5lIGNoYXJzLiBpbm5lckhUTUwgYmVoYXZlc1xuICogYXMgaXQgc2hvdWxkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgc2V0VGV4dENvbnRlbnQgPSBmdW5jdGlvbiAobm9kZSwgdGV4dCkge1xuICBpZiAodGV4dCkge1xuICAgIHZhciBmaXJzdENoaWxkID0gbm9kZS5maXJzdENoaWxkO1xuXG4gICAgaWYgKGZpcnN0Q2hpbGQgJiYgZmlyc3RDaGlsZCA9PT0gbm9kZS5sYXN0Q2hpbGQgJiYgZmlyc3RDaGlsZC5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICBmaXJzdENoaWxkLm5vZGVWYWx1ZSA9IHRleHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc2V0SW5uZXJIVE1MKG5vZGUsIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3Nlcih0ZXh0KSk7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgc2V0VGV4dENvbnRlbnQkMSA9IHNldFRleHRDb250ZW50O1xuXG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHdoaWNoIGFjY2VwdCBudW1iZXJzIGJ1dCBhcmUgbm90IGluIHVuaXRzIG9mIFwicHhcIi5cbiAqL1xudmFyIGlzVW5pdGxlc3NOdW1iZXIgPSB7XG4gIGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiB0cnVlLFxuICBib3JkZXJJbWFnZU91dHNldDogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VTbGljZTogdHJ1ZSxcbiAgYm9yZGVySW1hZ2VXaWR0aDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBjb2x1bW5zOiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZ3JpZFJvdzogdHJ1ZSxcbiAgZ3JpZFJvd0VuZDogdHJ1ZSxcbiAgZ3JpZFJvd1NwYW46IHRydWUsXG4gIGdyaWRSb3dTdGFydDogdHJ1ZSxcbiAgZ3JpZENvbHVtbjogdHJ1ZSxcbiAgZ3JpZENvbHVtbkVuZDogdHJ1ZSxcbiAgZ3JpZENvbHVtblNwYW46IHRydWUsXG4gIGdyaWRDb2x1bW5TdGFydDogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgZmxvb2RPcGFjaXR5OiB0cnVlLFxuICBzdG9wT3BhY2l0eTogdHJ1ZSxcbiAgc3Ryb2tlRGFzaGFycmF5OiB0cnVlLFxuICBzdHJva2VEYXNob2Zmc2V0OiB0cnVlLFxuICBzdHJva2VNaXRlcmxpbWl0OiB0cnVlLFxuICBzdHJva2VPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VXaWR0aDogdHJ1ZVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gcHJlZml4IHZlbmRvci1zcGVjaWZpYyBwcmVmaXgsIGVnOiBXZWJraXRcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgc3R5bGUgbmFtZSwgZWc6IHRyYW5zaXRpb25EdXJhdGlvblxuICogQHJldHVybiB7c3RyaW5nfSBzdHlsZSBuYW1lIHByZWZpeGVkIHdpdGggYHByZWZpeGAsIHByb3Blcmx5IGNhbWVsQ2FzZWQsIGVnOlxuICogV2Via2l0VHJhbnNpdGlvbkR1cmF0aW9uXG4gKi9cbmZ1bmN0aW9uIHByZWZpeEtleShwcmVmaXgsIGtleSkge1xuICByZXR1cm4gcHJlZml4ICsga2V5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsga2V5LnN1YnN0cmluZygxKTtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHN0eWxlIG5hbWVzIHRoYXQgbWF5IGNvbWUgcGFzc2VkIGluIHByZWZpeGVkIGJ5IGFkZGluZyBwZXJtdXRhdGlvbnNcbiAqIG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHByZWZpeGVzID0gWydXZWJraXQnLCAnbXMnLCAnTW96JywgJ08nXTtcblxuLy8gVXNpbmcgT2JqZWN0LmtleXMgaGVyZSwgb3IgZWxzZSB0aGUgdmFuaWxsYSBmb3ItaW4gbG9vcCBtYWtlcyBJRTggZ28gaW50byBhblxuLy8gaW5maW5pdGUgbG9vcCwgYmVjYXVzZSBpdCBpdGVyYXRlcyBvdmVyIHRoZSBuZXdseSBhZGRlZCBwcm9wcyB0b28uXG5PYmplY3Qua2V5cyhpc1VuaXRsZXNzTnVtYmVyKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wKSB7XG4gIHByZWZpeGVzLmZvckVhY2goZnVuY3Rpb24gKHByZWZpeCkge1xuICAgIGlzVW5pdGxlc3NOdW1iZXJbcHJlZml4S2V5KHByZWZpeCwgcHJvcCldID0gaXNVbml0bGVzc051bWJlcltwcm9wXTtcbiAgfSk7XG59KTtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgaWYgKCFpc0N1c3RvbVByb3BlcnR5ICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgdmFsdWUgIT09IDAgJiYgIShpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pKSB7XG4gICAgcmV0dXJuIHZhbHVlICsgJ3B4JzsgLy8gUHJlc3VtZXMgaW1wbGljaXQgJ3B4JyBzdWZmaXggZm9yIHVuaXRsZXNzIG51bWJlcnNcbiAgfVxuXG4gIHJldHVybiAoJycgKyB2YWx1ZSkudHJpbSgpO1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUgPSBlbXB0eUZ1bmN0aW9uJDE7XG5cbntcbiAgLy8gJ21zVHJhbnNmb3JtJyBpcyBjb3JyZWN0LCBidXQgdGhlIG90aGVyIHByZWZpeGVzIHNob3VsZCBiZSBjYXBpdGFsaXplZFxuICB2YXIgYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuID0gL14oPzp3ZWJraXR8bW96fG8pW0EtWl0vO1xuXG4gIC8vIHN0eWxlIHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvblxuICB2YXIgYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuID0gLztcXHMqJC87XG5cbiAgdmFyIHdhcm5lZFN0eWxlTmFtZXMgPSB7fTtcbiAgdmFyIHdhcm5lZFN0eWxlVmFsdWVzID0ge307XG4gIHZhciB3YXJuZWRGb3JOYU5WYWx1ZSA9IGZhbHNlO1xuICB2YXIgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IGZhbHNlO1xuXG4gIHZhciB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnVW5zdXBwb3J0ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIGNhbWVsaXplU3R5bGVOYW1lKG5hbWUpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCB2ZW5kb3ItcHJlZml4ZWQgc3R5bGUgcHJvcGVydHkgJXMuIERpZCB5b3UgbWVhbiAlcz8lcycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRTdHlsZVZhbHVlcy5oYXNPd25Qcm9wZXJ0eSh2YWx1ZSkgJiYgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVWYWx1ZXNbdmFsdWVdID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCBcIlN0eWxlIHByb3BlcnR5IHZhbHVlcyBzaG91bGRuJ3QgY29udGFpbiBhIHNlbWljb2xvbi4gXCIgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4lcycsIG5hbWUsIHZhbHVlLnJlcGxhY2UoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLCAnJyksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZUlzTmFOID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JOYU5WYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvck5hTlZhbHVlID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnYE5hTmAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eSA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkRm9ySW5maW5pdHlWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZEZvckluZmluaXR5VmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgSW5maW5pdHlgIGlzIGFuIGludmFsaWQgdmFsdWUgZm9yIHRoZSBgJXNgIGNzcyBzdHlsZSBwcm9wZXJ0eS4lcycsIG5hbWUsIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmIChuYW1lLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgICB3YXJuSHlwaGVuYXRlZFN0eWxlTmFtZShuYW1lLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4udGVzdChuYW1lKSkge1xuICAgICAgd2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGlmIChpc05hTih2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc05hTihuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgICAgfSBlbHNlIGlmICghaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHdhcm5TdHlsZVZhbHVlSXNJbmZpbml0eShuYW1lLCB2YWx1ZSwgZ2V0U3RhY2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxudmFyIHdhcm5WYWxpZFN0eWxlJDEgPSB3YXJuVmFsaWRTdHlsZTtcblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggQ1NTIHByb3BlcnRpZXMuXG4gKi9cblxuLyoqXG4gKiBUaGlzIGNyZWF0ZXMgYSBzdHJpbmcgdGhhdCBpcyBleHBlY3RlZCB0byBiZSBlcXVpdmFsZW50IHRvIHRoZSBzdHlsZVxuICogYXR0cmlidXRlIGdlbmVyYXRlZCBieSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcuIEl0IGJ5LXBhc3NlcyB3YXJuaW5ncyBhbmRcbiAqIHNlY3VyaXR5IGNoZWNrcyBzbyBpdCdzIG5vdCBzYWZlIHRvIHVzZSB0aGlzIHZhbHVlIGZvciBhbnl0aGluZyBvdGhlciB0aGFuXG4gKiBjb21wYXJpc29uLiBJdCBpcyBvbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKHN0eWxlcykge1xuICB7XG4gICAgdmFyIHNlcmlhbGl6ZWQgPSAnJztcbiAgICB2YXIgZGVsaW1pdGVyID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAoc3R5bGVWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBpc0N1c3RvbVByb3BlcnR5ID0gc3R5bGVOYW1lLmluZGV4T2YoJy0tJykgPT09IDA7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGVsaW1pdGVyICsgaHlwaGVuYXRlU3R5bGVOYW1lKHN0eWxlTmFtZSkgKyAnOic7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUsIGlzQ3VzdG9tUHJvcGVydHkpO1xuXG4gICAgICAgIGRlbGltaXRlciA9ICc7JztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQgfHwgbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAqICcnIChlbXB0eSBzdHJpbmcpLCB0aGUgY29ycmVzcG9uZGluZyBzdHlsZSBwcm9wZXJ0eSB3aWxsIGJlIHVuc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtvYmplY3R9IHN0eWxlc1xuICovXG5mdW5jdGlvbiBzZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZXMsIGdldFN0YWNrKSB7XG4gIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gIGZvciAodmFyIHN0eWxlTmFtZSBpbiBzdHlsZXMpIHtcbiAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICB7XG4gICAgICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkpIHtcbiAgICAgICAgd2FyblZhbGlkU3R5bGUkMShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICAgIHZhciBzdHlsZVZhbHVlID0gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShzdHlsZU5hbWUsIHN0eWxlc1tzdHlsZU5hbWVdLCBpc0N1c3RvbVByb3BlcnR5KTtcbiAgICBpZiAoc3R5bGVOYW1lID09PSAnZmxvYXQnKSB7XG4gICAgICBzdHlsZU5hbWUgPSAnY3NzRmxvYXQnO1xuICAgIH1cbiAgICBpZiAoaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVOYW1lLCBzdHlsZVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVbc3R5bGVOYW1lXSA9IHN0eWxlVmFsdWU7XG4gICAgfVxuICB9XG59XG5cbi8vIEZvciBIVE1MLCBjZXJ0YWluIHRhZ3Mgc2hvdWxkIG9taXQgdGhlaXIgY2xvc2UgdGFnLiBXZSBrZWVwIGEgd2hpdGVsaXN0IGZvclxuLy8gdGhvc2Ugc3BlY2lhbC1jYXNlIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICBhcmVhOiB0cnVlLFxuICBiYXNlOiB0cnVlLFxuICBicjogdHJ1ZSxcbiAgY29sOiB0cnVlLFxuICBlbWJlZDogdHJ1ZSxcbiAgaHI6IHRydWUsXG4gIGltZzogdHJ1ZSxcbiAgaW5wdXQ6IHRydWUsXG4gIGtleWdlbjogdHJ1ZSxcbiAgbGluazogdHJ1ZSxcbiAgbWV0YTogdHJ1ZSxcbiAgcGFyYW06IHRydWUsXG4gIHNvdXJjZTogdHJ1ZSxcbiAgdHJhY2s6IHRydWUsXG4gIHdicjogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gX2Fzc2lnbih7XG4gIG1lbnVpdGVtOiB0cnVlXG59LCBvbWl0dGVkQ2xvc2VUYWdzKTtcblxudmFyIEhUTUwkMSA9ICdfX2h0bWwnO1xuXG5mdW5jdGlvbiBhc3NlcnRWYWxpZFByb3BzKHRhZywgcHJvcHMsIGdldFN0YWNrKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHZvaWRFbGVtZW50VGFnc1t0YWddKSB7XG4gICAgIShwcm9wcy5jaGlsZHJlbiA9PSBudWxsICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5laXRoZXIgaGF2ZSBgY2hpbGRyZW5gIG5vciB1c2UgYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIHRhZywgZ2V0U3RhY2soKSkgOiB2b2lkIDA7XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQ2FuIG9ubHkgc2V0IG9uZSBvZiBgY2hpbGRyZW5gIG9yIGBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAuJykgOiB2b2lkIDA7XG4gICAgISh0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIEhUTUwkMSBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBpbnZhcmlhbnQoZmFsc2UsICdgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgIG11c3QgYmUgaW4gdGhlIGZvcm0gYHtfX2h0bWw6IC4uLn1gLiBQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIHx8ICFwcm9wcy5jb250ZW50RWRpdGFibGUgfHwgcHJvcHMuY2hpbGRyZW4gPT0gbnVsbCwgJ0EgY29tcG9uZW50IGlzIGBjb250ZW50RWRpdGFibGVgIGFuZCBjb250YWlucyBgY2hpbGRyZW5gIG1hbmFnZWQgYnkgJyArICdSZWFjdC4gSXQgaXMgbm93IHlvdXIgcmVzcG9uc2liaWxpdHkgdG8gZ3VhcmFudGVlIHRoYXQgbm9uZSBvZiAnICsgJ3Rob3NlIG5vZGVzIGFyZSB1bmV4cGVjdGVkbHkgbW9kaWZpZWQgb3IgZHVwbGljYXRlZC4gVGhpcyBpcyAnICsgJ3Byb2JhYmx5IG5vdCBpbnRlbnRpb25hbC4lcycsIGdldFN0YWNrKCkpO1xuICB9XG4gICEocHJvcHMuc3R5bGUgPT0gbnVsbCB8fCB0eXBlb2YgcHJvcHMuc3R5bGUgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgbm90IGEgc3RyaW5nLiBGb3IgZXhhbXBsZSwgc3R5bGU9e3ttYXJnaW5SaWdodDogc3BhY2luZyArIFxcJ2VtXFwnfX0gd2hlbiB1c2luZyBKU1guJXMnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gaXNDdXN0b21Db21wb25lbnQodGFnTmFtZSwgcHJvcHMpIHtcbiAgaWYgKHRhZ05hbWUuaW5kZXhPZignLScpID09PSAtMSkge1xuICAgIHJldHVybiB0eXBlb2YgcHJvcHMuaXMgPT09ICdzdHJpbmcnO1xuICB9XG4gIHN3aXRjaCAodGFnTmFtZSkge1xuICAgIC8vIFRoZXNlIGFyZSByZXNlcnZlZCBTVkcgYW5kIE1hdGhNTCBlbGVtZW50cy5cbiAgICAvLyBXZSBkb24ndCBtaW5kIHRoaXMgd2hpdGVsaXN0IHRvbyBtdWNoIGJlY2F1c2Ugd2UgZXhwZWN0IGl0IHRvIG5ldmVyIGdyb3cuXG4gICAgLy8gVGhlIGFsdGVybmF0aXZlIGlzIHRvIHRyYWNrIHRoZSBuYW1lc3BhY2UgaW4gYSBmZXcgcGxhY2VzIHdoaWNoIGlzIGNvbnZvbHV0ZWQuXG4gICAgLy8gaHR0cHM6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9jdXN0b20vI2N1c3RvbS1lbGVtZW50cy1jb3JlLWNvbmNlcHRzXG4gICAgY2FzZSAnYW5ub3RhdGlvbi14bWwnOlxuICAgIGNhc2UgJ2NvbG9yLXByb2ZpbGUnOlxuICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXNyYyc6XG4gICAgY2FzZSAnZm9udC1mYWNlLXVyaSc6XG4gICAgY2FzZSAnZm9udC1mYWNlLWZvcm1hdCc6XG4gICAgY2FzZSAnZm9udC1mYWNlLW5hbWUnOlxuICAgIGNhc2UgJ21pc3NpbmctZ2x5cGgnOlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG52YXIgYXJpYVByb3BlcnRpZXMgPSB7XG4gICdhcmlhLWN1cnJlbnQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1kZXRhaWxzJzogMCxcbiAgJ2FyaWEtZGlzYWJsZWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1oaWRkZW4nOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1pbnZhbGlkJzogMCwgLy8gc3RhdGVcbiAgJ2FyaWEta2V5c2hvcnRjdXRzJzogMCxcbiAgJ2FyaWEtbGFiZWwnOiAwLFxuICAnYXJpYS1yb2xlZGVzY3JpcHRpb24nOiAwLFxuICAvLyBXaWRnZXQgQXR0cmlidXRlc1xuICAnYXJpYS1hdXRvY29tcGxldGUnOiAwLFxuICAnYXJpYS1jaGVja2VkJzogMCxcbiAgJ2FyaWEtZXhwYW5kZWQnOiAwLFxuICAnYXJpYS1oYXNwb3B1cCc6IDAsXG4gICdhcmlhLWxldmVsJzogMCxcbiAgJ2FyaWEtbW9kYWwnOiAwLFxuICAnYXJpYS1tdWx0aWxpbmUnOiAwLFxuICAnYXJpYS1tdWx0aXNlbGVjdGFibGUnOiAwLFxuICAnYXJpYS1vcmllbnRhdGlvbic6IDAsXG4gICdhcmlhLXBsYWNlaG9sZGVyJzogMCxcbiAgJ2FyaWEtcHJlc3NlZCc6IDAsXG4gICdhcmlhLXJlYWRvbmx5JzogMCxcbiAgJ2FyaWEtcmVxdWlyZWQnOiAwLFxuICAnYXJpYS1zZWxlY3RlZCc6IDAsXG4gICdhcmlhLXNvcnQnOiAwLFxuICAnYXJpYS12YWx1ZW1heCc6IDAsXG4gICdhcmlhLXZhbHVlbWluJzogMCxcbiAgJ2FyaWEtdmFsdWVub3cnOiAwLFxuICAnYXJpYS12YWx1ZXRleHQnOiAwLFxuICAvLyBMaXZlIFJlZ2lvbiBBdHRyaWJ1dGVzXG4gICdhcmlhLWF0b21pYyc6IDAsXG4gICdhcmlhLWJ1c3knOiAwLFxuICAnYXJpYS1saXZlJzogMCxcbiAgJ2FyaWEtcmVsZXZhbnQnOiAwLFxuICAvLyBEcmFnLWFuZC1Ecm9wIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtZHJvcGVmZmVjdCc6IDAsXG4gICdhcmlhLWdyYWJiZWQnOiAwLFxuICAvLyBSZWxhdGlvbnNoaXAgQXR0cmlidXRlc1xuICAnYXJpYS1hY3RpdmVkZXNjZW5kYW50JzogMCxcbiAgJ2FyaWEtY29sY291bnQnOiAwLFxuICAnYXJpYS1jb2xpbmRleCc6IDAsXG4gICdhcmlhLWNvbHNwYW4nOiAwLFxuICAnYXJpYS1jb250cm9scyc6IDAsXG4gICdhcmlhLWRlc2NyaWJlZGJ5JzogMCxcbiAgJ2FyaWEtZXJyb3JtZXNzYWdlJzogMCxcbiAgJ2FyaWEtZmxvd3RvJzogMCxcbiAgJ2FyaWEtbGFiZWxsZWRieSc6IDAsXG4gICdhcmlhLW93bnMnOiAwLFxuICAnYXJpYS1wb3NpbnNldCc6IDAsXG4gICdhcmlhLXJvd2NvdW50JzogMCxcbiAgJ2FyaWEtcm93aW5kZXgnOiAwLFxuICAnYXJpYS1yb3dzcGFuJzogMCxcbiAgJ2FyaWEtc2V0c2l6ZSc6IDBcbn07XG5cbnZhciB3YXJuZWRQcm9wZXJ0aWVzID0ge307XG52YXIgckFSSUEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciByQVJJQUNhbWVsID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnR5KHRhZ05hbWUsIG5hbWUpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwod2FybmVkUHJvcGVydGllcywgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHJBUklBQ2FtZWwudGVzdChuYW1lKSkge1xuICAgIHZhciBhcmlhTmFtZSA9ICdhcmlhLScgKyBuYW1lLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIGNvcnJlY3ROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkoYXJpYU5hbWUpID8gYXJpYU5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChjb3JyZWN0TmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBBUklBIGF0dHJpYnV0ZXMgZm9sbG93IHRoZSBwYXR0ZXJuIGFyaWEtKiBhbmQgbXVzdCBiZSBsb3dlcmNhc2UuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IGNvcnJlY3ROYW1lKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBBUklBIGF0dHJpYnV0ZSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIGNvcnJlY3ROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAockFSSUEudGVzdChuYW1lKSkge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgc3RhbmRhcmROYW1lID0gYXJpYVByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gbG93ZXJDYXNlZE5hbWUgOiBudWxsO1xuXG4gICAgLy8gSWYgdGhpcyBpcyBhbiBhcmlhLSogYXR0cmlidXRlLCBidXQgaXMgbm90IGxpc3RlZCBpbiB0aGUga25vd24gRE9NXG4gICAgLy8gRE9NIHByb3BlcnRpZXMsIHRoZW4gaXQgaXMgYW4gaW52YWxpZCBhcmlhLSogYXR0cmlidXRlLlxuICAgIGlmIChzdGFuZGFyZE5hbWUgPT0gbnVsbCkge1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIGFyaWEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uLlxuICAgIGlmIChuYW1lICE9PSBzdGFuZGFyZE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllc1tuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybkludmFsaWRBUklBUHJvcHModHlwZSwgcHJvcHMpIHtcbiAgdmFyIGludmFsaWRQcm9wcyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgIHZhciBpc1ZhbGlkID0gdmFsaWRhdGVQcm9wZXJ0eSh0eXBlLCBrZXkpO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgaW52YWxpZFByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSBpbnZhbGlkUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG5cbiAgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPT09IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmlhIHByb3AgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfSBlbHNlIGlmIChpbnZhbGlkUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcHMgJXMgb24gPCVzPiB0YWcuICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL2ludmFsaWQtYXJpYS1wcm9wJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpIHtcbiAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50KHR5cGUsIHByb3BzKSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcyk7XG59XG5cbnZhciBkaWRXYXJuVmFsdWVOdWxsID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMSgpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wZXJ0aWVzJDEodHlwZSwgcHJvcHMpIHtcbiAgaWYgKHR5cGUgIT09ICdpbnB1dCcgJiYgdHlwZSAhPT0gJ3RleHRhcmVhJyAmJiB0eXBlICE9PSAnc2VsZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChwcm9wcyAhPSBudWxsICYmIHByb3BzLnZhbHVlID09PSBudWxsICYmICFkaWRXYXJuVmFsdWVOdWxsKSB7XG4gICAgZGlkV2FyblZhbHVlTnVsbCA9IHRydWU7XG4gICAgaWYgKHR5cGUgPT09ICdzZWxlY3QnICYmIHByb3BzLm11bHRpcGxlKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnYHZhbHVlYCBwcm9wIG9uIGAlc2Agc2hvdWxkIG5vdCBiZSBudWxsLiAnICsgJ0NvbnNpZGVyIHVzaW5nIGFuIGVtcHR5IGFycmF5IHdoZW4gYG11bHRpcGxlYCBpcyBzZXQgdG8gYHRydWVgICcgKyAndG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCBmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgc3RyaW5nIHRvIGNsZWFyIHRoZSBjb21wb25lbnQgb3IgYHVuZGVmaW5lZGAgJyArICdmb3IgdW5jb250cm9sbGVkIGNvbXBvbmVudHMuJXMnLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDEoKSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFdoZW4gYWRkaW5nIGF0dHJpYnV0ZXMgdG8gdGhlIEhUTUwgb3IgU1ZHIHdoaXRlbGlzdCwgYmUgc3VyZSB0b1xuLy8gYWxzbyBhZGQgdGhlbSB0byB0aGlzIG1vZHVsZSB0byBlbnN1cmUgY2FzaW5nIGFuZCBpbmNvcnJlY3QgbmFtZVxuLy8gd2FybmluZ3MuXG52YXIgcG9zc2libGVTdGFuZGFyZE5hbWVzID0ge1xuICAvLyBIVE1MXG4gIGFjY2VwdDogJ2FjY2VwdCcsXG4gIGFjY2VwdGNoYXJzZXQ6ICdhY2NlcHRDaGFyc2V0JyxcbiAgJ2FjY2VwdC1jaGFyc2V0JzogJ2FjY2VwdENoYXJzZXQnLFxuICBhY2Nlc3NrZXk6ICdhY2Nlc3NLZXknLFxuICBhY3Rpb246ICdhY3Rpb24nLFxuICBhbGxvd2Z1bGxzY3JlZW46ICdhbGxvd0Z1bGxTY3JlZW4nLFxuICBhbHQ6ICdhbHQnLFxuICBhczogJ2FzJyxcbiAgYXN5bmM6ICdhc3luYycsXG4gIGF1dG9jYXBpdGFsaXplOiAnYXV0b0NhcGl0YWxpemUnLFxuICBhdXRvY29tcGxldGU6ICdhdXRvQ29tcGxldGUnLFxuICBhdXRvY29ycmVjdDogJ2F1dG9Db3JyZWN0JyxcbiAgYXV0b2ZvY3VzOiAnYXV0b0ZvY3VzJyxcbiAgYXV0b3BsYXk6ICdhdXRvUGxheScsXG4gIGF1dG9zYXZlOiAnYXV0b1NhdmUnLFxuICBjYXB0dXJlOiAnY2FwdHVyZScsXG4gIGNlbGxwYWRkaW5nOiAnY2VsbFBhZGRpbmcnLFxuICBjZWxsc3BhY2luZzogJ2NlbGxTcGFjaW5nJyxcbiAgY2hhbGxlbmdlOiAnY2hhbGxlbmdlJyxcbiAgY2hhcnNldDogJ2NoYXJTZXQnLFxuICBjaGVja2VkOiAnY2hlY2tlZCcsXG4gIGNoaWxkcmVuOiAnY2hpbGRyZW4nLFxuICBjaXRlOiAnY2l0ZScsXG4gICdjbGFzcyc6ICdjbGFzc05hbWUnLFxuICBjbGFzc2lkOiAnY2xhc3NJRCcsXG4gIGNsYXNzbmFtZTogJ2NsYXNzTmFtZScsXG4gIGNvbHM6ICdjb2xzJyxcbiAgY29sc3BhbjogJ2NvbFNwYW4nLFxuICBjb250ZW50OiAnY29udGVudCcsXG4gIGNvbnRlbnRlZGl0YWJsZTogJ2NvbnRlbnRFZGl0YWJsZScsXG4gIGNvbnRleHRtZW51OiAnY29udGV4dE1lbnUnLFxuICBjb250cm9sczogJ2NvbnRyb2xzJyxcbiAgY29udHJvbHNsaXN0OiAnY29udHJvbHNMaXN0JyxcbiAgY29vcmRzOiAnY29vcmRzJyxcbiAgY3Jvc3NvcmlnaW46ICdjcm9zc09yaWdpbicsXG4gIGRhbmdlcm91c2x5c2V0aW5uZXJodG1sOiAnZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGV0aW1lOiAnZGF0ZVRpbWUnLFxuICAnZGVmYXVsdCc6ICdkZWZhdWx0JyxcbiAgZGVmYXVsdGNoZWNrZWQ6ICdkZWZhdWx0Q2hlY2tlZCcsXG4gIGRlZmF1bHR2YWx1ZTogJ2RlZmF1bHRWYWx1ZScsXG4gIGRlZmVyOiAnZGVmZXInLFxuICBkaXI6ICdkaXInLFxuICBkaXNhYmxlZDogJ2Rpc2FibGVkJyxcbiAgZG93bmxvYWQ6ICdkb3dubG9hZCcsXG4gIGRyYWdnYWJsZTogJ2RyYWdnYWJsZScsXG4gIGVuY3R5cGU6ICdlbmNUeXBlJyxcbiAgJ2Zvcic6ICdodG1sRm9yJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBmb3JtbWV0aG9kOiAnZm9ybU1ldGhvZCcsXG4gIGZvcm1hY3Rpb246ICdmb3JtQWN0aW9uJyxcbiAgZm9ybWVuY3R5cGU6ICdmb3JtRW5jVHlwZScsXG4gIGZvcm1ub3ZhbGlkYXRlOiAnZm9ybU5vVmFsaWRhdGUnLFxuICBmb3JtdGFyZ2V0OiAnZm9ybVRhcmdldCcsXG4gIGZyYW1lYm9yZGVyOiAnZnJhbWVCb3JkZXInLFxuICBoZWFkZXJzOiAnaGVhZGVycycsXG4gIGhlaWdodDogJ2hlaWdodCcsXG4gIGhpZGRlbjogJ2hpZGRlbicsXG4gIGhpZ2g6ICdoaWdoJyxcbiAgaHJlZjogJ2hyZWYnLFxuICBocmVmbGFuZzogJ2hyZWZMYW5nJyxcbiAgaHRtbGZvcjogJ2h0bWxGb3InLFxuICBodHRwZXF1aXY6ICdodHRwRXF1aXYnLFxuICAnaHR0cC1lcXVpdic6ICdodHRwRXF1aXYnLFxuICBpY29uOiAnaWNvbicsXG4gIGlkOiAnaWQnLFxuICBpbm5lcmh0bWw6ICdpbm5lckhUTUwnLFxuICBpbnB1dG1vZGU6ICdpbnB1dE1vZGUnLFxuICBpbnRlZ3JpdHk6ICdpbnRlZ3JpdHknLFxuICBpczogJ2lzJyxcbiAgaXRlbWlkOiAnaXRlbUlEJyxcbiAgaXRlbXByb3A6ICdpdGVtUHJvcCcsXG4gIGl0ZW1yZWY6ICdpdGVtUmVmJyxcbiAgaXRlbXNjb3BlOiAnaXRlbVNjb3BlJyxcbiAgaXRlbXR5cGU6ICdpdGVtVHlwZScsXG4gIGtleXBhcmFtczogJ2tleVBhcmFtcycsXG4gIGtleXR5cGU6ICdrZXlUeXBlJyxcbiAga2luZDogJ2tpbmQnLFxuICBsYWJlbDogJ2xhYmVsJyxcbiAgbGFuZzogJ2xhbmcnLFxuICBsaXN0OiAnbGlzdCcsXG4gIGxvb3A6ICdsb29wJyxcbiAgbG93OiAnbG93JyxcbiAgbWFuaWZlc3Q6ICdtYW5pZmVzdCcsXG4gIG1hcmdpbndpZHRoOiAnbWFyZ2luV2lkdGgnLFxuICBtYXJnaW5oZWlnaHQ6ICdtYXJnaW5IZWlnaHQnLFxuICBtYXg6ICdtYXgnLFxuICBtYXhsZW5ndGg6ICdtYXhMZW5ndGgnLFxuICBtZWRpYTogJ21lZGlhJyxcbiAgbWVkaWFncm91cDogJ21lZGlhR3JvdXAnLFxuICBtZXRob2Q6ICdtZXRob2QnLFxuICBtaW46ICdtaW4nLFxuICBtaW5sZW5ndGg6ICdtaW5MZW5ndGgnLFxuICBtdWx0aXBsZTogJ211bHRpcGxlJyxcbiAgbXV0ZWQ6ICdtdXRlZCcsXG4gIG5hbWU6ICduYW1lJyxcbiAgbm9uY2U6ICdub25jZScsXG4gIG5vdmFsaWRhdGU6ICdub1ZhbGlkYXRlJyxcbiAgb3BlbjogJ29wZW4nLFxuICBvcHRpbXVtOiAnb3B0aW11bScsXG4gIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgcGxhY2Vob2xkZXI6ICdwbGFjZWhvbGRlcicsXG4gIHBsYXlzaW5saW5lOiAncGxheXNJbmxpbmUnLFxuICBwb3N0ZXI6ICdwb3N0ZXInLFxuICBwcmVsb2FkOiAncHJlbG9hZCcsXG4gIHByb2ZpbGU6ICdwcm9maWxlJyxcbiAgcmFkaW9ncm91cDogJ3JhZGlvR3JvdXAnLFxuICByZWFkb25seTogJ3JlYWRPbmx5JyxcbiAgcmVmZXJyZXJwb2xpY3k6ICdyZWZlcnJlclBvbGljeScsXG4gIHJlbDogJ3JlbCcsXG4gIHJlcXVpcmVkOiAncmVxdWlyZWQnLFxuICByZXZlcnNlZDogJ3JldmVyc2VkJyxcbiAgcm9sZTogJ3JvbGUnLFxuICByb3dzOiAncm93cycsXG4gIHJvd3NwYW46ICdyb3dTcGFuJyxcbiAgc2FuZGJveDogJ3NhbmRib3gnLFxuICBzY29wZTogJ3Njb3BlJyxcbiAgc2NvcGVkOiAnc2NvcGVkJyxcbiAgc2Nyb2xsaW5nOiAnc2Nyb2xsaW5nJyxcbiAgc2VhbWxlc3M6ICdzZWFtbGVzcycsXG4gIHNlbGVjdGVkOiAnc2VsZWN0ZWQnLFxuICBzaGFwZTogJ3NoYXBlJyxcbiAgc2l6ZTogJ3NpemUnLFxuICBzaXplczogJ3NpemVzJyxcbiAgc3BhbjogJ3NwYW4nLFxuICBzcGVsbGNoZWNrOiAnc3BlbGxDaGVjaycsXG4gIHNyYzogJ3NyYycsXG4gIHNyY2RvYzogJ3NyY0RvYycsXG4gIHNyY2xhbmc6ICdzcmNMYW5nJyxcbiAgc3Jjc2V0OiAnc3JjU2V0JyxcbiAgc3RhcnQ6ICdzdGFydCcsXG4gIHN0ZXA6ICdzdGVwJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgdGFiaW5kZXg6ICd0YWJJbmRleCcsXG4gIHRhcmdldDogJ3RhcmdldCcsXG4gIHRpdGxlOiAndGl0bGUnLFxuICB0eXBlOiAndHlwZScsXG4gIHVzZW1hcDogJ3VzZU1hcCcsXG4gIHZhbHVlOiAndmFsdWUnLFxuICB3aWR0aDogJ3dpZHRoJyxcbiAgd21vZGU6ICd3bW9kZScsXG4gIHdyYXA6ICd3cmFwJyxcblxuICAvLyBTVkdcbiAgYWJvdXQ6ICdhYm91dCcsXG4gIGFjY2VudGhlaWdodDogJ2FjY2VudEhlaWdodCcsXG4gICdhY2NlbnQtaGVpZ2h0JzogJ2FjY2VudEhlaWdodCcsXG4gIGFjY3VtdWxhdGU6ICdhY2N1bXVsYXRlJyxcbiAgYWRkaXRpdmU6ICdhZGRpdGl2ZScsXG4gIGFsaWdubWVudGJhc2VsaW5lOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICAnYWxpZ25tZW50LWJhc2VsaW5lJzogJ2FsaWdubWVudEJhc2VsaW5lJyxcbiAgYWxsb3dyZW9yZGVyOiAnYWxsb3dSZW9yZGVyJyxcbiAgYWxwaGFiZXRpYzogJ2FscGhhYmV0aWMnLFxuICBhbXBsaXR1ZGU6ICdhbXBsaXR1ZGUnLFxuICBhcmFiaWNmb3JtOiAnYXJhYmljRm9ybScsXG4gICdhcmFiaWMtZm9ybSc6ICdhcmFiaWNGb3JtJyxcbiAgYXNjZW50OiAnYXNjZW50JyxcbiAgYXR0cmlidXRlbmFtZTogJ2F0dHJpYnV0ZU5hbWUnLFxuICBhdHRyaWJ1dGV0eXBlOiAnYXR0cmlidXRlVHlwZScsXG4gIGF1dG9yZXZlcnNlOiAnYXV0b1JldmVyc2UnLFxuICBhemltdXRoOiAnYXppbXV0aCcsXG4gIGJhc2VmcmVxdWVuY3k6ICdiYXNlRnJlcXVlbmN5JyxcbiAgYmFzZWxpbmVzaGlmdDogJ2Jhc2VsaW5lU2hpZnQnLFxuICAnYmFzZWxpbmUtc2hpZnQnOiAnYmFzZWxpbmVTaGlmdCcsXG4gIGJhc2Vwcm9maWxlOiAnYmFzZVByb2ZpbGUnLFxuICBiYm94OiAnYmJveCcsXG4gIGJlZ2luOiAnYmVnaW4nLFxuICBiaWFzOiAnYmlhcycsXG4gIGJ5OiAnYnknLFxuICBjYWxjbW9kZTogJ2NhbGNNb2RlJyxcbiAgY2FwaGVpZ2h0OiAnY2FwSGVpZ2h0JyxcbiAgJ2NhcC1oZWlnaHQnOiAnY2FwSGVpZ2h0JyxcbiAgY2xpcDogJ2NsaXAnLFxuICBjbGlwcGF0aDogJ2NsaXBQYXRoJyxcbiAgJ2NsaXAtcGF0aCc6ICdjbGlwUGF0aCcsXG4gIGNsaXBwYXRodW5pdHM6ICdjbGlwUGF0aFVuaXRzJyxcbiAgY2xpcHJ1bGU6ICdjbGlwUnVsZScsXG4gICdjbGlwLXJ1bGUnOiAnY2xpcFJ1bGUnLFxuICBjb2xvcjogJ2NvbG9yJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgJ2NvbG9yLWludGVycG9sYXRpb24nOiAnY29sb3JJbnRlcnBvbGF0aW9uJyxcbiAgY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVyczogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJzogJ2NvbG9ySW50ZXJwb2xhdGlvbkZpbHRlcnMnLFxuICBjb2xvcnByb2ZpbGU6ICdjb2xvclByb2ZpbGUnLFxuICAnY29sb3ItcHJvZmlsZSc6ICdjb2xvclByb2ZpbGUnLFxuICBjb2xvcnJlbmRlcmluZzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgJ2NvbG9yLXJlbmRlcmluZyc6ICdjb2xvclJlbmRlcmluZycsXG4gIGNvbnRlbnRzY3JpcHR0eXBlOiAnY29udGVudFNjcmlwdFR5cGUnLFxuICBjb250ZW50c3R5bGV0eXBlOiAnY29udGVudFN0eWxlVHlwZScsXG4gIGN1cnNvcjogJ2N1cnNvcicsXG4gIGN4OiAnY3gnLFxuICBjeTogJ2N5JyxcbiAgZDogJ2QnLFxuICBkYXRhdHlwZTogJ2RhdGF0eXBlJyxcbiAgZGVjZWxlcmF0ZTogJ2RlY2VsZXJhdGUnLFxuICBkZXNjZW50OiAnZGVzY2VudCcsXG4gIGRpZmZ1c2Vjb25zdGFudDogJ2RpZmZ1c2VDb25zdGFudCcsXG4gIGRpcmVjdGlvbjogJ2RpcmVjdGlvbicsXG4gIGRpc3BsYXk6ICdkaXNwbGF5JyxcbiAgZGl2aXNvcjogJ2Rpdmlzb3InLFxuICBkb21pbmFudGJhc2VsaW5lOiAnZG9taW5hbnRCYXNlbGluZScsXG4gICdkb21pbmFudC1iYXNlbGluZSc6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgZHVyOiAnZHVyJyxcbiAgZHg6ICdkeCcsXG4gIGR5OiAnZHknLFxuICBlZGdlbW9kZTogJ2VkZ2VNb2RlJyxcbiAgZWxldmF0aW9uOiAnZWxldmF0aW9uJyxcbiAgZW5hYmxlYmFja2dyb3VuZDogJ2VuYWJsZUJhY2tncm91bmQnLFxuICAnZW5hYmxlLWJhY2tncm91bmQnOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gIGVuZDogJ2VuZCcsXG4gIGV4cG9uZW50OiAnZXhwb25lbnQnLFxuICBleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbG9wYWNpdHk6ICdmaWxsT3BhY2l0eScsXG4gICdmaWxsLW9wYWNpdHknOiAnZmlsbE9wYWNpdHknLFxuICBmaWxscnVsZTogJ2ZpbGxSdWxlJyxcbiAgJ2ZpbGwtcnVsZSc6ICdmaWxsUnVsZScsXG4gIGZpbHRlcjogJ2ZpbHRlcicsXG4gIGZpbHRlcnJlczogJ2ZpbHRlclJlcycsXG4gIGZpbHRlcnVuaXRzOiAnZmlsdGVyVW5pdHMnLFxuICBmbG9vZG9wYWNpdHk6ICdmbG9vZE9wYWNpdHknLFxuICAnZmxvb2Qtb3BhY2l0eSc6ICdmbG9vZE9wYWNpdHknLFxuICBmbG9vZGNvbG9yOiAnZmxvb2RDb2xvcicsXG4gICdmbG9vZC1jb2xvcic6ICdmbG9vZENvbG9yJyxcbiAgZm9jdXNhYmxlOiAnZm9jdXNhYmxlJyxcbiAgZm9udGZhbWlseTogJ2ZvbnRGYW1pbHknLFxuICAnZm9udC1mYW1pbHknOiAnZm9udEZhbWlseScsXG4gIGZvbnRzaXplOiAnZm9udFNpemUnLFxuICAnZm9udC1zaXplJzogJ2ZvbnRTaXplJyxcbiAgZm9udHNpemVhZGp1c3Q6ICdmb250U2l6ZUFkanVzdCcsXG4gICdmb250LXNpemUtYWRqdXN0JzogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgZm9udHN0cmV0Y2g6ICdmb250U3RyZXRjaCcsXG4gICdmb250LXN0cmV0Y2gnOiAnZm9udFN0cmV0Y2gnLFxuICBmb250c3R5bGU6ICdmb250U3R5bGUnLFxuICAnZm9udC1zdHlsZSc6ICdmb250U3R5bGUnLFxuICBmb250dmFyaWFudDogJ2ZvbnRWYXJpYW50JyxcbiAgJ2ZvbnQtdmFyaWFudCc6ICdmb250VmFyaWFudCcsXG4gIGZvbnR3ZWlnaHQ6ICdmb250V2VpZ2h0JyxcbiAgJ2ZvbnQtd2VpZ2h0JzogJ2ZvbnRXZWlnaHQnLFxuICBmb3JtYXQ6ICdmb3JtYXQnLFxuICBmcm9tOiAnZnJvbScsXG4gIGZ4OiAnZngnLFxuICBmeTogJ2Z5JyxcbiAgZzE6ICdnMScsXG4gIGcyOiAnZzInLFxuICBnbHlwaG5hbWU6ICdnbHlwaE5hbWUnLFxuICAnZ2x5cGgtbmFtZSc6ICdnbHlwaE5hbWUnLFxuICBnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbDogJ2dseXBoT3JpZW50YXRpb25Ib3Jpem9udGFsJyxcbiAgJ2dseXBoLW9yaWVudGF0aW9uLWhvcml6b250YWwnOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICBnbHlwaG9yaWVudGF0aW9udmVydGljYWw6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnOiAnZ2x5cGhPcmllbnRhdGlvblZlcnRpY2FsJyxcbiAgZ2x5cGhyZWY6ICdnbHlwaFJlZicsXG4gIGdyYWRpZW50dHJhbnNmb3JtOiAnZ3JhZGllbnRUcmFuc2Zvcm0nLFxuICBncmFkaWVudHVuaXRzOiAnZ3JhZGllbnRVbml0cycsXG4gIGhhbmdpbmc6ICdoYW5naW5nJyxcbiAgaG9yaXphZHZ4OiAnaG9yaXpBZHZYJyxcbiAgJ2hvcml6LWFkdi14JzogJ2hvcml6QWR2WCcsXG4gIGhvcml6b3JpZ2lueDogJ2hvcml6T3JpZ2luWCcsXG4gICdob3Jpei1vcmlnaW4teCc6ICdob3Jpek9yaWdpblgnLFxuICBpZGVvZ3JhcGhpYzogJ2lkZW9ncmFwaGljJyxcbiAgaW1hZ2VyZW5kZXJpbmc6ICdpbWFnZVJlbmRlcmluZycsXG4gICdpbWFnZS1yZW5kZXJpbmcnOiAnaW1hZ2VSZW5kZXJpbmcnLFxuICBpbjI6ICdpbjInLFxuICAnaW4nOiAnaW4nLFxuICBpbmxpc3Q6ICdpbmxpc3QnLFxuICBpbnRlcmNlcHQ6ICdpbnRlcmNlcHQnLFxuICBrMTogJ2sxJyxcbiAgazI6ICdrMicsXG4gIGszOiAnazMnLFxuICBrNDogJ2s0JyxcbiAgazogJ2snLFxuICBrZXJuZWxtYXRyaXg6ICdrZXJuZWxNYXRyaXgnLFxuICBrZXJuZWx1bml0bGVuZ3RoOiAna2VybmVsVW5pdExlbmd0aCcsXG4gIGtlcm5pbmc6ICdrZXJuaW5nJyxcbiAga2V5cG9pbnRzOiAna2V5UG9pbnRzJyxcbiAga2V5c3BsaW5lczogJ2tleVNwbGluZXMnLFxuICBrZXl0aW1lczogJ2tleVRpbWVzJyxcbiAgbGVuZ3RoYWRqdXN0OiAnbGVuZ3RoQWRqdXN0JyxcbiAgbGV0dGVyc3BhY2luZzogJ2xldHRlclNwYWNpbmcnLFxuICAnbGV0dGVyLXNwYWNpbmcnOiAnbGV0dGVyU3BhY2luZycsXG4gIGxpZ2h0aW5nY29sb3I6ICdsaWdodGluZ0NvbG9yJyxcbiAgJ2xpZ2h0aW5nLWNvbG9yJzogJ2xpZ2h0aW5nQ29sb3InLFxuICBsaW1pdGluZ2NvbmVhbmdsZTogJ2xpbWl0aW5nQ29uZUFuZ2xlJyxcbiAgbG9jYWw6ICdsb2NhbCcsXG4gIG1hcmtlcmVuZDogJ21hcmtlckVuZCcsXG4gICdtYXJrZXItZW5kJzogJ21hcmtlckVuZCcsXG4gIG1hcmtlcmhlaWdodDogJ21hcmtlckhlaWdodCcsXG4gIG1hcmtlcm1pZDogJ21hcmtlck1pZCcsXG4gICdtYXJrZXItbWlkJzogJ21hcmtlck1pZCcsXG4gIG1hcmtlcnN0YXJ0OiAnbWFya2VyU3RhcnQnLFxuICAnbWFya2VyLXN0YXJ0JzogJ21hcmtlclN0YXJ0JyxcbiAgbWFya2VydW5pdHM6ICdtYXJrZXJVbml0cycsXG4gIG1hcmtlcndpZHRoOiAnbWFya2VyV2lkdGgnLFxuICBtYXNrOiAnbWFzaycsXG4gIG1hc2tjb250ZW50dW5pdHM6ICdtYXNrQ29udGVudFVuaXRzJyxcbiAgbWFza3VuaXRzOiAnbWFza1VuaXRzJyxcbiAgbWF0aGVtYXRpY2FsOiAnbWF0aGVtYXRpY2FsJyxcbiAgbW9kZTogJ21vZGUnLFxuICBudW1vY3RhdmVzOiAnbnVtT2N0YXZlcycsXG4gIG9mZnNldDogJ29mZnNldCcsXG4gIG9wYWNpdHk6ICdvcGFjaXR5JyxcbiAgb3BlcmF0b3I6ICdvcGVyYXRvcicsXG4gIG9yZGVyOiAnb3JkZXInLFxuICBvcmllbnQ6ICdvcmllbnQnLFxuICBvcmllbnRhdGlvbjogJ29yaWVudGF0aW9uJyxcbiAgb3JpZ2luOiAnb3JpZ2luJyxcbiAgb3ZlcmZsb3c6ICdvdmVyZmxvdycsXG4gIG92ZXJsaW5lcG9zaXRpb246ICdvdmVybGluZVBvc2l0aW9uJyxcbiAgJ292ZXJsaW5lLXBvc2l0aW9uJzogJ292ZXJsaW5lUG9zaXRpb24nLFxuICBvdmVybGluZXRoaWNrbmVzczogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgJ292ZXJsaW5lLXRoaWNrbmVzcyc6ICdvdmVybGluZVRoaWNrbmVzcycsXG4gIHBhaW50b3JkZXI6ICdwYWludE9yZGVyJyxcbiAgJ3BhaW50LW9yZGVyJzogJ3BhaW50T3JkZXInLFxuICBwYW5vc2UxOiAncGFub3NlMScsXG4gICdwYW5vc2UtMSc6ICdwYW5vc2UxJyxcbiAgcGF0aGxlbmd0aDogJ3BhdGhMZW5ndGgnLFxuICBwYXR0ZXJuY29udGVudHVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gIHBhdHRlcm50cmFuc2Zvcm06ICdwYXR0ZXJuVHJhbnNmb3JtJyxcbiAgcGF0dGVybnVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgcG9pbnRlcmV2ZW50czogJ3BvaW50ZXJFdmVudHMnLFxuICAncG9pbnRlci1ldmVudHMnOiAncG9pbnRlckV2ZW50cycsXG4gIHBvaW50czogJ3BvaW50cycsXG4gIHBvaW50c2F0eDogJ3BvaW50c0F0WCcsXG4gIHBvaW50c2F0eTogJ3BvaW50c0F0WScsXG4gIHBvaW50c2F0ejogJ3BvaW50c0F0WicsXG4gIHByZWZpeDogJ3ByZWZpeCcsXG4gIHByZXNlcnZlYWxwaGE6ICdwcmVzZXJ2ZUFscGhhJyxcbiAgcHJlc2VydmVhc3BlY3RyYXRpbzogJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLFxuICBwcmltaXRpdmV1bml0czogJ3ByaW1pdGl2ZVVuaXRzJyxcbiAgcHJvcGVydHk6ICdwcm9wZXJ0eScsXG4gIHI6ICdyJyxcbiAgcmFkaXVzOiAncmFkaXVzJyxcbiAgcmVmeDogJ3JlZlgnLFxuICByZWZ5OiAncmVmWScsXG4gIHJlbmRlcmluZ2ludGVudDogJ3JlbmRlcmluZ0ludGVudCcsXG4gICdyZW5kZXJpbmctaW50ZW50JzogJ3JlbmRlcmluZ0ludGVudCcsXG4gIHJlcGVhdGNvdW50OiAncmVwZWF0Q291bnQnLFxuICByZXBlYXRkdXI6ICdyZXBlYXREdXInLFxuICByZXF1aXJlZGV4dGVuc2lvbnM6ICdyZXF1aXJlZEV4dGVuc2lvbnMnLFxuICByZXF1aXJlZGZlYXR1cmVzOiAncmVxdWlyZWRGZWF0dXJlcycsXG4gIHJlc291cmNlOiAncmVzb3VyY2UnLFxuICByZXN0YXJ0OiAncmVzdGFydCcsXG4gIHJlc3VsdDogJ3Jlc3VsdCcsXG4gIHJlc3VsdHM6ICdyZXN1bHRzJyxcbiAgcm90YXRlOiAncm90YXRlJyxcbiAgcng6ICdyeCcsXG4gIHJ5OiAncnknLFxuICBzY2FsZTogJ3NjYWxlJyxcbiAgc2VjdXJpdHk6ICdzZWN1cml0eScsXG4gIHNlZWQ6ICdzZWVkJyxcbiAgc2hhcGVyZW5kZXJpbmc6ICdzaGFwZVJlbmRlcmluZycsXG4gICdzaGFwZS1yZW5kZXJpbmcnOiAnc2hhcGVSZW5kZXJpbmcnLFxuICBzbG9wZTogJ3Nsb3BlJyxcbiAgc3BhY2luZzogJ3NwYWNpbmcnLFxuICBzcGVjdWxhcmNvbnN0YW50OiAnc3BlY3VsYXJDb25zdGFudCcsXG4gIHNwZWN1bGFyZXhwb25lbnQ6ICdzcGVjdWxhckV4cG9uZW50JyxcbiAgc3BlZWQ6ICdzcGVlZCcsXG4gIHNwcmVhZG1ldGhvZDogJ3NwcmVhZE1ldGhvZCcsXG4gIHN0YXJ0b2Zmc2V0OiAnc3RhcnRPZmZzZXQnLFxuICBzdGRkZXZpYXRpb246ICdzdGREZXZpYXRpb24nLFxuICBzdGVtaDogJ3N0ZW1oJyxcbiAgc3RlbXY6ICdzdGVtdicsXG4gIHN0aXRjaHRpbGVzOiAnc3RpdGNoVGlsZXMnLFxuICBzdG9wY29sb3I6ICdzdG9wQ29sb3InLFxuICAnc3RvcC1jb2xvcic6ICdzdG9wQ29sb3InLFxuICBzdG9wb3BhY2l0eTogJ3N0b3BPcGFjaXR5JyxcbiAgJ3N0b3Atb3BhY2l0eSc6ICdzdG9wT3BhY2l0eScsXG4gIHN0cmlrZXRocm91Z2hwb3NpdGlvbjogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gICdzdHJpa2V0aHJvdWdoLXBvc2l0aW9uJzogJ3N0cmlrZXRocm91Z2hQb3NpdGlvbicsXG4gIHN0cmlrZXRocm91Z2h0aGlja25lc3M6ICdzdHJpa2V0aHJvdWdoVGhpY2tuZXNzJyxcbiAgJ3N0cmlrZXRocm91Z2gtdGhpY2tuZXNzJzogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICBzdHJpbmc6ICdzdHJpbmcnLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VkYXNoYXJyYXk6ICdzdHJva2VEYXNoYXJyYXknLFxuICAnc3Ryb2tlLWRhc2hhcnJheSc6ICdzdHJva2VEYXNoYXJyYXknLFxuICBzdHJva2VkYXNob2Zmc2V0OiAnc3Ryb2tlRGFzaG9mZnNldCcsXG4gICdzdHJva2UtZGFzaG9mZnNldCc6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgc3Ryb2tlbGluZWNhcDogJ3N0cm9rZUxpbmVjYXAnLFxuICAnc3Ryb2tlLWxpbmVjYXAnOiAnc3Ryb2tlTGluZWNhcCcsXG4gIHN0cm9rZWxpbmVqb2luOiAnc3Ryb2tlTGluZWpvaW4nLFxuICAnc3Ryb2tlLWxpbmVqb2luJzogJ3N0cm9rZUxpbmVqb2luJyxcbiAgc3Ryb2tlbWl0ZXJsaW1pdDogJ3N0cm9rZU1pdGVybGltaXQnLFxuICAnc3Ryb2tlLW1pdGVybGltaXQnOiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gIHN0cm9rZXdpZHRoOiAnc3Ryb2tlV2lkdGgnLFxuICAnc3Ryb2tlLXdpZHRoJzogJ3N0cm9rZVdpZHRoJyxcbiAgc3Ryb2tlb3BhY2l0eTogJ3N0cm9rZU9wYWNpdHknLFxuICAnc3Ryb2tlLW9wYWNpdHknOiAnc3Ryb2tlT3BhY2l0eScsXG4gIHN1cHByZXNzY29udGVudGVkaXRhYmxld2FybmluZzogJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZycsXG4gIHN1cHByZXNzaHlkcmF0aW9ud2FybmluZzogJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZycsXG4gIHN1cmZhY2VzY2FsZTogJ3N1cmZhY2VTY2FsZScsXG4gIHN5c3RlbWxhbmd1YWdlOiAnc3lzdGVtTGFuZ3VhZ2UnLFxuICB0YWJsZXZhbHVlczogJ3RhYmxlVmFsdWVzJyxcbiAgdGFyZ2V0eDogJ3RhcmdldFgnLFxuICB0YXJnZXR5OiAndGFyZ2V0WScsXG4gIHRleHRhbmNob3I6ICd0ZXh0QW5jaG9yJyxcbiAgJ3RleHQtYW5jaG9yJzogJ3RleHRBbmNob3InLFxuICB0ZXh0ZGVjb3JhdGlvbjogJ3RleHREZWNvcmF0aW9uJyxcbiAgJ3RleHQtZGVjb3JhdGlvbic6ICd0ZXh0RGVjb3JhdGlvbicsXG4gIHRleHRsZW5ndGg6ICd0ZXh0TGVuZ3RoJyxcbiAgdGV4dHJlbmRlcmluZzogJ3RleHRSZW5kZXJpbmcnLFxuICAndGV4dC1yZW5kZXJpbmcnOiAndGV4dFJlbmRlcmluZycsXG4gIHRvOiAndG8nLFxuICB0cmFuc2Zvcm06ICd0cmFuc2Zvcm0nLFxuICAndHlwZW9mJzogJ3R5cGVvZicsXG4gIHUxOiAndTEnLFxuICB1MjogJ3UyJyxcbiAgdW5kZXJsaW5lcG9zaXRpb246ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gICd1bmRlcmxpbmUtcG9zaXRpb24nOiAndW5kZXJsaW5lUG9zaXRpb24nLFxuICB1bmRlcmxpbmV0aGlja25lc3M6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICAndW5kZXJsaW5lLXRoaWNrbmVzcyc6ICd1bmRlcmxpbmVUaGlja25lc3MnLFxuICB1bmljb2RlOiAndW5pY29kZScsXG4gIHVuaWNvZGViaWRpOiAndW5pY29kZUJpZGknLFxuICAndW5pY29kZS1iaWRpJzogJ3VuaWNvZGVCaWRpJyxcbiAgdW5pY29kZXJhbmdlOiAndW5pY29kZVJhbmdlJyxcbiAgJ3VuaWNvZGUtcmFuZ2UnOiAndW5pY29kZVJhbmdlJyxcbiAgdW5pdHNwZXJlbTogJ3VuaXRzUGVyRW0nLFxuICAndW5pdHMtcGVyLWVtJzogJ3VuaXRzUGVyRW0nLFxuICB1bnNlbGVjdGFibGU6ICd1bnNlbGVjdGFibGUnLFxuICB2YWxwaGFiZXRpYzogJ3ZBbHBoYWJldGljJyxcbiAgJ3YtYWxwaGFiZXRpYyc6ICd2QWxwaGFiZXRpYycsXG4gIHZhbHVlczogJ3ZhbHVlcycsXG4gIHZlY3RvcmVmZmVjdDogJ3ZlY3RvckVmZmVjdCcsXG4gICd2ZWN0b3ItZWZmZWN0JzogJ3ZlY3RvckVmZmVjdCcsXG4gIHZlcnNpb246ICd2ZXJzaW9uJyxcbiAgdmVydGFkdnk6ICd2ZXJ0QWR2WScsXG4gICd2ZXJ0LWFkdi15JzogJ3ZlcnRBZHZZJyxcbiAgdmVydG9yaWdpbng6ICd2ZXJ0T3JpZ2luWCcsXG4gICd2ZXJ0LW9yaWdpbi14JzogJ3ZlcnRPcmlnaW5YJyxcbiAgdmVydG9yaWdpbnk6ICd2ZXJ0T3JpZ2luWScsXG4gICd2ZXJ0LW9yaWdpbi15JzogJ3ZlcnRPcmlnaW5ZJyxcbiAgdmhhbmdpbmc6ICd2SGFuZ2luZycsXG4gICd2LWhhbmdpbmcnOiAndkhhbmdpbmcnLFxuICB2aWRlb2dyYXBoaWM6ICd2SWRlb2dyYXBoaWMnLFxuICAndi1pZGVvZ3JhcGhpYyc6ICd2SWRlb2dyYXBoaWMnLFxuICB2aWV3Ym94OiAndmlld0JveCcsXG4gIHZpZXd0YXJnZXQ6ICd2aWV3VGFyZ2V0JyxcbiAgdmlzaWJpbGl0eTogJ3Zpc2liaWxpdHknLFxuICB2bWF0aGVtYXRpY2FsOiAndk1hdGhlbWF0aWNhbCcsXG4gICd2LW1hdGhlbWF0aWNhbCc6ICd2TWF0aGVtYXRpY2FsJyxcbiAgdm9jYWI6ICd2b2NhYicsXG4gIHdpZHRoczogJ3dpZHRocycsXG4gIHdvcmRzcGFjaW5nOiAnd29yZFNwYWNpbmcnLFxuICAnd29yZC1zcGFjaW5nJzogJ3dvcmRTcGFjaW5nJyxcbiAgd3JpdGluZ21vZGU6ICd3cml0aW5nTW9kZScsXG4gICd3cml0aW5nLW1vZGUnOiAnd3JpdGluZ01vZGUnLFxuICB4MTogJ3gxJyxcbiAgeDI6ICd4MicsXG4gIHg6ICd4JyxcbiAgeGNoYW5uZWxzZWxlY3RvcjogJ3hDaGFubmVsU2VsZWN0b3InLFxuICB4aGVpZ2h0OiAneEhlaWdodCcsXG4gICd4LWhlaWdodCc6ICd4SGVpZ2h0JyxcbiAgeGxpbmthY3R1YXRlOiAneGxpbmtBY3R1YXRlJyxcbiAgJ3hsaW5rOmFjdHVhdGUnOiAneGxpbmtBY3R1YXRlJyxcbiAgeGxpbmthcmNyb2xlOiAneGxpbmtBcmNyb2xlJyxcbiAgJ3hsaW5rOmFyY3JvbGUnOiAneGxpbmtBcmNyb2xlJyxcbiAgeGxpbmtocmVmOiAneGxpbmtIcmVmJyxcbiAgJ3hsaW5rOmhyZWYnOiAneGxpbmtIcmVmJyxcbiAgeGxpbmtyb2xlOiAneGxpbmtSb2xlJyxcbiAgJ3hsaW5rOnJvbGUnOiAneGxpbmtSb2xlJyxcbiAgeGxpbmtzaG93OiAneGxpbmtTaG93JyxcbiAgJ3hsaW5rOnNob3cnOiAneGxpbmtTaG93JyxcbiAgeGxpbmt0aXRsZTogJ3hsaW5rVGl0bGUnLFxuICAneGxpbms6dGl0bGUnOiAneGxpbmtUaXRsZScsXG4gIHhsaW5rdHlwZTogJ3hsaW5rVHlwZScsXG4gICd4bGluazp0eXBlJzogJ3hsaW5rVHlwZScsXG4gIHhtbGJhc2U6ICd4bWxCYXNlJyxcbiAgJ3htbDpiYXNlJzogJ3htbEJhc2UnLFxuICB4bWxsYW5nOiAneG1sTGFuZycsXG4gICd4bWw6bGFuZyc6ICd4bWxMYW5nJyxcbiAgeG1sbnM6ICd4bWxucycsXG4gICd4bWw6c3BhY2UnOiAneG1sU3BhY2UnLFxuICB4bWxuc3hsaW5rOiAneG1sbnNYbGluaycsXG4gICd4bWxuczp4bGluayc6ICd4bWxuc1hsaW5rJyxcbiAgeG1sc3BhY2U6ICd4bWxTcGFjZScsXG4gIHkxOiAneTEnLFxuICB5MjogJ3kyJyxcbiAgeTogJ3knLFxuICB5Y2hhbm5lbHNlbGVjdG9yOiAneUNoYW5uZWxTZWxlY3RvcicsXG4gIHo6ICd6JyxcbiAgem9vbWFuZHBhbjogJ3pvb21BbmRQYW4nXG59O1xuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtJDIoKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbntcbiAgdmFyIHdhcm5lZFByb3BlcnRpZXMkMSA9IHt9O1xuICB2YXIgaGFzT3duUHJvcGVydHkkMSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG4gIHZhciBFVkVOVF9OQU1FX1JFR0VYID0gL15vbltBLVpdLztcbiAgdmFyIHJBUklBJDEgPSBuZXcgUmVnRXhwKCdeKGFyaWEpLVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbiAgdmFyIHJBUklBQ2FtZWwkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSlbQS1aXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcblxuICB2YXIgdmFsaWRhdGVQcm9wZXJ0eSQxID0gZnVuY3Rpb24gKHRhZ05hbWUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5JDEuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzJDEsIG5hbWUpICYmIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocGx1Z2lucy5sZW5ndGggPT09IDAgJiYgRVZFTlRfTkFNRV9SRUdFWC50ZXN0KG5hbWUpKSB7XG4gICAgICAvLyBJZiBubyBldmVudCBwbHVnaW5zIGhhdmUgYmVlbiBpbmplY3RlZCwgd2UgbWlnaHQgYmUgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQuXG4gICAgICAvLyBEb24ndCBjaGVjayBldmVudHMgaW4gdGhpcyBjYXNlLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA6IG51bGw7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBldmVudCBoYW5kbGVyIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZS5pbmRleE9mKCdvbicpID09PSAwICYmIGxvd2VyQ2FzZWROYW1lLmxlbmd0aCA+IDIpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdVbmtub3duIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gSXQgd2lsbCBiZSBpZ25vcmVkLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIExldCB0aGUgQVJJQSBhdHRyaWJ1dGUgaG9vayB2YWxpZGF0ZSBBUklBIGF0dHJpYnV0ZXNcbiAgICBpZiAockFSSUEkMS50ZXN0KG5hbWUpIHx8IHJBUklBQ2FtZWwkMS50ZXN0KG5hbWUpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3VzaW4nIHx8IGxvd2VyQ2FzZWROYW1lID09PSAnb25mb2N1c291dCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCB1c2VzIG9uRm9jdXMgYW5kIG9uQmx1ciBpbnN0ZWFkIG9mIG9uRm9jdXNJbiBhbmQgb25Gb2N1c091dC4gJyArICdBbGwgUmVhY3QgZXZlbnRzIGFyZSBub3JtYWxpemVkIHRvIGJ1YmJsZSwgc28gb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0ICcgKyAnYXJlIG5vdCBuZWVkZWQvc3VwcG9ydGVkIGJ5IFJlYWN0LicpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ2lubmVyaHRtbCcpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdEaXJlY3RseSBzZXR0aW5nIHByb3BlcnR5IGBpbm5lckhUTUxgIGlzIG5vdCBwZXJtaXR0ZWQuICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIGxvb2t1cCBkb2N1bWVudGF0aW9uIG9uIGBkYW5nZXJvdXNseVNldElubmVySFRNTGAuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnYXJpYScpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgYGFyaWFgIGF0dHJpYnV0ZSBpcyByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSBpbiBSZWFjdC4gJyArICdQYXNzIGluZGl2aWR1YWwgYGFyaWEtYCBhdHRyaWJ1dGVzIGluc3RlYWQuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaXMnICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGEgYCVzYCBmb3IgYSBzdHJpbmcgYXR0cmlidXRlIGBpc2AuIElmIHRoaXMgaXMgZXhwZWN0ZWQsIGNhc3QgJyArICd0aGUgdmFsdWUgdG8gYSBzdHJpbmcuJXMnLCB0eXBlb2YgdmFsdWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWx1ZSkpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBOYU4gZm9yIHRoZSBgJXNgIGF0dHJpYnV0ZS4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IGlzUmVzZXJ2ZWRQcm9wKG5hbWUpO1xuXG4gICAgLy8gS25vd24gYXR0cmlidXRlcyBzaG91bGQgbWF0Y2ggdGhlIGNhc2luZyBzcGVjaWZpZWQgaW4gdGhlIHByb3BlcnR5IGNvbmZpZy5cbiAgICBpZiAocG9zc2libGVTdGFuZGFyZE5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSkge1xuICAgICAgdmFyIHN0YW5kYXJkTmFtZSA9IHBvc3NpYmxlU3RhbmRhcmROYW1lc1tsb3dlckNhc2VkTmFtZV07XG4gICAgICBpZiAoc3RhbmRhcmROYW1lICE9PSBuYW1lKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIERPTSBwcm9wZXJ0eSBgJXNgLiBEaWQgeW91IG1lYW4gYCVzYD8lcycsIG5hbWUsIHN0YW5kYXJkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc1Jlc2VydmVkICYmIG5hbWUgIT09IGxvd2VyQ2FzZWROYW1lKSB7XG4gICAgICAvLyBVbmtub3duIGF0dHJpYnV0ZXMgc2hvdWxkIGhhdmUgbG93ZXJjYXNlIGNhc2luZyBzaW5jZSB0aGF0J3MgaG93IHRoZXlcbiAgICAgIC8vIHdpbGwgYmUgY2FzZWQgYW55d2F5IHdpdGggc2VydmVyIHJlbmRlcmluZy5cbiAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdCBkb2VzIG5vdCByZWNvZ25pemUgdGhlIGAlc2AgcHJvcCBvbiBhIERPTSBlbGVtZW50LiBJZiB5b3UgJyArICdpbnRlbnRpb25hbGx5IHdhbnQgaXQgdG8gYXBwZWFyIGluIHRoZSBET00gYXMgYSBjdXN0b20gJyArICdhdHRyaWJ1dGUsIHNwZWxsIGl0IGFzIGxvd2VyY2FzZSBgJXNgIGluc3RlYWQuICcgKyAnSWYgeW91IGFjY2lkZW50YWxseSBwYXNzZWQgaXQgZnJvbSBhIHBhcmVudCBjb21wb25lbnQsIHJlbW92ZSAnICsgJ2l0IGZyb20gdGhlIERPTSBlbGVtZW50LiVzJywgbmFtZSwgbG93ZXJDYXNlZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicgJiYgIXNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uJXMnLCB2YWx1ZSwgbmFtZSwgbmFtZSwgdmFsdWUsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdSZWNlaXZlZCBgJXNgIGZvciBhIG5vbi1ib29sZWFuIGF0dHJpYnV0ZSBgJXNgLlxcblxcbicgKyAnSWYgeW91IHdhbnQgdG8gd3JpdGUgaXQgdG8gdGhlIERPTSwgcGFzcyBhIHN0cmluZyBpbnN0ZWFkOiAnICsgJyVzPVwiJXNcIiBvciAlcz17dmFsdWUudG9TdHJpbmcoKX0uXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgbmFtZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfVxuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIE5vdyB0aGF0IHdlJ3ZlIHZhbGlkYXRlZCBjYXNpbmcsIGRvIG5vdCB2YWxpZGF0ZVxuICAgIC8vIGRhdGEgdHlwZXMgZm9yIHJlc2VydmVkIHByb3BzXG4gICAgaWYgKGlzUmVzZXJ2ZWQpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIFdhcm4gd2hlbiBhIGtub3duIGF0dHJpYnV0ZSBpcyBhIGJhZCB0eXBlXG4gICAgaWYgKCFzaG91bGRTZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG52YXIgd2FyblVua25vd25Qcm9wZXJ0aWVzID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gIHZhciB1bmtub3duUHJvcHMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5JDEodHlwZSwga2V5LCBwcm9wc1trZXldKTtcbiAgICBpZiAoIWlzVmFsaWQpIHtcbiAgICAgIHVua25vd25Qcm9wcy5wdXNoKGtleSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHVua25vd25Qcm9wU3RyaW5nID0gdW5rbm93blByb3BzLm1hcChmdW5jdGlvbiAocHJvcCkge1xuICAgIHJldHVybiAnYCcgKyBwcm9wICsgJ2AnO1xuICB9KS5qb2luKCcsICcpO1xuICBpZiAodW5rbm93blByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlIGZvciBwcm9wICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIGl0IGZyb20gdGhlIGVsZW1lbnQsICcgKyAnb3IgcGFzcyBhIHN0cmluZyBvciBudW1iZXIgdmFsdWUgdG8ga2VlcCBpdCBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH0gZWxzZSBpZiAodW5rbm93blByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCB2YWx1ZXMgZm9yIHByb3BzICVzIG9uIDwlcz4gdGFnLiBFaXRoZXIgcmVtb3ZlIHRoZW0gZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIHRoZW0gaW4gdGhlIERPTS4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtYXR0cmlidXRlLWJlaGF2aW9yJXMnLCB1bmtub3duUHJvcFN0cmluZywgdHlwZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5Vbmtub3duUHJvcGVydGllcyh0eXBlLCBwcm9wcyk7XG59XG5cbi8vIFRPRE86IGRpcmVjdCBpbXBvcnRzIGxpa2Ugc29tZS1wYWNrYWdlL3NyYy8qIGFyZSBiYWQuIEZpeCBtZS5cbnZhciBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lO1xudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gZmFsc2U7XG52YXIgZGlkV2FyblNoYWR5RE9NID0gZmFsc2U7XG5cbnZhciBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCA9ICdkYW5nZXJvdXNseVNldElubmVySFRNTCc7XG52YXIgU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HID0gJ3N1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZyc7XG52YXIgU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xudmFyIEFVVE9GT0NVUyA9ICdhdXRvRm9jdXMnO1xudmFyIENISUxEUkVOID0gJ2NoaWxkcmVuJztcbnZhciBTVFlMRSA9ICdzdHlsZSc7XG52YXIgSFRNTCA9ICdfX2h0bWwnO1xuXG52YXIgSFRNTF9OQU1FU1BBQ0UgPSBOYW1lc3BhY2VzLmh0bWw7XG5cblxudmFyIGdldFN0YWNrID0gZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zKCcnKTtcblxue1xuICBnZXRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMjtcblxuICB2YXIgd2FybmVkVW5rbm93blRhZ3MgPSB7XG4gICAgLy8gQ2hyb21lIGlzIHRoZSBvbmx5IG1ham9yIGJyb3dzZXIgbm90IHNoaXBwaW5nIDx0aW1lPi4gQnV0IGFzIG9mIEp1bHlcbiAgICAvLyAyMDE3IGl0IGludGVuZHMgdG8gc2hpcCBpdCBkdWUgdG8gd2lkZXNwcmVhZCB1c2FnZS4gV2UgaW50ZW50aW9uYWxseVxuICAgIC8vICpkb24ndCogd2FybiBmb3IgPHRpbWU+IGV2ZW4gaWYgaXQncyB1bnJlY29nbml6ZWQgYnkgQ2hyb21lIGJlY2F1c2VcbiAgICAvLyBpdCBzb29uIHdpbGwgYmUsIGFuZCBtYW55IGFwcHMgaGF2ZSBiZWVuIHVzaW5nIGl0IGFueXdheS5cbiAgICB0aW1lOiB0cnVlLFxuICAgIC8vIFRoZXJlIGFyZSB3b3JraW5nIHBvbHlmaWxscyBmb3IgPGRpYWxvZz4uIExldCBwZW9wbGUgdXNlIGl0LlxuICAgIGRpYWxvZzogdHJ1ZVxuICB9O1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50ID0gZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcyk7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzJDIodHlwZSwgcHJvcHMpO1xuICB9O1xuXG4gIC8vIEhUTUwgcGFyc2luZyBub3JtYWxpemVzIENSIGFuZCBDUkxGIHRvIExGLlxuICAvLyBJdCBhbHNvIGNhbiB0dXJuIFxcdTAwMDAgaW50byBcXHVGRkZEIGluc2lkZSBhdHRyaWJ1dGVzLlxuICAvLyBodHRwczovL3d3dy53My5vcmcvVFIvaHRtbDUvc2luZ2xlLXBhZ2UuaHRtbCNwcmVwcm9jZXNzaW5nLXRoZS1pbnB1dC1zdHJlYW1cbiAgLy8gSWYgd2UgaGF2ZSBhIG1pc21hdGNoLCBpdCBtaWdodCBiZSBjYXVzZWQgYnkgdGhhdC5cbiAgLy8gV2Ugd2lsbCBzdGlsbCBwYXRjaCB1cCBpbiB0aGlzIGNhc2UgYnV0IG5vdCBmaXJlIHRoZSB3YXJuaW5nLlxuICB2YXIgTk9STUFMSVpFX05FV0xJTkVTX1JFR0VYID0gL1xcclxcbj8vZztcbiAgdmFyIE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCA9IC9cXHUwMDAwfFxcdUZGRkQvZztcblxuICB2YXIgbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlID0gZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBtYXJrdXBTdHJpbmcgPSB0eXBlb2YgbWFya3VwID09PSAnc3RyaW5nJyA/IG1hcmt1cCA6ICcnICsgbWFya3VwO1xuICAgIHJldHVybiBtYXJrdXBTdHJpbmcucmVwbGFjZShOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgsICdcXG4nKS5yZXBsYWNlKE5PUk1BTElaRV9OVUxMX0FORF9SRVBMQUNFTUVOVF9SRUdFWCwgJycpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yVGV4dERpZmZlcmVuY2UgPSBmdW5jdGlvbiAoc2VydmVyVGV4dCwgY2xpZW50VGV4dCkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VGV4dCk7XG4gICAgdmFyIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclRleHQpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVGV4dCA9PT0gbm9ybWFsaXplZENsaWVudFRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdUZXh0IGNvbnRlbnQgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiBcIiVzXCIgQ2xpZW50OiBcIiVzXCInLCBub3JtYWxpemVkU2VydmVyVGV4dCwgbm9ybWFsaXplZENsaWVudFRleHQpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yUHJvcERpZmZlcmVuY2UgPSBmdW5jdGlvbiAocHJvcE5hbWUsIHNlcnZlclZhbHVlLCBjbGllbnRWYWx1ZSkge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplZENsaWVudFZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKGNsaWVudFZhbHVlKTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclZhbHVlID0gbm9ybWFsaXplTWFya3VwRm9yVGV4dE9yQXR0cmlidXRlKHNlcnZlclZhbHVlKTtcbiAgICBpZiAobm9ybWFsaXplZFNlcnZlclZhbHVlID09PSBub3JtYWxpemVkQ2xpZW50VmFsdWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdQcm9wIGAlc2AgZGlkIG5vdCBtYXRjaC4gU2VydmVyOiAlcyBDbGllbnQ6ICVzJywgcHJvcE5hbWUsIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRTZXJ2ZXJWYWx1ZSksIEpTT04uc3RyaW5naWZ5KG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkpO1xuICB9O1xuXG4gIHZhciB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWVzKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBhdHRyaWJ1dGVOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH0pO1xuICAgIHdhcm5pbmcoZmFsc2UsICdFeHRyYSBhdHRyaWJ1dGVzIGZyb20gdGhlIHNlcnZlcjogJXMnLCBuYW1lcyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChsaXN0ZW5lciA9PT0gZmFsc2UpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdFeHBlY3RlZCBgJXNgIGxpc3RlbmVyIHRvIGJlIGEgZnVuY3Rpb24sIGluc3RlYWQgZ290IGBmYWxzZWAuXFxuXFxuJyArICdJZiB5b3UgdXNlZCB0byBjb25kaXRpb25hbGx5IG9taXQgaXQgd2l0aCAlcz17Y29uZGl0aW9uICYmIHZhbHVlfSwgJyArICdwYXNzICVzPXtjb25kaXRpb24gPyB2YWx1ZSA6IHVuZGVmaW5lZH0gaW5zdGVhZC4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIHJlZ2lzdHJhdGlvbk5hbWUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYSB2YWx1ZSBvZiBgJXNgIHR5cGUuJXMnLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMigpKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gUGFyc2UgdGhlIEhUTUwgYW5kIHJlYWQgaXQgYmFjayB0byBub3JtYWxpemUgdGhlIEhUTUwgc3RyaW5nIHNvIHRoYXQgaXRcbiAgLy8gY2FuIGJlIHVzZWQgZm9yIGNvbXBhcmlzb24uXG4gIHZhciBub3JtYWxpemVIVE1MID0gZnVuY3Rpb24gKHBhcmVudCwgaHRtbCkge1xuICAgIC8vIFdlIGNvdWxkIGhhdmUgY3JlYXRlZCBhIHNlcGFyYXRlIGRvY3VtZW50IGhlcmUgdG8gYXZvaWRcbiAgICAvLyByZS1pbml0aWFsaXppbmcgY3VzdG9tIGVsZW1lbnRzIGlmIHRoZXkgZXhpc3QuIEJ1dCB0aGlzIGJyZWFrc1xuICAgIC8vIGhvdyA8bm9zY3JpcHQ+IGlzIGJlaW5nIGhhbmRsZWQuIFNvIHdlIHVzZSB0aGUgc2FtZSBkb2N1bWVudC5cbiAgICAvLyBTZWUgdGhlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTExNTcuXG4gICAgdmFyIHRlc3RFbGVtZW50ID0gcGFyZW50Lm5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UgPyBwYXJlbnQub3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHBhcmVudC50YWdOYW1lKSA6IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhwYXJlbnQubmFtZXNwYWNlVVJJLCBwYXJlbnQudGFnTmFtZSk7XG4gICAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gaHRtbDtcbiAgICByZXR1cm4gdGVzdEVsZW1lbnQuaW5uZXJIVE1MO1xuICB9O1xufVxuXG5mdW5jdGlvbiBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICB2YXIgaXNEb2N1bWVudE9yRnJhZ21lbnQgPSByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCByb290Q29udGFpbmVyRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERTtcbiAgdmFyIGRvYyA9IGlzRG9jdW1lbnRPckZyYWdtZW50ID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xuICBsaXN0ZW5UbyhyZWdpc3RyYXRpb25OYW1lLCBkb2MpO1xufVxuXG5mdW5jdGlvbiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckVsZW1lbnQgOiByb290Q29udGFpbmVyRWxlbWVudC5vd25lckRvY3VtZW50O1xufVxuXG4vLyBUaGVyZSBhcmUgc28gbWFueSBtZWRpYSBldmVudHMsIGl0IG1ha2VzIHNlbnNlIHRvIGp1c3Rcbi8vIG1haW50YWluIGEgbGlzdCByYXRoZXIgdGhhbiBjcmVhdGUgYSBgdHJhcEJ1YmJsZWRFdmVudGAgZm9yIGVhY2hcbnZhciBtZWRpYUV2ZW50cyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcENhblBsYXk6ICdjYW5wbGF5JyxcbiAgdG9wQ2FuUGxheVRocm91Z2g6ICdjYW5wbGF5dGhyb3VnaCcsXG4gIHRvcER1cmF0aW9uQ2hhbmdlOiAnZHVyYXRpb25jaGFuZ2UnLFxuICB0b3BFbXB0aWVkOiAnZW1wdGllZCcsXG4gIHRvcEVuY3J5cHRlZDogJ2VuY3J5cHRlZCcsXG4gIHRvcEVuZGVkOiAnZW5kZWQnLFxuICB0b3BFcnJvcjogJ2Vycm9yJyxcbiAgdG9wTG9hZGVkRGF0YTogJ2xvYWRlZGRhdGEnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wUGF1c2U6ICdwYXVzZScsXG4gIHRvcFBsYXk6ICdwbGF5JyxcbiAgdG9wUGxheWluZzogJ3BsYXlpbmcnLFxuICB0b3BQcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgdG9wUmF0ZUNoYW5nZTogJ3JhdGVjaGFuZ2UnLFxuICB0b3BTZWVrZWQ6ICdzZWVrZWQnLFxuICB0b3BTZWVraW5nOiAnc2Vla2luZycsXG4gIHRvcFN0YWxsZWQ6ICdzdGFsbGVkJyxcbiAgdG9wU3VzcGVuZDogJ3N1c3BlbmQnLFxuICB0b3BUaW1lVXBkYXRlOiAndGltZXVwZGF0ZScsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJ1xufTtcblxuZnVuY3Rpb24gdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQobm9kZSkge1xuICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAvLyBub24taW50ZXJhY3RpdmUgZWxlbWVudHMsIHdoaWNoIG1lYW5zIGRlbGVnYXRlZCBjbGljayBsaXN0ZW5lcnMgZG8gbm90XG4gIC8vIGZpcmUuIFRoZSB3b3JrYXJvdW5kIGZvciB0aGlzIGJ1ZyBpbnZvbHZlcyBhdHRhY2hpbmcgYW4gZW1wdHkgY2xpY2tcbiAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAvLyBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICAvLyBKdXN0IHNldCBpdCB1c2luZyB0aGUgb25jbGljayBwcm9wZXJ0eSBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gbWFuYWdlIGFueVxuICAvLyBib29ra2VlcGluZyBmb3IgaXQuIE5vdCBzdXJlIGlmIHdlIG5lZWQgdG8gY2xlYXIgaXQgd2hlbiB0aGUgbGlzdGVuZXIgaXNcbiAgLy8gcmVtb3ZlZC5cbiAgLy8gVE9ETzogT25seSBkbyB0aGlzIGZvciB0aGUgcmVsZXZhbnQgU2FmYXJpcyBtYXliZT9cbiAgbm9kZS5vbmNsaWNrID0gZW1wdHlGdW5jdGlvbiQxO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsRE9NUHJvcGVydGllcyh0YWcsIGRvbUVsZW1lbnQsIHJvb3RDb250YWluZXJFbGVtZW50LCBuZXh0UHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIC8vIEZyZWV6ZSB0aGUgbmV4dCBzdHlsZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gYXNzdW1lIGl0IHdvbid0IGJlXG4gICAgICAgICAgLy8gbXV0YXRlZC4gV2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBmb3IgdGhpcyBpbiB0aGUgcGFzdC5cbiAgICAgICAgICBPYmplY3QuZnJlZXplKG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gUmVsaWVzIG9uIGB1cGRhdGVTdHlsZXNCeUlEYCBub3QgbXV0YXRpbmcgYHN0eWxlVXBkYXRlc2AuXG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBuZXh0UHJvcCwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHZhciBuZXh0SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIC8vIEF2b2lkIHNldHRpbmcgaW5pdGlhbCB0ZXh0Q29udGVudCB3aGVuIHRoZSB0ZXh0IGlzIGVtcHR5LiBJbiBJRTExIHNldHRpbmdcbiAgICAgICAgLy8gdGV4dENvbnRlbnQgb24gYSA8dGV4dGFyZWE+IHdpbGwgY2F1c2UgdGhlIHBsYWNlaG9sZGVyIHRvIG5vdFxuICAgICAgICAvLyBzaG93IHdpdGhpbiB0aGUgPHRleHRhcmVhPiB1bnRpbCBpdCBoYXMgYmVlbiBmb2N1c2VkIGFuZCBibHVycmVkIGFnYWluLlxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzY3MzEjaXNzdWVjb21tZW50LTI1NDg3NDU1M1xuICAgICAgICB2YXIgY2FuU2V0VGV4dENvbnRlbnQgPSB0YWcgIT09ICd0ZXh0YXJlYScgfHwgbmV4dFByb3AgIT09ICcnO1xuICAgICAgICBpZiAoY2FuU2V0VGV4dENvbnRlbnQpIHtcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCQxKGRvbUVsZW1lbnQsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbmV4dFByb3AgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHNldFRleHRDb250ZW50JDEoZG9tRWxlbWVudCwgJycgKyBuZXh0UHJvcCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBXZSBwb2x5ZmlsbCBpdCBzZXBhcmF0ZWx5IG9uIHRoZSBjbGllbnQgZHVyaW5nIGNvbW1pdC5cbiAgICAgIC8vIFdlIGJsYWNrbGlzdCBpdCBoZXJlIHJhdGhlciB0aGFuIGluIHRoZSBwcm9wZXJ0eSBsaXN0IGJlY2F1c2Ugd2UgZW1pdCBpdCBpbiBTU1IuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH0gZWxzZSBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgc2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAvLyBUT0RPOiBIYW5kbGUgd2FzQ3VzdG9tQ29tcG9uZW50VGFnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdXBkYXRlUGF5bG9hZC5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBwcm9wS2V5ID0gdXBkYXRlUGF5bG9hZFtpXTtcbiAgICB2YXIgcHJvcFZhbHVlID0gdXBkYXRlUGF5bG9hZFtpICsgMV07XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICBzZXRWYWx1ZUZvclN0eWxlcyhkb21FbGVtZW50LCBwcm9wVmFsdWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICBzZXRJbm5lckhUTUwoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBzZXRUZXh0Q29udGVudCQxKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSAhPSBudWxsKSB7XG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGVudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgIC8vIGJyaW5ncyB1cyBpbiBsaW5lIHdpdGggdGhlIHNhbWUgYmVoYXZpb3Igd2UgaGF2ZSBvbiBpbml0aWFsIHJlbmRlci5cbiAgICAgIGRlbGV0ZVZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQkMSh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQsIHBhcmVudE5hbWVzcGFjZSkge1xuICAvLyBXZSBjcmVhdGUgdGFncyBpbiB0aGUgbmFtZXNwYWNlIG9mIHRoZWlyIHBhcmVudCBjb250YWluZXIsIGV4Y2VwdCBIVE1MXG4gIHZhciBvd25lckRvY3VtZW50ID0gZ2V0T3duZXJEb2N1bWVudEZyb21Sb290Q29udGFpbmVyKHJvb3RDb250YWluZXJFbGVtZW50KTtcbiAgdmFyIGRvbUVsZW1lbnQ7XG4gIHZhciBuYW1lc3BhY2VVUkkgPSBwYXJlbnROYW1lc3BhY2U7XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgbmFtZXNwYWNlVVJJID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAge1xuICAgICAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpO1xuICAgICAgLy8gU2hvdWxkIHRoaXMgY2hlY2sgYmUgZ2F0ZWQgYnkgcGFyZW50IG5hbWVzcGFjZT8gTm90IHN1cmUgd2Ugd2FudCB0b1xuICAgICAgLy8gYWxsb3cgPFNWRz4gb3IgPG1BVEg+LlxuICAgICAgd2FybmluZyhpc0N1c3RvbUNvbXBvbmVudFRhZyB8fCB0eXBlID09PSB0eXBlLnRvTG93ZXJDYXNlKCksICc8JXMgLz4gaXMgdXNpbmcgdXBwZXJjYXNlIEhUTUwuIEFsd2F5cyB1c2UgbG93ZXJjYXNlIEhUTUwgdGFncyAnICsgJ2luIFJlYWN0LicsIHR5cGUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlID09PSAnc2NyaXB0Jykge1xuICAgICAgLy8gQ3JlYXRlIHRoZSBzY3JpcHQgdmlhIC5pbm5lckhUTUwgc28gaXRzIFwicGFyc2VyLWluc2VydGVkXCIgZmxhZyBpc1xuICAgICAgLy8gc2V0IHRvIHRydWUgYW5kIGl0IGRvZXMgbm90IGV4ZWN1dGVcbiAgICAgIHZhciBkaXYgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgZGl2LmlubmVySFRNTCA9ICc8c2NyaXB0PjwnICsgJy9zY3JpcHQ+JzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgICAgLy8gVGhpcyBpcyBndWFyYW50ZWVkIHRvIHlpZWxkIGEgc2NyaXB0IGVsZW1lbnQuXG4gICAgICB2YXIgZmlyc3RDaGlsZCA9IGRpdi5maXJzdENoaWxkO1xuICAgICAgZG9tRWxlbWVudCA9IGRpdi5yZW1vdmVDaGlsZChmaXJzdENoaWxkKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vICRGbG93SXNzdWUgYGNyZWF0ZUVsZW1lbnRgIHNob3VsZCBiZSB1cGRhdGVkIGZvciBXZWIgQ29tcG9uZW50c1xuICAgICAgZG9tRWxlbWVudCA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlLCB7IGlzOiBwcm9wcy5pcyB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2VwYXJhdGUgZWxzZSBicmFuY2ggaW5zdGVhZCBvZiB1c2luZyBgcHJvcHMuaXMgfHwgdW5kZWZpbmVkYCBhYm92ZSBiZWNhdXNlIG9mIGEgRmlyZWZveCBidWcuXG4gICAgICAvLyBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC82ODk2XG4gICAgICAvLyBhbmQgZGlzY3Vzc2lvbiBpbiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMjc2MjQwXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlVVJJLCB0eXBlKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgaWYgKCFpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZG9tRWxlbWVudCkgPT09ICdbb2JqZWN0IEhUTUxVbmtub3duRWxlbWVudF0nICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwod2FybmVkVW5rbm93blRhZ3MsIHR5cGUpKSB7XG4gICAgICAgIHdhcm5lZFVua25vd25UYWdzW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSB0YWcgPCVzPiBpcyB1bnJlY29nbml6ZWQgaW4gdGhpcyBicm93c2VyLiAnICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBSZWFjdCBjb21wb25lbnQsIHN0YXJ0IGl0cyBuYW1lIHdpdGggJyArICdhbiB1cHBlcmNhc2UgbGV0dGVyLicsIHR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkb21FbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUZXh0Tm9kZSQxKHRleHQsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHJldHVybiBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpLmNyZWF0ZVRleHROb2RlKHRleHQpO1xufVxuXG5mdW5jdGlvbiBzZXRJbml0aWFsUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHJvb3RDb250YWluZXJFbGVtZW50KSB7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcgJiYgIWRpZFdhcm5TaGFkeURPTSAmJiBkb21FbGVtZW50LnNoYWR5Um9vdCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGlzIHVzaW5nIHNoYWR5IERPTS4gVXNpbmcgc2hhZHkgRE9NIHdpdGggUmVhY3QgY2FuICcgKyAnY2F1c2UgdGhpbmdzIHRvIGJyZWFrIHN1YnRseS4nLCBnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMSgpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgZGlkV2FyblNoYWR5RE9NID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBNYWtlIHN1cmUgdGhhdCB3ZSBjaGVjayBpc01vdW50ZWQgYmVmb3JlIGZpcmluZyBhbnkgb2YgdGhlc2UgZXZlbnRzLlxuICB2YXIgcHJvcHM7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgIC8vIENyZWF0ZSBsaXN0ZW5lciBmb3IgZWFjaCBtZWRpYSBldmVudFxuICAgICAgZm9yICh2YXIgZXZlbnQgaW4gbWVkaWFFdmVudHMpIHtcbiAgICAgICAgaWYgKG1lZGlhRXZlbnRzLmhhc093blByb3BlcnR5KGV2ZW50KSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoZXZlbnQsIG1lZGlhRXZlbnRzW2V2ZW50XSwgZG9tRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdmb3JtJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFJlc2V0JywgJ3Jlc2V0JywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BTdWJtaXQnLCAnc3VibWl0JywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgcHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spO1xuXG4gIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BzLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgcG9zdE1vdW50V3JhcHBlciQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8vIENhbGN1bGF0ZSB0aGUgZGlmZiBiZXR3ZWVuIHRoZSB0d28gb2JqZWN0cy5cbmZ1bmN0aW9uIGRpZmZQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCBuZXh0UmF3UHJvcHMpO1xuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuXG4gIHZhciBsYXN0UHJvcHM7XG4gIHZhciBuZXh0UHJvcHM7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBsYXN0UmF3UHJvcHMpO1xuICAgICAgbmV4dFByb3BzID0gZ2V0SG9zdFByb3BzJDIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGxhc3RQcm9wcyA9IGxhc3RSYXdQcm9wcztcbiAgICAgIG5leHRQcm9wcyA9IG5leHRSYXdQcm9wcztcbiAgICAgIGlmICh0eXBlb2YgbGFzdFByb3BzLm9uQ2xpY2sgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG5leHRQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICBhc3NlcnRWYWxpZFByb3BzKHRhZywgbmV4dFByb3BzLCBnZXRTdGFjayk7XG5cbiAgdmFyIHByb3BLZXk7XG4gIHZhciBzdHlsZU5hbWU7XG4gIHZhciBzdHlsZVVwZGF0ZXMgPSBudWxsO1xuICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgaWYgKG5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCAhbGFzdFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IGxhc3RQcm9wc1twcm9wS2V5XSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICB2YXIgbGFzdFN0eWxlID0gbGFzdFByb3BzW3Byb3BLZXldO1xuICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbGFzdFN0eWxlKSB7XG4gICAgICAgIGlmIChsYXN0U3R5bGUuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwgfHwgcHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIC8vIE5vb3AuIFRoaXMgaXMgaGFuZGxlZCBieSB0aGUgY2xlYXIgdGV4dCBtZWNoYW5pc20uXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSkge1xuICAgICAgLy8gTm9vcFxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQVVUT0ZPQ1VTKSB7XG4gICAgICAvLyBOb29wLiBJdCBkb2Vzbid0IHdvcmsgb24gdXBkYXRlcyBhbnl3YXkuXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgY2FzZS4gSWYgYW55IGxpc3RlbmVyIHVwZGF0ZXMgd2UgbmVlZCB0byBlbnN1cmVcbiAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIGZpYmVyIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYWxsIG90aGVyIGRlbGV0ZWQgcHJvcGVydGllcyB3ZSBhZGQgaXQgdG8gdGhlIHF1ZXVlLiBXZSB1c2VcbiAgICAgIC8vIHRoZSB3aGl0ZWxpc3QgaW4gdGhlIGNvbW1pdCBwaGFzZSBpbnN0ZWFkLlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG51bGwpO1xuICAgIH1cbiAgfVxuICBmb3IgKHByb3BLZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgdmFyIG5leHRQcm9wID0gbmV4dFByb3BzW3Byb3BLZXldO1xuICAgIHZhciBsYXN0UHJvcCA9IGxhc3RQcm9wcyAhPSBudWxsID8gbGFzdFByb3BzW3Byb3BLZXldIDogdW5kZWZpbmVkO1xuICAgIGlmICghbmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8IG5leHRQcm9wID09PSBsYXN0UHJvcCB8fCBuZXh0UHJvcCA9PSBudWxsICYmIGxhc3RQcm9wID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobGFzdFByb3ApIHtcbiAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0UHJvcCkge1xuICAgICAgICAgIGlmIChsYXN0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmICghbmV4dFByb3AgfHwgIW5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKG5leHRQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgbGFzdFByb3Bbc3R5bGVOYW1lXSAhPT0gbmV4dFByb3Bbc3R5bGVOYW1lXSkge1xuICAgICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICBpZiAoIXVwZGF0ZVBheWxvYWQpIHtcbiAgICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZC5wdXNoKHByb3BLZXksIHN0eWxlVXBkYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3R5bGVVcGRhdGVzID0gbmV4dFByb3A7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBsYXN0SHRtbCA9IGxhc3RQcm9wID8gbGFzdFByb3BbSFRNTF0gOiB1bmRlZmluZWQ7XG4gICAgICBpZiAobmV4dEh0bWwgIT0gbnVsbCkge1xuICAgICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dEh0bWwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBJdCBtaWdodCBiZSB0b28gbGF0ZSB0byBjbGVhciB0aGlzIGlmIHdlIGhhdmUgY2hpbGRyZW5cbiAgICAgICAgLy8gaW5zZXJ0ZWQgYWxyZWFkeS5cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICBpZiAobGFzdFByb3AgIT09IG5leHRQcm9wICYmICh0eXBlb2YgbmV4dFByb3AgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpKSB7XG4gICAgICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChwcm9wS2V5LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgLy8gV2UgZWFnZXJseSBsaXN0ZW4gdG8gdGhpcyBldmVuIHRob3VnaCB3ZSBoYXZlbid0IGNvbW1pdHRlZCB5ZXQuXG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgICAgaWYgKCF1cGRhdGVQYXlsb2FkICYmIGxhc3RQcm9wICE9PSBuZXh0UHJvcCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgICAvLyB0aGF0IHRoZSBcImN1cnJlbnRcIiBwcm9wcyBwb2ludGVyIGdldHMgdXBkYXRlZCBzbyB3ZSBuZWVkIGEgY29tbWl0XG4gICAgICAgIC8vIHRvIHVwZGF0ZSB0aGlzIGVsZW1lbnQuXG4gICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRm9yIGFueSBvdGhlciBwcm9wZXJ0eSB3ZSBhbHdheXMgYWRkIGl0IHRvIHRoZSBxdWV1ZSBhbmQgdGhlbiB3ZVxuICAgICAgLy8gZmlsdGVyIGl0IG91dCB1c2luZyB0aGUgd2hpdGVsaXN0IGR1cmluZyB0aGUgY29tbWl0LlxuICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbiAgaWYgKHN0eWxlVXBkYXRlcykge1xuICAgICh1cGRhdGVQYXlsb2FkID0gdXBkYXRlUGF5bG9hZCB8fCBbXSkucHVzaChTVFlMRSwgc3R5bGVVcGRhdGVzKTtcbiAgfVxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuLy8gQXBwbHkgdGhlIGRpZmYuXG5mdW5jdGlvbiB1cGRhdGVQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdGFnLCBsYXN0UmF3UHJvcHMsIG5leHRSYXdQcm9wcykge1xuICB2YXIgd2FzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCBsYXN0UmF3UHJvcHMpO1xuICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIC8vIEFwcGx5IHRoZSBkaWZmLlxuICB1cGRhdGVET01Qcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHdhc0N1c3RvbUNvbXBvbmVudFRhZywgaXNDdXN0b21Db21wb25lbnRUYWcpO1xuXG4gIC8vIFRPRE86IEVuc3VyZSB0aGF0IGFuIHVwZGF0ZSBnZXRzIHNjaGVkdWxlZCBpZiBhbnkgb2YgdGhlIHNwZWNpYWwgcHJvcHNcbiAgLy8gY2hhbmdlZC5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBVcGRhdGUgdGhlIHdyYXBwZXIgYXJvdW5kIGlucHV0cyAqYWZ0ZXIqIHVwZGF0aW5nIHByb3BzLiBUaGlzIGhhcyB0b1xuICAgICAgLy8gaGFwcGVuIGFmdGVyIGB1cGRhdGVET01Qcm9wZXJ0aWVzYC4gT3RoZXJ3aXNlIEhUTUw1IGlucHV0IHZhbGlkYXRpb25zXG4gICAgICAvLyByYWlzZSB3YXJuaW5ncyBhbmQgcHJldmVudCB0aGUgbmV3IHZhbHVlIGZyb20gYmVpbmcgYXNzaWduZWQuXG4gICAgICB1cGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG5cbiAgICAgIC8vIFdlIGFsc28gY2hlY2sgdGhhdCB3ZSBoYXZlbid0IG1pc3NlZCBhIHZhbHVlIHVwZGF0ZSwgc3VjaCBhcyBhXG4gICAgICAvLyBSYWRpbyBncm91cCBzaGlmdGluZyB0aGUgY2hlY2tlZCB2YWx1ZSB0byBhbm90aGVyIG5hbWVkIHJhZGlvIGlucHV0LlxuICAgICAgdXBkYXRlVmFsdWVJZkNoYW5nZWQoZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICB1cGRhdGVXcmFwcGVyJDEoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAvLyA8c2VsZWN0PiB2YWx1ZSB1cGRhdGUgbmVlZHMgdG8gb2NjdXIgYWZ0ZXIgPG9wdGlvbj4gY2hpbGRyZW5cbiAgICAgIC8vIHJlY29uY2lsaWF0aW9uXG4gICAgICBwb3N0VXBkYXRlV3JhcHBlcihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxKGRvbUVsZW1lbnQsIHRhZywgcmF3UHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAge1xuICAgIHZhciBzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcgPSByYXdQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxXSA9PT0gdHJ1ZTtcbiAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIHJhd1Byb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaWZyYW1lJzpcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wTG9hZCcsICdsb2FkJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc291cmNlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbWcnOlxuICAgIGNhc2UgJ2ltYWdlJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEVycm9yJywgJ2Vycm9yJywgZG9tRWxlbWVudCk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RldGFpbHMnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wVG9nZ2xlJywgJ3RvZ2dsZScsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgdmFsaWRhdGVQcm9wcyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQxKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BJbnZhbGlkJywgJ2ludmFsaWQnLCBkb21FbGVtZW50KTtcbiAgICAgIC8vIEZvciBjb250cm9sbGVkIGNvbXBvbmVudHMgd2UgYWx3YXlzIG5lZWQgdG8gZW5zdXJlIHdlJ3JlIGxpc3RlbmluZ1xuICAgICAgLy8gdG8gb25DaGFuZ2UuIEV2ZW4gaWYgdGhlcmUgaXMgbm8gbGlzdGVuZXIuXG4gICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgJ29uQ2hhbmdlJyk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCByYXdQcm9wcywgZ2V0U3RhY2spO1xuXG4gIHtcbiAgICB2YXIgZXh0cmFBdHRyaWJ1dGVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgYXR0cmlidXRlcyA9IGRvbUVsZW1lbnQuYXR0cmlidXRlcztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5uYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgICBzd2l0Y2ggKG5hbWUpIHtcbiAgICAgICAgLy8gQnVpbHQtaW4gU1NSIGF0dHJpYnV0ZSBpcyB3aGl0ZWxpc3RlZFxuICAgICAgICBjYXNlICdkYXRhLXJlYWN0cm9vdCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENvbnRyb2xsZWQgYXR0cmlidXRlcyBhcmUgbm90IHZhbGlkYXRlZFxuICAgICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgICAgY2FzZSAndmFsdWUnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjaGVja2VkJzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2VsZWN0ZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgdXNlIHRoZSBvcmlnaW5hbCBuYW1lLlxuICAgICAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEwNjc2LlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXMuYWRkKGF0dHJpYnV0ZXNbaV0ubmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHVwZGF0ZVBheWxvYWQgPSBudWxsO1xuICBmb3IgKHZhciBwcm9wS2V5IGluIHJhd1Byb3BzKSB7XG4gICAgaWYgKCFyYXdQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IHJhd1Byb3BzW3Byb3BLZXldO1xuICAgIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gRm9yIHRleHQgY29udGVudCBjaGlsZHJlbiB3ZSBjb21wYXJlIGFnYWluc3QgdGV4dENvbnRlbnQuIFRoaXNcbiAgICAgIC8vIG1pZ2h0IG1hdGNoIGFkZGl0aW9uYWwgSFRNTCB0aGF0IGlzIGhpZGRlbiB3aGVuIHdlIHJlYWQgaXQgdXNpbmdcbiAgICAgIC8vIHRleHRDb250ZW50LiBFLmcuIFwiZm9vXCIgd2lsbCBtYXRjaCBcImY8c3Bhbj5vbzwvc3Bhbj5cIiBidXQgdGhhdCBzdGlsbFxuICAgICAgLy8gc2F0aXNmaWVzIG91ciByZXF1aXJlbWVudC4gT3VyIHJlcXVpcmVtZW50IGlzIG5vdCB0byBwcm9kdWNlIHBlcmZlY3RcbiAgICAgIC8vIEhUTUwgYW5kIGF0dHJpYnV0ZXMuIElkZWFsbHkgd2Ugc2hvdWxkIHByZXNlcnZlIHN0cnVjdHVyZSBidXQgaXQnc1xuICAgICAgLy8gb2sgbm90IHRvIGlmIHRoZSB2aXNpYmxlIGNvbnRlbnQgaXMgc3RpbGwgZW5vdWdoIHRvIGluZGljYXRlIHdoYXRcbiAgICAgIC8vIGV2ZW4gbGlzdGVuZXJzIHRoZXNlIG5vZGVzIG1pZ2h0IGJlIHdpcmVkIHVwIHRvLlxuICAgICAgLy8gVE9ETzogV2FybiBpZiB0aGVyZSBpcyBtb3JlIHRoYW4gYSBzaW5nbGUgdGV4dE5vZGUgYXMgYSBjaGlsZC5cbiAgICAgIC8vIFRPRE86IFNob3VsZCB3ZSB1c2UgZG9tRWxlbWVudC5maXJzdENoaWxkLm5vZGVWYWx1ZSB0byBjb21wYXJlP1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09IG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHRydWUgJiYgIXN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAgICAgd2FybkZvclRleHREaWZmZXJlbmNlKGRvbUVsZW1lbnQudGV4dENvbnRlbnQsIG5leHRQcm9wKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtDSElMRFJFTiwgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRvbUVsZW1lbnQudGV4dENvbnRlbnQgIT09ICcnICsgbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCAnJyArIG5leHRQcm9wXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAgIGlmICh0cnVlICYmIHR5cGVvZiBuZXh0UHJvcCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5Gb3JJbnZhbGlkRXZlbnRMaXN0ZW5lcihwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBWYWxpZGF0ZSB0aGF0IHRoZSBwcm9wZXJ0aWVzIGNvcnJlc3BvbmQgdG8gdGhlaXIgZXhwZWN0ZWQgdmFsdWVzLlxuICAgICAgdmFyIHNlcnZlclZhbHVlO1xuICAgICAgdmFyIHByb3BlcnR5SW5mbztcbiAgICAgIGlmIChzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGNvbXBhcmluZy4gV2UncmUgaWdub3JpbmcgYWxsIHRoZXNlIHdhcm5pbmdzLlxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgfHwgcHJvcEtleSA9PT0gU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSB8fFxuICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAvLyBUT0RPOiBPbmx5IGlnbm9yZSB0aGVtIG9uIGNvbnRyb2xsZWQgdGFncy5cbiAgICAgIHByb3BLZXkgPT09ICd2YWx1ZScgfHwgcHJvcEtleSA9PT0gJ2NoZWNrZWQnIHx8IHByb3BLZXkgPT09ICdzZWxlY3RlZCcpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgICB2YXIgcmF3SHRtbCA9IG5leHRQcm9wID8gbmV4dFByb3BbSFRNTF0gfHwgJycgOiAnJztcbiAgICAgICAgdmFyIHNlcnZlckhUTUwgPSBkb21FbGVtZW50LmlubmVySFRNTDtcbiAgICAgICAgdmFyIGV4cGVjdGVkSFRNTCA9IG5vcm1hbGl6ZUhUTUwoZG9tRWxlbWVudCwgcmF3SHRtbCk7XG4gICAgICAgIGlmIChleHBlY3RlZEhUTUwgIT09IHNlcnZlckhUTUwpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVySFRNTCwgZXhwZWN0ZWRIVE1MKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkpO1xuICAgICAgICB2YXIgZXhwZWN0ZWRTdHlsZSA9IGNyZWF0ZURhbmdlcm91c1N0cmluZ0ZvclN0eWxlcyhuZXh0UHJvcCk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZG9tRWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgIGlmIChleHBlY3RlZFN0eWxlICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgZXhwZWN0ZWRTdHlsZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkU2V0QXR0cmlidXRlKHByb3BLZXksIG5leHRQcm9wKSkge1xuICAgICAgICBpZiAocHJvcGVydHlJbmZvID0gZ2V0UHJvcGVydHlJbmZvKHByb3BLZXkpKSB7XG4gICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgICBzZXJ2ZXJWYWx1ZSA9IGdldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBvd25OYW1lc3BhY2UgPSBwYXJlbnROYW1lc3BhY2U7XG4gICAgICAgICAgaWYgKG93bk5hbWVzcGFjZSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICAgICAgICAgIG93bk5hbWVzcGFjZSA9IGdldEludHJpbnNpY05hbWVzcGFjZSh0YWcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleS50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5leHRQcm9wICE9PSBzZXJ2ZXJWYWx1ZSkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJWYWx1ZSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAge1xuICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICBpZiAoZXh0cmFBdHRyaWJ1dGVOYW1lcy5zaXplID4gMCAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICB3YXJuRm9yRXh0cmFBdHRyaWJ1dGVzKGV4dHJhQXR0cmlidXRlTmFtZXMpO1xuICAgIH1cbiAgfVxuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlcihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDMoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICBjYXNlICdvcHRpb24nOlxuICAgICAgLy8gRm9yIGlucHV0IGFuZCB0ZXh0YXJlYSB3ZSBjdXJyZW50IGFsd2F5cyBzZXQgdGhlIHZhbHVlIHByb3BlcnR5IGF0XG4gICAgICAvLyBwb3N0IG1vdW50IHRvIGZvcmNlIGl0IHRvIGRpdmVyZ2UgZnJvbSBhdHRyaWJ1dGVzLiBIb3dldmVyLCBmb3JcbiAgICAgIC8vIG9wdGlvbiBhbmQgc2VsZWN0IHdlIGRvbid0IHF1aXRlIGRvIHRoZSBzYW1lIHRoaW5nIGFuZCBzZWxlY3RcbiAgICAgIC8vIGlzIG5vdCByZXNpbGllbnQgdG8gdGhlIERPTSBzdGF0ZSBjaGFuZ2luZyBzbyB3ZSBkb24ndCBkbyB0aGF0IGhlcmUuXG4gICAgICAvLyBUT0RPOiBDb25zaWRlciBub3QgZG9pbmcgdGhpcyBmb3IgaW5wdXQgYW5kIHRleHRhcmVhLlxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICh0eXBlb2YgcmF3UHJvcHMub25DbGljayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGNhc3QgbWF5IG5vdCBiZSBzb3VuZCBmb3IgU1ZHLCBNYXRoTUwgb3IgY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgICB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChkb21FbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZVBheWxvYWQ7XG59XG5cbmZ1bmN0aW9uIGRpZmZIeWRyYXRlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB2YXIgaXNEaWZmZXJlbnQgPSB0ZXh0Tm9kZS5ub2RlVmFsdWUgIT09IHRleHQ7XG4gIHJldHVybiBpc0RpZmZlcmVudDtcbn1cblxuZnVuY3Rpb24gd2FybkZvclVubWF0Y2hlZFRleHQkMSh0ZXh0Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgd2FybkZvclRleHREaWZmZXJlbmNlKHRleHROb2RlLm5vZGVWYWx1ZSwgdGV4dCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIGEgPCVzPiBpbiA8JXM+LicsIGNoaWxkLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxKHBhcmVudE5vZGUsIGNoaWxkKSB7XG4gIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdEaWQgbm90IGV4cGVjdCBzZXJ2ZXIgSFRNTCB0byBjb250YWluIHRoZSB0ZXh0IG5vZGUgXCIlc1wiIGluIDwlcz4uJywgY2hpbGQubm9kZVZhbHVlLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxKHBhcmVudE5vZGUsIHRhZywgcHJvcHMpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyA8JXM+IGluIDwlcz4uJywgdGFnLCBwYXJlbnROb2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxKHBhcmVudE5vZGUsIHRleHQpIHtcbiAge1xuICAgIGlmICh0ZXh0ID09PSAnJykge1xuICAgICAgLy8gV2UgZXhwZWN0IHRvIGluc2VydCBlbXB0eSB0ZXh0IG5vZGVzIHNpbmNlIHRoZXkncmUgbm90IHJlcHJlc2VudGVkIGluXG4gICAgICAvLyB0aGUgSFRNTC5cbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHNwZWNpYWwgY2FzZSBpZiB3ZSBjYW4ganVzdCBhdm9pZCBpbnNlcnRpbmcgZW1wdHlcbiAgICAgIC8vIHRleHQgbm9kZXMuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSBtYXRjaGluZyB0ZXh0IG5vZGUgZm9yIFwiJXNcIiBpbiA8JXM+LicsIHRleHQsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZShkb21FbGVtZW50LCB0YWcsIHByb3BzKSB7XG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgICAgcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICAgIHJldHVybjtcbiAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUZpYmVyQ29tcG9uZW50ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlVGV4dE5vZGU6IGNyZWF0ZVRleHROb2RlJDEsXG5cdHNldEluaXRpYWxQcm9wZXJ0aWVzOiBzZXRJbml0aWFsUHJvcGVydGllcyQxLFxuXHRkaWZmUHJvcGVydGllczogZGlmZlByb3BlcnRpZXMkMSxcblx0dXBkYXRlUHJvcGVydGllczogdXBkYXRlUHJvcGVydGllcyQxLFxuXHRkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzOiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFRleHQ6IGRpZmZIeWRyYXRlZFRleHQkMSxcblx0d2FybkZvclVubWF0Y2hlZFRleHQ6IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDEsXG5cdHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQ6IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxLFxuXHR3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQ6IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxLFxuXHRyZXN0b3JlQ29udHJvbGxlZFN0YXRlOiByZXN0b3JlQ29udHJvbGxlZFN0YXRlXG59KTtcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb24kMTtcblxue1xuICAvLyBUaGlzIHZhbGlkYXRpb24gY29kZSB3YXMgd3JpdHRlbiBiYXNlZCBvbiB0aGUgSFRNTDUgcGFyc2luZyBzcGVjOlxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1zY29wZVxuICAvL1xuICAvLyBOb3RlOiB0aGlzIGRvZXMgbm90IGNhdGNoIGFsbCBpbnZhbGlkIG5lc3RpbmcsIG5vciBkb2VzIGl0IHRyeSB0byAoYXMgaXQnc1xuICAvLyBub3QgY2xlYXIgd2hhdCBwcmFjdGljYWwgYmVuZWZpdCBkb2luZyBzbyBwcm92aWRlcyk7IGluc3RlYWQsIHdlIHdhcm4gb25seVxuICAvLyBmb3IgY2FzZXMgd2hlcmUgdGhlIHBhcnNlciB3aWxsIGdpdmUgYSBwYXJzZSB0cmVlIGRpZmZlcmluZyBmcm9tIHdoYXQgUmVhY3RcbiAgLy8gaW50ZW5kZWQuIEZvciBleGFtcGxlLCA8Yj48ZGl2PjwvZGl2PjwvYj4gaXMgaW52YWxpZCBidXQgd2UgZG9uJ3Qgd2FyblxuICAvLyBiZWNhdXNlIGl0IHN0aWxsIHBhcnNlcyBjb3JyZWN0bHk7IHdlIGRvIHdhcm4gZm9yIG90aGVyIGNhc2VzIGxpa2UgbmVzdGVkXG4gIC8vIDxwPiB0YWdzIHdoZXJlIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHNlY29uZCBlbGVtZW50IGltcGxpY2l0bHkgY2xvc2VzIHRoZVxuICAvLyBmaXJzdCwgY2F1c2luZyBhIGNvbmZ1c2luZyBtZXNzLlxuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3NwZWNpYWxcbiAgdmFyIHNwZWNpYWxUYWdzID0gWydhZGRyZXNzJywgJ2FwcGxldCcsICdhcmVhJywgJ2FydGljbGUnLCAnYXNpZGUnLCAnYmFzZScsICdiYXNlZm9udCcsICdiZ3NvdW5kJywgJ2Jsb2NrcXVvdGUnLCAnYm9keScsICdicicsICdidXR0b24nLCAnY2FwdGlvbicsICdjZW50ZXInLCAnY29sJywgJ2NvbGdyb3VwJywgJ2RkJywgJ2RldGFpbHMnLCAnZGlyJywgJ2RpdicsICdkbCcsICdkdCcsICdlbWJlZCcsICdmaWVsZHNldCcsICdmaWdjYXB0aW9uJywgJ2ZpZ3VyZScsICdmb290ZXInLCAnZm9ybScsICdmcmFtZScsICdmcmFtZXNldCcsICdoMScsICdoMicsICdoMycsICdoNCcsICdoNScsICdoNicsICdoZWFkJywgJ2hlYWRlcicsICdoZ3JvdXAnLCAnaHInLCAnaHRtbCcsICdpZnJhbWUnLCAnaW1nJywgJ2lucHV0JywgJ2lzaW5kZXgnLCAnbGknLCAnbGluaycsICdsaXN0aW5nJywgJ21haW4nLCAnbWFycXVlZScsICdtZW51JywgJ21lbnVpdGVtJywgJ21ldGEnLCAnbmF2JywgJ25vZW1iZWQnLCAnbm9mcmFtZXMnLCAnbm9zY3JpcHQnLCAnb2JqZWN0JywgJ29sJywgJ3AnLCAncGFyYW0nLCAncGxhaW50ZXh0JywgJ3ByZScsICdzY3JpcHQnLCAnc2VjdGlvbicsICdzZWxlY3QnLCAnc291cmNlJywgJ3N0eWxlJywgJ3N1bW1hcnknLCAndGFibGUnLCAndGJvZHknLCAndGQnLCAndGVtcGxhdGUnLCAndGV4dGFyZWEnLCAndGZvb3QnLCAndGgnLCAndGhlYWQnLCAndGl0bGUnLCAndHInLCAndHJhY2snLCAndWwnLCAnd2JyJywgJ3htcCddO1xuXG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIHZhciBpblNjb3BlVGFncyA9IFsnYXBwbGV0JywgJ2NhcHRpb24nLCAnaHRtbCcsICd0YWJsZScsICd0ZCcsICd0aCcsICdtYXJxdWVlJywgJ29iamVjdCcsICd0ZW1wbGF0ZScsXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaHRtbC1pbnRlZ3JhdGlvbi1wb2ludFxuICAvLyBUT0RPOiBEaXN0aW5ndWlzaCBieSBuYW1lc3BhY2UgaGVyZSAtLSBmb3IgPHRpdGxlPiwgaW5jbHVkaW5nIGl0IGhlcmVcbiAgLy8gZXJycyBvbiB0aGUgc2lkZSBvZiBmZXdlciB3YXJuaW5nc1xuICAnZm9yZWlnbk9iamVjdCcsICdkZXNjJywgJ3RpdGxlJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tYnV0dG9uLXNjb3BlXG4gIHZhciBidXR0b25TY29wZVRhZ3MgPSBpblNjb3BlVGFncy5jb25jYXQoWydidXR0b24nXSk7XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjZ2VuZXJhdGUtaW1wbGllZC1lbmQtdGFnc1xuICB2YXIgaW1wbGllZEVuZFRhZ3MgPSBbJ2RkJywgJ2R0JywgJ2xpJywgJ29wdGlvbicsICdvcHRncm91cCcsICdwJywgJ3JwJywgJ3J0J107XG5cbiAgdmFyIGVtcHR5QW5jZXN0b3JJbmZvID0ge1xuICAgIGN1cnJlbnQ6IG51bGwsXG5cbiAgICBmb3JtVGFnOiBudWxsLFxuICAgIGFUYWdJblNjb3BlOiBudWxsLFxuICAgIGJ1dHRvblRhZ0luU2NvcGU6IG51bGwsXG4gICAgbm9iclRhZ0luU2NvcGU6IG51bGwsXG4gICAgcFRhZ0luQnV0dG9uU2NvcGU6IG51bGwsXG5cbiAgICBsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsLFxuICAgIGRsSXRlbVRhZ0F1dG9jbG9zaW5nOiBudWxsXG4gIH07XG5cbiAgdmFyIHVwZGF0ZWRBbmNlc3RvckluZm8kMSA9IGZ1bmN0aW9uIChvbGRJbmZvLCB0YWcsIGluc3RhbmNlKSB7XG4gICAgdmFyIGFuY2VzdG9ySW5mbyA9IF9hc3NpZ24oe30sIG9sZEluZm8gfHwgZW1wdHlBbmNlc3RvckluZm8pO1xuICAgIHZhciBpbmZvID0geyB0YWc6IHRhZywgaW5zdGFuY2U6IGluc3RhbmNlIH07XG5cbiAgICBpZiAoaW5TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChidXR0b25TY29wZVRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSkge1xuICAgICAgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZWUgcnVsZXMgZm9yICdsaScsICdkZCcsICdkdCcgc3RhcnQgdGFncyBpblxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBpZiAoc3BlY2lhbFRhZ3MuaW5kZXhPZih0YWcpICE9PSAtMSAmJiB0YWcgIT09ICdhZGRyZXNzJyAmJiB0YWcgIT09ICdkaXYnICYmIHRhZyAhPT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgIH1cblxuICAgIGFuY2VzdG9ySW5mby5jdXJyZW50ID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGRcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNhcHRpb25cbiAgICAgIC8vIE5vIHNwZWNpYWwgYmVoYXZpb3Igc2luY2UgdGhlc2UgcnVsZXMgZmFsbCBiYWNrIHRvIFwiaW4gYm9keVwiIG1vZGUgZm9yXG4gICAgICAvLyBhbGwgZXhjZXB0IHNwZWNpYWwgdGFibGUgbm9kZXMgd2hpY2ggY2F1c2UgYmFkIHBhcnNpbmcgYmVoYXZpb3IgYW55d2F5LlxuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50clxuICAgICAgY2FzZSAndHInOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndGgnIHx8IHRhZyA9PT0gJ3RkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50Ym9keVxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAndHInIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRhYmxlXG4gICAgICBjYXNlICd0YWJsZSc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjYXB0aW9uJyB8fCB0YWcgPT09ICdjb2xncm91cCcgfHwgdGFnID09PSAndGJvZHknIHx8IHRhZyA9PT0gJ3Rmb290JyB8fCB0YWcgPT09ICd0aGVhZCcgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluaGVhZFxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdiYXNlJyB8fCB0YWcgPT09ICdiYXNlZm9udCcgfHwgdGFnID09PSAnYmdzb3VuZCcgfHwgdGFnID09PSAnbGluaycgfHwgdGFnID09PSAnbWV0YScgfHwgdGFnID09PSAndGl0bGUnIHx8IHRhZyA9PT0gJ25vc2NyaXB0JyB8fCB0YWcgPT09ICdub2ZyYW1lcycgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICAgIGNhc2UgJyNkb2N1bWVudCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdodG1sJztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgY2FzZSAnY2FwdGlvbic6XG4gICAgICBjYXNlICdjb2wnOlxuICAgICAgY2FzZSAnY29sZ3JvdXAnOlxuICAgICAgY2FzZSAnZnJhbWUnOlxuICAgICAgY2FzZSAnaGVhZCc6XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgIGNhc2UgJ3RoJzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3RyJzpcbiAgICAgICAgLy8gVGhlc2UgdGFncyBhcmUgb25seSB2YWxpZCB3aXRoIGEgZmV3IHBhcmVudHMgdGhhdCBoYXZlIHNwZWNpYWwgY2hpbGRcbiAgICAgICAgLy8gcGFyc2luZyBydWxlcyAtLSBpZiB3ZSdyZSBkb3duIGhlcmUsIHRoZW4gbm9uZSBvZiB0aG9zZSBtYXRjaGVkIGFuZFxuICAgICAgICAvLyBzbyB3ZSBhbGxvdyBpdCBvbmx5IGlmIHdlIGRvbid0IGtub3cgd2hhdCB0aGUgcGFyZW50IGlzLCBhcyBhbGwgb3RoZXJcbiAgICAgICAgLy8gY2FzZXMgYXJlIGludmFsaWQuXG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgPT0gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgZmluZEludmFsaWRBbmNlc3RvckZvclRhZyA9IGZ1bmN0aW9uICh0YWcsIGFuY2VzdG9ySW5mbykge1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgIGNhc2UgJ2FydGljbGUnOlxuICAgICAgY2FzZSAnYXNpZGUnOlxuICAgICAgY2FzZSAnYmxvY2txdW90ZSc6XG4gICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICBjYXNlICdkaWFsb2cnOlxuICAgICAgY2FzZSAnZGlyJzpcbiAgICAgIGNhc2UgJ2Rpdic6XG4gICAgICBjYXNlICdkbCc6XG4gICAgICBjYXNlICdmaWVsZHNldCc6XG4gICAgICBjYXNlICdmaWdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2ZpZ3VyZSc6XG4gICAgICBjYXNlICdmb290ZXInOlxuICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgIGNhc2UgJ2hncm91cCc6XG4gICAgICBjYXNlICdtYWluJzpcbiAgICAgIGNhc2UgJ21lbnUnOlxuICAgICAgY2FzZSAnbmF2JzpcbiAgICAgIGNhc2UgJ29sJzpcbiAgICAgIGNhc2UgJ3AnOlxuICAgICAgY2FzZSAnc2VjdGlvbic6XG4gICAgICBjYXNlICdzdW1tYXJ5JzpcbiAgICAgIGNhc2UgJ3VsJzpcbiAgICAgIGNhc2UgJ3ByZSc6XG4gICAgICBjYXNlICdsaXN0aW5nJzpcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgIGNhc2UgJ2hyJzpcbiAgICAgIGNhc2UgJ3htcCc6XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICB2YXIgZGlkV2FybiA9IHt9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZyA9IGZ1bmN0aW9uIChjaGlsZFRhZywgY2hpbGRUZXh0LCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcblxuICAgIGlmIChjaGlsZFRleHQgIT0gbnVsbCkge1xuICAgICAgd2FybmluZyhjaGlsZFRhZyA9PSBudWxsLCAndmFsaWRhdGVET01OZXN0aW5nOiB3aGVuIGNoaWxkVGV4dCBpcyBwYXNzZWQsIGNoaWxkVGFnIHNob3VsZCBiZSBudWxsJyk7XG4gICAgICBjaGlsZFRhZyA9ICcjdGV4dCc7XG4gICAgfVxuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGludmFsaWRQYXJlbnRPckFuY2VzdG9yID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG4gICAgaWYgKCFpbnZhbGlkUGFyZW50T3JBbmNlc3Rvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBhbmNlc3RvclRhZyA9IGludmFsaWRQYXJlbnRPckFuY2VzdG9yLnRhZztcbiAgICB2YXIgYWRkZW5kdW0gPSBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDYoKTtcblxuICAgIHZhciB3YXJuS2V5ID0gISFpbnZhbGlkUGFyZW50ICsgJ3wnICsgY2hpbGRUYWcgKyAnfCcgKyBhbmNlc3RvclRhZyArICd8JyArIGFkZGVuZHVtO1xuICAgIGlmIChkaWRXYXJuW3dhcm5LZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5bd2FybktleV0gPSB0cnVlO1xuXG4gICAgdmFyIHRhZ0Rpc3BsYXlOYW1lID0gY2hpbGRUYWc7XG4gICAgdmFyIHdoaXRlc3BhY2VJbmZvID0gJyc7XG4gICAgaWYgKGNoaWxkVGFnID09PSAnI3RleHQnKSB7XG4gICAgICBpZiAoL1xcUy8udGVzdChjaGlsZFRleHQpKSB7XG4gICAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJ1RleHQgbm9kZXMnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnV2hpdGVzcGFjZSB0ZXh0IG5vZGVzJztcbiAgICAgICAgd2hpdGVzcGFjZUluZm8gPSBcIiBNYWtlIHN1cmUgeW91IGRvbid0IGhhdmUgYW55IGV4dHJhIHdoaXRlc3BhY2UgYmV0d2VlbiB0YWdzIG9uIFwiICsgJ2VhY2ggbGluZSBvZiB5b3VyIHNvdXJjZSBjb2RlLic7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhZ0Rpc3BsYXlOYW1lID0gJzwnICsgY2hpbGRUYWcgKyAnPic7XG4gICAgfVxuXG4gICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICBpZiAoYW5jZXN0b3JUYWcgPT09ICd0YWJsZScgJiYgY2hpbGRUYWcgPT09ICd0cicpIHtcbiAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgfVxuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgY2hpbGQgb2YgPCVzPi4lcyVzJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIHdoaXRlc3BhY2VJbmZvLCBpbmZvLCBhZGRlbmR1bSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogJXMgY2Fubm90IGFwcGVhciBhcyBhIGRlc2NlbmRhbnQgb2YgJyArICc8JXM+LiVzJywgdGFnRGlzcGxheU5hbWUsIGFuY2VzdG9yVGFnLCBhZGRlbmR1bSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRPRE86IHR1cm4gdGhpcyBpbnRvIGEgbmFtZWQgZXhwb3J0XG4gIHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvID0gdXBkYXRlZEFuY2VzdG9ySW5mbyQxO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLmN1cnJlbnQ7XG4gICAgdmFyIHBhcmVudFRhZyA9IHBhcmVudEluZm8gJiYgcGFyZW50SW5mby50YWc7XG4gICAgcmV0dXJuIGlzVGFnVmFsaWRXaXRoUGFyZW50KHRhZywgcGFyZW50VGFnKSAmJiAhZmluZEludmFsaWRBbmNlc3RvckZvclRhZyh0YWcsIGFuY2VzdG9ySW5mbyk7XG4gIH07XG59XG5cbnZhciB2YWxpZGF0ZURPTU5lc3RpbmckMSA9IHZhbGlkYXRlRE9NTmVzdGluZztcblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGNyZWF0ZUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50JDE7XG52YXIgY3JlYXRlVGV4dE5vZGUgPSBjcmVhdGVUZXh0Tm9kZSQxO1xudmFyIHNldEluaXRpYWxQcm9wZXJ0aWVzID0gc2V0SW5pdGlhbFByb3BlcnRpZXMkMTtcbnZhciBkaWZmUHJvcGVydGllcyA9IGRpZmZQcm9wZXJ0aWVzJDE7XG52YXIgdXBkYXRlUHJvcGVydGllcyA9IHVwZGF0ZVByb3BlcnRpZXMkMTtcbnZhciBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzID0gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFRleHQgPSBkaWZmSHlkcmF0ZWRUZXh0JDE7XG52YXIgd2FybkZvclVubWF0Y2hlZFRleHQgPSB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxO1xudmFyIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQgPSB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMTtcbnZhciB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQgPSB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQkMTtcbnZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gdmFsaWRhdGVET01OZXN0aW5nJDEudXBkYXRlZEFuY2VzdG9ySW5mbztcbnZhciBwcmVjYWNoZUZpYmVyTm9kZSA9IHByZWNhY2hlRmliZXJOb2RlJDE7XG52YXIgdXBkYXRlRmliZXJQcm9wcyA9IHVwZGF0ZUZpYmVyUHJvcHMkMTtcblxuXG57XG4gIHZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyA9ICdzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcnO1xuICBpZiAodHlwZW9mIE1hcCAhPT0gJ2Z1bmN0aW9uJyB8fCBNYXAucHJvdG90eXBlID09IG51bGwgfHwgdHlwZW9mIE1hcC5wcm90b3R5cGUuZm9yRWFjaCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0ICE9PSAnZnVuY3Rpb24nIHx8IFNldC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5jbGVhciAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgU2V0LnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gTWFwIGFuZCBTZXQgYnVpbHQtaW4gdHlwZXMuIE1ha2Ugc3VyZSB0aGF0IHlvdSBsb2FkIGEgJyArICdwb2x5ZmlsbCBpbiBvbGRlciBicm93c2Vycy4gaHR0cDovL2ZiLm1lL3JlYWN0LXBvbHlmaWxscycpO1xuICB9XG59XG5cbmluamVjdGlvbiQzLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQoUmVhY3RET01GaWJlckNvbXBvbmVudCk7XG5cbnZhciBldmVudHNFbmFibGVkID0gbnVsbDtcbnZhciBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG5cbi8qKlxuICogVHJ1ZSBpZiB0aGUgc3VwcGxpZWQgRE9NIG5vZGUgaXMgYSB2YWxpZCBub2RlIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgRE9NIGlzIGEgdmFsaWQgRE9NIG5vZGUuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZENvbnRhaW5lcihub2RlKSB7XG4gIHJldHVybiAhIShub2RlICYmIChub2RlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSAmJiBub2RlLm5vZGVWYWx1ZSA9PT0gJyByZWFjdC1tb3VudC1wb2ludC11bnN0YWJsZSAnKSk7XG59XG5cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljKGNvbnRhaW5lcikge1xuICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgcmV0dXJuICEhKHJvb3RFbGVtZW50ICYmIHJvb3RFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdEVsZW1lbnQuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdidXR0b24nOlxuICAgIGNhc2UgJ2lucHV0JzpcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJldHVybiAhIXByb3BzLmF1dG9Gb2N1cztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbnZhciBET01SZW5kZXJlciA9IHJlYWN0UmVjb25jaWxlcih7XG4gIGdldFJvb3RIb3N0Q29udGV4dDogZnVuY3Rpb24gKHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgIHZhciB0eXBlID0gdm9pZCAwO1xuICAgIHZhciBuYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgdmFyIG5vZGVUeXBlID0gcm9vdENvbnRhaW5lckluc3RhbmNlLm5vZGVUeXBlO1xuICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgRE9DVU1FTlRfTk9ERTpcbiAgICAgIGNhc2UgRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAge1xuICAgICAgICAgIHR5cGUgPSBub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSA/ICcjZG9jdW1lbnQnIDogJyNmcmFnbWVudCc7XG4gICAgICAgICAgdmFyIHJvb3QgPSByb290Q29udGFpbmVySW5zdGFuY2UuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICAgIG5hbWVzcGFjZSA9IHJvb3QgPyByb290Lm5hbWVzcGFjZVVSSSA6IGdldENoaWxkTmFtZXNwYWNlKG51bGwsICcnKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFID8gcm9vdENvbnRhaW5lckluc3RhbmNlLnBhcmVudE5vZGUgOiByb290Q29udGFpbmVySW5zdGFuY2U7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IGNvbnRhaW5lci5uYW1lc3BhY2VVUkkgfHwgbnVsbDtcbiAgICAgICAgICB0eXBlID0gY29udGFpbmVyLnRhZ05hbWU7XG4gICAgICAgICAgbmFtZXNwYWNlID0gZ2V0Q2hpbGROYW1lc3BhY2Uob3duTmFtZXNwYWNlLCB0eXBlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICB2YXIgdmFsaWRhdGVkVGFnID0gdHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHZhbGlkYXRlZFRhZywgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IG5hbWVzcGFjZSwgYW5jZXN0b3JJbmZvOiBfYW5jZXN0b3JJbmZvIH07XG4gICAgfVxuICAgIHJldHVybiBuYW1lc3BhY2U7XG4gIH0sXG4gIGdldENoaWxkSG9zdENvbnRleHQ6IGZ1bmN0aW9uIChwYXJlbnRIb3N0Q29udGV4dCwgdHlwZSkge1xuICAgIHtcbiAgICAgIHZhciBwYXJlbnRIb3N0Q29udGV4dERldiA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgICAgdmFyIF9uYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnRIb3N0Q29udGV4dERldi5uYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgdmFyIF9hbmNlc3RvckluZm8yID0gdXBkYXRlZEFuY2VzdG9ySW5mbyhwYXJlbnRIb3N0Q29udGV4dERldi5hbmNlc3RvckluZm8sIHR5cGUsIG51bGwpO1xuICAgICAgcmV0dXJuIHsgbmFtZXNwYWNlOiBfbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8yIH07XG4gICAgfVxuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSBwYXJlbnRIb3N0Q29udGV4dDtcbiAgICByZXR1cm4gZ2V0Q2hpbGROYW1lc3BhY2UocGFyZW50TmFtZXNwYWNlLCB0eXBlKTtcbiAgfSxcbiAgZ2V0UHVibGljSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSxcbiAgcHJlcGFyZUZvckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIGV2ZW50c0VuYWJsZWQgPSBpc0VuYWJsZWQoKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCk7XG4gICAgc2V0RW5hYmxlZChmYWxzZSk7XG4gIH0sXG4gIHJlc2V0QWZ0ZXJDb21taXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXN0b3JlU2VsZWN0aW9uKHNlbGVjdGlvbkluZm9ybWF0aW9uKTtcbiAgICBzZWxlY3Rpb25JbmZvcm1hdGlvbiA9IG51bGw7XG4gICAgc2V0RW5hYmxlZChldmVudHNFbmFibGVkKTtcbiAgICBldmVudHNFbmFibGVkID0gbnVsbDtcbiAgfSxcbiAgY3JlYXRlSW5zdGFuY2U6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAge1xuICAgICAgLy8gVE9ETzogdGFrZSBuYW1lc3BhY2UgaW50byBhY2NvdW50IHdoZW4gdmFsaWRhdGluZy5cbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEodHlwZSwgbnVsbCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgcHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICB9XG4gICAgdmFyIGRvbUVsZW1lbnQgPSBjcmVhdGVFbGVtZW50KHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIHBhcmVudE5hbWVzcGFjZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgZG9tRWxlbWVudCk7XG4gICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgcmV0dXJuIGRvbUVsZW1lbnQ7XG4gIH0sXG4gIGFwcGVuZEluaXRpYWxDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgfSxcbiAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW46IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgc2V0SW5pdGlhbFByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcmV0dXJuIHNob3VsZEF1dG9Gb2N1c0hvc3RDb21wb25lbnQodHlwZSwgcHJvcHMpO1xuICB9LFxuICBwcmVwYXJlVXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAge1xuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICBpZiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuICE9PSB0eXBlb2Ygb2xkUHJvcHMuY2hpbGRyZW4gJiYgKHR5cGVvZiBuZXdQcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgdmFyIHN0cmluZyA9ICcnICsgbmV3UHJvcHMuY2hpbGRyZW47XG4gICAgICAgIHZhciBvd25BbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvKGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHN0cmluZywgb3duQW5jZXN0b3JJbmZvKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRpZmZQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgfSxcbiAgc2hvdWxkU2V0VGV4dENvbnRlbnQ6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiB0eXBlID09PSAndGV4dGFyZWEnIHx8IHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT09ICdvYmplY3QnICYmIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9PSBudWxsICYmIHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTC5fX2h0bWwgPT09ICdzdHJpbmcnO1xuICB9LFxuICBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOiBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICByZXR1cm4gISFwcm9wcy5oaWRkZW47XG4gIH0sXG4gIGNyZWF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIHZhbGlkYXRlRE9NTmVzdGluZyQxKG51bGwsIHRleHQsIGhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbyk7XG4gICAgfVxuICAgIHZhciB0ZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlKHRleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG4gICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dE5vZGUpO1xuICAgIHJldHVybiB0ZXh0Tm9kZTtcbiAgfSxcblxuXG4gIG5vdzogbm93LFxuXG4gIG11dGF0aW9uOiB7XG4gICAgY29tbWl0TW91bnQ6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBuZXdQcm9wcywgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgZG9tRWxlbWVudC5mb2N1cygpO1xuICAgIH0sXG4gICAgY29tbWl0VXBkYXRlOiBmdW5jdGlvbiAoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICAvLyBVcGRhdGUgdGhlIHByb3BzIGhhbmRsZSBzbyB0aGF0IHdlIGtub3cgd2hpY2ggcHJvcHMgYXJlIHRoZSBvbmVzIHdpdGhcbiAgICAgIC8vIHdpdGggY3VycmVudCBldmVudCBoYW5kbGVycy5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoZG9tRWxlbWVudCwgbmV3UHJvcHMpO1xuICAgICAgLy8gQXBwbHkgdGhlIGRpZmYgdG8gdGhlIERPTSBub2RlLlxuICAgICAgdXBkYXRlUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMpO1xuICAgIH0sXG4gICAgcmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQpIHtcbiAgICAgIGRvbUVsZW1lbnQudGV4dENvbnRlbnQgPSAnJztcbiAgICB9LFxuICAgIGNvbW1pdFRleHRVcGRhdGU6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgIHRleHRJbnN0YW5jZS5ub2RlVmFsdWUgPSBuZXdUZXh0O1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIGFwcGVuZENoaWxkVG9Db250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBjb250YWluZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGluc2VydEJlZm9yZTogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCwgYmVmb3JlQ2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgIH0sXG4gICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmU6IGZ1bmN0aW9uIChjb250YWluZXIsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLmluc2VydEJlZm9yZShjaGlsZCwgYmVmb3JlQ2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChwYXJlbnRJbnN0YW5jZSwgY2hpbGQpIHtcbiAgICAgIHBhcmVudEluc3RhbmNlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBoeWRyYXRpb246IHtcbiAgICBjYW5IeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBpbnN0YW5jZS5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFICYmIHR5cGUudG9Mb3dlckNhc2UoKSA9PT0gaW5zdGFuY2Uubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICB9LFxuICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAgIC8vIEVtcHR5IHN0cmluZ3MgYXJlIG5vdCBwYXJzZWQgYnkgSFRNTCBzbyB0aGVyZSB3b24ndCBiZSBhIGNvcnJlY3QgbWF0Y2ggaGVyZS5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluc3RhbmNlLm5vZGVUeXBlID09PSBURVhUX05PREU7XG4gICAgfSxcbiAgICBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgICAgdmFyIG5vZGUgPSBpbnN0YW5jZS5uZXh0U2libGluZztcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobm9kZSAmJiBub2RlLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbm9kZS5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5vZGUgPSBub2RlLm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcbiAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlKSB7XG4gICAgICB2YXIgbmV4dCA9IHBhcmVudEluc3RhbmNlLmZpcnN0Q2hpbGQ7XG4gICAgICAvLyBTa2lwIG5vbi1oeWRyYXRhYmxlIG5vZGVzLlxuICAgICAgd2hpbGUgKG5leHQgJiYgbmV4dC5ub2RlVHlwZSAhPT0gRUxFTUVOVF9OT0RFICYmIG5leHQubm9kZVR5cGUgIT09IFRFWFRfTk9ERSkge1xuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH0sXG4gICAgaHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBpbnN0YW5jZSk7XG4gICAgICAvLyBUT0RPOiBQb3NzaWJseSBkZWZlciB0aGlzIHVudGlsIHRoZSBjb21taXQgcGhhc2Ugd2hlcmUgYWxsIHRoZSBldmVudHNcbiAgICAgIC8vIGdldCBhdHRhY2hlZC5cbiAgICAgIHVwZGF0ZUZpYmVyUHJvcHMoaW5zdGFuY2UsIHByb3BzKTtcbiAgICAgIHZhciBwYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG4gICAgICB7XG4gICAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgICBwYXJlbnROYW1lc3BhY2UgPSBob3N0Q29udGV4dERldi5uYW1lc3BhY2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkUHJvcGVydGllcyhpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHBhcmVudE5hbWVzcGFjZSwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICB9LFxuICAgIGh5ZHJhdGVUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uICh0ZXh0SW5zdGFuY2UsIHRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIHRleHRJbnN0YW5jZSk7XG4gICAgICByZXR1cm4gZGlmZkh5ZHJhdGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgIH0sXG4gICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9yVW5tYXRjaGVkVGV4dCh0ZXh0SW5zdGFuY2UsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSkge1xuICAgICAge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudENvbnRhaW5lciwgaW5zdGFuY2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZVRleHQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICBpZiAoaW5zdGFuY2Uubm9kZVR5cGUgPT09IDEpIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRJbnN0YW5jZSwgaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lckluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcykge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50Q29udGFpbmVyLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudENvbnRhaW5lciwgdGV4dCkge1xuICAgICAge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZFRleHQocGFyZW50Q29udGFpbmVyLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50KHBhcmVudEluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazogcklDLFxuXG4gIHVzZVN5bmNTY2hlZHVsaW5nOiAhZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTVxufSk7XG5cbmluamVjdGlvbiQ0LmluamVjdEZpYmVyQmF0Y2hlZFVwZGF0ZXMoRE9NUmVuZGVyZXIuYmF0Y2hlZFVwZGF0ZXMpO1xuXG52YXIgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgY2hpbGRyZW4sIGNvbnRhaW5lciwgZm9yY2VIeWRyYXRlLCBjYWxsYmFjaykge1xuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICB7XG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyICYmIGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICB2YXIgaG9zdEluc3RhbmNlID0gRE9NUmVuZGVyZXIuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIuY3VycmVudCk7XG4gICAgICBpZiAoaG9zdEluc3RhbmNlKSB7XG4gICAgICAgIHdhcm5pbmcoaG9zdEluc3RhbmNlLnBhcmVudE5vZGUgPT09IGNvbnRhaW5lciwgJ3JlbmRlciguLi4pOiBJdCBsb29rcyBsaWtlIHRoZSBSZWFjdC1yZW5kZXJlZCBjb250ZW50IG9mIHRoaXMgJyArICdjb250YWluZXIgd2FzIHJlbW92ZWQgd2l0aG91dCB1c2luZyBSZWFjdC4gVGhpcyBpcyBub3QgJyArICdzdXBwb3J0ZWQgYW5kIHdpbGwgY2F1c2UgZXJyb3JzLiBJbnN0ZWFkLCBjYWxsICcgKyAnUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSB0byBlbXB0eSBhIGNvbnRhaW5lci4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgaXNSb290UmVuZGVyZWRCeVNvbWVSZWFjdCA9ICEhY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gICAgdmFyIHJvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKHJvb3RFbCAmJiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEocm9vdEVsKSk7XG5cbiAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCB8fCBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0LCAncmVuZGVyKC4uLik6IFJlcGxhY2luZyBSZWFjdC1yZW5kZXJlZCBjaGlsZHJlbiB3aXRoIGEgbmV3IHJvb3QgJyArICdjb21wb25lbnQuIElmIHlvdSBpbnRlbmRlZCB0byB1cGRhdGUgdGhlIGNoaWxkcmVuIG9mIHRoaXMgbm9kZSwgJyArICd5b3Ugc2hvdWxkIGluc3RlYWQgaGF2ZSB0aGUgZXhpc3RpbmcgY2hpbGRyZW4gdXBkYXRlIHRoZWlyIHN0YXRlICcgKyAnYW5kIHJlbmRlciB0aGUgbmV3IGNvbXBvbmVudHMgaW5zdGVhZCBvZiBjYWxsaW5nIFJlYWN0RE9NLnJlbmRlci4nKTtcblxuICAgIHdhcm5pbmcoY29udGFpbmVyLm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgfHwgIWNvbnRhaW5lci50YWdOYW1lIHx8IGNvbnRhaW5lci50YWdOYW1lLnRvVXBwZXJDYXNlKCkgIT09ICdCT0RZJywgJ3JlbmRlcigpOiBSZW5kZXJpbmcgY29tcG9uZW50cyBkaXJlY3RseSBpbnRvIGRvY3VtZW50LmJvZHkgaXMgJyArICdkaXNjb3VyYWdlZCwgc2luY2UgaXRzIGNoaWxkcmVuIGFyZSBvZnRlbiBtYW5pcHVsYXRlZCBieSB0aGlyZC1wYXJ0eSAnICsgJ3NjcmlwdHMgYW5kIGJyb3dzZXIgZXh0ZW5zaW9ucy4gVGhpcyBtYXkgbGVhZCB0byBzdWJ0bGUgJyArICdyZWNvbmNpbGlhdGlvbiBpc3N1ZXMuIFRyeSByZW5kZXJpbmcgaW50byBhIGNvbnRhaW5lciBlbGVtZW50IGNyZWF0ZWQgJyArICdmb3IgeW91ciBhcHAuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyO1xuICBpZiAoIXJvb3QpIHtcbiAgICB2YXIgc2hvdWxkSHlkcmF0ZSA9IGZvcmNlSHlkcmF0ZSB8fCBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKTtcbiAgICAvLyBGaXJzdCBjbGVhciBhbnkgZXhpc3RpbmcgY29udGVudC5cbiAgICBpZiAoIXNob3VsZEh5ZHJhdGUpIHtcbiAgICAgIHZhciB3YXJuZWQgPSBmYWxzZTtcbiAgICAgIHZhciByb290U2libGluZyA9IHZvaWQgMDtcbiAgICAgIHdoaWxlIChyb290U2libGluZyA9IGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghd2FybmVkICYmIHJvb3RTaWJsaW5nLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgcm9vdFNpYmxpbmcuaGFzQXR0cmlidXRlKFJPT1RfQVRUUklCVVRFX05BTUUpKSB7XG4gICAgICAgICAgICB3YXJuZWQgPSB0cnVlO1xuICAgICAgICAgICAgd2FybmluZyhmYWxzZSwgJ3JlbmRlcigpOiBUYXJnZXQgbm9kZSBoYXMgbWFya3VwIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgdGhlcmUgJyArICdhcmUgdW5yZWxhdGVkIG5vZGVzIGFzIHdlbGwuIFRoaXMgaXMgbW9zdCBjb21tb25seSBjYXVzZWQgYnkgJyArICd3aGl0ZS1zcGFjZSBpbnNlcnRlZCBhcm91bmQgc2VydmVyLXJlbmRlcmVkIG1hcmt1cC4nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKHJvb3RTaWJsaW5nKTtcbiAgICAgIH1cbiAgICB9XG4gICAge1xuICAgICAgaWYgKHNob3VsZEh5ZHJhdGUgJiYgIWZvcmNlSHlkcmF0ZSAmJiAhd2FybmVkQWJvdXRIeWRyYXRlQVBJKSB7XG4gICAgICAgIHdhcm5lZEFib3V0SHlkcmF0ZUFQSSA9IHRydWU7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAncmVuZGVyKCk6IENhbGxpbmcgUmVhY3RET00ucmVuZGVyKCkgdG8gaHlkcmF0ZSBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwICcgKyAnd2lsbCBzdG9wIHdvcmtpbmcgaW4gUmVhY3QgdjE3LiBSZXBsYWNlIHRoZSBSZWFjdERPTS5yZW5kZXIoKSBjYWxsICcgKyAnd2l0aCBSZWFjdERPTS5oeWRyYXRlKCkgaWYgeW91IHdhbnQgUmVhY3QgdG8gYXR0YWNoIHRvIHRoZSBzZXJ2ZXIgSFRNTC4nKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIG5ld1Jvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBzaG91bGRIeWRyYXRlKTtcbiAgICByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgPSBuZXdSb290O1xuICAgIC8vIEluaXRpYWwgbW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgIERPTVJlbmRlcmVyLnVuYmF0Y2hlZFVwZGF0ZXMoZnVuY3Rpb24gKCkge1xuICAgICAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCBuZXdSb290LCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIHJvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBET01SZW5kZXJlci5nZXRQdWJsaWNSb290SW5zdGFuY2Uocm9vdCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVyKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IG51bGw7XG5cbiAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ1RhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiB2b2lkIDA7XG4gIC8vIFRPRE86IHBhc3MgUmVhY3RET00gcG9ydGFsIGltcGxlbWVudGF0aW9uIGFzIHRoaXJkIGFyZ3VtZW50XG4gIHJldHVybiBjcmVhdGVQb3J0YWwkMShjaGlsZHJlbiwgY29udGFpbmVyLCBudWxsLCBrZXkpO1xufVxuXG5mdW5jdGlvbiBSZWFjdFJvb3QoY29udGFpbmVyLCBoeWRyYXRlKSB7XG4gIHZhciByb290ID0gRE9NUmVuZGVyZXIuY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lciA9IHJvb3Q7XG59XG5SZWFjdFJvb3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIChjaGlsZHJlbiwgY2FsbGJhY2spIHtcbiAgdmFyIHJvb3QgPSB0aGlzLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblJlYWN0Um9vdC5wcm90b3R5cGUudW5tb3VudCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIHJvb3QsIG51bGwsIGNhbGxiYWNrKTtcbn07XG5cbnZhciBSZWFjdERPTSA9IHtcbiAgY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgZmluZERPTU5vZGU6IGZ1bmN0aW9uIChjb21wb25lbnRPckVsZW1lbnQpIHtcbiAgICB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB3YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXI7XG4gICAgICAgIHdhcm5pbmcod2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgZmluZERPTU5vZGUgaW5zaWRlIGl0cyByZW5kZXIoKS4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUob3duZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgICBvd25lci5zdGF0ZU5vZGUuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9yRWxlbWVudC5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gY29tcG9uZW50T3JFbGVtZW50O1xuICAgIH1cblxuICAgIHZhciBpbnN0ID0gZ2V0KGNvbXBvbmVudE9yRWxlbWVudCk7XG4gICAgaWYgKGluc3QpIHtcbiAgICAgIHJldHVybiBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlKGluc3QpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IGFwcGVhcnMgdG8gYmUgbmVpdGhlciBSZWFjdENvbXBvbmVudCBub3IgRE9NTm9kZS4gS2V5czogJXMnLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKTtcbiAgICB9XG4gIH0sXG4gIGh5ZHJhdGU6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgLy8gVE9ETzogdGhyb3cgb3Igd2FybiBpZiB3ZSBjb3VsZG4ndCBoeWRyYXRlP1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIHRydWUsIGNhbGxiYWNrKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBlbGVtZW50LCBjb250YWluZXIsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgaGFzKHBhcmVudENvbXBvbmVudCkpID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBlbGVtZW50LCBjb250YWluZXJOb2RlLCBmYWxzZSwgY2FsbGJhY2spO1xuICB9LFxuICB1bm1vdW50Q29tcG9uZW50QXROb2RlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XG4gICAgIWlzVmFsaWRDb250YWluZXIoY29udGFpbmVyKSA/IGludmFyaWFudChmYWxzZSwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcblxuICAgIGlmIChjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcikge1xuICAgICAge1xuICAgICAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciByZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QgPSByb290RWwgJiYgIWdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpO1xuICAgICAgICB3YXJuaW5nKCFyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBhbm90aGVyIGNvcHkgb2YgUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFVubW91bnQgc2hvdWxkIG5vdCBiZSBiYXRjaGVkLlxuICAgICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIG51bGwsIGNvbnRhaW5lciwgZmFsc2UsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG51bGw7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICAvLyBJZiB5b3UgY2FsbCB1bm1vdW50Q29tcG9uZW50QXROb2RlIHR3aWNlIGluIHF1aWNrIHN1Y2Nlc3Npb24sIHlvdSdsbFxuICAgICAgLy8gZ2V0IGB0cnVlYCB0d2ljZS4gVGhhdCdzIHByb2JhYmx5IGZpbmU/XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3RFbCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICB2YXIgaGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSAhIShfcm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShfcm9vdEVsKSk7XG5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICAgIHZhciBpc0NvbnRhaW5lclJlYWN0Um9vdCA9IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gMSAmJiBpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lci5wYXJlbnROb2RlKSAmJiAhIWNvbnRhaW5lci5wYXJlbnROb2RlLl9yZWFjdFJvb3RDb250YWluZXI7XG5cbiAgICAgICAgd2FybmluZyghaGFzTm9uUm9vdFJlYWN0Q2hpbGQsIFwidW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3UncmUgYXR0ZW1wdGluZyB0byB1bm1vdW50IFwiICsgJ3dhcyByZW5kZXJlZCBieSBSZWFjdCBhbmQgaXMgbm90IGEgdG9wLWxldmVsIGNvbnRhaW5lci4gJXMnLCBpc0NvbnRhaW5lclJlYWN0Um9vdCA/ICdZb3UgbWF5IGhhdmUgYWNjaWRlbnRhbGx5IHBhc3NlZCBpbiBhIFJlYWN0IHJvb3Qgbm9kZSBpbnN0ZWFkICcgKyAnb2YgaXRzIGNvbnRhaW5lci4nIDogJ0luc3RlYWQsIGhhdmUgdGhlIHBhcmVudCBjb21wb25lbnQgdXBkYXRlIGl0cyBzdGF0ZSBhbmQgJyArICdyZXJlbmRlciBpbiBvcmRlciB0byByZW1vdmUgdGhpcyBjb21wb25lbnQuJyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cblxuICAvLyBUZW1wb3JhcnkgYWxpYXMgc2luY2Ugd2UgYWxyZWFkeSBzaGlwcGVkIFJlYWN0IDE2IFJDIHdpdGggaXQuXG4gIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy5cbiAgdW5zdGFibGVfY3JlYXRlUG9ydGFsOiBjcmVhdGVQb3J0YWwsXG5cbiAgdW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gIHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczogRE9NUmVuZGVyZXIuZGVmZXJyZWRVcGRhdGVzLFxuXG4gIGZsdXNoU3luYzogRE9NUmVuZGVyZXIuZmx1c2hTeW5jLFxuXG4gIF9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEOiB7XG4gICAgLy8gRm9yIFRhcEV2ZW50UGx1Z2luIHdoaWNoIGlzIHBvcHVsYXIgaW4gb3BlbiBzb3VyY2VcbiAgICBFdmVudFBsdWdpbkh1YjogRXZlbnRQbHVnaW5IdWIsXG4gICAgLy8gVXNlZCBieSB0ZXN0LXV0aWxzXG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeTogRXZlbnRQbHVnaW5SZWdpc3RyeSxcbiAgICBFdmVudFByb3BhZ2F0b3JzOiBFdmVudFByb3BhZ2F0b3JzLFxuICAgIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudDogUmVhY3RDb250cm9sbGVkQ29tcG9uZW50LFxuICAgIFJlYWN0RE9NQ29tcG9uZW50VHJlZTogUmVhY3RET01Db21wb25lbnRUcmVlLFxuICAgIFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjogUmVhY3RET01FdmVudExpc3RlbmVyXG4gIH1cbn07XG5cbmlmIChlbmFibGVDcmVhdGVSb290KSB7XG4gIFJlYWN0RE9NLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbiBjcmVhdGVSb290KGNvbnRhaW5lciwgb3B0aW9ucykge1xuICAgIHZhciBoeWRyYXRlID0gb3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuaHlkcmF0ZSA9PT0gdHJ1ZTtcbiAgICByZXR1cm4gbmV3IFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpO1xuICB9O1xufVxuXG52YXIgZm91bmREZXZUb29scyA9IERPTVJlbmRlcmVyLmluamVjdEludG9EZXZUb29scyh7XG4gIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcbiAgYnVuZGxlVHlwZTogMSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuICByZW5kZXJlclBhY2thZ2VOYW1lOiAncmVhY3QtZG9tJ1xufSk7XG5cbntcbiAgaWYgKCFmb3VuZERldlRvb2xzICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB3aW5kb3cudG9wID09PSB3aW5kb3cuc2VsZikge1xuICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgIGlmIChuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID4gLTEgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdFZGdlJykgPT09IC0xIHx8IG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignRmlyZWZveCcpID4gLTEpIHtcbiAgICAgIHZhciBwcm90b2NvbCA9IHdpbmRvdy5sb2NhdGlvbi5wcm90b2NvbDtcbiAgICAgIC8vIERvbid0IHdhcm4gaW4gZXhvdGljIGNhc2VzIGxpa2UgY2hyb21lLWV4dGVuc2lvbjovLy5cbiAgICAgIGlmICgvXihodHRwcz98ZmlsZSk6JC8udGVzdChwcm90b2NvbCkpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKCclY0Rvd25sb2FkIHRoZSBSZWFjdCBEZXZUb29scyAnICsgJ2ZvciBhIGJldHRlciBkZXZlbG9wbWVudCBleHBlcmllbmNlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMnICsgKHByb3RvY29sID09PSAnZmlsZTonID8gJ1xcbllvdSBtaWdodCBuZWVkIHRvIHVzZSBhIGxvY2FsIEhUVFAgc2VydmVyIChpbnN0ZWFkIG9mIGZpbGU6Ly8pOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtZGV2dG9vbHMtZmFxJyA6ICcnKSwgJ2ZvbnQtd2VpZ2h0OmJvbGQnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuXG5cbnZhciBSZWFjdERPTSQyID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGRlZmF1bHQ6IFJlYWN0RE9NXG59KTtcblxudmFyIFJlYWN0RE9NJDMgPSAoIFJlYWN0RE9NJDIgJiYgUmVhY3RET00gKSB8fCBSZWFjdERPTSQyO1xuXG4vLyBUT0RPOiBkZWNpZGUgb24gdGhlIHRvcC1sZXZlbCBleHBvcnQgZm9ybS5cbi8vIFRoaXMgaXMgaGFja3kgYnV0IG1ha2VzIGl0IHdvcmsgd2l0aCBib3RoIFJvbGx1cCBhbmQgSmVzdC5cbnZhciByZWFjdERvbSA9IFJlYWN0RE9NJDNbJ2RlZmF1bHQnXSA/IFJlYWN0RE9NJDNbJ2RlZmF1bHQnXSA6IFJlYWN0RE9NJDM7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVhY3REb207XG4gIH0pKCk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20uZGV2ZWxvcG1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaHlwaGVuYXRlID0gcmVxdWlyZSgnLi9oeXBoZW5hdGUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9ebXMtLztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBDU1MgcHJvcGVydHkgbmFtZSwgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnYmFja2dyb3VuZENvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmQtY29sb3JcIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnTW96VHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbW96LXRyYW5zaXRpb25cIlxuICogICA+IGh5cGhlbmF0ZVN0eWxlTmFtZSgnbXNUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tcy10cmFuc2l0aW9uXCJcbiAqXG4gKiBBcyBNb2Rlcm5penIgc3VnZ2VzdHMgKGh0dHA6Ly9tb2Rlcm5penIuY29tL2RvY3MvI3ByZWZpeGVkKSwgYW4gYG1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBgLW1zLWAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBoeXBoZW5hdGUoc3RyaW5nKS5yZXBsYWNlKG1zUGF0dGVybiwgJy1tcy0nKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBfdXBwZXJjYXNlUGF0dGVybiA9IC8oW0EtWl0pL2c7XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgc3RyaW5nLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKlxuICogRm9yIENTUyBzdHlsZSBuYW1lcywgdXNlIGBoeXBoZW5hdGVTdHlsZU5hbWVgIGluc3RlYWQgd2hpY2ggd29ya3MgcHJvcGVybHlcbiAqIHdpdGggYWxsIHZlbmRvciBwcmVmaXhlcywgaW5jbHVkaW5nIGBtc2AuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfdXBwZXJjYXNlUGF0dGVybiwgJy0kMScpLnRvTG93ZXJDYXNlKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwiaW1wb3J0IFJlYWN0LCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBheGlvcyBmcm9tICdheGlvcyc7XG5pbXBvcnQgQmFzaWNJbmZvIGZyb20gJy4vY29tcG9uZW50cy9iYXNpY2luZm8nO1xuaW1wb3J0IEJpbyBmcm9tICcuL2NvbXBvbmVudHMvYmlvJztcbmltcG9ydCBUZWNoU2tpbGxzIGZyb20gJy4vY29tcG9uZW50cy90ZWNoc2tpbGxzJztcbmltcG9ydCBFeHBlcmllbmNlIGZyb20gJy4vY29tcG9uZW50cy9leHBlcmllbmNlJztcbmltcG9ydCBQcm9qZWN0cyBmcm9tICcuL2NvbXBvbmVudHMvcHJvamVjdHMnO1xuXG5jbGFzcyBBcHAgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb25zdHJ1Y3Rvcihwcm9wcyl7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGRhdGE6IHt9XG4gICAgfVxuXG4gICAgdGhpcy5sb2FkQ29tbWVudHNGcm9tU2VydmVyID0gdGhpcy5sb2FkQ29tbWVudHNGcm9tU2VydmVyLmJpbmQodGhpcyk7XG5cbiAgfVxuXG4gIGxvYWRDb21tZW50c0Zyb21TZXJ2ZXIoKSB7XG4gICAgYXhpb3MuZ2V0KHRoaXMucHJvcHMudXJsKVxuICAgICAgLnRoZW4ocmVzID0+IHtcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh7IGRhdGE6IHJlcy5kYXRhWzBdIH0pO1xuICAgIH0pXG4gIH1cblxuXG4gIGNvbXBvbmVudERpZE1vdW50KCl7XG4gICAgdGhpcy5sb2FkQ29tbWVudHNGcm9tU2VydmVyKClcbiAgfTtcblxuICByZW5kZXIoKSB7XG4gICAgcmV0dXJuIChcbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwid3JhcHBlclwiPlxuICAgICAgICA8QmFzaWNJbmZvIGluZm8gPSB7dGhpcy5zdGF0ZS5kYXRhLmJhc2ljaW5mb30gLz5cbiAgICAgICAgPEJpbyBpbmZvID0ge3RoaXMuc3RhdGUuZGF0YS5iaW99IC8+XG4gICAgICAgIDxUZWNoU2tpbGxzIGluZm8gPSB7dGhpcy5zdGF0ZS5kYXRhLnNraWxsc30gLz5cbiAgICAgICAgPEV4cGVyaWVuY2UgaW5mbyA9IHt0aGlzLnN0YXRlLmRhdGEuZXhwZXJpZW5jZX0gLz5cbiAgICAgICAgPFByb2plY3RzIC8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2FwcC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQmFzaWNJbmZvID0gKHByb3BzKSA9PiB7XG5cbiAgICBpZighcHJvcHMuaW5mbykge1xuICAgICAgcmV0dXJuIDxkaXY+TG9hZGluZyA8aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+PC9kaXY+O1xuICAgIH1cblxuICAgICQoZnVuY3Rpb24gKCkge1xuICAgICAgJCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLnRvb2x0aXAoe1xuICAgICAgICBodG1sOiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCB0b29sdGlwVGV4dCA9IFwiVGhpcyBDViBoYXMgYmVlbiBidWlsZCB3aXRoIE1vbmdvREIsIEV4cHJlc3MsIFJlYWN0IGFuZCBOb2RlXCI7XG5cbiAgICByZXR1cm4oXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxhIGhyZWY9XCIvZG9jcy9NYXhfX0dvbHViZXZfQ1YuZG9jeFwiIGNsYXNzTmFtZT1cImRvd25sb2FkLWljb25cIiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cImxlZnRcIiB0aXRsZT1cImRvd25sb2FkIGN2LmRvY3hcIj48aSBjbGFzc05hbWU9XCJmYSBmYS1kb3dubG9hZCBmYS0yeFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT48L2E+XG4gICAgICA8YSBjbGFzc05hbWU9XCJpbmZvXCIgaHJlZj0naHR0cHM6Ly9naXRodWIuY29tL01heEdvbC9DVl9IRVJPS1UnIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwibGVmdFwiIHRpdGxlPXsgdG9vbHRpcFRleHQgfT48c3BhbiBjbGFzc05hbWU9J2ZhIGZhLTJ4IGZhLWdpdGh1Yic+PC9zcGFuPjwvYT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy0xMlwiPlxuICAgICAgICAgICAgPGltZyBzcmM9XCIvaW1hZ2VzL21heC5wbmdcIiBjbGFzc05hbWU9XCJpbWctY2lyY2xlIGNlbnRlci1ibG9ja1wiIC8+XG4gICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj57IHByb3BzLmluZm8ubmFtZSB9PC9oND5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+PHN0cm9uZz57IHByb3BzLmluZm8udGl0bGUgfTwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDxociBjbGFzc05hbWU9XCJzbWFsbC1kaXZpZGVyXCIgLz5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+PHN0cm9uZz57IHByb3BzLmluZm8uYWRkcmVzcyB9PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj48c3Ryb25nPnsgcHJvcHMuaW5mby5lbWFpbCB9PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPGhyIGNsYXNzTmFtZT1cInNtYWxsLWRpdmlkZXJcIiAvPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj48c3Ryb25nPjA3NzM5IDM2NTQzMDwvc3Ryb25nPjwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljSW5mbztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL2Jhc2ljaW5mby5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IEJpbyA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj57IHByb3BzLmluZm8udGl0bGUgfTwvaDQ+XG4gICAgICAgICAgPGhyIGNsYXNzTmFtZT1cIm5vcm1hbC1kaXZpZGVyXCIgLz5cbiAgICAgICAgICA8cD57IHByb3BzLmluZm8uYWJvdXRfbWUgfTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvY29tcG9uZW50cy9iaW8uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNraWxsc0xpc3QgZnJvbSAnLi9za2lsbHNsaXN0JztcblxuY29uc3QgVGVjaFNraWxscyA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIGNvbnN0IHNraWxsTGlzdCA9IE9iamVjdC5rZXlzKHByb3BzLmluZm8uc2tpbGxzX3N0YWNrKS5tYXAoZnVuY3Rpb24oc2tpbGxuYW1lLCBpbmRleCl7XG4gICAgcmV0dXJuIDxTa2lsbHNMaXN0IGtleT17aW5kZXh9IG5hbWU9e3NraWxsbmFtZX0gc2tpbGxzPXtwcm9wcy5pbmZvLnNraWxsc19zdGFja1tza2lsbG5hbWVdfSAvPlxuICB9KVxuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj57IHByb3BzLmluZm8udGl0bGUgfTwvaDQ+XG4gICAgICAgICAgPGhyIGNsYXNzTmFtZT1cIm5vcm1hbC1kaXZpZGVyXCIgLz5cblxuICAgICAgICAgIHsgc2tpbGxMaXN0IH1cblxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRlY2hTa2lsbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvY29tcG9uZW50cy90ZWNoc2tpbGxzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgU2tpbGxzTGlzdCA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5za2lsbHMpIHtcbiAgICByZXR1cm4gPGRpdj48aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+PC9kaXY+O1xuICB9XG5cbiAgY29uc3Qgc2tpbGxzSXRlbXMgPSBwcm9wcy5za2lsbHMubWFwKGZ1bmN0aW9uKGl0ZW0pe1xuICAgIGlmKHByb3BzLnNraWxscy5pbmRleE9mKGl0ZW0pID09PSBwcm9wcy5za2lsbHMubGVuZ3RoLTEpe1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtICsgJywgJztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0XCI+PHN0cm9uZz57cHJvcHMubmFtZX06PC9zdHJvbmc+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xMFwiPntza2lsbHNJdGVtc308L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBTa2lsbHNMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2NvbXBvbmVudHMvc2tpbGxzbGlzdC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRXhwZXJpZW5jZUl0ZW0gZnJvbSAnLi9leHBlcmllbnNlbGlzdCc7XG5cblxuY29uc3QgRXhwZXJpZW5jZSA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIGNvbnN0IGV4cGVyaWVuY2VMaXN0SXRlbSA9IHByb3BzLmluZm8ud29yay5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xuICAgIHJldHVybiA8RXhwZXJpZW5jZUl0ZW0ga2V5PXtpbmRleH0gd29yaz17aXRlbX0gLz5cbiAgfSk7XG5cbiAgcmV0dXJuKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tcG9uZW50LWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wteHMtMTJcIj5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwic2VjdGlvbi10aXRsZVwiPnsgcHJvcHMuaW5mby50aXRsZSB9PC9oND5cbiAgICAgICAgICA8aHIgY2xhc3NOYW1lPVwibm9ybWFsLWRpdmlkZXJcIiAvPlxuXG4gICAgICAgICAgeyBleHBlcmllbmNlTGlzdEl0ZW0gfVxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwZXJpZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL2V4cGVyaWVuY2UuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBFeHBlcmllbmNlSXRlbSA9IChwcm9wcykgPT4ge1xuXG4gIGNvbnN0IGR1dHkgPSBwcm9wcy53b3JrLmR1dHkubWFwKGZ1bmN0aW9uKGl0ZW1kdXR5LCBpbmRleCl7XG4gICAgcmV0dXJuIDxsaSBrZXk9e2luZGV4fT57aXRlbWR1dHl9PC9saT47XG4gIH0pO1xuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyB3b3JrLWluZm9cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgIDxoND57IHByb3BzLndvcmsuY29tcGFueSB9PHNwYW4gY2xhc3NOYW1lPVwicHVsbC1yaWdodFwiPnsgcHJvcHMud29yay50aW1lIH08L3NwYW4+PC9oND5cbiAgICAgICAgPHA+eyBwcm9wcy53b3JrLm92ZXJ2aWV3IH08L3A+XG4gICAgICAgIDxoNT48c3Ryb25nPnsgcHJvcHMud29yay5qb2J0aXRsZSB9PC9zdHJvbmc+PC9oNT5cbiAgICAgICAgPHVsPlxuICAgICAgICAgIHsgZHV0eSB9XG4gICAgICAgIDwvdWw+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxuXG59XG5cbmV4cG9ydCBkZWZhdWx0IEV4cGVyaWVuY2VJdGVtO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2NvbXBvbmVudHMvZXhwZXJpZW5zZWxpc3QuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IE93bENhcm91c2VsIGZyb20gJ3JlYWN0LW93bC1jYXJvdXNlbDInO1xuXG5jb25zdCBQcm9qZWN0cyA9IChwcm9wcykgPT4ge1xuXG4gIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBpdGVtczogNCxcbiAgICAgIG5hdjogdHJ1ZSxcbiAgICAgIHJld2luZDogdHJ1ZSxcbiAgICAgIHJlc3BvbnNpdmU6IHtcbiAgICAgICAgMDoge1xuICAgICAgICAgIGl0ZW1zOiAxLFxuICAgICAgICAgIG5hdjogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICA2MDA6IHtcbiAgICAgICAgICBpdGVtczogMyxcbiAgICAgICAgICBuYXY6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgMTAwMDoge1xuICAgICAgICAgIGl0ZW1zOiA0LFxuICAgICAgICAgIG5hdjogdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgcmV0dXJuIChcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj5Qcm9qZWN0PC9oND5cbiAgICAgICAgICA8aHIgY2xhc3NOYW1lPVwibm9ybWFsLWRpdmlkZXJcIiAvPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wteHMtMTJcIj5cbiAgICAgICAgICA8T3dsQ2Fyb3VzZWwgb3B0aW9ucz17b3B0aW9uc30gPlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHA6Ly9sZW1vbmFkZW1vbmV5LmNvbS9ob21lXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPkxlbW9uYWRlPGJyIC8+IE1vbmV5PC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHA6Ly9sZW1vbmFkZXJld2FyZC5jb21cIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+TGVtb25hZGU8YnIgLz4gUmV3YXJkPC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHA6Ly9sZW1vbmFkZW1vbmV5LmNvbS9idWRnZXQvaW5jb21lXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPkJ1ZGdldDxiciAvPiBDYWxjdWxhdG9yPC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHA6Ly9sZW1vbmFkZW1vbmV5LmNvbS9maW5hbmNpYWwtaGVhbHRoLWNoZWNrL2luY29tZVwiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5GaW5hbmNpYWw8YnIgLz4gSGVhbHRoPC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHA6Ly9zaWVtZW5zLmxlbW9uYWRlcmV3YXJkLmNvbS9ESUdJVEFML1BBR0VTL3BlbnNpb25fbW9kZWxsZXIvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPlBlbnNpb248YnIgLz4gTW9kdWxsZXI8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL2xlbW9uYWRlbW9uZXkuY29tL21vcnRnYWdlLWFwcC93aGljaC1wcm9wZXJ0eVwiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5Nb3J0Z2FnZTxiciAvPiBDYWxjdWxhdG9yPC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9NYXhHb2wvcmVhY3QtY2FyZHNcIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+Q3JlZGl0PGJyIC8+IChSZWFjdCk8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL01heEdvbC9DVl9IRVJPS1VcIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+Q1Y8YnIgLz4oUmVhY3QpPC9zdHJvbmc+PC9kaXY+PC9hPjwvZGl2PlxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJpbWFnZS1jb3IgY2VudGVyLWJsb2NrXCI+PGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS9NYXhHb2wvTUVSTlwiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5NRVJOPGJyIC8+IChSZWFjdCk8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgPC9Pd2xDYXJvdXNlbD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBQcm9qZWN0cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL3Byb2plY3RzLmpzIiwiKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKFwicHJvcC10eXBlc1wiKSwgcmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtcInByb3AtdHlwZXNcIiwgXCJyZWFjdFwiLCBcInJlYWN0LWRvbVwiXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJyZWFjdC1vd2wtY2Fyb3VzZWwyXCJdID0gZmFjdG9yeShyZXF1aXJlKFwicHJvcC10eXBlc1wiKSwgcmVxdWlyZShcInJlYWN0XCIpLCByZXF1aXJlKFwicmVhY3QtZG9tXCIpKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJyZWFjdC1vd2wtY2Fyb3VzZWwyXCJdID0gZmFjdG9yeShyb290W1wiUHJvcFR5cGVzXCJdLCByb290W1wiUmVhY3RcIl0sIHJvb3RbXCJSZWFjdERPTVwiXSk7XG59KSh0aGlzLCBmdW5jdGlvbihfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X18sIF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbi8qKioqKiovIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcblxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge30sXG4vKioqKioqLyBcdFx0XHRpZDogbW9kdWxlSWQsXG4vKioqKioqLyBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4vKioqKioqLyBcdFx0fTtcblxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cblxuXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV2YWwoXCIndXNlIHN0cmljdCc7XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFxcXCJfX2VzTW9kdWxlXFxcIiwge1xcblxcdHZhbHVlOiB0cnVlXFxufSk7XFxuXFxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG52YXIgX3JlYWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcXG5cXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcXG5cXG52YXIgX3JlYWN0RG9tID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcXG5cXG52YXIgX3Byb3BUeXBlcyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XFxuXFxudmFyIF9wcm9wVHlwZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcHJvcFR5cGVzKTtcXG5cXG5fX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oMSk7XFxuXFxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cXG5cXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuZnVuY3Rpb24gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4oc2VsZiwgY2FsbCkgeyBpZiAoIXNlbGYpIHsgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcXFwiKTsgfSByZXR1cm4gY2FsbCAmJiAodHlwZW9mIGNhbGwgPT09IFxcXCJvYmplY3RcXFwiIHx8IHR5cGVvZiBjYWxsID09PSBcXFwiZnVuY3Rpb25cXFwiKSA/IGNhbGwgOiBzZWxmOyB9XFxuXFxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7IGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uLCBub3QgXFxcIiArIHR5cGVvZiBzdXBlckNsYXNzKTsgfSBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHsgY29uc3RydWN0b3I6IHsgdmFsdWU6IHN1YkNsYXNzLCBlbnVtZXJhYmxlOiBmYWxzZSwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH0pOyBpZiAoc3VwZXJDbGFzcykgT2JqZWN0LnNldFByb3RvdHlwZU9mID8gT2JqZWN0LnNldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKSA6IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cXG5cXG52YXIgb3dsQ2Fyb3VzZWxPcHRpb25zID0ge1xcblxcdGNvcmU6IFsnaXRlbXMnLCAnbG9vcCcsICdjZW50ZXInLCAncmV3aW5kJywgJ21vdXNlRHJhZycsICd0b3VjaERyYWcnLCAncHVsbERyYWcnLCAnZnJlZURyYWcnLCAnbWFyZ2luJywgJ3N0YWdlUGFkZGluZycsICdtZXJnZScsICdtZXJnZUZpdCcsICdhdXRvV2lkdGgnLCAnc3RhcnRQb3NpdGlvbicsICdydGwnLCAnc21hcnRTcGVlZCcsICdmbHVpZFNwZWVkJywgJ2RyYWdFbmRTcGVlZCcsICdyZXNwb25zaXZlJywgJ3Jlc3BvbnNpdmVSZWZyZXNoUmF0ZScsICdyZXNwb25zaXZlQmFzZUVsZW1lbnQnLCAnZmFsbGJhY2tFYXNpbmcnLCAnaW5mbycsICduZXN0ZWRJdGVtU2VsZWN0b3InLCAnaXRlbUVsZW1lbnQnLCAnc3RhZ2VFbGVtZW50JywgJ3JlZnJlc2hDbGFzcycsICdsb2FkZWRDbGFzcycsICdsb2FkaW5nQ2xhc3MnLCAncnRsQ2xhc3MnLCAncmVzcG9uc2l2ZUNsYXNzJywgJ2RyYWdDbGFzcycsICdpdGVtQ2xhc3MnLCAnc3RhZ2VDbGFzcycsICdzdGFnZU91dGVyQ2xhc3MnLCAnZ3JhYkNsYXNzJ10sXFxuXFx0YXV0b3JlZnJlc2g6IFsnYXV0b1JlZnJlc2gnLCAnYXV0b1JlZnJlc2hJbnRlcnZhbCddLFxcblxcdGxhenk6IFsnbGF6eUxvYWQnXSxcXG5cXHRhdXRvSGVpZ2h0OiBbJ2F1dG9IZWlnaHQnLCAnYXV0b0hlaWdodENsYXNzJ10sXFxuXFx0dmlkZW86IFsndmlkZW8nLCAndmlkZW9IZWlnaHQnLCAndmlkZW9XaWR0aCddLFxcblxcdGFuaW1hdGU6IFsnYW5pbWF0ZU91dCcsICdhbmltYXRlSW4nXSxcXG5cXHRhdXRvcGxheTogWydhdXRvcGxheScsICdhdXRvcGxheVRpbWVvdXQnLCAnYXV0b3BsYXlIb3ZlclBhdXNlJywgJ2F1dG9wbGF5U3BlZWQnXSxcXG5cXHRuYXZpZ2F0aW9uOiBbJ25hdicsICduYXZUZXh0JywgJ25hdlNwZWVkJywgJ25hdkVsZW1lbnQnLCAnbmF2Q29udGFpbmVyJywgJ25hdkNvbnRhaW5lckNsYXNzJywgJ25hdkNsYXNzJywgJ3NsaWRlQnknLCAnZG90Q2xhc3MnLCAnZG90c0NsYXNzJywgJ2RvdHMnLCAnZG90c0VhY2gnLCAnZG90c0RhdGEnLCAnZG90c1NwZWVkJywgJ2RvdHNDb250YWluZXInXSxcXG5cXHRoYXNoOiBbJ1VSTGhhc2hMaXN0ZW5lciddXFxufTtcXG5cXG52YXIgb3dsQ2Fyb3VzZWxFdmVudHMgPSB7XFxuXFx0Y29yZTogWydvbkluaXRpYWxpemUnLCAnb25Jbml0aWFsaXplZCcsICdvblJlc2l6ZScsICdvblJlc2l6ZWQnLCAnb25SZWZyZXNoJywgJ29uUmVmcmVzaGVkJywgJ29uRHJhZycsICdvbkRyYWdnZWQnLCAnb25UcmFuc2xhdGUnLCAnb25UcmFuc2xhdGVkJywgJ29uQ2hhbmdlJywgJ29uQ2hhbmdlZCddLFxcblxcdGxhenk6IFsnb25Mb2FkTGF6eScsICdvbkxvYWRlZExhenknXSxcXG5cXHR2aWRlbzogWydvblN0b3BWaWRlbycsICdvblBsYXlWaWRlbyddXFxufTtcXG5cXG52YXIgT3dsQ2Fyb3VzZWwgPSBmdW5jdGlvbiAoX1JlYWN0JENvbXBvbmVudCkge1xcblxcdF9pbmhlcml0cyhPd2xDYXJvdXNlbCwgX1JlYWN0JENvbXBvbmVudCk7XFxuXFxuXFx0ZnVuY3Rpb24gT3dsQ2Fyb3VzZWwocHJvcHMsIGNvbnRleHQpIHtcXG5cXHRcXHRfY2xhc3NDYWxsQ2hlY2sodGhpcywgT3dsQ2Fyb3VzZWwpO1xcblxcblxcdFxcdHZhciBfdGhpcyA9IF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHRoaXMsIChPd2xDYXJvdXNlbC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKE93bENhcm91c2VsKSkuY2FsbCh0aGlzLCBwcm9wcywgY29udGV4dCkpO1xcblxcblxcdFxcdF90aGlzLm9uVHJhbnNsYXRlID0gZnVuY3Rpb24gKG5leHQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0XFx0XFx0X3RoaXMuY3VycmVudFBvc2l0aW9uID0gZXZlbnQuaXRlbS5pbmRleDtcXG5cXHRcXHRcXHRcXHRpZiAobmV4dCkgbmV4dChldmVudCk7XFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdF90aGlzLm5leHQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIF90aGlzLiRjYXIubmV4dCgpO1xcblxcdFxcdH07XFxuXFx0XFx0X3RoaXMucHJldiA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX3RoaXMuJGNhci5wcmV2KCk7XFxuXFx0XFx0fTtcXG5cXHRcXHRfdGhpcy5nb1RvID0gZnVuY3Rpb24gKHgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX3RoaXMuJGNhci50byh4KTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdF90aGlzLmN1cnJlbnRQb3NpdGlvbiA9IDA7XFxuXFx0XFx0X3RoaXMub25UcmFuc2xhdGUgPSBfdGhpcy5vblRyYW5zbGF0ZS5iaW5kKF90aGlzKTtcXG5cXHRcXHRyZXR1cm4gX3RoaXM7XFxuXFx0fVxcblxcblxcdF9jcmVhdGVDbGFzcyhPd2xDYXJvdXNlbCwgW3tcXG5cXHRcXHRrZXk6ICdjb21wb25lbnREaWRNb3VudCcsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudERpZE1vdW50KCkge1xcblxcdFxcdFxcdHRoaXMuJG5vZGUgPSAkKCgwLCBfcmVhY3REb20uZmluZERPTU5vZGUpKHRoaXMpKTtcXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xcblxcdFxcdFxcdHRoaXMuaW5pdChvcHRpb25zKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGtleTogJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxcblxcdFxcdHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5leHRQcm9wcykge1xcblxcdFxcdFxcdHRoaXMuZGVzdHJveSgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0a2V5OiAnY29tcG9uZW50RGlkVXBkYXRlJyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB0aGlzLmdldE9wdGlvbnMoKTtcXG5cXHRcXHRcXHRvcHRpb25zLnN0YXJ0UG9zaXRpb24gPSB0aGlzLmN1cnJlbnRQb3NpdGlvbjtcXG5cXHRcXHRcXHR0aGlzLmluaXQob3B0aW9ucyk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdjb21wb25lbnRXaWxsVW5tb3VudCcsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xcblxcdFxcdFxcdHRoaXMuZGVzdHJveSgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0a2V5OiAnaW5pdCcsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xcblxcdFxcdFxcdHZhciBuZXh0ID0gb3B0aW9ucy5vblRyYW5zbGF0ZTtcXG5cXHRcXHRcXHRvcHRpb25zLm9uVHJhbnNsYXRlID0gdGhpcy5vblRyYW5zbGF0ZShuZXh0KTtcXG5cXHRcXHRcXHR0aGlzLiRub2RlLm93bENhcm91c2VsKG9wdGlvbnMpO1xcblxcdFxcdFxcdHRoaXMuJGNhciA9IHRoaXMuJG5vZGUuZGF0YSgnb3dsLmNhcm91c2VsJyk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdkZXN0cm95JyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG5cXHRcXHRcXHR0aGlzLiRjYXIuZGVzdHJveSgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0a2V5OiAnZ2V0T3B0aW9ucycsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIGdldE9wdGlvbnMoKSB7XFxuXFx0XFx0XFx0dmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuXFx0XFx0XFx0dmFyIG9wdGlvbnMgPSB7fTtcXG5cXG5cXHRcXHRcXHR2YXIgY2FyT3B0aW9ucyA9IE9iamVjdC52YWx1ZXMob3dsQ2Fyb3VzZWxPcHRpb25zKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHYpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYS5jb25jYXQodik7XFxuXFx0XFx0XFx0fSwgW10pO1xcblxcblxcdFxcdFxcdGNhck9wdGlvbnMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHZhbCBpbiBfdGhpczIucHJvcHMub3B0aW9ucykgb3B0aW9uc1t2YWxdID0gX3RoaXMyLnByb3BzLm9wdGlvbnNbdmFsXTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR2YXIgY2FyRXZlbnRzID0gT2JqZWN0LnZhbHVlcyhvd2xDYXJvdXNlbEV2ZW50cykucmVkdWNlKGZ1bmN0aW9uIChhLCB2KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGEuY29uY2F0KHYpO1xcblxcdFxcdFxcdH0sIFtdKTtcXG5cXG5cXHRcXHRcXHRjYXJFdmVudHMuZm9yRWFjaChmdW5jdGlvbiAodmFsKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHZhbCBpbiBfdGhpczIucHJvcHMuZXZlbnRzKSBvcHRpb25zW3ZhbF0gPSBfdGhpczIucHJvcHMuZXZlbnRzW3ZhbF07XFxuXFx0XFx0XFx0fSk7XFxuXFxuXFx0XFx0XFx0cmV0dXJuIG9wdGlvbnM7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdyZW5kZXInLFxcblxcdFxcdHZhbHVlOiBmdW5jdGlvbiByZW5kZXIoKSB7XFxuXFx0XFx0XFx0dmFyIF9wcm9wcyA9IHRoaXMucHJvcHMsXFxuXFx0XFx0XFx0ICAgIG9wdGlvbnMgPSBfcHJvcHMub3B0aW9ucyxcXG5cXHRcXHRcXHQgICAgZXZlbnRzID0gX3Byb3BzLmV2ZW50cyxcXG5cXHRcXHRcXHQgICAgY2hpbGRyZW4gPSBfcHJvcHMuY2hpbGRyZW4sXFxuXFx0XFx0XFx0ICAgIHByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9wcm9wcywgWydvcHRpb25zJywgJ2V2ZW50cycsICdjaGlsZHJlbiddKTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoXFxuXFx0XFx0XFx0XFx0J2RpdicsXFxuXFx0XFx0XFx0XFx0X2V4dGVuZHMoeyBjbGFzc05hbWU6ICdvd2wtY2Fyb3VzZWwgb3dsLXRoZW1lJyB9LCBwcm9wcyksXFxuXFx0XFx0XFx0XFx0Y2hpbGRyZW5cXG5cXHRcXHRcXHQpO1xcblxcdFxcdH1cXG5cXHR9XSk7XFxuXFxuXFx0cmV0dXJuIE93bENhcm91c2VsO1xcbn0oX3JlYWN0Mi5kZWZhdWx0LkNvbXBvbmVudCk7XFxuXFxuT3dsQ2Fyb3VzZWwucHJvcFR5cGVzID0ge1xcblxcdGNoaWxkcmVuOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5lbGVtZW50LCBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5T2YoX3Byb3BUeXBlczIuZGVmYXVsdC5lbGVtZW50LmlzUmVxdWlyZWQpXSkuaXNSZXF1aXJlZCxcXG5cXG5cXHRzdHlsZTogX3Byb3BUeXBlczIuZGVmYXVsdC5vYmplY3QsXFxuXFx0aWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcblxcdG9wdGlvbnM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc2hhcGUoe1xcblxcdFxcdC8vIGNvcmVcXG5cXHRcXHRpdGVtczogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0bG9vcDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGNlbnRlcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdHJld2luZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdG1vdXNlRHJhZzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdHRvdWNoRHJhZzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdHB1bGxEcmFnOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0ZnJlZURyYWc6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXG5cXHRcXHRtYXJnaW46IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxcblxcdFxcdHN0YWdlUGFkZGluZzogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFxuXFx0XFx0bWVyZ2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRtZXJnZUZpdDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGF1dG9XaWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdHN0YXJ0UG9zaXRpb246IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxcblxcdFxcdHJ0bDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdHNtYXJ0U3BlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxcblxcdFxcdGZsdWlkU3BlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRkcmFnRW5kU3BlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXG5cXHRcXHRyZXNwb25zaXZlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLCBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdF0pLFxcblxcdFxcdHJlc3BvbnNpdmVSZWZyZXNoUmF0ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0cmVzcG9uc2l2ZUJhc2VFbGVtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcXG5cXG5cXHRcXHRmYWxsYmFja0Vhc2luZzogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFxuXFx0XFx0aW5mbzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdG5lc3RlZEl0ZW1TZWxlY3RvcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGl0ZW1FbGVtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRzdGFnZUVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcblxcdFxcdHJlZnJlc2hDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0bG9hZGVkQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdGxvYWRpbmdDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0cnRsQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdHJlc3BvbnNpdmVDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0ZHJhZ0NsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRpdGVtQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdHN0YWdlQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdHN0YWdlT3V0ZXJDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0Z3JhYkNsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXG5cXHRcXHQvLyBhdXRvUmVmcmVzaFxcblxcdFxcdGF1dG9SZWZyZXNoOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0YXV0b1JlZnJlc2hJbnRlcnZhbDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFxuXFx0XFx0Ly8gbGF6eVxcblxcdFxcdGxhenlMb2FkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0Ly8gYXV0b0hlaWdodFxcblxcdFxcdGF1dG9IZWlnaHQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRhdXRvSGVpZ2h0Q2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcblxcdFxcdC8vIHZpZGVvXFxuXFx0XFx0dmlkZW86IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHR2aWRlb0hlaWdodDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdHZpZGVvV2lkdGg6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXG5cXHRcXHQvLyBhbmltYXRlXFxuXFx0XFx0YW5pbWF0ZU91dDogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCwgX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmddKSxcXG5cXHRcXHRhbmltYXRlSW46IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsIF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nXSksXFxuXFxuXFx0XFx0Ly8gYXV0b3BsYXlcXG5cXHRcXHRhdXRvcGxheTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGF1dG9wbGF5VGltZW91dDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0YXV0b3BsYXlIb3ZlclBhdXNlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0YXV0b3BsYXlTcGVlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdC8vIG5hdmlnYXRpb25cXG5cXHRcXHRuYXY6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRuYXZUZXh0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5LFxcblxcdFxcdG5hdlNwZWVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0bmF2RWxlbWVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0bmF2Q29udGFpbmVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0bmF2Q29udGFpbmVyQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdG5hdkNsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmFycmF5LFxcblxcdFxcdHNsaWRlQnk6IF9wcm9wVHlwZXMyLmRlZmF1bHQubnVtYmVyLFxcblxcdFxcdGRvdENsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRkb3RzQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdGRvdHM6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRkb3RzRWFjaDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGRvdHNEYXRhOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0ZG90c1NwZWVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0ZG90c0NvbnRhaW5lcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdC8vIGhhc2hcXG5cXHRcXHRVUkxoYXNoTGlzdGVuZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbFxcblxcdH0pLFxcblxcblxcdGV2ZW50czogX3Byb3BUeXBlczIuZGVmYXVsdC5zaGFwZSh7XFxuXFx0XFx0Ly8gY29yZVxcblxcdFxcdG9uSW5pdGlhbGl6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uSW5pdGlhbGl6ZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvblJlc2l6ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uUmVzaXplZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uUmVmcmVzaDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uUmVmcmVzaGVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25EcmFnOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25EcmFnZ2VkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25UcmFuc2xhdGU6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvblRyYW5zbGF0ZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvbkNoYW5nZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uQ2hhbmdlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcblxcdFxcdC8vIGxhenlcXG5cXHRcXHRvbkxvYWRMYXp5OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25Mb2FkZWRMYXp5OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFxuXFx0XFx0Ly8gdmlkZW9cXG5cXHRcXHRvblN0b3BWaWRlbzogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uUGxheVZpZGVvOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmNcXG5cXHR9KVxcbn07XFxuXFxuT3dsQ2Fyb3VzZWwuZGVmYXVsdFByb3BzID0ge1xcblxcdG9wdGlvbnM6IHt9LFxcblxcdGV2ZW50czoge31cXG59O1xcblxcbmV4cG9ydHMuZGVmYXVsdCA9IE93bENhcm91c2VsO1xcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiAuL2NvbXBvbmVudHMvT3dsQ2Fyb3VzZWwuanN4XFxuICoqIG1vZHVsZSBpZCA9IDBcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vY29tcG9uZW50cy9Pd2xDYXJvdXNlbC5qc3g/XCIpO1xuXG4vKioqLyB9LFxuLyogMSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXZhbChcIid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qKlxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjFcXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE3IERhdmlkIERldXRzY2hcXG4gKiBMaWNlbnNlZCB1bmRlciAgKClcXG4gKi9cXG4vKipcXG4gKiBPd2wgY2Fyb3VzZWxcXG4gKiBAdmVyc2lvbiAyLjEuNlxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICogQHRvZG8gTGF6eSBMb2FkIEljb25cXG4gKiBAdG9kbyBwcmV2ZW50IGFuaW1hdGlvbmVuZCBidWJsaW5nXFxuICogQHRvZG8gaXRlbXNTY2FsZVVwXFxuICogQHRvZG8gVGVzdCBaZXB0b1xcbiAqIEB0b2RvIHN0YWdlUGFkZGluZyBjYWxjdWxhdGUgd3JvbmcgYWN0aXZlIGNsYXNzZXNcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyBhIGNhcm91c2VsLlxcbiAgKiBAY2xhc3MgVGhlIE93bCBDYXJvdXNlbC5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeX0gZWxlbWVudCAtIFRoZSBlbGVtZW50IHRvIGNyZWF0ZSB0aGUgY2Fyb3VzZWwgZm9yLlxcbiAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gVGhlIG9wdGlvbnNcXG4gICovXFxuXFx0ZnVuY3Rpb24gT3dsKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEN1cnJlbnQgc2V0dGluZ3MgZm9yIHRoZSBjYXJvdXNlbC5cXG4gICAqIEBwdWJsaWNcXG4gICAqL1xcblxcdFxcdHRoaXMuc2V0dGluZ3MgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQ3VycmVudCBvcHRpb25zIHNldCBieSB0aGUgY2FsbGVyIGluY2x1ZGluZyBkZWZhdWx0cy5cXG4gICAqIEBwdWJsaWNcXG4gICAqL1xcblxcdFxcdHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPd2wuRGVmYXVsdHMsIG9wdGlvbnMpO1xcblxcblxcdFxcdC8qKlxcbiAgICogUGx1Z2luIGVsZW1lbnQuXFxuICAgKiBAcHVibGljXFxuICAgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gJChlbGVtZW50KTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFByb3hpZWQgZXZlbnQgaGFuZGxlcnMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlcyB0byB0aGUgcnVubmluZyBwbHVnaW5zIG9mIHRoaXMgY2Fyb3VzZWwuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9wbHVnaW5zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50bHkgc3VwcHJlc3NlZCBldmVudHMgdG8gcHJldmVudCB0aGVtIGZyb20gYmVlaW5nIHJldHJpZ2dlcmVkLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5fc3VwcmVzcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQWJzb2x1dGUgY3VycmVudCBwb3NpdGlvbi5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX2N1cnJlbnQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX3NwZWVkID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIENvb3JkaW5hdGVzIG9mIGFsbCBpdGVtcyBpbiBwaXhlbC5cXG4gICAqIEB0b2RvIFRoZSBuYW1lIG9mIHRoaXMgbWVtYmVyIGlzIG1pc3NsZWFkaW5nLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEN1cnJlbnQgYnJlYWtwb2ludC5cXG4gICAqIEB0b2RvIFJlYWwgbWVkaWEgcXVlcmllcyB3b3VsZCBiZSBuaWNlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5fYnJlYWtwb2ludCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50IHdpZHRoIG9mIHRoZSBwbHVnaW4gZWxlbWVudC5cXG4gICAqL1xcblxcdFxcdHRoaXMuX3dpZHRoID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCByZWFsIGl0ZW1zLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5faXRlbXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCBjbG9uZWQgaXRlbXMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9jbG9uZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE1lcmdlIHZhbHVlcyBvZiBhbGwgaXRlbXMuXFxuICAgKiBAdG9kbyBNYXliZSB0aGlzIGNvdWxkIGJlIHBhcnQgb2YgYSBwbHVnaW4uXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9tZXJnZXJzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBXaWR0aHMgb2YgYWxsIGl0ZW1zLlxcbiAgICovXFxuXFx0XFx0dGhpcy5fd2lkdGhzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBJbnZhbGlkYXRlZCBwYXJ0cyB3aXRoaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE9yZGVyZWQgbGlzdCBvZiB3b3JrZXJzIGZvciB0aGUgdXBkYXRlIHByb2Nlc3MuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9waXBlID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGZvciB0aGUgZHJhZyBvcGVyYXRpb24uXFxuICAgKiBAdG9kbyAjMjYxXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9kcmFnID0ge1xcblxcdFxcdFxcdHRpbWU6IG51bGwsXFxuXFx0XFx0XFx0dGFyZ2V0OiBudWxsLFxcblxcdFxcdFxcdHBvaW50ZXI6IG51bGwsXFxuXFx0XFx0XFx0c3RhZ2U6IHtcXG5cXHRcXHRcXHRcXHRzdGFydDogbnVsbCxcXG5cXHRcXHRcXHRcXHRjdXJyZW50OiBudWxsXFxuXFx0XFx0XFx0fSxcXG5cXHRcXHRcXHRkaXJlY3Rpb246IG51bGxcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQ3VycmVudCBzdGF0ZSBpbmZvcm1hdGlvbiBhbmQgdGhlaXIgdGFncy5cXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9zdGF0ZXMgPSB7XFxuXFx0XFx0XFx0Y3VycmVudDoge30sXFxuXFx0XFx0XFx0dGFnczoge1xcblxcdFxcdFxcdFxcdCdpbml0aWFsaXppbmcnOiBbJ2J1c3knXSxcXG5cXHRcXHRcXHRcXHQnYW5pbWF0aW5nJzogWydidXN5J10sXFxuXFx0XFx0XFx0XFx0J2RyYWdnaW5nJzogWydpbnRlcmFjdGluZyddXFxuXFx0XFx0XFx0fVxcblxcdFxcdH07XFxuXFxuXFx0XFx0JC5lYWNoKFsnb25SZXNpemUnLCAnb25UaHJvdHRsZWRSZXNpemUnXSwgJC5wcm94eShmdW5jdGlvbiAoaSwgaGFuZGxlcikge1xcblxcdFxcdFxcdHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdID0gJC5wcm94eSh0aGlzW2hhbmRsZXJdLCB0aGlzKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0JC5lYWNoKE93bC5QbHVnaW5zLCAkLnByb3h5KGZ1bmN0aW9uIChrZXksIHBsdWdpbikge1xcblxcdFxcdFxcdHRoaXMuX3BsdWdpbnNba2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsga2V5LnNsaWNlKDEpXSA9IG5ldyBwbHVnaW4odGhpcyk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdCQuZWFjaChPd2wuV29ya2VycywgJC5wcm94eShmdW5jdGlvbiAocHJpb3JpdHksIHdvcmtlcikge1xcblxcdFxcdFxcdHRoaXMuX3BpcGUucHVzaCh7XFxuXFx0XFx0XFx0XFx0J2ZpbHRlcic6IHdvcmtlci5maWx0ZXIsXFxuXFx0XFx0XFx0XFx0J3J1bic6ICQucHJveHkod29ya2VyLnJ1biwgdGhpcylcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0dGhpcy5zZXR1cCgpO1xcblxcdFxcdHRoaXMuaW5pdGlhbGl6ZSgpO1xcblxcdH1cXG5cXG5cXHQvKipcXG4gICogRGVmYXVsdCBvcHRpb25zIGZvciB0aGUgY2Fyb3VzZWwuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0T3dsLkRlZmF1bHRzID0ge1xcblxcdFxcdGl0ZW1zOiAzLFxcblxcdFxcdGxvb3A6IGZhbHNlLFxcblxcdFxcdGNlbnRlcjogZmFsc2UsXFxuXFx0XFx0cmV3aW5kOiBmYWxzZSxcXG5cXG5cXHRcXHRtb3VzZURyYWc6IHRydWUsXFxuXFx0XFx0dG91Y2hEcmFnOiB0cnVlLFxcblxcdFxcdHB1bGxEcmFnOiB0cnVlLFxcblxcdFxcdGZyZWVEcmFnOiBmYWxzZSxcXG5cXG5cXHRcXHRtYXJnaW46IDAsXFxuXFx0XFx0c3RhZ2VQYWRkaW5nOiAwLFxcblxcblxcdFxcdG1lcmdlOiBmYWxzZSxcXG5cXHRcXHRtZXJnZUZpdDogdHJ1ZSxcXG5cXHRcXHRhdXRvV2lkdGg6IGZhbHNlLFxcblxcblxcdFxcdHN0YXJ0UG9zaXRpb246IDAsXFxuXFx0XFx0cnRsOiBmYWxzZSxcXG5cXG5cXHRcXHRzbWFydFNwZWVkOiAyNTAsXFxuXFx0XFx0Zmx1aWRTcGVlZDogZmFsc2UsXFxuXFx0XFx0ZHJhZ0VuZFNwZWVkOiBmYWxzZSxcXG5cXG5cXHRcXHRyZXNwb25zaXZlOiB7fSxcXG5cXHRcXHRyZXNwb25zaXZlUmVmcmVzaFJhdGU6IDIwMCxcXG5cXHRcXHRyZXNwb25zaXZlQmFzZUVsZW1lbnQ6IHdpbmRvdyxcXG5cXG5cXHRcXHRmYWxsYmFja0Vhc2luZzogJ3N3aW5nJyxcXG5cXG5cXHRcXHRpbmZvOiBmYWxzZSxcXG5cXG5cXHRcXHRuZXN0ZWRJdGVtU2VsZWN0b3I6IGZhbHNlLFxcblxcdFxcdGl0ZW1FbGVtZW50OiAnZGl2JyxcXG5cXHRcXHRzdGFnZUVsZW1lbnQ6ICdkaXYnLFxcblxcblxcdFxcdHJlZnJlc2hDbGFzczogJ293bC1yZWZyZXNoJyxcXG5cXHRcXHRsb2FkZWRDbGFzczogJ293bC1sb2FkZWQnLFxcblxcdFxcdGxvYWRpbmdDbGFzczogJ293bC1sb2FkaW5nJyxcXG5cXHRcXHRydGxDbGFzczogJ293bC1ydGwnLFxcblxcdFxcdHJlc3BvbnNpdmVDbGFzczogJ293bC1yZXNwb25zaXZlJyxcXG5cXHRcXHRkcmFnQ2xhc3M6ICdvd2wtZHJhZycsXFxuXFx0XFx0aXRlbUNsYXNzOiAnb3dsLWl0ZW0nLFxcblxcdFxcdHN0YWdlQ2xhc3M6ICdvd2wtc3RhZ2UnLFxcblxcdFxcdHN0YWdlT3V0ZXJDbGFzczogJ293bC1zdGFnZS1vdXRlcicsXFxuXFx0XFx0Z3JhYkNsYXNzOiAnb3dsLWdyYWInXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRW51bWVyYXRpb24gZm9yIHdpZHRoLlxcbiAgKiBAcHVibGljXFxuICAqIEByZWFkb25seVxcbiAgKiBAZW51bSB7U3RyaW5nfVxcbiAgKi9cXG5cXHRPd2wuV2lkdGggPSB7XFxuXFx0XFx0RGVmYXVsdDogJ2RlZmF1bHQnLFxcblxcdFxcdElubmVyOiAnaW5uZXInLFxcblxcdFxcdE91dGVyOiAnb3V0ZXInXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRW51bWVyYXRpb24gZm9yIHR5cGVzLlxcbiAgKiBAcHVibGljXFxuICAqIEByZWFkb25seVxcbiAgKiBAZW51bSB7U3RyaW5nfVxcbiAgKi9cXG5cXHRPd2wuVHlwZSA9IHtcXG5cXHRcXHRFdmVudDogJ2V2ZW50JyxcXG5cXHRcXHRTdGF0ZTogJ3N0YXRlJ1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENvbnRhaW5zIGFsbCByZWdpc3RlcmVkIHBsdWdpbnMuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0T3dsLlBsdWdpbnMgPSB7fTtcXG5cXG5cXHQvKipcXG4gICogTGlzdCBvZiB3b3JrZXJzIGludm9sdmVkIGluIHRoZSB1cGRhdGUgcHJvY2Vzcy5cXG4gICovXFxuXFx0T3dsLldvcmtlcnMgPSBbe1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHRoaXMuX3dpZHRoID0gdGhpcy4kZWxlbWVudC53aWR0aCgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oY2FjaGUpIHtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gdGhpcy5faXRlbXMgJiYgdGhpcy5faXRlbXNbdGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KV07XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bigpIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNsb25lZCcpLnJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgbWFyZ2luID0gdGhpcy5zZXR0aW5ncy5tYXJnaW4gfHwgJycsXFxuXFx0XFx0XFx0ICAgIGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXFxuXFx0XFx0XFx0ICAgIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsLFxcblxcdFxcdFxcdCAgICBjc3MgPSB7XFxuXFx0XFx0XFx0XFx0J3dpZHRoJzogJ2F1dG8nLFxcblxcdFxcdFxcdFxcdCdtYXJnaW4tbGVmdCc6IHJ0bCA/IG1hcmdpbiA6ICcnLFxcblxcdFxcdFxcdFxcdCdtYXJnaW4tcmlnaHQnOiBydGwgPyAnJyA6IG1hcmdpblxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0IWdyaWQgJiYgdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jc3MoY3NzKTtcXG5cXG5cXHRcXHRcXHRjYWNoZS5jc3MgPSBjc3M7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bihjYWNoZSkge1xcblxcdFxcdFxcdHZhciB3aWR0aCA9ICh0aGlzLndpZHRoKCkgLyB0aGlzLnNldHRpbmdzLml0ZW1zKS50b0ZpeGVkKDMpIC0gdGhpcy5zZXR0aW5ncy5tYXJnaW4sXFxuXFx0XFx0XFx0ICAgIG1lcmdlID0gbnVsbCxcXG5cXHRcXHRcXHQgICAgaXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXFxuXFx0XFx0XFx0ICAgIHdpZHRocyA9IFtdO1xcblxcblxcdFxcdFxcdGNhY2hlLml0ZW1zID0ge1xcblxcdFxcdFxcdFxcdG1lcmdlOiBmYWxzZSxcXG5cXHRcXHRcXHRcXHR3aWR0aDogd2lkdGhcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0bWVyZ2UgPSB0aGlzLl9tZXJnZXJzW2l0ZXJhdG9yXTtcXG5cXHRcXHRcXHRcXHRtZXJnZSA9IHRoaXMuc2V0dGluZ3MubWVyZ2VGaXQgJiYgTWF0aC5taW4obWVyZ2UsIHRoaXMuc2V0dGluZ3MuaXRlbXMpIHx8IG1lcmdlO1xcblxcblxcdFxcdFxcdFxcdGNhY2hlLml0ZW1zLm1lcmdlID0gbWVyZ2UgPiAxIHx8IGNhY2hlLml0ZW1zLm1lcmdlO1xcblxcblxcdFxcdFxcdFxcdHdpZHRoc1tpdGVyYXRvcl0gPSAhZ3JpZCA/IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpIDogd2lkdGggKiBtZXJnZTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fd2lkdGhzID0gd2lkdGhzO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dmFyIGNsb25lcyA9IFtdLFxcblxcdFxcdFxcdCAgICBpdGVtcyA9IHRoaXMuX2l0ZW1zLFxcblxcdFxcdFxcdCAgICBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXFxuXFxuXFx0XFx0XFx0Ly8gVE9ETzogU2hvdWxkIGJlIGNvbXB1dGVkIGZyb20gbnVtYmVyIG9mIG1pbiB3aWR0aCBpdGVtcyBpbiBzdGFnZVxcblxcdFxcdFxcdHZpZXcgPSBNYXRoLm1heChzZXR0aW5ncy5pdGVtcyAqIDIsIDQpLFxcblxcdFxcdFxcdCAgICBzaXplID0gTWF0aC5jZWlsKGl0ZW1zLmxlbmd0aCAvIDIpICogMixcXG5cXHRcXHRcXHQgICAgcmVwZWF0ID0gc2V0dGluZ3MubG9vcCAmJiBpdGVtcy5sZW5ndGggPyBzZXR0aW5ncy5yZXdpbmQgPyB2aWV3IDogTWF0aC5tYXgodmlldywgc2l6ZSkgOiAwLFxcblxcdFxcdFxcdCAgICBhcHBlbmQgPSAnJyxcXG5cXHRcXHRcXHQgICAgcHJlcGVuZCA9ICcnO1xcblxcblxcdFxcdFxcdHJlcGVhdCAvPSAyO1xcblxcblxcdFxcdFxcdHdoaWxlIChyZXBlYXQtLSkge1xcblxcdFxcdFxcdFxcdC8vIFN3aXRjaCB0byBvbmx5IHVzaW5nIGFwcGVuZGVkIGNsb25lc1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGNsb25lcy5sZW5ndGggLyAyLCB0cnVlKSk7XFxuXFx0XFx0XFx0XFx0YXBwZW5kID0gYXBwZW5kICsgaXRlbXNbY2xvbmVzW2Nsb25lcy5sZW5ndGggLSAxXV1bMF0ub3V0ZXJIVE1MO1xcblxcdFxcdFxcdFxcdGNsb25lcy5wdXNoKHRoaXMubm9ybWFsaXplKGl0ZW1zLmxlbmd0aCAtIDEgLSAoY2xvbmVzLmxlbmd0aCAtIDEpIC8gMiwgdHJ1ZSkpO1xcblxcdFxcdFxcdFxcdHByZXBlbmQgPSBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUwgKyBwcmVwZW5kO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jbG9uZXMgPSBjbG9uZXM7XFxuXFxuXFx0XFx0XFx0JChhcHBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5hcHBlbmRUbyh0aGlzLiRzdGFnZSk7XFxuXFx0XFx0XFx0JChwcmVwZW5kKS5hZGRDbGFzcygnY2xvbmVkJykucHJlcGVuZFRvKHRoaXMuJHN0YWdlKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcXG5cXHRcXHRcXHQgICAgc2l6ZSA9IHRoaXMuX2Nsb25lcy5sZW5ndGggKyB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGl0ZXJhdG9yID0gLTEsXFxuXFx0XFx0XFx0ICAgIHByZXZpb3VzID0gMCxcXG5cXHRcXHRcXHQgICAgY3VycmVudCA9IDAsXFxuXFx0XFx0XFx0ICAgIGNvb3JkaW5hdGVzID0gW107XFxuXFxuXFx0XFx0XFx0d2hpbGUgKCsraXRlcmF0b3IgPCBzaXplKSB7XFxuXFx0XFx0XFx0XFx0cHJldmlvdXMgPSBjb29yZGluYXRlc1tpdGVyYXRvciAtIDFdIHx8IDA7XFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IHRoaXMuX3dpZHRoc1t0aGlzLnJlbGF0aXZlKGl0ZXJhdG9yKV0gKyB0aGlzLnNldHRpbmdzLm1hcmdpbjtcXG5cXHRcXHRcXHRcXHRjb29yZGluYXRlcy5wdXNoKHByZXZpb3VzICsgY3VycmVudCAqIHJ0bCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2Nvb3JkaW5hdGVzID0gY29vcmRpbmF0ZXM7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bigpIHtcXG5cXHRcXHRcXHR2YXIgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nLFxcblxcdFxcdFxcdCAgICBjb29yZGluYXRlcyA9IHRoaXMuX2Nvb3JkaW5hdGVzLFxcblxcdFxcdFxcdCAgICBjc3MgPSB7XFxuXFx0XFx0XFx0XFx0J3dpZHRoJzogTWF0aC5jZWlsKE1hdGguYWJzKGNvb3JkaW5hdGVzW2Nvb3JkaW5hdGVzLmxlbmd0aCAtIDFdKSkgKyBwYWRkaW5nICogMixcXG5cXHRcXHRcXHRcXHQncGFkZGluZy1sZWZ0JzogcGFkZGluZyB8fCAnJyxcXG5cXHRcXHRcXHRcXHQncGFkZGluZy1yaWdodCc6IHBhZGRpbmcgfHwgJydcXG5cXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNzcyhjc3MpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oY2FjaGUpIHtcXG5cXHRcXHRcXHR2YXIgaXRlcmF0b3IgPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXFxuXFx0XFx0XFx0ICAgIGdyaWQgPSAhdGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgsXFxuXFx0XFx0XFx0ICAgIGl0ZW1zID0gdGhpcy4kc3RhZ2UuY2hpbGRyZW4oKTtcXG5cXG5cXHRcXHRcXHRpZiAoZ3JpZCAmJiBjYWNoZS5pdGVtcy5tZXJnZSkge1xcblxcdFxcdFxcdFxcdHdoaWxlIChpdGVyYXRvci0tKSB7XFxuXFx0XFx0XFx0XFx0XFx0Y2FjaGUuY3NzLndpZHRoID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXTtcXG5cXHRcXHRcXHRcXHRcXHRpdGVtcy5lcShpdGVyYXRvcikuY3NzKGNhY2hlLmNzcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoZ3JpZCkge1xcblxcdFxcdFxcdFxcdGNhY2hlLmNzcy53aWR0aCA9IGNhY2hlLml0ZW1zLndpZHRoO1xcblxcdFxcdFxcdFxcdGl0ZW1zLmNzcyhjYWNoZS5jc3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWydpdGVtcyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCA8IDEgJiYgdGhpcy4kc3RhZ2UucmVtb3ZlQXR0cignc3R5bGUnKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKGNhY2hlKSB7XFxuXFx0XFx0XFx0Y2FjaGUuY3VycmVudCA9IGNhY2hlLmN1cnJlbnQgPyB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmluZGV4KGNhY2hlLmN1cnJlbnQpIDogMDtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gTWF0aC5tYXgodGhpcy5taW5pbXVtKCksIE1hdGgubWluKHRoaXMubWF4aW11bSgpLCBjYWNoZS5jdXJyZW50KSk7XFxuXFx0XFx0XFx0dGhpcy5yZXNldChjYWNoZS5jdXJyZW50KTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWydwb3NpdGlvbiddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHRoaXMuX2N1cnJlbnQpKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdwb3NpdGlvbicsICdpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bCA/IDEgOiAtMSxcXG5cXHRcXHRcXHQgICAgcGFkZGluZyA9IHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nICogMixcXG5cXHRcXHRcXHQgICAgYmVnaW4gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMuY3VycmVudCgpKSArIHBhZGRpbmcsXFxuXFx0XFx0XFx0ICAgIGVuZCA9IGJlZ2luICsgdGhpcy53aWR0aCgpICogcnRsLFxcblxcdFxcdFxcdCAgICBpbm5lcixcXG5cXHRcXHRcXHQgICAgb3V0ZXIsXFxuXFx0XFx0XFx0ICAgIG1hdGNoZXMgPSBbXSxcXG5cXHRcXHRcXHQgICAgaSxcXG5cXHRcXHRcXHQgICAgbjtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSAwLCBuID0gdGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aW5uZXIgPSB0aGlzLl9jb29yZGluYXRlc1tpIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRvdXRlciA9IE1hdGguYWJzKHRoaXMuX2Nvb3JkaW5hdGVzW2ldKSArIHBhZGRpbmcgKiBydGw7XFxuXFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMub3AoaW5uZXIsICc8PScsIGJlZ2luKSAmJiB0aGlzLm9wKGlubmVyLCAnPicsIGVuZCkgfHwgdGhpcy5vcChvdXRlciwgJzwnLCBiZWdpbikgJiYgdGhpcy5vcChvdXRlciwgJz4nLCBlbmQpKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2hlcy5wdXNoKGkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oJzplcSgnICsgbWF0Y2hlcy5qb2luKCcpLCA6ZXEoJykgKyAnKScpLmFkZENsYXNzKCdhY3RpdmUnKTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNlbnRlcicpLnJlbW92ZUNsYXNzKCdjZW50ZXInKTtcXG5cXHRcXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMuY3VycmVudCgpKS5hZGRDbGFzcygnY2VudGVyJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XTtcXG5cXG5cXHQvKipcXG4gICogSW5pdGlhbGl6ZXMgdGhlIGNhcm91c2VsLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0aGlzLmVudGVyKCdpbml0aWFsaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2luaXRpYWxpemUnKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuc2V0dGluZ3MucnRsQ2xhc3MsIHRoaXMuc2V0dGluZ3MucnRsKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGggJiYgIXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykpIHtcXG5cXHRcXHRcXHR2YXIgaW1ncywgbmVzdGVkU2VsZWN0b3IsIHdpZHRoO1xcblxcdFxcdFxcdGltZ3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2ltZycpO1xcblxcdFxcdFxcdG5lc3RlZFNlbGVjdG9yID0gdGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IgPyAnLicgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA6IHVuZGVmaW5lZDtcXG5cXHRcXHRcXHR3aWR0aCA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4obmVzdGVkU2VsZWN0b3IpLndpZHRoKCk7XFxuXFxuXFx0XFx0XFx0aWYgKGltZ3MubGVuZ3RoICYmIHdpZHRoIDw9IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLnByZWxvYWRBdXRvV2lkdGhJbWFnZXMoaW1ncyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpO1xcblxcblxcdFxcdC8vIEhBQ0s6IERJU0FCTEUgU0NST0xMQkFSXFxuXFx0XFx0dmFyIG92ZXJmbG93VmFsID0gJCgnYm9keScpLmNzcygnb3ZlcmZsb3cnKTtcXG5cXHRcXHQkKCdib2R5JykuY3NzKHsgJ292ZXJmbG93JzogJ2hpZGRlbicgfSk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIHN0YWdlXFxuXFx0XFx0dGhpcy4kc3RhZ2UgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VFbGVtZW50ICsgJyBjbGFzcz1cXFwiJyArIHRoaXMuc2V0dGluZ3Muc3RhZ2VDbGFzcyArICdcXFwiLz4nKS53cmFwKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5zZXR0aW5ncy5zdGFnZU91dGVyQ2xhc3MgKyAnXFxcIi8+Jyk7XFxuXFxuXFx0XFx0Ly8gYXBwZW5kIHN0YWdlXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hcHBlbmQodGhpcy4kc3RhZ2UucGFyZW50KCkpO1xcblxcblxcdFxcdC8vIGFwcGVuZCBjb250ZW50XFxuXFx0XFx0dGhpcy5yZXBsYWNlKHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oKS5ub3QodGhpcy4kc3RhZ2UucGFyZW50KCkpKTtcXG5cXG5cXHRcXHQvLyBjaGVjayB2aXNpYmlsaXR5XFxuXFx0XFx0aWYgKHRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG5cXHRcXHRcXHQvLyB1cGRhdGUgdmlld1xcblxcdFxcdFxcdHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Ly8gaW52YWxpZGF0ZSB3aWR0aFxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Ly8gSEFDSzogUkVTVE9SRSBTQ1JPTExCQVJcXG5cXHRcXHQkKCdib2R5JykuY3NzKHsgJ292ZXJmbG93Jzogb3ZlcmZsb3dWYWwgfSk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5yZWdpc3RlckV2ZW50SGFuZGxlcnMoKTtcXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdpbml0aWFsaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2luaXRpYWxpemVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2V0dXBzIHRoZSBjdXJyZW50IHNldHRpbmdzLlxcbiAgKiBAdG9kbyBSZW1vdmUgcmVzcG9uc2l2ZSBjbGFzc2VzLiBXaHkgc2hvdWxkIGFkYXB0aXZlIGRlc2lnbnMgYmUgYnJvdWdodCBpbnRvIElFOD9cXG4gICogQHRvZG8gU3VwcG9ydCBmb3IgbWVkaWEgcXVlcmllcyBieSB1c2luZyBgbWF0Y2hNZWRpYWAgd291bGQgYmUgbmljZS5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnNldHVwID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciB2aWV3cG9ydCA9IHRoaXMudmlld3BvcnQoKSxcXG5cXHRcXHQgICAgb3ZlcndyaXRlcyA9IHRoaXMub3B0aW9ucy5yZXNwb25zaXZlLFxcblxcdFxcdCAgICBtYXRjaCA9IC0xLFxcblxcdFxcdCAgICBzZXR0aW5ncyA9IG51bGw7XFxuXFxuXFx0XFx0aWYgKCFvdmVyd3JpdGVzKSB7XFxuXFx0XFx0XFx0c2V0dGluZ3MgPSAkLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdCQuZWFjaChvdmVyd3JpdGVzLCBmdW5jdGlvbiAoYnJlYWtwb2ludCkge1xcblxcdFxcdFxcdFxcdGlmIChicmVha3BvaW50IDw9IHZpZXdwb3J0ICYmIGJyZWFrcG9pbnQgPiBtYXRjaCkge1xcblxcdFxcdFxcdFxcdFxcdG1hdGNoID0gTnVtYmVyKGJyZWFrcG9pbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMsIG92ZXJ3cml0ZXNbbWF0Y2hdKTtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIHNldHRpbmdzLnN0YWdlUGFkZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdHNldHRpbmdzLnN0YWdlUGFkZGluZyA9IHNldHRpbmdzLnN0YWdlUGFkZGluZygpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRkZWxldGUgc2V0dGluZ3MucmVzcG9uc2l2ZTtcXG5cXG5cXHRcXHRcXHQvLyByZXNwb25zaXZlIGNsYXNzXFxuXFx0XFx0XFx0aWYgKHNldHRpbmdzLnJlc3BvbnNpdmVDbGFzcykge1xcblxcdFxcdFxcdFxcdHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKCcoJyArIHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLSlcXFxcXFxcXFMrXFxcXFxcXFxzJywgJ2cnKSwgJyQxJyArIG1hdGNoKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3NldHRpbmdzJywgdmFsdWU6IHNldHRpbmdzIH0gfSk7XFxuXFx0XFx0dGhpcy5fYnJlYWtwb2ludCA9IG1hdGNoO1xcblxcdFxcdHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ3NldHRpbmdzJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAnc2V0dGluZ3MnLCB2YWx1ZTogdGhpcy5zZXR0aW5ncyB9IH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFVwZGF0ZXMgb3B0aW9uIGxvZ2ljIGlmIG5lY2Vzc2VyeS5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9wdGlvbnNMb2dpYyA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5hdXRvV2lkdGgpIHtcXG5cXHRcXHRcXHR0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyA9IGZhbHNlO1xcblxcdFxcdFxcdHRoaXMuc2V0dGluZ3MubWVyZ2UgPSBmYWxzZTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUHJlcGFyZXMgYW4gaXRlbSBiZWZvcmUgYWRkLlxcbiAgKiBAdG9kbyBSZW5hbWUgZXZlbnQgcGFyYW1ldGVyIGBjb250ZW50YCB0byBgaXRlbWAuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHJldHVybnMge2pRdWVyeXxIVE1MRWxlbWVudH0gLSBUaGUgaXRlbSBjb250YWluZXIuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucHJlcGFyZSA9IGZ1bmN0aW9uIChpdGVtKSB7XFxuXFx0XFx0dmFyIGV2ZW50ID0gdGhpcy50cmlnZ2VyKCdwcmVwYXJlJywgeyBjb250ZW50OiBpdGVtIH0pO1xcblxcblxcdFxcdGlmICghZXZlbnQuZGF0YSkge1xcblxcdFxcdFxcdGV2ZW50LmRhdGEgPSAkKCc8JyArIHRoaXMuc2V0dGluZ3MuaXRlbUVsZW1lbnQgKyAnLz4nKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuaXRlbUNsYXNzKS5hcHBlbmQoaXRlbSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMudHJpZ2dlcigncHJlcGFyZWQnLCB7IGNvbnRlbnQ6IGV2ZW50LmRhdGEgfSk7XFxuXFxuXFx0XFx0cmV0dXJuIGV2ZW50LmRhdGE7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVXBkYXRlcyB0aGUgdmlldy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaSA9IDAsXFxuXFx0XFx0ICAgIG4gPSB0aGlzLl9waXBlLmxlbmd0aCxcXG5cXHRcXHQgICAgZmlsdGVyID0gJC5wcm94eShmdW5jdGlvbiAocCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzW3BdO1xcblxcdFxcdH0sIHRoaXMuX2ludmFsaWRhdGVkKSxcXG5cXHRcXHQgICAgY2FjaGUgPSB7fTtcXG5cXG5cXHRcXHR3aGlsZSAoaSA8IG4pIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5faW52YWxpZGF0ZWQuYWxsIHx8ICQuZ3JlcCh0aGlzLl9waXBlW2ldLmZpbHRlciwgZmlsdGVyKS5sZW5ndGggPiAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fcGlwZVtpXS5ydW4oY2FjaGUpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpKys7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2ludmFsaWRhdGVkID0ge307XFxuXFxuXFx0XFx0IXRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5lbnRlcigndmFsaWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSB3aWR0aCBvZiB0aGUgdmlldy5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge093bC5XaWR0aH0gW2RpbWVuc2lvbj1Pd2wuV2lkdGguRGVmYXVsdF0gLSBUaGUgZGltZW5zaW9uIHRvIHJldHVybi5cXG4gICogQHJldHVybnMge051bWJlcn0gLSBUaGUgd2lkdGggb2YgdGhlIHZpZXcgaW4gcGl4ZWwuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUud2lkdGggPSBmdW5jdGlvbiAoZGltZW5zaW9uKSB7XFxuXFx0XFx0ZGltZW5zaW9uID0gZGltZW5zaW9uIHx8IE93bC5XaWR0aC5EZWZhdWx0O1xcblxcdFxcdHN3aXRjaCAoZGltZW5zaW9uKSB7XFxuXFx0XFx0XFx0Y2FzZSBPd2wuV2lkdGguSW5uZXI6XFxuXFx0XFx0XFx0Y2FzZSBPd2wuV2lkdGguT3V0ZXI6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xcblxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuX3dpZHRoIC0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlZnJlc2hlcyB0aGUgY2Fyb3VzZWwgcHJpbWFyaWx5IGZvciBhZGFwdGl2ZSBwdXJwb3Nlcy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dGhpcy5lbnRlcigncmVmcmVzaGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVmcmVzaCcpO1xcblxcblxcdFxcdHRoaXMuc2V0dXAoKTtcXG5cXG5cXHRcXHR0aGlzLm9wdGlvbnNMb2dpYygpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XFxuXFxuXFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5yZWZyZXNoQ2xhc3MpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ3JlZnJlc2hpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3JlZnJlc2hlZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRocm90dGxlZFJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xcblxcdFxcdHRoaXMucmVzaXplVGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCh0aGlzLl9oYW5kbGVycy5vblJlc2l6ZSwgdGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlUmVmcmVzaFJhdGUpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENoZWNrcyB3aW5kb3cgYHJlc2l6ZWAgZXZlbnQuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAoIXRoaXMuX2l0ZW1zLmxlbmd0aCkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuX3dpZHRoID09PSB0aGlzLiRlbGVtZW50LndpZHRoKCkpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5lbnRlcigncmVzaXppbmcnKTtcXG5cXG5cXHRcXHRpZiAodGhpcy50cmlnZ2VyKCdyZXNpemUnKS5pc0RlZmF1bHRQcmV2ZW50ZWQoKSkge1xcblxcdFxcdFxcdHRoaXMubGVhdmUoJ3Jlc2l6aW5nJyk7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ3dpZHRoJyk7XFxuXFxuXFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgncmVzaXppbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3Jlc2l6ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBSZWdpc3RlcnMgZXZlbnQgaGFuZGxlcnMuXFxuICAqIEB0b2RvIENoZWNrIGBtc1BvaW50ZXJFbmFibGVkYFxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlckV2ZW50SGFuZGxlcnMgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0aWYgKCQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJC5zdXBwb3J0LnRyYW5zaXRpb24uZW5kICsgJy5vd2wuY29yZScsICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHR0aGlzLm9uKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubW91c2VEcmFnKSB7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZHJhZ0NsYXNzKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbignbW91c2Vkb3duLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ2RyYWdzdGFydC5vd2wuY29yZSBzZWxlY3RzdGFydC5vd2wuY29yZScsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnRvdWNoRHJhZykge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCd0b3VjaHN0YXJ0Lm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ1N0YXJ0LCB0aGlzKSk7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoY2FuY2VsLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ0VuZCwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBIYW5kbGVzIGB0b3VjaHN0YXJ0YCBhbmQgYG1vdXNlZG93bmAgZXZlbnRzLlxcbiAgKiBAdG9kbyBIb3Jpem9udGFsIHN3aXBlIHRocmVzaG9sZCBhcyBvcHRpb25cXG4gICogQHRvZG8gIzI2MVxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vbkRyYWdTdGFydCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciBzdGFnZSA9IG51bGw7XFxuXFxuXFx0XFx0aWYgKGV2ZW50LndoaWNoID09PSAzKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoJC5zdXBwb3J0LnRyYW5zZm9ybSkge1xcblxcdFxcdFxcdHN0YWdlID0gdGhpcy4kc3RhZ2UuY3NzKCd0cmFuc2Zvcm0nKS5yZXBsYWNlKC8uKlxcXFwofFxcXFwpfCAvZywgJycpLnNwbGl0KCcsJyk7XFxuXFx0XFx0XFx0c3RhZ2UgPSB7XFxuXFx0XFx0XFx0XFx0eDogc3RhZ2Vbc3RhZ2UubGVuZ3RoID09PSAxNiA/IDEyIDogNF0sXFxuXFx0XFx0XFx0XFx0eTogc3RhZ2Vbc3RhZ2UubGVuZ3RoID09PSAxNiA/IDEzIDogNV1cXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5wb3NpdGlvbigpO1xcblxcdFxcdFxcdHN0YWdlID0ge1xcblxcdFxcdFxcdFxcdHg6IHRoaXMuc2V0dGluZ3MucnRsID8gc3RhZ2UubGVmdCArIHRoaXMuJHN0YWdlLndpZHRoKCkgLSB0aGlzLndpZHRoKCkgKyB0aGlzLnNldHRpbmdzLm1hcmdpbiA6IHN0YWdlLmxlZnQsXFxuXFx0XFx0XFx0XFx0eTogc3RhZ2UudG9wXFxuXFx0XFx0XFx0fTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuaXMoJ2FuaW1hdGluZycpKSB7XFxuXFx0XFx0XFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA/IHRoaXMuYW5pbWF0ZShzdGFnZS54KSA6IHRoaXMuJHN0YWdlLnN0b3AoKTtcXG5cXHRcXHRcXHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcywgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicpO1xcblxcblxcdFxcdHRoaXMuc3BlZWQoMCk7XFxuXFxuXFx0XFx0dGhpcy5fZHJhZy50aW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuXFx0XFx0dGhpcy5fZHJhZy50YXJnZXQgPSAkKGV2ZW50LnRhcmdldCk7XFxuXFx0XFx0dGhpcy5fZHJhZy5zdGFnZS5zdGFydCA9IHN0YWdlO1xcblxcdFxcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xcblxcdFxcdHRoaXMuX2RyYWcucG9pbnRlciA9IHRoaXMucG9pbnRlcihldmVudCk7XFxuXFxuXFx0XFx0JChkb2N1bWVudCkub24oJ21vdXNldXAub3dsLmNvcmUgdG91Y2hlbmQub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XFxuXFxuXFx0XFx0JChkb2N1bWVudCkub25lKCdtb3VzZW1vdmUub3dsLmNvcmUgdG91Y2htb3ZlLm93bC5jb3JlJywgJC5wcm94eShmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHR2YXIgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKTtcXG5cXG5cXHRcXHRcXHQkKGRvY3VtZW50KS5vbignbW91c2Vtb3ZlLm93bC5jb3JlIHRvdWNobW92ZS5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdNb3ZlLCB0aGlzKSk7XFxuXFxuXFx0XFx0XFx0aWYgKE1hdGguYWJzKGRlbHRhLngpIDwgTWF0aC5hYnMoZGVsdGEueSkgJiYgdGhpcy5pcygndmFsaWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLmVudGVyKCdkcmFnZ2luZycpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcignZHJhZycpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBIYW5kbGVzIHRoZSBgdG91Y2htb3ZlYCBhbmQgYG1vdXNlbW92ZWAgZXZlbnRzLlxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uRHJhZ01vdmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHR2YXIgbWluaW11bSA9IG51bGwsXFxuXFx0XFx0ICAgIG1heGltdW0gPSBudWxsLFxcblxcdFxcdCAgICBwdWxsID0gbnVsbCxcXG5cXHRcXHQgICAgZGVsdGEgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5wb2ludGVyLCB0aGlzLnBvaW50ZXIoZXZlbnQpKSxcXG5cXHRcXHQgICAgc3RhZ2UgPSB0aGlzLmRpZmZlcmVuY2UodGhpcy5fZHJhZy5zdGFnZS5zdGFydCwgZGVsdGEpO1xcblxcblxcdFxcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0bWluaW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpICsgMSkgLSBtaW5pbXVtO1xcblxcdFxcdFxcdHN0YWdlLnggPSAoKHN0YWdlLnggLSBtaW5pbXVtKSAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW0gKyBtaW5pbXVtO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWluaW11bSA9IHRoaXMuc2V0dGluZ3MucnRsID8gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSkgOiB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWluaW11bSgpKTtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWluaW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkpO1xcblxcdFxcdFxcdHB1bGwgPSB0aGlzLnNldHRpbmdzLnB1bGxEcmFnID8gLTEgKiBkZWx0YS54IC8gNSA6IDA7XFxuXFx0XFx0XFx0c3RhZ2UueCA9IE1hdGgubWF4KE1hdGgubWluKHN0YWdlLngsIG1pbmltdW0gKyBwdWxsKSwgbWF4aW11bSArIHB1bGwpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9kcmFnLnN0YWdlLmN1cnJlbnQgPSBzdGFnZTtcXG5cXG5cXHRcXHR0aGlzLmFuaW1hdGUoc3RhZ2UueCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogSGFuZGxlcyB0aGUgYHRvdWNoZW5kYCBhbmQgYG1vdXNldXBgIGV2ZW50cy5cXG4gICogQHRvZG8gIzI2MVxcbiAgKiBAdG9kbyBUaHJlc2hvbGQgZm9yIGNsaWNrIGV2ZW50XFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uRHJhZ0VuZCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpLFxcblxcdFxcdCAgICBzdGFnZSA9IHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCxcXG5cXHRcXHQgICAgZGlyZWN0aW9uID0gZGVsdGEueCA+IDAgXiB0aGlzLnNldHRpbmdzLnJ0bCA/ICdsZWZ0JyA6ICdyaWdodCc7XFxuXFxuXFx0XFx0JChkb2N1bWVudCkub2ZmKCcub3dsLmNvcmUnKTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpO1xcblxcblxcdFxcdGlmIChkZWx0YS54ICE9PSAwICYmIHRoaXMuaXMoJ2RyYWdnaW5nJykgfHwgIXRoaXMuaXMoJ3ZhbGlkJykpIHtcXG5cXHRcXHRcXHR0aGlzLnNwZWVkKHRoaXMuc2V0dGluZ3MuZHJhZ0VuZFNwZWVkIHx8IHRoaXMuc2V0dGluZ3Muc21hcnRTcGVlZCk7XFxuXFx0XFx0XFx0dGhpcy5jdXJyZW50KHRoaXMuY2xvc2VzdChzdGFnZS54LCBkZWx0YS54ICE9PSAwID8gZGlyZWN0aW9uIDogdGhpcy5fZHJhZy5kaXJlY3Rpb24pKTtcXG5cXHRcXHRcXHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XFxuXFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLl9kcmFnLmRpcmVjdGlvbiA9IGRpcmVjdGlvbjtcXG5cXG5cXHRcXHRcXHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPiAzIHx8IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gdGhpcy5fZHJhZy50aW1lID4gMzAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fZHJhZy50YXJnZXQub25lKCdjbGljay5vd2wuY29yZScsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuaXMoJ2RyYWdnaW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMubGVhdmUoJ2RyYWdnaW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdkcmFnZ2VkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtIGZvciBhIGNvb3JkaW5hdGUuXFxuICAqIEB0b2RvIFNldHRpbmcgYGZyZWVEcmFnYCBtYWtlcyBgY2xvc2VzdGAgbm90IHJldXNhYmxlLiBTZWUgIzE2NS5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge051bWJlcn0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIGluIHBpeGVsLlxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZGlyZWN0aW9uIC0gVGhlIGRpcmVjdGlvbiB0byBjaGVjayBmb3IgdGhlIGNsb3Nlc3QgaXRlbS4gRXRoZXIgYGxlZnRgIG9yIGByaWdodGAuXFxuICAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGNsb3Nlc3QgaXRlbS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5jbG9zZXN0ID0gZnVuY3Rpb24gKGNvb3JkaW5hdGUsIGRpcmVjdGlvbikge1xcblxcdFxcdHZhciBwb3NpdGlvbiA9IC0xLFxcblxcdFxcdCAgICBwdWxsID0gMzAsXFxuXFx0XFx0ICAgIHdpZHRoID0gdGhpcy53aWR0aCgpLFxcblxcdFxcdCAgICBjb29yZGluYXRlcyA9IHRoaXMuY29vcmRpbmF0ZXMoKTtcXG5cXG5cXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MuZnJlZURyYWcpIHtcXG5cXHRcXHRcXHQvLyBjaGVjayBjbG9zZXN0IGl0ZW1cXG5cXHRcXHRcXHQkLmVhY2goY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24gKGluZGV4LCB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdC8vIG9uIGEgbGVmdCBwdWxsLCBjaGVjayBvbiBjdXJyZW50IGluZGV4XFxuXFx0XFx0XFx0XFx0aWYgKGRpcmVjdGlvbiA9PT0gJ2xlZnQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlICsgcHVsbCkge1xcblxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uID0gaW5kZXg7XFxuXFx0XFx0XFx0XFx0XFx0Ly8gb24gYSByaWdodCBwdWxsLCBjaGVjayBvbiBwcmV2aW91cyBpbmRleFxcblxcdFxcdFxcdFxcdFxcdC8vIHRvIGRvIHNvLCBzdWJ0cmFjdCB3aWR0aCBmcm9tIHZhbHVlIGFuZCBzZXQgcG9zaXRpb24gPSBpbmRleCArIDFcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gJ3JpZ2h0JyAmJiBjb29yZGluYXRlID4gdmFsdWUgLSB3aWR0aCAtIHB1bGwgJiYgY29vcmRpbmF0ZSA8IHZhbHVlIC0gd2lkdGggKyBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBpbmRleCArIDE7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc8JywgdmFsdWUpICYmIHRoaXMub3AoY29vcmRpbmF0ZSwgJz4nLCBjb29yZGluYXRlc1tpbmRleCArIDFdIHx8IHZhbHVlIC0gd2lkdGgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBkaXJlY3Rpb24gPT09ICdsZWZ0JyA/IGluZGV4ICsgMSA6IGluZGV4O1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gcG9zaXRpb24gPT09IC0xO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCF0aGlzLnNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHQvLyBub24gbG9vcCBib3VuZHJpZXNcXG5cXHRcXHRcXHRpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPicsIGNvb3JkaW5hdGVzW3RoaXMubWluaW11bSgpXSkpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1pbmltdW0oKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJzwnLCBjb29yZGluYXRlc1t0aGlzLm1heGltdW0oKV0pKSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSBjb29yZGluYXRlID0gdGhpcy5tYXhpbXVtKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQW5pbWF0ZXMgdGhlIHN0YWdlLlxcbiAgKiBAdG9kbyAjMjcwXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvb3JkaW5hdGUgLSBUaGUgY29vcmRpbmF0ZSBpbiBwaXhlbHMuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuYW5pbWF0ZSA9IGZ1bmN0aW9uIChjb29yZGluYXRlKSB7XFxuXFx0XFx0dmFyIGFuaW1hdGUgPSB0aGlzLnNwZWVkKCkgPiAwO1xcblxcblxcdFxcdHRoaXMuaXMoJ2FuaW1hdGluZycpICYmIHRoaXMub25UcmFuc2l0aW9uRW5kKCk7XFxuXFxuXFx0XFx0aWYgKGFuaW1hdGUpIHtcXG5cXHRcXHRcXHR0aGlzLmVudGVyKCdhbmltYXRpbmcnKTtcXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZScpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoJC5zdXBwb3J0LnRyYW5zZm9ybTNkICYmICQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY3NzKHtcXG5cXHRcXHRcXHRcXHR0cmFuc2Zvcm06ICd0cmFuc2xhdGUzZCgnICsgY29vcmRpbmF0ZSArICdweCwwcHgsMHB4KScsXFxuXFx0XFx0XFx0XFx0dHJhbnNpdGlvbjogdGhpcy5zcGVlZCgpIC8gMTAwMCArICdzJ1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0gZWxzZSBpZiAoYW5pbWF0ZSkge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmFuaW1hdGUoe1xcblxcdFxcdFxcdFxcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXFxuXFx0XFx0XFx0fSwgdGhpcy5zcGVlZCgpLCB0aGlzLnNldHRpbmdzLmZhbGxiYWNrRWFzaW5nLCAkLnByb3h5KHRoaXMub25UcmFuc2l0aW9uRW5kLCB0aGlzKSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3Moe1xcblxcdFxcdFxcdFxcdGxlZnQ6IGNvb3JkaW5hdGUgKyAncHgnXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENoZWNrcyB3aGV0aGVyIHRoZSBjYXJvdXNlbCBpcyBpbiBhIHNwZWNpZmljIHN0YXRlIG9yIG5vdC5cXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0YXRlIC0gVGhlIHN0YXRlIHRvIGNoZWNrLlxcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSBUaGUgZmxhZyB3aGljaCBpbmRpY2F0ZXMgaWYgdGhlIGNhcm91c2VsIGlzIGJ1c3kuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuaXMgPSBmdW5jdGlvbiAoc3RhdGUpIHtcXG5cXHRcXHRyZXR1cm4gdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdICYmIHRoaXMuX3N0YXRlcy5jdXJyZW50W3N0YXRlXSA+IDA7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSBuZXcgYWJzb2x1dGUgcG9zaXRpb24gb3Igbm90aGluZyB0byBsZWF2ZSBpdCB1bmNoYW5nZWQuXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjdXJyZW50IGl0ZW0uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2N1cnJlbnQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDApIHtcXG5cXHRcXHRcXHRyZXR1cm4gdW5kZWZpbmVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5fY3VycmVudCAhPT0gcG9zaXRpb24pIHtcXG5cXHRcXHRcXHR2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoJ2NoYW5nZScsIHsgcHJvcGVydHk6IHsgbmFtZTogJ3Bvc2l0aW9uJywgdmFsdWU6IHBvc2l0aW9uIH0gfSk7XFxuXFxuXFx0XFx0XFx0aWYgKGV2ZW50LmRhdGEgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUoZXZlbnQuZGF0YSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2N1cnJlbnQgPSBwb3NpdGlvbjtcXG5cXG5cXHRcXHRcXHR0aGlzLmludmFsaWRhdGUoJ3Bvc2l0aW9uJyk7XFxuXFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdjaGFuZ2VkJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAncG9zaXRpb24nLCB2YWx1ZTogdGhpcy5fY3VycmVudCB9IH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5fY3VycmVudDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBJbnZhbGlkYXRlcyB0aGUgZ2l2ZW4gcGFydCBvZiB0aGUgdXBkYXRlIHJvdXRpbmUuXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbcGFydF0gLSBUaGUgcGFydCB0byBpbnZhbGlkYXRlLlxcbiAgKiBAcmV0dXJucyB7QXJyYXkuPFN0cmluZz59IC0gVGhlIGludmFsaWRhdGVkIHBhcnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmludmFsaWRhdGUgPSBmdW5jdGlvbiAocGFydCkge1xcblxcdFxcdGlmICgkLnR5cGUocGFydCkgPT09ICdzdHJpbmcnKSB7XFxuXFx0XFx0XFx0dGhpcy5faW52YWxpZGF0ZWRbcGFydF0gPSB0cnVlO1xcblxcdFxcdFxcdHRoaXMuaXMoJ3ZhbGlkJykgJiYgdGhpcy5sZWF2ZSgndmFsaWQnKTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2ludmFsaWRhdGVkLCBmdW5jdGlvbiAodiwgaSkge1xcblxcdFxcdFxcdHJldHVybiBpO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlc2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIG5ldyBpdGVtLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbik7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3NwZWVkID0gMDtcXG5cXHRcXHR0aGlzLl9jdXJyZW50ID0gcG9zaXRpb247XFxuXFxuXFx0XFx0dGhpcy5zdXBwcmVzcyhbJ3RyYW5zbGF0ZScsICd0cmFuc2xhdGVkJ10pO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZSh0aGlzLmNvb3JkaW5hdGVzKHBvc2l0aW9uKSk7XFxuXFxuXFx0XFx0dGhpcy5yZWxlYXNlKFsndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnXSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogTm9ybWFsaXplcyBhbiBhYnNvbHV0ZSBvciBhIHJlbGF0aXZlIHBvc2l0aW9uIG9mIGFuIGl0ZW0uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIG9yIHJlbGF0aXZlIHBvc2l0aW9uIHRvIG5vcm1hbGl6ZS5cXG4gICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0aGUgZ2l2ZW4gcG9zaXRpb24gaXMgcmVsYXRpdmUgb3Igbm90LlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBub3JtYWxpemVkIHBvc2l0aW9uLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgcmVsYXRpdmUpIHtcXG5cXHRcXHR2YXIgbiA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHQgICAgbSA9IHJlbGF0aXZlID8gMCA6IHRoaXMuX2Nsb25lcy5sZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLmlzTnVtZXJpYyhwb3NpdGlvbikgfHwgbiA8IDEpIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHVuZGVmaW5lZDtcXG5cXHRcXHR9IGVsc2UgaWYgKHBvc2l0aW9uIDwgMCB8fCBwb3NpdGlvbiA+PSBuICsgbSkge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gKChwb3NpdGlvbiAtIG0gLyAyKSAlIG4gKyBuKSAlIG4gKyBtIC8gMjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENvbnZlcnRzIGFuIGFic29sdXRlIHBvc2l0aW9uIG9mIGFuIGl0ZW0gaW50byBhIHJlbGF0aXZlIG9uZS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gdG8gY29udmVydC5cXG4gICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY29udmVydGVkIHBvc2l0aW9uLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlbGF0aXZlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0cmV0dXJuIHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSBtYXhpbXVtIHBvc2l0aW9uIGZvciB0aGUgY3VycmVudCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9XFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUubWF4aW11bSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xcblxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3MsXFxuXFx0XFx0ICAgIG1heGltdW0gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGgsXFxuXFx0XFx0ICAgIGl0ZXJhdG9yLFxcblxcdFxcdCAgICByZWNpcHJvY2FsSXRlbXNXaWR0aCxcXG5cXHRcXHQgICAgZWxlbWVudFdpZHRoO1xcblxcblxcdFxcdGlmIChzZXR0aW5ncy5sb29wKSB7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyICsgdGhpcy5faXRlbXMubGVuZ3RoIC0gMTtcXG5cXHRcXHR9IGVsc2UgaWYgKHNldHRpbmdzLmF1dG9XaWR0aCB8fCBzZXR0aW5ncy5tZXJnZSkge1xcblxcdFxcdFxcdGl0ZXJhdG9yID0gdGhpcy5faXRlbXMubGVuZ3RoO1xcblxcdFxcdFxcdHJlY2lwcm9jYWxJdGVtc1dpZHRoID0gdGhpcy5faXRlbXNbLS1pdGVyYXRvcl0ud2lkdGgoKTtcXG5cXHRcXHRcXHRlbGVtZW50V2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XFxuXFx0XFx0XFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcXG5cXHRcXHRcXHRcXHRyZWNpcHJvY2FsSXRlbXNXaWR0aCArPSB0aGlzLl9pdGVtc1tpdGVyYXRvcl0ud2lkdGgoKSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdFxcdFxcdGlmIChyZWNpcHJvY2FsSXRlbXNXaWR0aCA+IGVsZW1lbnRXaWR0aCkge1xcblxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0bWF4aW11bSA9IGl0ZXJhdG9yICsgMTtcXG5cXHRcXHR9IGVsc2UgaWYgKHNldHRpbmdzLmNlbnRlcikge1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIHNldHRpbmdzLml0ZW1zO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAocmVsYXRpdmUpIHtcXG5cXHRcXHRcXHRtYXhpbXVtIC09IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gTWF0aC5tYXgobWF4aW11bSwgMCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB0aGUgbWluaW11bSBwb3NpdGlvbiBmb3IgdGhlIGN1cnJlbnQgaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRvIHJldHVybiBhbiBhYnNvbHV0ZSBwb3NpdGlvbiBvciBhIHJlbGF0aXZlIHBvc2l0aW9uLlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfVxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1pbmltdW0gPSBmdW5jdGlvbiAocmVsYXRpdmUpIHtcXG5cXHRcXHRyZXR1cm4gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXFxuICAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5pdGVtcyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXMuX2l0ZW1zLnNsaWNlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdHJldHVybiB0aGlzLl9pdGVtc1twb3NpdGlvbl07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcmVsYXRpdmUgcG9zaXRpb24uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtwb3NpdGlvbl0gLSBUaGUgcmVsYXRpdmUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXFxuICAqIEByZXR1cm4ge2pRdWVyeXxBcnJheS48alF1ZXJ5Pn0gLSBUaGUgaXRlbSBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gb3IgYWxsIGl0ZW1zIGlmIG5vIHBvc2l0aW9uIHdhcyBnaXZlbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5tZXJnZXJzID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fbWVyZ2Vycy5zbGljZSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXHRcXHRyZXR1cm4gdGhpcy5fbWVyZ2Vyc1twb3NpdGlvbl07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB0aGUgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGNsb25lcyBmb3IgYW4gaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG4gICogQHJldHVybnMge0FycmF5LjxOdW1iZXI+fSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciB0aGUgaXRlbSBvciBhbGwgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb25lcyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xcblxcdFxcdHZhciBvZGQgPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMixcXG5cXHRcXHQgICAgZXZlbiA9IG9kZCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHQgICAgbWFwID0gZnVuY3Rpb24gbWFwKGluZGV4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIGluZGV4ICUgMiA9PT0gMCA/IGV2ZW4gKyBpbmRleCAvIDIgOiBvZGQgLSAoaW5kZXggKyAxKSAvIDI7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiAkLm1hcCh0aGlzLl9jbG9uZXMsIGZ1bmN0aW9uICh2LCBpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIG1hcChpKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24gKHYsIGkpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdiA9PT0gcG9zaXRpb24gPyBtYXAoaSkgOiBudWxsO1xcblxcdFxcdH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNldHMgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIHNwZWVkLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBpbiBtaWxsaXNlY29uZHMgb3Igbm90aGluZyB0byBsZWF2ZSBpdCB1bmNoYW5nZWQuXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIGN1cnJlbnQgYW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5zcGVlZCA9IGZ1bmN0aW9uIChzcGVlZCkge1xcblxcdFxcdGlmIChzcGVlZCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3BlZWQgPSBzcGVlZDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuX3NwZWVkO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIGNvb3JkaW5hdGUgb2YgYW4gaXRlbS5cXG4gICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZXRob2QgaXMgbWlzc2xlYW5kaW5nLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB3aXRoaW4gYG1pbmltdW0oKWAgYW5kIGBtYXhpbXVtKClgLlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfEFycmF5LjxOdW1iZXI+fSAtIFRoZSBjb29yZGluYXRlIG9mIHRoZSBpdGVtIGluIHBpeGVsIG9yIGFsbCBjb29yZGluYXRlcy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5jb29yZGluYXRlcyA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xcblxcdFxcdHZhciBtdWx0aXBsaWVyID0gMSxcXG5cXHRcXHQgICAgbmV3UG9zaXRpb24gPSBwb3NpdGlvbiAtIDEsXFxuXFx0XFx0ICAgIGNvb3JkaW5hdGU7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5fY29vcmRpbmF0ZXMsICQucHJveHkoZnVuY3Rpb24gKGNvb3JkaW5hdGUsIGluZGV4KSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXMoaW5kZXgpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MuY2VudGVyKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucnRsKSB7XFxuXFx0XFx0XFx0XFx0bXVsdGlwbGllciA9IC0xO1xcblxcdFxcdFxcdFxcdG5ld1Bvc2l0aW9uID0gcG9zaXRpb24gKyAxO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbcG9zaXRpb25dO1xcblxcdFxcdFxcdGNvb3JkaW5hdGUgKz0gKHRoaXMud2lkdGgoKSAtIGNvb3JkaW5hdGUgKyAodGhpcy5fY29vcmRpbmF0ZXNbbmV3UG9zaXRpb25dIHx8IDApKSAvIDIgKiBtdWx0aXBsaWVyO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y29vcmRpbmF0ZSA9IHRoaXMuX2Nvb3JkaW5hdGVzW25ld1Bvc2l0aW9uXSB8fCAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRjb29yZGluYXRlID0gTWF0aC5jZWlsKGNvb3JkaW5hdGUpO1xcblxcblxcdFxcdHJldHVybiBjb29yZGluYXRlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENhbGN1bGF0ZXMgdGhlIHNwZWVkIGZvciBhIHRyYW5zbGF0aW9uLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBmcm9tIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBzdGFydCBpdGVtLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gdG8gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBpdGVtLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gW2ZhY3Rvcj11bmRlZmluZWRdIC0gVGhlIHRpbWUgZmFjdG9yIGluIG1pbGxpc2Vjb25kcy5cXG4gICogQHJldHVybnMge051bWJlcn0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2xhdGlvbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5kdXJhdGlvbiA9IGZ1bmN0aW9uIChmcm9tLCB0bywgZmFjdG9yKSB7XFxuXFx0XFx0aWYgKGZhY3RvciA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiAwO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoTWF0aC5hYnModG8gLSBmcm9tKSwgMSksIDYpICogTWF0aC5hYnMoZmFjdG9yIHx8IHRoaXMuc2V0dGluZ3Muc21hcnRTcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2xpZGVzIHRvIHRoZSBzcGVjaWZpZWQgaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS50byA9IGZ1bmN0aW9uIChwb3NpdGlvbiwgc3BlZWQpIHtcXG5cXHRcXHR2YXIgY3VycmVudCA9IHRoaXMuY3VycmVudCgpLFxcblxcdFxcdCAgICByZXZlcnQgPSBudWxsLFxcblxcdFxcdCAgICBkaXN0YW5jZSA9IHBvc2l0aW9uIC0gdGhpcy5yZWxhdGl2ZShjdXJyZW50KSxcXG5cXHRcXHQgICAgZGlyZWN0aW9uID0gKGRpc3RhbmNlID4gMCkgLSAoZGlzdGFuY2UgPCAwKSxcXG5cXHRcXHQgICAgaXRlbXMgPSB0aGlzLl9pdGVtcy5sZW5ndGgsXFxuXFx0XFx0ICAgIG1pbmltdW0gPSB0aGlzLm1pbmltdW0oKSxcXG5cXHRcXHQgICAgbWF4aW11bSA9IHRoaXMubWF4aW11bSgpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MucmV3aW5kICYmIE1hdGguYWJzKGRpc3RhbmNlKSA+IGl0ZW1zIC8gMikge1xcblxcdFxcdFxcdFxcdGRpc3RhbmNlICs9IGRpcmVjdGlvbiAqIC0xICogaXRlbXM7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHBvc2l0aW9uID0gY3VycmVudCArIGRpc3RhbmNlO1xcblxcdFxcdFxcdHJldmVydCA9ICgocG9zaXRpb24gLSBtaW5pbXVtKSAlIGl0ZW1zICsgaXRlbXMpICUgaXRlbXMgKyBtaW5pbXVtO1xcblxcblxcdFxcdFxcdGlmIChyZXZlcnQgIT09IHBvc2l0aW9uICYmIHJldmVydCAtIGRpc3RhbmNlIDw9IG1heGltdW0gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPiAwKSB7XFxuXFx0XFx0XFx0XFx0Y3VycmVudCA9IHJldmVydCAtIGRpc3RhbmNlO1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gcmV2ZXJ0O1xcblxcdFxcdFxcdFxcdHRoaXMucmVzZXQoY3VycmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0gZWxzZSBpZiAodGhpcy5zZXR0aW5ncy5yZXdpbmQpIHtcXG5cXHRcXHRcXHRtYXhpbXVtICs9IDE7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAocG9zaXRpb24gJSBtYXhpbXVtICsgbWF4aW11bSkgJSBtYXhpbXVtO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSBNYXRoLm1heChtaW5pbXVtLCBNYXRoLm1pbihtYXhpbXVtLCBwb3NpdGlvbikpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLnNwZWVkKHRoaXMuZHVyYXRpb24oY3VycmVudCwgcG9zaXRpb24sIHNwZWVkKSk7XFxuXFx0XFx0dGhpcy5jdXJyZW50KHBvc2l0aW9uKTtcXG5cXG5cXHRcXHRpZiAodGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHNwZWVkKSB7XFxuXFx0XFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcXG5cXHRcXHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpICsgMSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNsaWRlcyB0byB0aGUgcHJldmlvdXMgaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIChzcGVlZCkge1xcblxcdFxcdHNwZWVkID0gc3BlZWQgfHwgZmFsc2U7XFxuXFx0XFx0dGhpcy50byh0aGlzLnJlbGF0aXZlKHRoaXMuY3VycmVudCgpKSAtIDEsIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBIYW5kbGVzIHRoZSBlbmQgb2YgYW4gYW5pbWF0aW9uLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGFyZ3VtZW50cy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vblRyYW5zaXRpb25FbmQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXG5cXHRcXHQvLyBpZiBjc3MyIGFuaW1hdGlvbiB0aGVuIGV2ZW50IG9iamVjdCBpcyB1bmRlZmluZWRcXG5cXHRcXHRpZiAoZXZlbnQgIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcblxcblxcdFxcdFxcdC8vIENhdGNoIG9ubHkgb3dsLXN0YWdlIHRyYW5zaXRpb25FbmQgZXZlbnRcXG5cXHRcXHRcXHRpZiAoKGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50IHx8IGV2ZW50Lm9yaWdpbmFsVGFyZ2V0KSAhPT0gdGhpcy4kc3RhZ2UuZ2V0KDApKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgnYW5pbWF0aW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCd0cmFuc2xhdGVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB2aWV3cG9ydCB3aWR0aC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcmV0dXJuIHtOdW1iZXJ9IC0gVGhlIHdpZHRoIGluIHBpeGVsLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnZpZXdwb3J0ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciB3aWR0aDtcXG5cXHRcXHRpZiAodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCAhPT0gd2luZG93KSB7XFxuXFx0XFx0XFx0d2lkdGggPSAkKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQmFzZUVsZW1lbnQpLndpZHRoKCk7XFxuXFx0XFx0fSBlbHNlIGlmICh3aW5kb3cuaW5uZXJXaWR0aCkge1xcblxcdFxcdFxcdHdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XFxuXFx0XFx0fSBlbHNlIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0d2lkdGggPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb25zb2xlLndhcm4oJ0NhbiBub3QgZGV0ZWN0IHZpZXdwb3J0IHdpZHRoLicpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gd2lkdGg7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVwbGFjZXMgdGhlIGN1cnJlbnQgY29udGVudC5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fGpRdWVyeXxTdHJpbmd9IGNvbnRlbnQgLSBUaGUgbmV3IGNvbnRlbnQuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVwbGFjZSA9IGZ1bmN0aW9uIChjb250ZW50KSB7XFxuXFx0XFx0dGhpcy4kc3RhZ2UuZW1wdHkoKTtcXG5cXHRcXHR0aGlzLl9pdGVtcyA9IFtdO1xcblxcblxcdFxcdGlmIChjb250ZW50KSB7XFxuXFx0XFx0XFx0Y29udGVudCA9IGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZW50IDogJChjb250ZW50KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKSB7XFxuXFx0XFx0XFx0Y29udGVudCA9IGNvbnRlbnQuZmluZCgnLicgKyB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3Rvcik7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnRlbnQuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5ub2RlVHlwZSA9PT0gMTtcXG5cXHRcXHR9KS5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGluZGV4LCBpdGVtKSB7XFxuXFx0XFx0XFx0aXRlbSA9IHRoaXMucHJlcGFyZShpdGVtKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5hcHBlbmQoaXRlbSk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMucHVzaChpdGVtKTtcXG5cXHRcXHRcXHR0aGlzLl9tZXJnZXJzLnB1c2goaXRlbS5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHR0aGlzLnJlc2V0KHRoaXMuaXNOdW1lcmljKHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbikgPyB0aGlzLnNldHRpbmdzLnN0YXJ0UG9zaXRpb24gOiAwKTtcXG5cXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQWRkcyBhbiBpdGVtLlxcbiAgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gY29udGVudCAtIFRoZSBpdGVtIGNvbnRlbnQgdG8gYWRkLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBhdCB3aGljaCB0byBpbnNlcnQgdGhlIGl0ZW0gb3RoZXJ3aXNlIHRoZSBpdGVtIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZC5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoY29udGVudCwgcG9zaXRpb24pIHtcXG5cXHRcXHR2YXIgY3VycmVudCA9IHRoaXMucmVsYXRpdmUodGhpcy5fY3VycmVudCk7XFxuXFxuXFx0XFx0cG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5faXRlbXMubGVuZ3RoIDogdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdGNvbnRlbnQgPSBjb250ZW50IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGVudCA6ICQoY29udGVudCk7XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdhZGQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXG5cXHRcXHRjb250ZW50ID0gdGhpcy5wcmVwYXJlKGNvbnRlbnQpO1xcblxcblxcdFxcdGlmICh0aGlzLl9pdGVtcy5sZW5ndGggPT09IDAgfHwgcG9zaXRpb24gPT09IHRoaXMuX2l0ZW1zLmxlbmd0aCkge1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCAmJiB0aGlzLiRzdGFnZS5hcHBlbmQoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMubGVuZ3RoICE9PSAwICYmIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uIC0gMV0uYWZ0ZXIoY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMucHVzaChjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9tZXJnZXJzLnB1c2goY29udGVudC5maW5kKCdbZGF0YS1tZXJnZV0nKS5hZGRCYWNrKCdbZGF0YS1tZXJnZV0nKS5hdHRyKCdkYXRhLW1lcmdlJykgKiAxIHx8IDEpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXNbcG9zaXRpb25dLmJlZm9yZShjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAwLCBjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2l0ZW1zW2N1cnJlbnRdICYmIHRoaXMucmVzZXQodGhpcy5faXRlbXNbY3VycmVudF0uaW5kZXgoKSk7XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcignYWRkZWQnLCB7IGNvbnRlbnQ6IGNvbnRlbnQsIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBSZW1vdmVzIGFuIGl0ZW0gYnkgaXRzIHBvc2l0aW9uLlxcbiAgKiBAdG9kbyBVc2UgYGl0ZW1gIGluc3RlYWQgb2YgYGNvbnRlbnRgIGZvciB0aGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbSB0byByZW1vdmUuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMudHJpZ2dlcigncmVtb3ZlJywgeyBjb250ZW50OiB0aGlzLl9pdGVtc1twb3NpdGlvbl0sIHBvc2l0aW9uOiBwb3NpdGlvbiB9KTtcXG5cXG5cXHRcXHR0aGlzLl9pdGVtc1twb3NpdGlvbl0ucmVtb3ZlKCk7XFxuXFx0XFx0dGhpcy5faXRlbXMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcXG5cXHRcXHR0aGlzLl9tZXJnZXJzLnNwbGljZShwb3NpdGlvbiwgMSk7XFxuXFxuXFx0XFx0dGhpcy5pbnZhbGlkYXRlKCdpdGVtcycpO1xcblxcblxcdFxcdHRoaXMudHJpZ2dlcigncmVtb3ZlZCcsIHsgY29udGVudDogbnVsbCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFByZWxvYWRzIGltYWdlcyB3aXRoIGF1dG8gd2lkdGguXFxuICAqIEB0b2RvIFJlcGxhY2UgYnkgYSBtb3JlIGdlbmVyaWMgYXBwcm9hY2hcXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnByZWxvYWRBdXRvV2lkdGhJbWFnZXMgPSBmdW5jdGlvbiAoaW1hZ2VzKSB7XFxuXFx0XFx0aW1hZ2VzLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaSwgZWxlbWVudCkge1xcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ3ByZS1sb2FkaW5nJyk7XFxuXFx0XFx0XFx0ZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuXFx0XFx0XFx0JChuZXcgSW1hZ2UoKSkub25lKCdsb2FkJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuYXR0cignc3JjJywgZS50YXJnZXQuc3JjKTtcXG5cXHRcXHRcXHRcXHRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdHRoaXMubGVhdmUoJ3ByZS1sb2FkaW5nJyk7XFxuXFx0XFx0XFx0XFx0IXRoaXMuaXMoJ3ByZS1sb2FkaW5nJykgJiYgIXRoaXMuaXMoJ2luaXRpYWxpemluZycpICYmIHRoaXMucmVmcmVzaCgpO1xcblxcdFxcdFxcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCBlbGVtZW50LmF0dHIoJ3NyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMnKSB8fCBlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVzdHJveXMgdGhlIGNhcm91c2VsLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50Lm9mZignLm93bC5jb3JlJyk7XFxuXFx0XFx0dGhpcy4kc3RhZ2Uub2ZmKCcub3dsLmNvcmUnKTtcXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmUgIT09IGZhbHNlKSB7XFxuXFx0XFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLnJlc2l6ZVRpbWVyKTtcXG5cXHRcXHRcXHR0aGlzLm9mZih3aW5kb3csICdyZXNpemUnLCB0aGlzLl9oYW5kbGVycy5vblRocm90dGxlZFJlc2l6ZSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGZvciAodmFyIGkgaW4gdGhpcy5fcGx1Z2lucykge1xcblxcdFxcdFxcdHRoaXMuX3BsdWdpbnNbaV0uZGVzdHJveSgpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmNsb25lZCcpLnJlbW92ZSgpO1xcblxcblxcdFxcdHRoaXMuJHN0YWdlLnVud3JhcCgpO1xcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuY29udGVudHMoKS51bndyYXAoKTtcXG5cXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbigpLnVud3JhcCgpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRlZENsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucnRsQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ncmFiQ2xhc3MpLmF0dHIoJ2NsYXNzJywgdGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycpLnJlcGxhY2UobmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUNsYXNzICsgJy1cXFxcXFxcXFMrXFxcXFxcXFxzJywgJ2cnKSwgJycpKS5yZW1vdmVEYXRhKCdvd2wuY2Fyb3VzZWwnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBPcGVyYXRvcnMgdG8gY2FsY3VsYXRlIHJpZ2h0LXRvLWxlZnQgYW5kIGxlZnQtdG8tcmlnaHQuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFthXSAtIFRoZSBsZWZ0IHNpZGUgb3BlcmFuZC5cXG4gICogQHBhcmFtIHtTdHJpbmd9IFtvXSAtIFRoZSBvcGVyYXRvci5cXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtiXSAtIFRoZSByaWdodCBzaWRlIG9wZXJhbmQuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub3AgPSBmdW5jdGlvbiAoYSwgbywgYikge1xcblxcdFxcdHZhciBydGwgPSB0aGlzLnNldHRpbmdzLnJ0bDtcXG5cXHRcXHRzd2l0Y2ggKG8pIHtcXG5cXHRcXHRcXHRjYXNlICc8JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA+IGIgOiBhIDwgYjtcXG5cXHRcXHRcXHRjYXNlICc+JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA8IGIgOiBhID4gYjtcXG5cXHRcXHRcXHRjYXNlICc+PSc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPD0gYiA6IGEgPj0gYjtcXG5cXHRcXHRcXHRjYXNlICc8PSc6XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHJ0bCA/IGEgPj0gYiA6IGEgPD0gYjtcXG5cXHRcXHRcXHRkZWZhdWx0OlxcblxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBBdHRhY2hlcyB0byBhbiBpbnRlcm5hbCBldmVudC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGV2ZW50IHNvdXJjZS5cXG4gICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gVGhlIGV2ZW50IG5hbWUuXFxuICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIC0gVGhlIGV2ZW50IGhhbmRsZXIgdG8gYXR0YWNoLlxcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IGNhcHR1cmUgLSBXZXRoZXIgdGhlIGV2ZW50IHNob3VsZCBiZSBoYW5kbGVkIGF0IHRoZSBjYXB0dXJpbmcgcGhhc2Ugb3Igbm90LlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSkge1xcblxcdFxcdGlmIChlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcXG5cXHRcXHR9IGVsc2UgaWYgKGVsZW1lbnQuYXR0YWNoRXZlbnQpIHtcXG5cXHRcXHRcXHRlbGVtZW50LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXRhY2hlcyBmcm9tIGFuIGludGVybmFsIGV2ZW50LlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgc291cmNlLlxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlciB0byBkZXRhY2guXFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSAtIFdldGhlciB0aGUgYXR0YWNoZWQgZXZlbnQgaGFuZGxlciB3YXMgcmVnaXN0ZXJlZCBhcyBhIGNhcHR1cmluZyBsaXN0ZW5lciBvciBub3QuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKGVsZW1lbnQsIGV2ZW50LCBsaXN0ZW5lciwgY2FwdHVyZSkge1xcblxcdFxcdGlmIChlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcXG5cXHRcXHRcXHRlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKTtcXG5cXHRcXHR9IGVsc2UgaWYgKGVsZW1lbnQuZGV0YWNoRXZlbnQpIHtcXG5cXHRcXHRcXHRlbGVtZW50LmRldGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBUcmlnZ2VycyBhIHB1YmxpYyBldmVudC5cXG4gICogQHRvZG8gUmVtb3ZlIGBzdGF0dXNgLCBgcmVsYXRlZFRhcmdldGAgc2hvdWxkIGJlIHVzZWQgaW5zdGVhZC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFRoZSBldmVudCBuYW1lLlxcbiAgKiBAcGFyYW0geyp9IFtkYXRhPW51bGxdIC0gVGhlIGV2ZW50IGRhdGEuXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbbmFtZXNwYWNlPWNhcm91c2VsXSAtIFRoZSBldmVudCBuYW1lc3BhY2UuXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBbc3RhdGVdIC0gVGhlIHN0YXRlIHdoaWNoIGlzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZXZlbnQuXFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2VudGVyPWZhbHNlXSAtIEluZGljYXRlcyBpZiB0aGUgY2FsbCBlbnRlcnMgdGhlIHNwZWNpZmllZCBzdGF0ZSBvciBub3QuXFxuICAqIEByZXR1cm5zIHtFdmVudH0gLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnRyaWdnZXIgPSBmdW5jdGlvbiAobmFtZSwgZGF0YSwgbmFtZXNwYWNlLCBzdGF0ZSwgZW50ZXIpIHtcXG5cXHRcXHR2YXIgc3RhdHVzID0ge1xcblxcdFxcdFxcdGl0ZW06IHsgY291bnQ6IHRoaXMuX2l0ZW1zLmxlbmd0aCwgaW5kZXg6IHRoaXMuY3VycmVudCgpIH1cXG5cXHRcXHR9LFxcblxcdFxcdCAgICBoYW5kbGVyID0gJC5jYW1lbENhc2UoJC5ncmVwKFsnb24nLCBuYW1lLCBuYW1lc3BhY2VdLCBmdW5jdGlvbiAodikge1xcblxcdFxcdFxcdHJldHVybiB2O1xcblxcdFxcdH0pLmpvaW4oJy0nKS50b0xvd2VyQ2FzZSgpKSxcXG5cXHRcXHQgICAgZXZlbnQgPSAkLkV2ZW50KFtuYW1lLCAnb3dsJywgbmFtZXNwYWNlIHx8ICdjYXJvdXNlbCddLmpvaW4oJy4nKS50b0xvd2VyQ2FzZSgpLCAkLmV4dGVuZCh7IHJlbGF0ZWRUYXJnZXQ6IHRoaXMgfSwgc3RhdHVzLCBkYXRhKSk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLl9zdXByZXNzW25hbWVdKSB7XFxuXFx0XFx0XFx0JC5lYWNoKHRoaXMuX3BsdWdpbnMsIGZ1bmN0aW9uIChuYW1lLCBwbHVnaW4pIHtcXG5cXHRcXHRcXHRcXHRpZiAocGx1Z2luLm9uVHJpZ2dlcikge1xcblxcdFxcdFxcdFxcdFxcdHBsdWdpbi5vblRyaWdnZXIoZXZlbnQpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHR0aGlzLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IG5hbWUgfSk7XFxuXFx0XFx0XFx0dGhpcy4kZWxlbWVudC50cmlnZ2VyKGV2ZW50KTtcXG5cXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncyAmJiB0eXBlb2YgdGhpcy5zZXR0aW5nc1toYW5kbGVyXSA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdFxcdFxcdHRoaXMuc2V0dGluZ3NbaGFuZGxlcl0uY2FsbCh0aGlzLCBldmVudCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRW50ZXJzIGEgc3RhdGUuXFxuICAqIEBwYXJhbSBuYW1lIC0gVGhlIHN0YXRlIG5hbWUuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAobmFtZSkge1xcblxcdFxcdCQuZWFjaChbbmFtZV0uY29uY2F0KHRoaXMuX3N0YXRlcy50YWdzW25hbWVdIHx8IFtdKSwgJC5wcm94eShmdW5jdGlvbiAoaSwgbmFtZSkge1xcblxcdFxcdFxcdGlmICh0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0gPSAwO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSsrO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBMZWF2ZXMgYSBzdGF0ZS5cXG4gICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuXFx0XFx0JC5lYWNoKFtuYW1lXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbbmFtZV0gfHwgW10pLCAkLnByb3h5KGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuXFx0XFx0XFx0dGhpcy5fc3RhdGVzLmN1cnJlbnRbbmFtZV0tLTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVnaXN0ZXJzIGFuIGV2ZW50IG9yIHN0YXRlLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgLSBUaGUgZXZlbnQgb3Igc3RhdGUgdG8gcmVnaXN0ZXIuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAob2JqZWN0KSB7XFxuXFx0XFx0aWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5FdmVudCkge1xcblxcdFxcdFxcdGlmICghJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSkge1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0gPSB7fTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLm93bCkge1xcblxcdFxcdFxcdFxcdHZhciBfZGVmYXVsdCA9ICQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0uX2RlZmF1bHQ7XFxuXFx0XFx0XFx0XFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5fZGVmYXVsdCA9IGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKF9kZWZhdWx0ICYmIF9kZWZhdWx0LmFwcGx5ICYmICghZS5uYW1lc3BhY2UgfHwgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPT09IC0xKSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBfZGVmYXVsdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gZS5uYW1lc3BhY2UgJiYgZS5uYW1lc3BhY2UuaW5kZXhPZignb3dsJykgPiAtMTtcXG5cXHRcXHRcXHRcXHR9O1xcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsID0gdHJ1ZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmIChvYmplY3QudHlwZSA9PT0gT3dsLlR5cGUuU3RhdGUpIHtcXG5cXHRcXHRcXHRpZiAoIXRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkge1xcblxcdFxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9IG9iamVjdC50YWdzO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdLmNvbmNhdChvYmplY3QudGFncyk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSA9ICQuZ3JlcCh0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0sICQucHJveHkoZnVuY3Rpb24gKHRhZywgaSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAkLmluQXJyYXkodGFnLCB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0pID09PSBpO1xcblxcdFxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU3VwcHJlc3NlcyBldmVudHMuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byBzdXBwcmVzcy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5zdXBwcmVzcyA9IGZ1bmN0aW9uIChldmVudHMpIHtcXG5cXHRcXHQkLmVhY2goZXZlbnRzLCAkLnByb3h5KGZ1bmN0aW9uIChpbmRleCwgZXZlbnQpIHtcXG5cXHRcXHRcXHR0aGlzLl9zdXByZXNzW2V2ZW50XSA9IHRydWU7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlbGVhc2VzIHN1cHByZXNzZWQgZXZlbnRzLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7QXJyYXkuPFN0cmluZz59IGV2ZW50cyAtIFRoZSBldmVudHMgdG8gcmVsZWFzZS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50cykge1xcblxcdFxcdCQuZWFjaChldmVudHMsICQucHJveHkoZnVuY3Rpb24gKGluZGV4LCBldmVudCkge1xcblxcdFxcdFxcdGRlbGV0ZSB0aGlzLl9zdXByZXNzW2V2ZW50XTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB1bmlmaWVkIHBvaW50ZXIgY29vcmRpbmF0ZXMgZnJvbSBldmVudC5cXG4gICogQHRvZG8gIzI2MVxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7RXZlbnR9IC0gVGhlIGBtb3VzZWRvd25gIG9yIGB0b3VjaHN0YXJ0YCBldmVudC5cXG4gICogQHJldHVybnMge09iamVjdH0gLSBDb250YWlucyBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBvZiBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucG9pbnRlciA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciByZXN1bHQgPSB7IHg6IG51bGwsIHk6IG51bGwgfTtcXG5cXG5cXHRcXHRldmVudCA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQgfHwgZXZlbnQgfHwgd2luZG93LmV2ZW50O1xcblxcblxcdFxcdGV2ZW50ID0gZXZlbnQudG91Y2hlcyAmJiBldmVudC50b3VjaGVzLmxlbmd0aCA/IGV2ZW50LnRvdWNoZXNbMF0gOiBldmVudC5jaGFuZ2VkVG91Y2hlcyAmJiBldmVudC5jaGFuZ2VkVG91Y2hlcy5sZW5ndGggPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xcblxcblxcdFxcdGlmIChldmVudC5wYWdlWCkge1xcblxcdFxcdFxcdHJlc3VsdC54ID0gZXZlbnQucGFnZVg7XFxuXFx0XFx0XFx0cmVzdWx0LnkgPSBldmVudC5wYWdlWTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJlc3VsdC54ID0gZXZlbnQuY2xpZW50WDtcXG5cXHRcXHRcXHRyZXN1bHQueSA9IGV2ZW50LmNsaWVudFk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGV0ZXJtaW5lcyBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3Igc29tZXRoaW5nIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge051bWJlcnxTdHJpbmd8T2JqZWN0fEFycmF5fEJvb2xlYW58UmVnRXhwfEZ1bmN0aW9ufFN5bWJvbH0gLSBUaGUgaW5wdXQgdG8gYmUgdGVzdGVkXFxuICAqIEByZXR1cm5zIHtCb29sZWFufSAtIEFuIGluZGljYXRpb24gaWYgdGhlIGlucHV0IGlzIGEgTnVtYmVyIG9yIGNhbiBiZSBjb2VyY2VkIHRvIGEgTnVtYmVyXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuaXNOdW1lcmljID0gZnVuY3Rpb24gKG51bWJlcikge1xcblxcdFxcdHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChudW1iZXIpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSBkaWZmZXJlbmNlIG9mIHR3byB2ZWN0b3JzLlxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIGZpcnN0IHZlY3Rvci5cXG4gICogQHBhcmFtIHtPYmplY3R9IC0gVGhlIHNlY29uZCB2ZWN0b3IuXFxuICAqIEByZXR1cm5zIHtPYmplY3R9IC0gVGhlIGRpZmZlcmVuY2UuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuZGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChmaXJzdCwgc2Vjb25kKSB7XFxuXFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHR4OiBmaXJzdC54IC0gc2Vjb25kLngsXFxuXFx0XFx0XFx0eTogZmlyc3QueSAtIHNlY29uZC55XFxuXFx0XFx0fTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBUaGUgalF1ZXJ5IFBsdWdpbiBmb3IgdGhlIE93bCBDYXJvdXNlbFxcbiAgKiBAdG9kbyBOYXZpZ2F0aW9uIHBsdWdpbiBgbmV4dGAgYW5kIGBwcmV2YFxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdCQuZm4ub3dsQ2Fyb3VzZWwgPSBmdW5jdGlvbiAob3B0aW9uKSB7XFxuXFx0XFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcblxcblxcdFxcdHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHZhciAkdGhpcyA9ICQodGhpcyksXFxuXFx0XFx0XFx0ICAgIGRhdGEgPSAkdGhpcy5kYXRhKCdvd2wuY2Fyb3VzZWwnKTtcXG5cXG5cXHRcXHRcXHRpZiAoIWRhdGEpIHtcXG5cXHRcXHRcXHRcXHRkYXRhID0gbmV3IE93bCh0aGlzLCAodHlwZW9mIG9wdGlvbiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob3B0aW9uKSkgPT0gJ29iamVjdCcgJiYgb3B0aW9uKTtcXG5cXHRcXHRcXHRcXHQkdGhpcy5kYXRhKCdvd2wuY2Fyb3VzZWwnLCBkYXRhKTtcXG5cXG5cXHRcXHRcXHRcXHQkLmVhY2goWyduZXh0JywgJ3ByZXYnLCAndG8nLCAnZGVzdHJveScsICdyZWZyZXNoJywgJ3JlcGxhY2UnLCAnYWRkJywgJ3JlbW92ZSddLCBmdW5jdGlvbiAoaSwgZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRcXHRkYXRhLnJlZ2lzdGVyKHsgdHlwZTogT3dsLlR5cGUuRXZlbnQsIG5hbWU6IGV2ZW50IH0pO1xcblxcdFxcdFxcdFxcdFxcdGRhdGEuJGVsZW1lbnQub24oZXZlbnQgKyAnLm93bC5jYXJvdXNlbC5jb3JlJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnJlbGF0ZWRUYXJnZXQgIT09IHRoaXMpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnN1cHByZXNzKFtldmVudF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdGRhdGFbZXZlbnRdLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5yZWxlYXNlKFtldmVudF0pO1xcblxcdFxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHR9LCBkYXRhKSk7XFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnICYmIG9wdGlvbi5jaGFyQXQoMCkgIT09ICdfJykge1xcblxcdFxcdFxcdFxcdGRhdGFbb3B0aW9uXS5hcHBseShkYXRhLCBhcmdzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVGhlIGNvbnN0cnVjdG9yIGZvciB0aGUgalF1ZXJ5IFBsdWdpblxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IgPSBPd2w7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEF1dG9SZWZyZXNoIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIGF1dG8gcmVmcmVzaCBwbHVnaW4uXFxuICAqIEBjbGFzcyBUaGUgQXV0byBSZWZyZXNoIFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBBdXRvUmVmcmVzaCA9IGZ1bmN0aW9uIEF1dG9SZWZyZXNoKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogUmVmcmVzaCBpbnRlcnZhbC5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtudW1iZXJ9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9pbnRlcnZhbCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBXaGV0aGVyIHRoZSBlbGVtZW50IGlzIGN1cnJlbnRseSB2aXNpYmxlIG9yIG5vdC5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtCb29sZWFufVxcbiAgICovXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvUmVmcmVzaCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMud2F0Y2goKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b1JlZnJlc2guRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZWZhdWx0IG9wdGlvbnMuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0QXV0b1JlZnJlc2guRGVmYXVsdHMgPSB7XFxuXFx0XFx0YXV0b1JlZnJlc2g6IHRydWUsXFxuXFx0XFx0YXV0b1JlZnJlc2hJbnRlcnZhbDogNTAwXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogV2F0Y2hlcyB0aGUgZWxlbWVudC5cXG4gICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLndhdGNoID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGlmICh0aGlzLl9pbnRlcnZhbCkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSA9IHRoaXMuX2NvcmUuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJyk7XFxuXFx0XFx0dGhpcy5faW50ZXJ2YWwgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoJC5wcm94eSh0aGlzLnJlZnJlc2gsIHRoaXMpLCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoSW50ZXJ2YWwpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlZnJlc2hlcyB0aGUgZWxlbWVudC5cXG4gICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLnJlZnJlc2ggPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0aWYgKHRoaXMuX2NvcmUuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykgPT09IHRoaXMuX3Zpc2libGUpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3Zpc2libGUgPSAhdGhpcy5fdmlzaWJsZTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50LnRvZ2dsZUNsYXNzKCdvd2wtaGlkZGVuJywgIXRoaXMuX3Zpc2libGUpO1xcblxcblxcdFxcdHRoaXMuX3Zpc2libGUgJiYgdGhpcy5fY29yZS5pbnZhbGlkYXRlKCd3aWR0aCcpICYmIHRoaXMuX2NvcmUucmVmcmVzaCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqL1xcblxcdEF1dG9SZWZyZXNoLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9SZWZyZXNoID0gQXV0b1JlZnJlc2g7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIExhenkgUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIHRoZSBsYXp5IHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBMYXp5IFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBMYXp5ID0gZnVuY3Rpb24gTGF6eShjYXJvdXNlbCkge1xcblxcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFscmVhZHkgbG9hZGVkIGl0ZW1zLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge0FycmF5LjxqUXVlcnk+fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fbG9hZGVkID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBFdmVudCBoYW5kbGVycy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsIGNoYW5nZS5vd2wuY2Fyb3VzZWwgcmVzaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0aWYgKCF0aGlzLl9jb3JlLnNldHRpbmdzIHx8ICF0aGlzLl9jb3JlLnNldHRpbmdzLmxhenlMb2FkKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJyB8fCBlLnR5cGUgPT0gJ2luaXRpYWxpemVkJykge1xcblxcdFxcdFxcdFxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIG4gPSBzZXR0aW5ncy5jZW50ZXIgJiYgTWF0aC5jZWlsKHNldHRpbmdzLml0ZW1zIC8gMikgfHwgc2V0dGluZ3MuaXRlbXMsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGkgPSBzZXR0aW5ncy5jZW50ZXIgJiYgbiAqIC0xIHx8IDAsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIHBvc2l0aW9uID0gKGUucHJvcGVydHkgJiYgZS5wcm9wZXJ0eS52YWx1ZSAhPT0gdW5kZWZpbmVkID8gZS5wcm9wZXJ0eS52YWx1ZSA6IHRoaXMuX2NvcmUuY3VycmVudCgpKSArIGksXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGNsb25lcyA9IHRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoLFxcblxcdFxcdFxcdFxcdFxcdCAgICBsb2FkID0gJC5wcm94eShmdW5jdGlvbiAoaSwgdikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubG9hZCh2KTtcXG5cXHRcXHRcXHRcXHRcXHR9LCB0aGlzKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHR3aGlsZSAoaSsrIDwgbikge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMubG9hZChjbG9uZXMgLyAyICsgdGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbikpO1xcblxcdFxcdFxcdFxcdFxcdFxcdGNsb25lcyAmJiAkLmVhY2godGhpcy5fY29yZS5jbG9uZXModGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbikpLCBsb2FkKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwb3NpdGlvbisrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCB0aGUgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIExhenkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlclxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRMYXp5LkRlZmF1bHRzID0ge1xcblxcdFxcdGxhenlMb2FkOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIExvYWRzIGFsbCByZXNvdXJjZXMgb2YgYW4gaXRlbSBhdCB0aGUgc3BlY2lmaWVkIHBvc2l0aW9uLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0uXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0TGF6eS5wcm90b3R5cGUubG9hZCA9IGZ1bmN0aW9uIChwb3NpdGlvbikge1xcblxcdFxcdHZhciAkaXRlbSA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEocG9zaXRpb24pLFxcblxcdFxcdCAgICAkZWxlbWVudHMgPSAkaXRlbSAmJiAkaXRlbS5maW5kKCcub3dsLWxhenknKTtcXG5cXG5cXHRcXHRpZiAoISRlbGVtZW50cyB8fCAkLmluQXJyYXkoJGl0ZW0uZ2V0KDApLCB0aGlzLl9sb2FkZWQpID4gLTEpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdCRlbGVtZW50cy5lYWNoKCQucHJveHkoZnVuY3Rpb24gKGluZGV4LCBlbGVtZW50KSB7XFxuXFx0XFx0XFx0dmFyICRlbGVtZW50ID0gJChlbGVtZW50KSxcXG5cXHRcXHRcXHQgICAgaW1hZ2UsXFxuXFx0XFx0XFx0ICAgIHVybCA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvID4gMSAmJiAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYy1yZXRpbmEnKSB8fCAkZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpO1xcblxcblxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XFxuXFxuXFx0XFx0XFx0aWYgKCRlbGVtZW50LmlzKCdpbWcnKSkge1xcblxcdFxcdFxcdFxcdCRlbGVtZW50Lm9uZSgnbG9hZC5vd2wubGF6eScsICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdCRlbGVtZW50LmNzcygnb3BhY2l0eScsIDEpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignbG9hZGVkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcXG5cXHRcXHRcXHRcXHR9LCB0aGlzKSkuYXR0cignc3JjJywgdXJsKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGltYWdlID0gbmV3IEltYWdlKCk7XFxuXFx0XFx0XFx0XFx0aW1hZ2Uub25sb2FkID0gJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JGVsZW1lbnQuY3NzKHtcXG5cXHRcXHRcXHRcXHRcXHRcXHQnYmFja2dyb3VuZC1pbWFnZSc6ICd1cmwoXFxcIicgKyB1cmwgKyAnXFxcIiknLFxcblxcdFxcdFxcdFxcdFxcdFxcdCdvcGFjaXR5JzogJzEnXFxuXFx0XFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpO1xcblxcdFxcdFxcdFxcdGltYWdlLnNyYyA9IHVybDtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMuX2xvYWRlZC5wdXNoKCRpdGVtLmdldCgwKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRMYXp5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuaGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkxhenkgPSBMYXp5O1xcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvSGVpZ2h0IFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgYXV0byBoZWlnaHQgcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIEF1dG8gSGVpZ2h0IFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBBdXRvSGVpZ2h0ID0gZnVuY3Rpb24gQXV0b0hlaWdodChjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCBldmVudCBoYW5kbGVycy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsIHJlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b0hlaWdodCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2xvYWRlZC5vd2wubGF6eSc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0ICYmIGUuZWxlbWVudC5jbG9zZXN0KCcuJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKS5pbmRleCgpID09PSB0aGlzLl9jb3JlLmN1cnJlbnQoKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMudXBkYXRlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9IZWlnaHQuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZWZhdWx0IG9wdGlvbnMuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0QXV0b0hlaWdodC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvSGVpZ2h0OiBmYWxzZSxcXG5cXHRcXHRhdXRvSGVpZ2h0Q2xhc3M6ICdvd2wtaGVpZ2h0J1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFVwZGF0ZXMgdGhlIHZpZXcuXFxuICAqL1xcblxcdEF1dG9IZWlnaHQucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgc3RhcnQgPSB0aGlzLl9jb3JlLl9jdXJyZW50LFxcblxcdFxcdCAgICBlbmQgPSBzdGFydCArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbXMsXFxuXFx0XFx0ICAgIHZpc2libGUgPSB0aGlzLl9jb3JlLiRzdGFnZS5jaGlsZHJlbigpLnRvQXJyYXkoKS5zbGljZShzdGFydCwgZW5kKSxcXG5cXHRcXHQgICAgaGVpZ2h0cyA9IFtdLFxcblxcdFxcdCAgICBtYXhoZWlnaHQgPSAwO1xcblxcblxcdFxcdCQuZWFjaCh2aXNpYmxlLCBmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRoZWlnaHRzLnB1c2goJChpdGVtKS5oZWlnaHQoKSk7XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0bWF4aGVpZ2h0ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kc3RhZ2UucGFyZW50KCkuaGVpZ2h0KG1heGhlaWdodCkuYWRkQ2xhc3ModGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0Q2xhc3MpO1xcblxcdH07XFxuXFxuXFx0QXV0b0hlaWdodC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkF1dG9IZWlnaHQgPSBBdXRvSGVpZ2h0O1xcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBWaWRlbyBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIHZpZGVvIHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBWaWRlbyBQbHVnaW5cXG4gICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbFxcbiAgKi9cXG5cXHR2YXIgVmlkZW8gPSBmdW5jdGlvbiBWaWRlbyhjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIENhY2hlIGFsbCB2aWRlbyBVUkxzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX3ZpZGVvcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQ3VycmVudCBwbGF5aW5nIGl0ZW0uXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuICAgKiBAdG9kbyBUaGUgY2xvbmVkIGNvbnRlbnQgcmVtb3ZhbGUgaXMgdG9vIGxhdGVcXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUucmVnaXN0ZXIoeyB0eXBlOiAnc3RhdGUnLCBuYW1lOiAncGxheWluZycsIHRhZ3M6IFsnaW50ZXJhY3RpbmcnXSB9KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3Jlc2l6ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW8gJiYgdGhpcy5pc0luRnVsbFNjcmVlbigpKSB7XFxuXFx0XFx0XFx0XFx0XFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5pcygncmVzaXppbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUuJHN0YWdlLmZpbmQoJy5jbG9uZWQgLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJyAmJiB0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0dmFyICRlbGVtZW50ID0gJChlLmNvbnRlbnQpLmZpbmQoJy5vd2wtdmlkZW8nKTtcXG5cXG5cXHRcXHRcXHRcXHRpZiAoJGVsZW1lbnQubGVuZ3RoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JGVsZW1lbnQuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmZldGNoKCRlbGVtZW50LCAkKGUuY29udGVudCkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBWaWRlby5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24oJ2NsaWNrLm93bC52aWRlbycsICcub3dsLXZpZGVvLXBsYXktaWNvbicsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHR0aGlzLnBsYXkoZSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRWaWRlby5EZWZhdWx0cyA9IHtcXG5cXHRcXHR2aWRlbzogZmFsc2UsXFxuXFx0XFx0dmlkZW9IZWlnaHQ6IGZhbHNlLFxcblxcdFxcdHZpZGVvV2lkdGg6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB0aGUgdmlkZW8gSUQgYW5kIHRoZSB0eXBlIChZb3VUdWJlL1ZpbWVvL3Z6YWFyIG9ubHkpLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7alF1ZXJ5fSB0YXJnZXQgLSBUaGUgdGFyZ2V0IGNvbnRhaW5pbmcgdGhlIHZpZGVvIGRhdGEuXFxuICAqIEBwYXJhbSB7alF1ZXJ5fSBpdGVtIC0gVGhlIGl0ZW0gY29udGFpbmluZyB0aGUgdmlkZW8uXFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5mZXRjaCA9IGZ1bmN0aW9uICh0YXJnZXQsIGl0ZW0pIHtcXG5cXHRcXHR2YXIgdHlwZSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGFyZ2V0LmF0dHIoJ2RhdGEtdmltZW8taWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAndmltZW8nO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGFyZ2V0LmF0dHIoJ2RhdGEtdnphYXItaWQnKSkge1xcblxcdFxcdFxcdFxcdHJldHVybiAndnphYXInO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICd5b3V0dWJlJztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSgpLFxcblxcdFxcdCAgICBpZCA9IHRhcmdldC5hdHRyKCdkYXRhLXZpbWVvLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEteW91dHViZS1pZCcpIHx8IHRhcmdldC5hdHRyKCdkYXRhLXZ6YWFyLWlkJyksXFxuXFx0XFx0ICAgIHdpZHRoID0gdGFyZ2V0LmF0dHIoJ2RhdGEtd2lkdGgnKSB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLnZpZGVvV2lkdGgsXFxuXFx0XFx0ICAgIGhlaWdodCA9IHRhcmdldC5hdHRyKCdkYXRhLWhlaWdodCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9IZWlnaHQsXFxuXFx0XFx0ICAgIHVybCA9IHRhcmdldC5hdHRyKCdocmVmJyk7XFxuXFxuXFx0XFx0aWYgKHVybCkge1xcblxcblxcdFxcdFxcdC8qXFxuICAgXFx0XFx0UGFyc2VzIHRoZSBpZCdzIG91dCBvZiB0aGUgZm9sbG93aW5nIHVybHMgKGFuZCBwcm9iYWJseSBtb3JlKTpcXG4gICBcXHRcXHRodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PTppZFxcbiAgIFxcdFxcdGh0dHBzOi8veW91dHUuYmUvOmlkXFxuICAgXFx0XFx0aHR0cHM6Ly92aW1lby5jb20vOmlkXFxuICAgXFx0XFx0aHR0cHM6Ly92aW1lby5jb20vY2hhbm5lbHMvOmNoYW5uZWwvOmlkXFxuICAgXFx0XFx0aHR0cHM6Ly92aW1lby5jb20vZ3JvdXBzLzpncm91cC92aWRlb3MvOmlkXFxuICAgXFx0XFx0aHR0cHM6Ly9hcHAudnphYXIuY29tL3ZpZGVvcy86aWRcXG4gICBcXHRcXHRcXHRWaXN1YWwgZXhhbXBsZTogaHR0cHM6Ly9yZWdleHBlci5jb20vIyhodHRwJTNBJTdDaHR0cHMlM0ElN0MpJTVDJTJGJTVDJTJGKHBsYXllci4lN0N3d3cuJTdDYXBwLiklM0YodmltZW8lNUMuY29tJTdDeW91dHUoYmUlNUMuY29tJTdDJTVDLmJlJTdDYmUlNUMuZ29vZ2xlYXBpcyU1Qy5jb20pJTdDdnphYXIlNUMuY29tKSU1QyUyRih2aWRlbyU1QyUyRiU3Q3ZpZGVvcyU1QyUyRiU3Q2VtYmVkJTVDJTJGJTdDY2hhbm5lbHMlNUMlMkYuJTJCJTVDJTJGJTdDZ3JvdXBzJTVDJTJGLiUyQiU1QyUyRiU3Q3dhdGNoJTVDJTNGdiUzRCU3Q3YlNUMlMkYpJTNGKCU1QkEtWmEtejAtOS5fJTI1LSU1RCopKCU1QyUyNiU1Q1MlMkIpJTNGXFxuICAgKi9cXG5cXG5cXHRcXHRcXHRpZCA9IHVybC5tYXRjaCgvKGh0dHA6fGh0dHBzOnwpXFxcXC9cXFxcLyhwbGF5ZXIufHd3dy58YXBwLik/KHZpbWVvXFxcXC5jb218eW91dHUoYmVcXFxcLmNvbXxcXFxcLmJlfGJlXFxcXC5nb29nbGVhcGlzXFxcXC5jb20pfHZ6YWFyXFxcXC5jb20pXFxcXC8odmlkZW9cXFxcL3x2aWRlb3NcXFxcL3xlbWJlZFxcXFwvfGNoYW5uZWxzXFxcXC8uK1xcXFwvfGdyb3Vwc1xcXFwvLitcXFxcL3x3YXRjaFxcXFw/dj18dlxcXFwvKT8oW0EtWmEtejAtOS5fJS1dKikoXFxcXCZcXFxcUyspPy8pO1xcblxcblxcdFxcdFxcdGlmIChpZFszXS5pbmRleE9mKCd5b3V0dScpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3lvdXR1YmUnO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoaWRbM10uaW5kZXhPZigndmltZW8nKSA+IC0xKSB7XFxuXFx0XFx0XFx0XFx0dHlwZSA9ICd2aW1lbyc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2emFhcicpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3Z6YWFyJztcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignVmlkZW8gVVJMIG5vdCBzdXBwb3J0ZWQuJyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlkID0gaWRbNl07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgdmlkZW8gVVJMLicpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aWRlb3NbdXJsXSA9IHtcXG5cXHRcXHRcXHR0eXBlOiB0eXBlLFxcblxcdFxcdFxcdGlkOiBpZCxcXG5cXHRcXHRcXHR3aWR0aDogd2lkdGgsXFxuXFx0XFx0XFx0aGVpZ2h0OiBoZWlnaHRcXG5cXHRcXHR9O1xcblxcblxcdFxcdGl0ZW0uYXR0cignZGF0YS12aWRlbycsIHVybCk7XFxuXFxuXFx0XFx0dGhpcy50aHVtYm5haWwodGFyZ2V0LCB0aGlzLl92aWRlb3NbdXJsXSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB2aWRlbyB0aHVtYm5haWwuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtqUXVlcnl9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29udGFpbmluZyB0aGUgdmlkZW8gZGF0YS5cXG4gICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUaGUgdmlkZW8gaW5mbyBvYmplY3QuXFxuICAqIEBzZWUgYGZldGNoYFxcbiAgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUudGh1bWJuYWlsID0gZnVuY3Rpb24gKHRhcmdldCwgdmlkZW8pIHtcXG5cXHRcXHR2YXIgdG5MaW5rLFxcblxcdFxcdCAgICBpY29uLFxcblxcdFxcdCAgICBwYXRoLFxcblxcdFxcdCAgICBkaW1lbnNpb25zID0gdmlkZW8ud2lkdGggJiYgdmlkZW8uaGVpZ2h0ID8gJ3N0eWxlPVxcXCJ3aWR0aDonICsgdmlkZW8ud2lkdGggKyAncHg7aGVpZ2h0OicgKyB2aWRlby5oZWlnaHQgKyAncHg7XFxcIicgOiAnJyxcXG5cXHRcXHQgICAgY3VzdG9tVG4gPSB0YXJnZXQuZmluZCgnaW1nJyksXFxuXFx0XFx0ICAgIHNyY1R5cGUgPSAnc3JjJyxcXG5cXHRcXHQgICAgbGF6eUNsYXNzID0gJycsXFxuXFx0XFx0ICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHQgICAgY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKHBhdGgpIHtcXG5cXHRcXHRcXHRpY29uID0gJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby1wbGF5LWljb25cXFwiPjwvZGl2Pic7XFxuXFxuXFx0XFx0XFx0aWYgKHNldHRpbmdzLmxhenlMb2FkKSB7XFxuXFx0XFx0XFx0XFx0dG5MaW5rID0gJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby10biAnICsgbGF6eUNsYXNzICsgJ1xcXCIgJyArIHNyY1R5cGUgKyAnPVxcXCInICsgcGF0aCArICdcXFwiPjwvZGl2Pic7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0bkxpbmsgPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXRuXFxcIiBzdHlsZT1cXFwib3BhY2l0eToxO2JhY2tncm91bmQtaW1hZ2U6dXJsKCcgKyBwYXRoICsgJylcXFwiPjwvZGl2Pic7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRhcmdldC5hZnRlcih0bkxpbmspO1xcblxcdFxcdFxcdHRhcmdldC5hZnRlcihpY29uKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHdyYXAgdmlkZW8gY29udGVudCBpbnRvIG93bC12aWRlby13cmFwcGVyIGRpdlxcblxcdFxcdHRhcmdldC53cmFwKCc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8td3JhcHBlclxcXCInICsgZGltZW5zaW9ucyArICc+PC9kaXY+Jyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQpIHtcXG5cXHRcXHRcXHRzcmNUeXBlID0gJ2RhdGEtc3JjJztcXG5cXHRcXHRcXHRsYXp5Q2xhc3MgPSAnb3dsLWxhenknO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBjdXN0b20gdGh1bWJuYWlsXFxuXFx0XFx0aWYgKGN1c3RvbVRuLmxlbmd0aCkge1xcblxcdFxcdFxcdGNyZWF0ZShjdXN0b21Ubi5hdHRyKHNyY1R5cGUpKTtcXG5cXHRcXHRcXHRjdXN0b21Ubi5yZW1vdmUoKTtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICh2aWRlby50eXBlID09PSAneW91dHViZScpIHtcXG5cXHRcXHRcXHRwYXRoID0gXFxcIi8vaW1nLnlvdXR1YmUuY29tL3ZpL1xcXCIgKyB2aWRlby5pZCArIFxcXCIvaHFkZWZhdWx0LmpwZ1xcXCI7XFxuXFx0XFx0XFx0Y3JlYXRlKHBhdGgpO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3ZpbWVvJykge1xcblxcdFxcdFxcdCQuYWpheCh7XFxuXFx0XFx0XFx0XFx0dHlwZTogJ0dFVCcsXFxuXFx0XFx0XFx0XFx0dXJsOiAnLy92aW1lby5jb20vYXBpL3YyL3ZpZGVvLycgKyB2aWRlby5pZCArICcuanNvbicsXFxuXFx0XFx0XFx0XFx0anNvbnA6ICdjYWxsYmFjaycsXFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGU6ICdqc29ucCcsXFxuXFx0XFx0XFx0XFx0c3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGF0aCA9IGRhdGFbMF0udGh1bWJuYWlsX2xhcmdlO1xcblxcdFxcdFxcdFxcdFxcdGNyZWF0ZShwYXRoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndnphYXInKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3Z6YWFyLmNvbS9hcGkvdmlkZW9zLycgKyB2aWRlby5pZCArICcuanNvbicsXFxuXFx0XFx0XFx0XFx0anNvbnA6ICdjYWxsYmFjaycsXFxuXFx0XFx0XFx0XFx0ZGF0YVR5cGU6ICdqc29ucCcsXFxuXFx0XFx0XFx0XFx0c3VjY2VzczogZnVuY3Rpb24gc3VjY2VzcyhkYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGF0aCA9IGRhdGEuZnJhbWVncmFiX3VybDtcXG5cXHRcXHRcXHRcXHRcXHRjcmVhdGUocGF0aCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTdG9wcyB0aGUgY3VycmVudCB2aWRlby5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3AnLCBudWxsLCAndmlkZW8nKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLmZpbmQoJy5vd2wtdmlkZW8tZnJhbWUnKS5yZW1vdmUoKTtcXG5cXHRcXHR0aGlzLl9wbGF5aW5nLnJlbW92ZUNsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBudWxsO1xcblxcdFxcdHRoaXMuX2NvcmUubGVhdmUoJ3BsYXlpbmcnKTtcXG5cXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3N0b3BwZWQnLCBudWxsLCAndmlkZW8nKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTdGFydHMgdGhlIGN1cnJlbnQgdmlkZW8uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUucGxheSA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciB0YXJnZXQgPSAkKGV2ZW50LnRhcmdldCksXFxuXFx0XFx0ICAgIGl0ZW0gPSB0YXJnZXQuY2xvc2VzdCgnLicgKyB0aGlzLl9jb3JlLnNldHRpbmdzLml0ZW1DbGFzcyksXFxuXFx0XFx0ICAgIHZpZGVvID0gdGhpcy5fdmlkZW9zW2l0ZW0uYXR0cignZGF0YS12aWRlbycpXSxcXG5cXHRcXHQgICAgd2lkdGggPSB2aWRlby53aWR0aCB8fCAnMTAwJScsXFxuXFx0XFx0ICAgIGhlaWdodCA9IHZpZGVvLmhlaWdodCB8fCB0aGlzLl9jb3JlLiRzdGFnZS5oZWlnaHQoKSxcXG5cXHRcXHQgICAgaHRtbDtcXG5cXG5cXHRcXHRpZiAodGhpcy5fcGxheWluZykge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29yZS5lbnRlcigncGxheWluZycpO1xcblxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcigncGxheScsIG51bGwsICd2aWRlbycpO1xcblxcblxcdFxcdGl0ZW0gPSB0aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUoaXRlbS5pbmRleCgpKSk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS5yZXNldChpdGVtLmluZGV4KCkpO1xcblxcblxcdFxcdGlmICh2aWRlby50eXBlID09PSAneW91dHViZScpIHtcXG5cXHRcXHRcXHRodG1sID0gJzxpZnJhbWUgd2lkdGg9XFxcIicgKyB3aWR0aCArICdcXFwiIGhlaWdodD1cXFwiJyArIGhlaWdodCArICdcXFwiIHNyYz1cXFwiLy93d3cueW91dHViZS5jb20vZW1iZWQvJyArIHZpZGVvLmlkICsgJz9hdXRvcGxheT0xJnJlbD0wJnY9JyArIHZpZGVvLmlkICsgJ1xcXCIgZnJhbWVib3JkZXI9XFxcIjBcXFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3ZpbWVvJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSBzcmM9XFxcIi8vcGxheWVyLnZpbWVvLmNvbS92aWRlby8nICsgdmlkZW8uaWQgKyAnP2F1dG9wbGF5PTFcXFwiIHdpZHRoPVxcXCInICsgd2lkdGggKyAnXFxcIiBoZWlnaHQ9XFxcIicgKyBoZWlnaHQgKyAnXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgd2Via2l0YWxsb3dmdWxsc2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JztcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2emFhcicpIHtcXG5cXHRcXHRcXHRodG1sID0gJzxpZnJhbWUgZnJhbWVib3JkZXI9XFxcIjBcXFwiJyArICdoZWlnaHQ9XFxcIicgKyBoZWlnaHQgKyAnXFxcIicgKyAnd2lkdGg9XFxcIicgKyB3aWR0aCArICdcXFwiIGFsbG93ZnVsbHNjcmVlbiBtb3phbGxvd2Z1bGxzY3JlZW4gd2Via2l0QWxsb3dGdWxsU2NyZWVuICcgKyAnc3JjPVxcXCIvL3ZpZXcudnphYXIuY29tLycgKyB2aWRlby5pZCArICcvcGxheWVyP2F1dG9wbGF5PXRydWVcXFwiPjwvaWZyYW1lPic7XFxuXFx0XFx0fVxcblxcblxcdFxcdCQoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby1mcmFtZVxcXCI+JyArIGh0bWwgKyAnPC9kaXY+JykuaW5zZXJ0QWZ0ZXIoaXRlbS5maW5kKCcub3dsLXZpZGVvJykpO1xcblxcblxcdFxcdHRoaXMuX3BsYXlpbmcgPSBpdGVtLmFkZENsYXNzKCdvd2wtdmlkZW8tcGxheWluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIENoZWNrcyB3aGV0aGVyIGFuIHZpZGVvIGlzIGN1cnJlbnRseSBpbiBmdWxsIHNjcmVlbiBtb2RlIG9yIG5vdC5cXG4gICogQHRvZG8gQmFkIHN0eWxlIGJlY2F1c2UgbG9va3MgbGlrZSBhIHJlYWRvbmx5IG1ldGhvZCBidXQgY2hhbmdlcyBtZW1iZXJzLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuaXNJbkZ1bGxTY3JlZW4gPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGVsZW1lbnQgPSBkb2N1bWVudC5mdWxsc2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudCB8fCBkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudDtcXG5cXG5cXHRcXHRyZXR1cm4gZWxlbWVudCAmJiAkKGVsZW1lbnQpLnBhcmVudCgpLmhhc0NsYXNzKCdvd2wtdmlkZW8tZnJhbWUnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgKi9cXG5cXHRWaWRlby5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoJ2NsaWNrLm93bC52aWRlbycpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5WaWRlbyA9IFZpZGVvO1xcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBbmltYXRlIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgYW5pbWF0ZSBwbHVnaW4uXFxuICAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cXG4gICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxcbiAgKi9cXG5cXHR2YXIgQW5pbWF0ZSA9IGZ1bmN0aW9uIEFuaW1hdGUoc2NvcGUpIHtcXG5cXHRcXHR0aGlzLmNvcmUgPSBzY29wZTtcXG5cXHRcXHR0aGlzLmNvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBbmltYXRlLkRlZmF1bHRzLCB0aGlzLmNvcmUub3B0aW9ucyk7XFxuXFx0XFx0dGhpcy5zd2FwcGluZyA9IHRydWU7XFxuXFx0XFx0dGhpcy5wcmV2aW91cyA9IHVuZGVmaW5lZDtcXG5cXHRcXHR0aGlzLm5leHQgPSB1bmRlZmluZWQ7XFxuXFxuXFx0XFx0dGhpcy5oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnByZXZpb3VzID0gdGhpcy5jb3JlLmN1cnJlbnQoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLm5leHQgPSBlLnByb3BlcnR5LnZhbHVlO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnZHJhZy5vd2wuY2Fyb3VzZWwgZHJhZ2dlZC5vd2wuY2Fyb3VzZWwgdHJhbnNsYXRlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zd2FwcGluZyA9IGUudHlwZSA9PSAndHJhbnNsYXRlZCc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0cmFuc2xhdGUub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLnN3YXBwaW5nICYmICh0aGlzLmNvcmUub3B0aW9ucy5hbmltYXRlT3V0IHx8IHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVJbikpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN3YXAoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdHRoaXMuY29yZS4kZWxlbWVudC5vbih0aGlzLmhhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZWZhdWx0IG9wdGlvbnMuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0QW5pbWF0ZS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhbmltYXRlT3V0OiBmYWxzZSxcXG5cXHRcXHRhbmltYXRlSW46IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVG9nZ2xlcyB0aGUgYW5pbWF0aW9uIGNsYXNzZXMgd2hlbmV2ZXIgYW4gdHJhbnNsYXRpb25zIHN0YXJ0cy5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcmV0dXJucyB7Qm9vbGVhbnx1bmRlZmluZWR9XFxuICAqL1xcblxcdEFuaW1hdGUucHJvdG90eXBlLnN3YXAgPSBmdW5jdGlvbiAoKSB7XFxuXFxuXFx0XFx0aWYgKHRoaXMuY29yZS5zZXR0aW5ncy5pdGVtcyAhPT0gMSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCEkLnN1cHBvcnQuYW5pbWF0aW9uIHx8ICEkLnN1cHBvcnQudHJhbnNpdGlvbikge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5jb3JlLnNwZWVkKDApO1xcblxcblxcdFxcdHZhciBsZWZ0LFxcblxcdFxcdCAgICBjbGVhciA9ICQucHJveHkodGhpcy5jbGVhciwgdGhpcyksXFxuXFx0XFx0ICAgIHByZXZpb3VzID0gdGhpcy5jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMucHJldmlvdXMpLFxcblxcdFxcdCAgICBuZXh0ID0gdGhpcy5jb3JlLiRzdGFnZS5jaGlsZHJlbigpLmVxKHRoaXMubmV4dCksXFxuXFx0XFx0ICAgIGluY29taW5nID0gdGhpcy5jb3JlLnNldHRpbmdzLmFuaW1hdGVJbixcXG5cXHRcXHQgICAgb3V0Z29pbmcgPSB0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZU91dDtcXG5cXG5cXHRcXHRpZiAodGhpcy5jb3JlLmN1cnJlbnQoKSA9PT0gdGhpcy5wcmV2aW91cykge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKG91dGdvaW5nKSB7XFxuXFx0XFx0XFx0bGVmdCA9IHRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLnByZXZpb3VzKSAtIHRoaXMuY29yZS5jb29yZGluYXRlcyh0aGlzLm5leHQpO1xcblxcdFxcdFxcdHByZXZpb3VzLm9uZSgkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCwgY2xlYXIpLmNzcyh7ICdsZWZ0JzogbGVmdCArICdweCcgfSkuYWRkQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1vdXQnKS5hZGRDbGFzcyhvdXRnb2luZyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChpbmNvbWluZykge1xcblxcdFxcdFxcdG5leHQub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcikuYWRkQ2xhc3MoJ2FuaW1hdGVkIG93bC1hbmltYXRlZC1pbicpLmFkZENsYXNzKGluY29taW5nKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0JChlLnRhcmdldCkuY3NzKHsgJ2xlZnQnOiAnJyB9KS5yZW1vdmVDbGFzcygnYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLW91dCBvd2wtYW5pbWF0ZWQtaW4nKS5yZW1vdmVDbGFzcyh0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZUluKS5yZW1vdmVDbGFzcyh0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZU91dCk7XFxuXFx0XFx0dGhpcy5jb3JlLm9uVHJhbnNpdGlvbkVuZCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuaGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLmNvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuaGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLkFuaW1hdGUgPSBBbmltYXRlO1xcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBBdXRvcGxheSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIGF1dG9wbGF5IHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBBdXRvcGxheSBQbHVnaW5cXG4gICogQHBhcmFtIHtPd2x9IHNjb3BlIC0gVGhlIE93bCBDYXJvdXNlbFxcbiAgKi9cXG5cXHR2YXIgQXV0b3BsYXkgPSBmdW5jdGlvbiBBdXRvcGxheShjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFRoZSBhdXRvcGxheSB0aW1lb3V0LlxcbiAgICogQHR5cGUge1RpbWVvdXR9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl90aW1lb3V0ID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyB3aGVuZXZlciB0aGUgYXV0b3BsYXkgaXMgcGF1c2VkLlxcbiAgICogQHR5cGUge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCBldmVudCBoYW5kbGVycy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3NldHRpbmdzJykge1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHQvL2NvbnNvbGUubG9nKCdwbGF5PycsIGUpO1xcblxcdFxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5fc2V0QXV0b1BsYXlJbnRlcnZhbCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGxheSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncGxheS5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uIChlLCB0LCBzKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KHQsIHMpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnc3RvcC5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5zdG9wKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdtb3VzZW92ZXIub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBhdXNlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdtb3VzZWxlYXZlLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSAmJiB0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0b3VjaHN0YXJ0Lm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBhdXNlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCd0b3VjaGVuZC5vd2wuY29yZSc6ICQucHJveHkoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdGlmICh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5SG92ZXJQYXVzZSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGxheSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEF1dG9wbGF5LkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBdXRvcGxheS5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvcGxheTogZmFsc2UsXFxuXFx0XFx0YXV0b3BsYXlUaW1lb3V0OiA1MDAwLFxcblxcdFxcdGF1dG9wbGF5SG92ZXJQYXVzZTogZmFsc2UsXFxuXFx0XFx0YXV0b3BsYXlTcGVlZDogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTdGFydHMgdGhlIGF1dG9wbGF5LlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXFxuICAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKHRpbWVvdXQsIHNwZWVkKSB7XFxuXFx0XFx0dGhpcy5fcGF1c2VkID0gZmFsc2U7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvcmUuZW50ZXIoJ3JvdGF0aW5nJyk7XFxuXFxuXFx0XFx0dGhpcy5fc2V0QXV0b1BsYXlJbnRlcnZhbCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgYSBuZXcgdGltZW91dFxcbiAgKiBAcHJpdmF0ZVxcbiAgKiBAcGFyYW0ge051bWJlcn0gW3RpbWVvdXRdIC0gVGhlIGludGVydmFsIGJlZm9yZSB0aGUgbmV4dCBhbmltYXRpb24gc3RhcnRzLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkXSAtIFRoZSBhbmltYXRpb24gc3BlZWQgZm9yIHRoZSBhbmltYXRpb25zLlxcbiAgKiBAcmV0dXJuIHtUaW1lb3V0fVxcbiAgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuX2dldE5leHRUaW1lb3V0ID0gZnVuY3Rpb24gKHRpbWVvdXQsIHNwZWVkKSB7XFxuXFx0XFx0aWYgKHRoaXMuX3RpbWVvdXQpIHtcXG5cXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3BhdXNlZCB8fCB0aGlzLl9jb3JlLmlzKCdidXN5JykgfHwgdGhpcy5fY29yZS5pcygnaW50ZXJhY3RpbmcnKSB8fCBkb2N1bWVudC5oaWRkZW4pIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHRoaXMuX2NvcmUubmV4dChzcGVlZCB8fCB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5U3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpLCB0aW1lb3V0IHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlUaW1lb3V0KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTZXRzIGF1dG9wbGF5IGluIG1vdGlvbi5cXG4gICogQHByaXZhdGVcXG4gICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLl9zZXRBdXRvUGxheUludGVydmFsID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSB0aGlzLl9nZXROZXh0VGltZW91dCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFN0b3BzIHRoZSBhdXRvcGxheS5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAoIXRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XFxuXFx0XFx0dGhpcy5fY29yZS5sZWF2ZSgncm90YXRpbmcnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTdG9wcyB0aGUgYXV0b3BsYXkuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fcGF1c2VkID0gdHJ1ZTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0dGhpcy5zdG9wKCk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLmF1dG9wbGF5ID0gQXV0b3BsYXk7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIE5hdmlnYXRpb24gUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIG5hdmlnYXRpb24gcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIE5hdmlnYXRpb24gUGx1Z2luXFxuICAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWwuXFxuICAqL1xcblxcblxcdHZhciBOYXZpZ2F0aW9uID0gZnVuY3Rpb24gTmF2aWdhdGlvbihjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEluZGljYXRlcyB3aGV0aGVyIHRoZSBwbHVnaW4gaXMgaW5pdGlhbGl6ZWQgb3Igbm90LlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9pbml0aWFsaXplZCA9IGZhbHNlO1xcblxcblxcdFxcdC8qKlxcbiAgICogVGhlIGN1cnJlbnQgcGFnaW5nIGluZGV4ZXMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7QXJyYXl9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9wYWdlcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIERPTSBlbGVtZW50cyBvZiB0aGUgdXNlciBpbnRlcmZhY2UuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29udHJvbHMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE1hcmt1cCBmb3IgYW4gaW5kaWNhdG9yLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge0FycmF5LjxTdHJpbmc+fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fdGVtcGxhdGVzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBUaGUgY2Fyb3VzZWwgZWxlbWVudC5cXG4gICAqIEB0eXBlIHtqUXVlcnl9XFxuICAgKi9cXG5cXHRcXHR0aGlzLiRlbGVtZW50ID0gdGhpcy5fY29yZS4kZWxlbWVudDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIE92ZXJyaWRkZW4gbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWwuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fb3ZlcnJpZGVzID0ge1xcblxcdFxcdFxcdG5leHQ6IHRoaXMuX2NvcmUubmV4dCxcXG5cXHRcXHRcXHRwcmV2OiB0aGlzLl9jb3JlLnByZXYsXFxuXFx0XFx0XFx0dG86IHRoaXMuX2NvcmUudG9cXG5cXHRcXHR9O1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdwcmVwYXJlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90c0RhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl90ZW1wbGF0ZXMucHVzaCgnPGRpdiBjbGFzcz1cXFwiJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90Q2xhc3MgKyAnXFxcIj4nICsgJChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWRvdF0nKS5hZGRCYWNrKCdbZGF0YS1kb3RdJykuYXR0cignZGF0YS1kb3QnKSArICc8L2Rpdj4nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2FkZGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMCwgdGhpcy5fdGVtcGxhdGVzLnBvcCgpKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlbW92ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3MuZG90c0RhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl90ZW1wbGF0ZXMuc3BsaWNlKGUucG9zaXRpb24sIDEpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnY2hhbmdlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5kcmF3KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmICF0aGlzLl9pbml0aWFsaXplZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignaW5pdGlhbGl6ZScsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5pbml0aWFsaXplKCk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXcoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9pbml0aWFsaXplZCA9IHRydWU7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9pbml0aWFsaXplZCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcigncmVmcmVzaCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXcoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ3JlZnJlc2hlZCcsIG51bGwsICduYXZpZ2F0aW9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIE5hdmlnYXRpb24uRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZWZhdWx0IG9wdGlvbnMuXFxuICAqIEBwdWJsaWNcXG4gICogQHRvZG8gUmVuYW1lIGBzbGlkZUJ5YCB0byBgbmF2QnlgXFxuICAqL1xcblxcdE5hdmlnYXRpb24uRGVmYXVsdHMgPSB7XFxuXFx0XFx0bmF2OiBmYWxzZSxcXG5cXHRcXHRuYXZUZXh0OiBbJ3ByZXYnLCAnbmV4dCddLFxcblxcdFxcdG5hdlNwZWVkOiBmYWxzZSxcXG5cXHRcXHRuYXZFbGVtZW50OiAnZGl2JyxcXG5cXHRcXHRuYXZDb250YWluZXI6IGZhbHNlLFxcblxcdFxcdG5hdkNvbnRhaW5lckNsYXNzOiAnb3dsLW5hdicsXFxuXFx0XFx0bmF2Q2xhc3M6IFsnb3dsLXByZXYnLCAnb3dsLW5leHQnXSxcXG5cXHRcXHRzbGlkZUJ5OiAxLFxcblxcdFxcdGRvdENsYXNzOiAnb3dsLWRvdCcsXFxuXFx0XFx0ZG90c0NsYXNzOiAnb3dsLWRvdHMnLFxcblxcdFxcdGRvdHM6IHRydWUsXFxuXFx0XFx0ZG90c0VhY2g6IGZhbHNlLFxcblxcdFxcdGRvdHNEYXRhOiBmYWxzZSxcXG5cXHRcXHRkb3RzU3BlZWQ6IGZhbHNlLFxcblxcdFxcdGRvdHNDb250YWluZXI6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogSW5pdGlhbGl6ZXMgdGhlIGxheW91dCBvZiB0aGUgcGx1Z2luIGFuZCBleHRlbmRzIHRoZSBjYXJvdXNlbC5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBvdmVycmlkZSxcXG5cXHRcXHQgICAgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzO1xcblxcblxcdFxcdC8vIGNyZWF0ZSBET00gc3RydWN0dXJlIGZvciByZWxhdGl2ZSBuYXZpZ2F0aW9uXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlID0gKHNldHRpbmdzLm5hdkNvbnRhaW5lciA/ICQoc2V0dGluZ3MubmF2Q29udGFpbmVyKSA6ICQoJzxkaXY+JykuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q29udGFpbmVyQ2xhc3MpLmFwcGVuZFRvKHRoaXMuJGVsZW1lbnQpKS5hZGRDbGFzcygnZGlzYWJsZWQnKTtcXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kcHJldmlvdXMgPSAkKCc8JyArIHNldHRpbmdzLm5hdkVsZW1lbnQgKyAnPicpLmFkZENsYXNzKHNldHRpbmdzLm5hdkNsYXNzWzBdKS5odG1sKHNldHRpbmdzLm5hdlRleHRbMF0pLnByZXBlbmRUbyh0aGlzLl9jb250cm9scy4kcmVsYXRpdmUpLm9uKCdjbGljaycsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHR0aGlzLnByZXYoc2V0dGluZ3MubmF2U3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHRcXHR0aGlzLl9jb250cm9scy4kbmV4dCA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JykuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMV0pLmh0bWwoc2V0dGluZ3MubmF2VGV4dFsxXSkuYXBwZW5kVG8odGhpcy5fY29udHJvbHMuJHJlbGF0aXZlKS5vbignY2xpY2snLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0dGhpcy5uZXh0KHNldHRpbmdzLm5hdlNwZWVkKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIGFic29sdXRlIG5hdmlnYXRpb25cXG5cXHRcXHRpZiAoIXNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzID0gWyQoJzxkaXY+JykuYWRkQ2xhc3Moc2V0dGluZ3MuZG90Q2xhc3MpLmFwcGVuZCgkKCc8c3Bhbj4nKSkucHJvcCgnb3V0ZXJIVE1MJyldO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUgPSAoc2V0dGluZ3MuZG90c0NvbnRhaW5lciA/ICQoc2V0dGluZ3MuZG90c0NvbnRhaW5lcikgOiAkKCc8ZGl2PicpLmFkZENsYXNzKHNldHRpbmdzLmRvdHNDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5vbignY2xpY2snLCAnZGl2JywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdHZhciBpbmRleCA9ICQoZS50YXJnZXQpLnBhcmVudCgpLmlzKHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSkgPyAkKGUudGFyZ2V0KS5pbmRleCgpIDogJChlLnRhcmdldCkucGFyZW50KCkuaW5kZXgoKTtcXG5cXG5cXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFxuXFx0XFx0XFx0dGhpcy50byhpbmRleCwgc2V0dGluZ3MuZG90c1NwZWVkKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0Ly8gb3ZlcnJpZGUgcHVibGljIG1ldGhvZHMgb2YgdGhlIGNhcm91c2VsXFxuXFx0XFx0Zm9yIChvdmVycmlkZSBpbiB0aGlzLl9vdmVycmlkZXMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlW292ZXJyaWRlXSA9ICQucHJveHkodGhpc1tvdmVycmlkZV0sIHRoaXMpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIGNvbnRyb2wsIHByb3BlcnR5LCBvdmVycmlkZTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAoY29udHJvbCBpbiB0aGlzLl9jb250cm9scykge1xcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzW2NvbnRyb2xdLnJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKG92ZXJyaWRlIGluIHRoaXMub3ZlcmlkZXMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlW292ZXJyaWRlXSA9IHRoaXMuX292ZXJyaWRlc1tvdmVycmlkZV07XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgc3RhdGUuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBpLFxcblxcdFxcdCAgICBqLFxcblxcdFxcdCAgICBrLFxcblxcdFxcdCAgICBsb3dlciA9IHRoaXMuX2NvcmUuY2xvbmVzKCkubGVuZ3RoIC8gMixcXG5cXHRcXHQgICAgdXBwZXIgPSBsb3dlciArIHRoaXMuX2NvcmUuaXRlbXMoKS5sZW5ndGgsXFxuXFx0XFx0ICAgIG1heGltdW0gPSB0aGlzLl9jb3JlLm1heGltdW0odHJ1ZSksXFxuXFx0XFx0ICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHQgICAgc2l6ZSA9IHNldHRpbmdzLmNlbnRlciB8fCBzZXR0aW5ncy5hdXRvV2lkdGggfHwgc2V0dGluZ3MuZG90c0RhdGEgPyAxIDogc2V0dGluZ3MuZG90c0VhY2ggfHwgc2V0dGluZ3MuaXRlbXM7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgIT09ICdwYWdlJykge1xcblxcdFxcdFxcdHNldHRpbmdzLnNsaWRlQnkgPSBNYXRoLm1pbihzZXR0aW5ncy5zbGlkZUJ5LCBzZXR0aW5ncy5pdGVtcyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChzZXR0aW5ncy5kb3RzIHx8IHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGFnZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHRmb3IgKGkgPSBsb3dlciwgaiA9IDAsIGsgPSAwOyBpIDwgdXBwZXI7IGkrKykge1xcblxcdFxcdFxcdFxcdGlmIChqID49IHNpemUgfHwgaiA9PT0gMCkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3BhZ2VzLnB1c2goe1xcblxcdFxcdFxcdFxcdFxcdFxcdHN0YXJ0OiBNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGVuZDogaSAtIGxvd2VyICsgc2l6ZSAtIDFcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoTWF0aC5taW4obWF4aW11bSwgaSAtIGxvd2VyKSA9PT0gbWF4aW11bSkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGJyZWFrO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRqID0gMCwgKytrO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRqICs9IHRoaXMuX2NvcmUubWVyZ2Vycyh0aGlzLl9jb3JlLnJlbGF0aXZlKGkpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERyYXdzIHRoZSB1c2VyIGludGVyZmFjZS5cXG4gICogQHRvZG8gVGhlIG9wdGlvbiBgZG90c0RhdGFgIHdvbnQgd29yay5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBkaWZmZXJlbmNlLFxcblxcdFxcdCAgICBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3MsXFxuXFx0XFx0ICAgIGRpc2FibGVkID0gdGhpcy5fY29yZS5pdGVtcygpLmxlbmd0aCA8PSBzZXR0aW5ncy5pdGVtcyxcXG5cXHRcXHQgICAgaW5kZXggPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKSxcXG5cXHRcXHQgICAgbG9vcCA9IHNldHRpbmdzLmxvb3AgfHwgc2V0dGluZ3MucmV3aW5kO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZS50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhc2V0dGluZ3MubmF2IHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MubmF2KSB7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJHByZXZpb3VzLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFsb29wICYmIGluZGV4IDw9IHRoaXMuX2NvcmUubWluaW11bSh0cnVlKSk7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJG5leHQudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPj0gdGhpcy5fY29yZS5tYXhpbXVtKHRydWUpKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5kb3RzIHx8IGRpc2FibGVkKTtcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3MuZG90cykge1xcblxcdFxcdFxcdGRpZmZlcmVuY2UgPSB0aGlzLl9wYWdlcy5sZW5ndGggLSB0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5sZW5ndGg7XFxuXFxuXFx0XFx0XFx0aWYgKHNldHRpbmdzLmRvdHNEYXRhICYmIGRpZmZlcmVuY2UgIT09IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuaHRtbCh0aGlzLl90ZW1wbGF0ZXMuam9pbignJykpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuYXBwZW5kKG5ldyBBcnJheShkaWZmZXJlbmNlICsgMSkuam9pbih0aGlzLl90ZW1wbGF0ZXNbMF0pKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGRpZmZlcmVuY2UgPCAwKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuc2xpY2UoZGlmZmVyZW5jZSkucmVtb3ZlKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5maW5kKCcuYWN0aXZlJykucmVtb3ZlQ2xhc3MoJ2FjdGl2ZScpO1xcblxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmVxKCQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpKS5hZGRDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEV4dGVuZHMgZXZlbnQgZGF0YS5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBvYmplY3Qgd2hpY2ggZ2V0cyB0aHJvd24uXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLm9uVHJpZ2dlciA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0ZXZlbnQucGFnZSA9IHtcXG5cXHRcXHRcXHRpbmRleDogJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcyksXFxuXFx0XFx0XFx0Y291bnQ6IHRoaXMuX3BhZ2VzLmxlbmd0aCxcXG5cXHRcXHRcXHRzaXplOiBzZXR0aW5ncyAmJiAoc2V0dGluZ3MuY2VudGVyIHx8IHNldHRpbmdzLmF1dG9XaWR0aCB8fCBzZXR0aW5ncy5kb3RzRGF0YSA/IDEgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcylcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIGN1cnJlbnQgcGFnZSBwb3NpdGlvbiBvZiB0aGUgY2Fyb3VzZWwuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHJldHVybnMge051bWJlcn1cXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuY3VycmVudCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgY3VycmVudCA9IHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpO1xcblxcdFxcdHJldHVybiAkLmdyZXAodGhpcy5fcGFnZXMsICQucHJveHkoZnVuY3Rpb24gKHBhZ2UsIGluZGV4KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHBhZ2Uuc3RhcnQgPD0gY3VycmVudCAmJiBwYWdlLmVuZCA+PSBjdXJyZW50O1xcblxcdFxcdH0sIHRoaXMpKS5wb3AoKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSBjdXJyZW50IHN1Y2Nlc29yL3ByZWRlY2Vzc29yIHBvc2l0aW9uLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9XFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmdldFBvc2l0aW9uID0gZnVuY3Rpb24gKHN1Y2Nlc3Nvcikge1xcblxcdFxcdHZhciBwb3NpdGlvbixcXG5cXHRcXHQgICAgbGVuZ3RoLFxcblxcdFxcdCAgICBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLnNsaWRlQnkgPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XFxuXFx0XFx0XFx0c3VjY2Vzc29yID8gKytwb3NpdGlvbiA6IC0tcG9zaXRpb247XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9wYWdlc1socG9zaXRpb24gJSBsZW5ndGggKyBsZW5ndGgpICUgbGVuZ3RoXS5zdGFydDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSk7XFxuXFx0XFx0XFx0bGVuZ3RoID0gdGhpcy5fY29yZS5pdGVtcygpLmxlbmd0aDtcXG5cXHRcXHRcXHRzdWNjZXNzb3IgPyBwb3NpdGlvbiArPSBzZXR0aW5ncy5zbGlkZUJ5IDogcG9zaXRpb24gLT0gc2V0dGluZ3Muc2xpZGVCeTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHBvc2l0aW9uO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNsaWRlcyB0byB0aGUgbmV4dCBpdGVtIG9yIHBhZ2UuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZD1mYWxzZV0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcbiAgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5uZXh0ID0gZnVuY3Rpb24gKHNwZWVkKSB7XFxuXFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTbGlkZXMgdG8gdGhlIHByZXZpb3VzIGl0ZW0gb3IgcGFnZS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLnByZXYgPSBmdW5jdGlvbiAoc3BlZWQpIHtcXG5cXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbihmYWxzZSksIHNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTbGlkZXMgdG8gdGhlIHNwZWNpZmllZCBpdGVtIG9yIHBhZ2UuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIG9yIHBhZ2UuXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG4gICogQHBhcmFtIHtCb29sZWFufSBbc3RhbmRhcmQ9ZmFsc2VdIC0gV2hldGhlciB0byB1c2UgdGhlIHN0YW5kYXJkIGJlaGF2aW91ciBvciBub3QuXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBzcGVlZCwgc3RhbmRhcmQpIHtcXG5cXHRcXHR2YXIgbGVuZ3RoO1xcblxcblxcdFxcdGlmICghc3RhbmRhcmQgJiYgdGhpcy5fcGFnZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0bGVuZ3RoID0gdGhpcy5fcGFnZXMubGVuZ3RoO1xcblxcdFxcdFxcdCQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKSh0aGlzLl9wYWdlc1socG9zaXRpb24gJSBsZW5ndGggKyBsZW5ndGgpICUgbGVuZ3RoXS5zdGFydCwgc3BlZWQpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHBvc2l0aW9uLCBzcGVlZCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLk5hdmlnYXRpb24gPSBOYXZpZ2F0aW9uO1xcbn0pKHdpbmRvdy5aZXB0byB8fCB3aW5kb3cualF1ZXJ5LCB3aW5kb3csIGRvY3VtZW50KTtcXG5cXG4vKipcXG4gKiBIYXNoIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBBcnR1cyBLb2xhbm93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFx0J3VzZSBzdHJpY3QnO1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIHRoZSBoYXNoIHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBIYXNoIFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcblxcdHZhciBIYXNoID0gZnVuY3Rpb24gSGFzaChjYXJvdXNlbCkge1xcblxcdFxcdC8qKlxcbiAgICogUmVmZXJlbmNlIHRvIHRoZSBjb3JlLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge093bH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2NvcmUgPSBjYXJvdXNlbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEhhc2ggaW5kZXggZm9yIHRoZSBpdGVtcy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYXNoZXMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcbiAgICogQHR5cGUge2pRdWVyeX1cXG4gICAqL1xcblxcdFxcdHRoaXMuJGVsZW1lbnQgPSB0aGlzLl9jb3JlLiRlbGVtZW50O1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2NvcmUuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA9PT0gJ1VSTEhhc2gnKSB7XFxuXFx0XFx0XFx0XFx0XFx0JCh3aW5kb3cpLnRyaWdnZXIoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgaGFzaCA9ICQoZS5jb250ZW50KS5maW5kKCdbZGF0YS1oYXNoXScpLmFkZEJhY2soJ1tkYXRhLWhhc2hdJykuYXR0cignZGF0YS1oYXNoJyk7XFxuXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCFoYXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9oYXNoZXNbaGFzaF0gPSBlLmNvbnRlbnQ7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb3JlLml0ZW1zKHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpKSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaGFzaCA9ICQubWFwKHRoaXMuX2hhc2hlcywgZnVuY3Rpb24gKGl0ZW0sIGhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm4gaXRlbSA9PT0gY3VycmVudCA/IGhhc2ggOiBudWxsO1xcblxcdFxcdFxcdFxcdFxcdH0pLmpvaW4oKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWhhc2ggfHwgd2luZG93LmxvY2F0aW9uLmhhc2guc2xpY2UoMSkgPT09IGhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gaGFzaDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgSGFzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciB0aGUgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLiRlbGVtZW50Lm9uKHRoaXMuX2hhbmRsZXJzKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBsaXN0ZW5lciBmb3IgaGFzaCBuYXZpZ2F0aW9uXFxuXFx0XFx0JCh3aW5kb3cpLm9uKCdoYXNoY2hhbmdlLm93bC5uYXZpZ2F0aW9uJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdHZhciBoYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpLFxcblxcdFxcdFxcdCAgICBpdGVtcyA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCksXFxuXFx0XFx0XFx0ICAgIHBvc2l0aW9uID0gdGhpcy5faGFzaGVzW2hhc2hdICYmIGl0ZW1zLmluZGV4KHRoaXMuX2hhc2hlc1toYXNoXSk7XFxuXFxuXFx0XFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQgfHwgcG9zaXRpb24gPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl9jb3JlLnRvKHRoaXMuX2NvcmUucmVsYXRpdmUocG9zaXRpb24pLCBmYWxzZSwgdHJ1ZSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRIYXNoLkRlZmF1bHRzID0ge1xcblxcdFxcdFVSTGhhc2hMaXN0ZW5lcjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdEhhc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdCQod2luZG93KS5vZmYoJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuSGFzaCA9IEhhc2g7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIFN1cHBvcnQgUGx1Z2luXFxuICpcXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgVml2aWQgUGxhbmV0IFNvZnR3YXJlIEdtYkhcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHR2YXIgc3R5bGUgPSAkKCc8c3VwcG9ydD4nKS5nZXQoMCkuc3R5bGUsXFxuXFx0ICAgIHByZWZpeGVzID0gJ1dlYmtpdCBNb3ogTyBtcycuc3BsaXQoJyAnKSxcXG5cXHQgICAgZXZlbnRzID0ge1xcblxcdFxcdHRyYW5zaXRpb246IHtcXG5cXHRcXHRcXHRlbmQ6IHtcXG5cXHRcXHRcXHRcXHRXZWJraXRUcmFuc2l0aW9uOiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0TW96VHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnLFxcblxcdFxcdFxcdFxcdE9UcmFuc2l0aW9uOiAnb1RyYW5zaXRpb25FbmQnLFxcblxcdFxcdFxcdFxcdHRyYW5zaXRpb246ICd0cmFuc2l0aW9uZW5kJ1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGFuaW1hdGlvbjoge1xcblxcdFxcdFxcdGVuZDoge1xcblxcdFxcdFxcdFxcdFdlYmtpdEFuaW1hdGlvbjogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0TW96QW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJyxcXG5cXHRcXHRcXHRcXHRPQW5pbWF0aW9uOiAnb0FuaW1hdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0YW5pbWF0aW9uOiAnYW5pbWF0aW9uZW5kJ1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fSxcXG5cXHQgICAgdGVzdHMgPSB7XFxuXFx0XFx0Y3NzdHJhbnNmb3JtczogZnVuY3Rpb24gY3NzdHJhbnNmb3JtcygpIHtcXG5cXHRcXHRcXHRyZXR1cm4gISF0ZXN0KCd0cmFuc2Zvcm0nKTtcXG5cXHRcXHR9LFxcblxcdFxcdGNzc3RyYW5zZm9ybXMzZDogZnVuY3Rpb24gY3NzdHJhbnNmb3JtczNkKCkge1xcblxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3BlcnNwZWN0aXZlJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHRjc3N0cmFuc2l0aW9uczogZnVuY3Rpb24gY3NzdHJhbnNpdGlvbnMoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhdGVzdCgndHJhbnNpdGlvbicpO1xcblxcdFxcdH0sXFxuXFx0XFx0Y3NzYW5pbWF0aW9uczogZnVuY3Rpb24gY3NzYW5pbWF0aW9ucygpIHtcXG5cXHRcXHRcXHRyZXR1cm4gISF0ZXN0KCdhbmltYXRpb24nKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiB0ZXN0KHByb3BlcnR5LCBwcmVmaXhlZCkge1xcblxcdFxcdHZhciByZXN1bHQgPSBmYWxzZSxcXG5cXHRcXHQgICAgdXBwZXIgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xcblxcblxcdFxcdCQuZWFjaCgocHJvcGVydHkgKyAnICcgKyBwcmVmaXhlcy5qb2luKHVwcGVyICsgJyAnKSArIHVwcGVyKS5zcGxpdCgnICcpLCBmdW5jdGlvbiAoaSwgcHJvcGVydHkpIHtcXG5cXHRcXHRcXHRpZiAoc3R5bGVbcHJvcGVydHldICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHRyZXN1bHQgPSBwcmVmaXhlZCA/IHByb3BlcnR5IDogdHJ1ZTtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH0pO1xcblxcblxcdFxcdHJldHVybiByZXN1bHQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIHByZWZpeGVkKHByb3BlcnR5KSB7XFxuXFx0XFx0cmV0dXJuIHRlc3QocHJvcGVydHksIHRydWUpO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzdHJhbnNpdGlvbnMoKSkge1xcblxcdFxcdC8qIGpzaGludCAtVzA1MyAqL1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNpdGlvbicpKTtcXG5cXHRcXHQkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQgPSBldmVudHMudHJhbnNpdGlvbi5lbmRbJC5zdXBwb3J0LnRyYW5zaXRpb25dO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzYW5pbWF0aW9ucygpKSB7XFxuXFx0XFx0LyoganNoaW50IC1XMDUzICovXFxuXFx0XFx0JC5zdXBwb3J0LmFuaW1hdGlvbiA9IG5ldyBTdHJpbmcocHJlZml4ZWQoJ2FuaW1hdGlvbicpKTtcXG5cXHRcXHQkLnN1cHBvcnQuYW5pbWF0aW9uLmVuZCA9IGV2ZW50cy5hbmltYXRpb24uZW5kWyQuc3VwcG9ydC5hbmltYXRpb25dO1xcblxcdH1cXG5cXG5cXHRpZiAodGVzdHMuY3NzdHJhbnNmb3JtcygpKSB7XFxuXFx0XFx0LyoganNoaW50IC1XMDUzICovXFxuXFx0XFx0JC5zdXBwb3J0LnRyYW5zZm9ybSA9IG5ldyBTdHJpbmcocHJlZml4ZWQoJ3RyYW5zZm9ybScpKTtcXG5cXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtM2QgPSB0ZXN0cy5jc3N0cmFuc2Zvcm1zM2QoKTtcXG5cXHR9XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiAuL3NyYy9vd2wuY2Fyb3VzZWwuanNcXG4gKiogbW9kdWxlIGlkID0gMVxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvb3dsLmNhcm91c2VsLmpzP1wiKTtcblxuLyoqKi8gfSxcbi8qIDIgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV2YWwoXCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKCk7XFxuLy8gaW1wb3J0c1xcblxcblxcbi8vIG1vZHVsZVxcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcXFwiLyoqXFxcXG4gKiBPd2wgQ2Fyb3VzZWwgdjIuMi4xXFxcXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE3IERhdmlkIERldXRzY2hcXFxcbiAqIExpY2Vuc2VkIHVuZGVyICAoKVxcXFxuICovXFxcXG4vKlxcXFxuICogIE93bCBDYXJvdXNlbCAtIENvcmVcXFxcbiAqL1xcXFxuLm93bC1jYXJvdXNlbCB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7XFxcXG4gIHdpZHRoOiAxMDAlO1xcXFxuICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcXFxuICAvKiBwb3NpdGlvbiByZWxhdGl2ZSBhbmQgei1pbmRleCBmaXggd2Via2l0IHJlbmRlcmluZyBmb250cyBpc3N1ZSAqL1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIHotaW5kZXg6IDE7IH1cXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLXN0YWdlIHtcXFxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gICAgLW1zLXRvdWNoLWFjdGlvbjogcGFuLVk7XFxcXG4gICAgLW1vei1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgLyogZml4IGZpcmVmb3ggYW5pbWF0aW9uIGdsaXRjaCAqLyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZTphZnRlciB7XFxcXG4gICAgY29udGVudDogXFxcXFxcXCIuXFxcXFxcXCI7XFxcXG4gICAgZGlzcGxheTogYmxvY2s7XFxcXG4gICAgY2xlYXI6IGJvdGg7XFxcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgIGxpbmUtaGVpZ2h0OiAwO1xcXFxuICAgIGhlaWdodDogMDsgfVxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtc3RhZ2Utb3V0ZXIge1xcXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgICBvdmVyZmxvdzogaGlkZGVuO1xcXFxuICAgIC8qIGZpeCBmb3IgZmxhc2hpbmcgYmFja2dyb3VuZCAqL1xcXFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwcHgsIDBweCwgMHB4KTsgfVxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtd3JhcHBlcixcXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLWl0ZW0ge1xcXFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgIC1tb3otYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgIC1tcy1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcXFxuICAgIC1tb3otdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTtcXFxcbiAgICAtbXMtdHJhbnNmb3JtOiB0cmFuc2xhdGUzZCgwLCAwLCAwKTsgfVxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtaXRlbSB7XFxcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICAgIG1pbi1oZWlnaHQ6IDFweDtcXFxcbiAgICBmbG9hdDogbGVmdDtcXFxcbiAgICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgICAtd2Via2l0LXRhcC1oaWdobGlnaHQtY29sb3I6IHRyYW5zcGFyZW50O1xcXFxuICAgIC13ZWJraXQtdG91Y2gtY2FsbG91dDogbm9uZTsgfVxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtaXRlbSBpbWcge1xcXFxuICAgIGRpc3BsYXk6IGJsb2NrO1xcXFxuICAgIHdpZHRoOiAxMDAlOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYuZGlzYWJsZWQsXFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1kb3RzLmRpc2FibGVkIHtcXFxcbiAgICBkaXNwbGF5OiBub25lOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYgLm93bC1wcmV2LFxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtbmF2IC5vd2wtbmV4dCxcXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLWRvdCB7XFxcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICAgIGN1cnNvcjogaGFuZDtcXFxcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgIHVzZXItc2VsZWN0OiBub25lOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwub3dsLWxvYWRlZCB7XFxcXG4gICAgZGlzcGxheTogYmxvY2s7IH1cXFxcbiAgLm93bC1jYXJvdXNlbC5vd2wtbG9hZGluZyB7XFxcXG4gICAgb3BhY2l0eTogMDtcXFxcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1oaWRkZW4ge1xcXFxuICAgIG9wYWNpdHk6IDA7IH1cXFxcbiAgLm93bC1jYXJvdXNlbC5vd2wtcmVmcmVzaCAub3dsLWl0ZW0ge1xcXFxuICAgIHZpc2liaWxpdHk6IGhpZGRlbjsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1kcmFnIC5vd2wtaXRlbSB7XFxcXG4gICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAtbW96LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICB1c2VyLXNlbGVjdDogbm9uZTsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1ncmFiIHtcXFxcbiAgICBjdXJzb3I6IG1vdmU7XFxcXG4gICAgY3Vyc29yOiAtd2Via2l0LWdyYWI7XFxcXG4gICAgY3Vyc29yOiBncmFiOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwub3dsLXJ0bCB7XFxcXG4gICAgZGlyZWN0aW9uOiBydGw7IH1cXFxcbiAgLm93bC1jYXJvdXNlbC5vd2wtcnRsIC5vd2wtaXRlbSB7XFxcXG4gICAgZmxvYXQ6IHJpZ2h0OyB9XFxcXG5cXFxcbi8qIE5vIEpzICovXFxcXG4ubm8tanMgLm93bC1jYXJvdXNlbCB7XFxcXG4gIGRpc3BsYXk6IGJsb2NrOyB9XFxcXG5cXFxcbi8qXFxcXG4gKiAgT3dsIENhcm91c2VsIC0gQW5pbWF0ZSBQbHVnaW5cXFxcbiAqL1xcXFxuLm93bC1jYXJvdXNlbCAuYW5pbWF0ZWQge1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbi1kdXJhdGlvbjogMTAwMG1zO1xcXFxuICAgICAgICAgIGFuaW1hdGlvbi1kdXJhdGlvbjogMTAwMG1zO1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbi1maWxsLW1vZGU6IGJvdGg7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDsgfVxcXFxuXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtYW5pbWF0ZWQtaW4ge1xcXFxuICB6LWluZGV4OiAwOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC1hbmltYXRlZC1vdXQge1xcXFxuICB6LWluZGV4OiAxOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLmZhZGVPdXQge1xcXFxuICAtd2Via2l0LWFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0O1xcXFxuICAgICAgICAgIGFuaW1hdGlvbi1uYW1lOiBmYWRlT3V0OyB9XFxcXG5cXFxcbkAtd2Via2l0LWtleWZyYW1lcyBmYWRlT3V0IHtcXFxcbiAgMCUge1xcXFxuICAgIG9wYWNpdHk6IDE7IH1cXFxcbiAgMTAwJSB7XFxcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxcXG5cXFxcbkBrZXlmcmFtZXMgZmFkZU91dCB7XFxcXG4gIDAlIHtcXFxcbiAgICBvcGFjaXR5OiAxOyB9XFxcXG4gIDEwMCUge1xcXFxuICAgIG9wYWNpdHk6IDA7IH0gfVxcXFxuXFxcXG4vKlxcXFxuICogXFxcXHRPd2wgQ2Fyb3VzZWwgLSBBdXRvIEhlaWdodCBQbHVnaW5cXFxcbiAqL1xcXFxuLm93bC1oZWlnaHQge1xcXFxuICB0cmFuc2l0aW9uOiBoZWlnaHQgNTAwbXMgZWFzZS1pbi1vdXQ7IH1cXFxcblxcXFxuLypcXFxcbiAqIFxcXFx0T3dsIENhcm91c2VsIC0gTGF6eSBMb2FkIFBsdWdpblxcXFxuICovXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSAub3dsLWxhenkge1xcXFxuICBvcGFjaXR5OiAwO1xcXFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDQwMG1zIGVhc2U7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLWl0ZW0gaW1nLm93bC1sYXp5IHtcXFxcbiAgLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6IHByZXNlcnZlLTNkO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7IH1cXFxcblxcXFxuLypcXFxcbiAqIFxcXFx0T3dsIENhcm91c2VsIC0gVmlkZW8gUGx1Z2luXFxcXG4gKi9cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby13cmFwcGVyIHtcXFxcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICBoZWlnaHQ6IDEwMCU7XFxcXG4gIGJhY2tncm91bmQ6ICMwMDA7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXBsYXktaWNvbiB7XFxcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXFxcbiAgaGVpZ2h0OiA4MHB4O1xcXFxuICB3aWR0aDogODBweDtcXFxcbiAgbGVmdDogNTAlO1xcXFxuICB0b3A6IDUwJTtcXFxcbiAgbWFyZ2luLWxlZnQ6IC00MHB4O1xcXFxuICBtYXJnaW4tdG9wOiAtNDBweDtcXFxcbiAgLyogYmFja2dyb3VuZDogdXJsKFxcXFxcXFwib3dsLnZpZGVvLnBsYXkucG5nXFxcXFxcXCIpIG5vLXJlcGVhdDsgKi9cXFxcbiAgY3Vyc29yOiBwb2ludGVyO1xcXFxuICB6LWluZGV4OiAxO1xcXFxuICAtd2Via2l0LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgdHJhbnNpdGlvbjogLXdlYmtpdC10cmFuc2Zvcm0gMTAwbXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDEwMG1zIGVhc2U7XFxcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAxMDBtcyBlYXNlLCAtd2Via2l0LXRyYW5zZm9ybSAxMDBtcyBlYXNlOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5LWljb246aG92ZXIge1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMS4zLCAxLjMpO1xcXFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoMS4zLCAxLjMpOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tdG4sXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheWluZyAub3dsLXZpZGVvLXBsYXktaWNvbiB7XFxcXG4gIGRpc3BsYXk6IG5vbmU7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXRuIHtcXFxcbiAgb3BhY2l0eTogMDtcXFxcbiAgaGVpZ2h0OiAxMDAlO1xcXFxuICBiYWNrZ3JvdW5kLXBvc2l0aW9uOiBjZW50ZXIgY2VudGVyO1xcXFxuICBiYWNrZ3JvdW5kLXJlcGVhdDogbm8tcmVwZWF0O1xcXFxuICBiYWNrZ3JvdW5kLXNpemU6IGNvbnRhaW47XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgNDAwbXMgZWFzZTsgfVxcXFxuXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tZnJhbWUge1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIHotaW5kZXg6IDE7XFxcXG4gIGhlaWdodDogMTAwJTtcXFxcbiAgd2lkdGg6IDEwMCU7IH1cXFxcblxcXCIsIFxcXCJcXFwiXSk7XFxuXFxuLy8gZXhwb3J0c1xcblxcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiAuL34vY3NzLWxvYWRlciEuL34vcG9zdGNzcy1sb2FkZXIhLi9zcmMvb3dsLmNhcm91c2VsLmNzc1xcbiAqKiBtb2R1bGUgaWQgPSAyXFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXFxuICoqL1xcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9vd2wuY2Fyb3VzZWwuY3NzPy4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlclwiKTtcblxuLyoqKi8gfSxcbi8qIDMgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV2YWwoXCIvKlxcclxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxyXFxuXFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxcclxcbiovXFxyXFxuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcXHJcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xcclxcblxcdHZhciBsaXN0ID0gW107XFxyXFxuXFxyXFxuXFx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xcclxcblxcdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcXHJcXG5cXHRcXHR2YXIgcmVzdWx0ID0gW107XFxyXFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcXHJcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IHRoaXNbaV07XFxyXFxuXFx0XFx0XFx0aWYoaXRlbVsyXSkge1xcclxcblxcdFxcdFxcdFxcdHJlc3VsdC5wdXNoKFxcXCJAbWVkaWEgXFxcIiArIGl0ZW1bMl0gKyBcXFwie1xcXCIgKyBpdGVtWzFdICsgXFxcIn1cXFwiKTtcXHJcXG5cXHRcXHRcXHR9IGVsc2Uge1xcclxcblxcdFxcdFxcdFxcdHJlc3VsdC5wdXNoKGl0ZW1bMV0pO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFx0XFx0cmV0dXJuIHJlc3VsdC5qb2luKFxcXCJcXFwiKTtcXHJcXG5cXHR9O1xcclxcblxcclxcblxcdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XFxyXFxuXFx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xcclxcblxcdFxcdGlmKHR5cGVvZiBtb2R1bGVzID09PSBcXFwic3RyaW5nXFxcIilcXHJcXG5cXHRcXHRcXHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcXFwiXFxcIl1dO1xcclxcblxcdFxcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XFxyXFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcXHJcXG5cXHRcXHRcXHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xcclxcblxcdFxcdFxcdGlmKHR5cGVvZiBpZCA9PT0gXFxcIm51bWJlclxcXCIpXFxyXFxuXFx0XFx0XFx0XFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XFxyXFxuXFx0XFx0XFx0dmFyIGl0ZW0gPSBtb2R1bGVzW2ldO1xcclxcblxcdFxcdFxcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcXHJcXG5cXHRcXHRcXHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xcclxcblxcdFxcdFxcdC8vICB3aGVuIGEgbW9kdWxlIGlzIGltcG9ydGVkIG11bHRpcGxlIHRpbWVzIHdpdGggZGlmZmVyZW50IG1lZGlhIHF1ZXJpZXMuXFxyXFxuXFx0XFx0XFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcXHJcXG5cXHRcXHRcXHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXFxcIm51bWJlclxcXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcXHJcXG5cXHRcXHRcXHRcXHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XFxyXFxuXFx0XFx0XFx0XFx0XFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XFxyXFxuXFx0XFx0XFx0XFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpdGVtWzJdID0gXFxcIihcXFwiICsgaXRlbVsyXSArIFxcXCIpIGFuZCAoXFxcIiArIG1lZGlhUXVlcnkgKyBcXFwiKVxcXCI7XFxyXFxuXFx0XFx0XFx0XFx0fVxcclxcblxcdFxcdFxcdFxcdGxpc3QucHVzaChpdGVtKTtcXHJcXG5cXHRcXHRcXHR9XFxyXFxuXFx0XFx0fVxcclxcblxcdH07XFxyXFxuXFx0cmV0dXJuIGxpc3Q7XFxyXFxufTtcXHJcXG5cXG5cXG4vKioqKioqKioqKioqKioqKipcXG4gKiogV0VCUEFDSyBGT09URVJcXG4gKiogLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXFxuICoqIG1vZHVsZSBpZCA9IDNcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcz9cIik7XG5cbi8qKiovIH0sXG4vKiA0ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXHRldmFsKFwiLypcXG5cXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxcblxcdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcXG4qL1xcbnZhciBzdHlsZXNJbkRvbSA9IHt9LFxcblxcdG1lbW9pemUgPSBmdW5jdGlvbihmbikge1xcblxcdFxcdHZhciBtZW1vO1xcblxcdFxcdHJldHVybiBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBtZW1vID09PSBcXFwidW5kZWZpbmVkXFxcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0cmV0dXJuIG1lbW87XFxuXFx0XFx0fTtcXG5cXHR9LFxcblxcdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xcblxcdFxcdHJldHVybiAvbXNpZSBbNi05XVxcXFxiLy50ZXN0KHNlbGYubmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKTtcXG5cXHR9KSxcXG5cXHRnZXRIZWFkRWxlbWVudCA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xcblxcdFxcdHJldHVybiBkb2N1bWVudC5oZWFkIHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJoZWFkXFxcIilbMF07XFxuXFx0fSksXFxuXFx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXFxuXFx0c2luZ2xldG9uQ291bnRlciA9IDAsXFxuXFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGxpc3QsIG9wdGlvbnMpIHtcXG5cXHRpZihmYWxzZSkge1xcblxcdFxcdGlmKHR5cGVvZiBkb2N1bWVudCAhPT0gXFxcIm9iamVjdFxcXCIpIHRocm93IG5ldyBFcnJvcihcXFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XFxcIik7XFxuXFx0fVxcblxcblxcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcblxcdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxcblxcdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuc2luZ2xldG9uID09PSBcXFwidW5kZWZpbmVkXFxcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XFxuXFxuXFx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIDxoZWFkPi5cXG5cXHRpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBvcHRpb25zLmluc2VydEF0ID0gXFxcImJvdHRvbVxcXCI7XFxuXFxuXFx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcXG5cXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGUobmV3TGlzdCkge1xcblxcdFxcdHZhciBtYXlSZW1vdmUgPSBbXTtcXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XFxuXFx0XFx0XFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XFxuXFx0XFx0XFx0ZG9tU3R5bGUucmVmcy0tO1xcblxcdFxcdFxcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYobmV3TGlzdCkge1xcblxcdFxcdFxcdHZhciBuZXdTdHlsZXMgPSBsaXN0VG9TdHlsZXMobmV3TGlzdCk7XFxuXFx0XFx0XFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xcblxcdFxcdFxcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcXG5cXHRcXHRcXHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxcblxcdFxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzW2pdKCk7XFxuXFx0XFx0XFx0XFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbmZ1bmN0aW9uIGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucykge1xcblxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRpZihkb21TdHlsZSkge1xcblxcdFxcdFxcdGRvbVN0eWxlLnJlZnMrKztcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0c1tqXShpdGVtLnBhcnRzW2pdKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcXG5cXHRcXHRcXHRcXHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR2YXIgcGFydHMgPSBbXTtcXG5cXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xcblxcdHZhciBzdHlsZXMgPSBbXTtcXG5cXHR2YXIgbmV3U3R5bGVzID0ge307XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHR2YXIgaXRlbSA9IGxpc3RbaV07XFxuXFx0XFx0dmFyIGlkID0gaXRlbVswXTtcXG5cXHRcXHR2YXIgY3NzID0gaXRlbVsxXTtcXG5cXHRcXHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xcblxcdFxcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xcblxcdFxcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcXG5cXHRcXHRpZighbmV3U3R5bGVzW2lkXSlcXG5cXHRcXHRcXHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xcblxcdFxcdGVsc2VcXG5cXHRcXHRcXHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XFxuXFx0fVxcblxcdHJldHVybiBzdHlsZXM7XFxufVxcblxcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcXG5cXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XFxuXFx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XFxuXFx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJ0b3BcXFwiKSB7XFxuXFx0XFx0aWYoIWxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wKSB7XFxuXFx0XFx0XFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBoZWFkLmZpcnN0Q2hpbGQpO1xcblxcdFxcdH0gZWxzZSBpZihsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZykge1xcblxcdFxcdFxcdGhlYWQuaW5zZXJ0QmVmb3JlKHN0eWxlRWxlbWVudCwgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH1cXG5cXHRcXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XFxuXFx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcXFwiYm90dG9tXFxcIikge1xcblxcdFxcdGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHRocm93IG5ldyBFcnJvcihcXFwiSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyICdpbnNlcnRBdCcuIE11c3QgYmUgJ3RvcCcgb3IgJ2JvdHRvbScuXFxcIik7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KSB7XFxuXFx0c3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcXG5cXHR2YXIgaWR4ID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AuaW5kZXhPZihzdHlsZUVsZW1lbnQpO1xcblxcdGlmKGlkeCA+PSAwKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykge1xcblxcdHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJzdHlsZVxcXCIpO1xcblxcdHN0eWxlRWxlbWVudC50eXBlID0gXFxcInRleHQvY3NzXFxcIjtcXG5cXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGVFbGVtZW50KTtcXG5cXHRyZXR1cm4gc3R5bGVFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKSB7XFxuXFx0dmFyIGxpbmtFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwibGlua1xcXCIpO1xcblxcdGxpbmtFbGVtZW50LnJlbCA9IFxcXCJzdHlsZXNoZWV0XFxcIjtcXG5cXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xcblxcdHJldHVybiBsaW5rRWxlbWVudDtcXG59XFxuXFxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XFxuXFxuXFx0aWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XFxuXFx0XFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XFxuXFx0XFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgZmFsc2UpO1xcblxcdFxcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xcblxcdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXFxuXFx0XFx0dHlwZW9mIFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgQmxvYiA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBidG9hID09PSBcXFwiZnVuY3Rpb25cXFwiKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XFxuXFx0XFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0cmVtb3ZlID0gZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0XFx0aWYoc3R5bGVFbGVtZW50LmhyZWYpXFxuXFx0XFx0XFx0XFx0VVJMLnJldm9rZU9iamVjdFVSTChzdHlsZUVsZW1lbnQuaHJlZik7XFxuXFx0XFx0fTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHR9O1xcblxcdH1cXG5cXG5cXHR1cGRhdGUob2JqKTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XFxuXFx0XFx0aWYobmV3T2JqKSB7XFxuXFx0XFx0XFx0aWYobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwKVxcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR1cGRhdGUob2JqID0gbmV3T2JqKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHJlbW92ZSgpO1xcblxcdFxcdH1cXG5cXHR9O1xcbn1cXG5cXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xcblxcdHZhciB0ZXh0U3RvcmUgPSBbXTtcXG5cXG5cXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xcblxcdFxcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcXG5cXHRcXHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXFxcbicpO1xcblxcdH07XFxufSkoKTtcXG5cXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnKHN0eWxlRWxlbWVudCwgaW5kZXgsIHJlbW92ZSwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IHJlbW92ZSA/IFxcXCJcXFwiIDogb2JqLmNzcztcXG5cXG5cXHRpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XFxuXFx0fSBlbHNlIHtcXG5cXHRcXHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XFxuXFx0XFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2RlcztcXG5cXHRcXHRpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoY3NzTm9kZSk7XFxuXFx0XFx0fVxcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xcblxcdHZhciBjc3MgPSBvYmouY3NzO1xcblxcdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcXG5cXG5cXHRpZihtZWRpYSkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXFxcIm1lZGlhXFxcIiwgbWVkaWEpXFxuXFx0fVxcblxcblxcdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHdoaWxlKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKSB7XFxuXFx0XFx0XFx0c3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcXG5cXHRcXHR9XFxuXFx0XFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xcblxcdH1cXG59XFxuXFxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XFxuXFxuXFx0aWYoc291cmNlTWFwKSB7XFxuXFx0XFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcXG5cXHRcXHRjc3MgKz0gXFxcIlxcXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcXFwiICsgYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSArIFxcXCIgKi9cXFwiO1xcblxcdH1cXG5cXG5cXHR2YXIgYmxvYiA9IG5ldyBCbG9iKFtjc3NdLCB7IHR5cGU6IFxcXCJ0ZXh0L2Nzc1xcXCIgfSk7XFxuXFxuXFx0dmFyIG9sZFNyYyA9IGxpbmtFbGVtZW50LmhyZWY7XFxuXFxuXFx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XFxuXFxuXFx0aWYob2xkU3JjKVxcblxcdFxcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcXG59XFxuXFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIC4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXFxuICoqIG1vZHVsZSBpZCA9IDRcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vfi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzP1wiKTtcblxuLyoqKi8gfSxcbi8qIDUgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV2YWwoXCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xcblxcbi8vIGxvYWQgdGhlIHN0eWxlc1xcbnZhciBjb250ZW50ID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcXG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXFxudmFyIHVwZGF0ZSA9IF9fd2VicGFja19yZXF1aXJlX18oNCkoY29udGVudCwge30pO1xcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xcbi8vIEhvdCBNb2R1bGUgUmVwbGFjZW1lbnRcXG5pZihmYWxzZSkge1xcblxcdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0aWYoIWNvbnRlbnQubG9jYWxzKSB7XFxuXFx0XFx0bW9kdWxlLmhvdC5hY2NlcHQoXFxcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi4vbm9kZV9tb2R1bGVzL3Bvc3Rjc3MtbG9hZGVyL2luZGV4LmpzIS4vb3dsLmNhcm91c2VsLmNzc1xcXCIsIGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcXFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wuY2Fyb3VzZWwuY3NzXFxcIik7XFxuXFx0XFx0XFx0aWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XFxuXFx0XFx0XFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xcblxcdFxcdH0pO1xcblxcdH1cXG5cXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXFxuXFx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XFxufVxcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiAuL3NyYy9vd2wuY2Fyb3VzZWwuY3NzXFxuICoqIG1vZHVsZSBpZCA9IDVcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL293bC5jYXJvdXNlbC5jc3M/XCIpO1xuXG4vKioqLyB9LFxuLyogNiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXZhbChcIm1vZHVsZS5leHBvcnRzID0gX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV82X187XFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIGV4dGVybmFsIHtcXFwicm9vdFxcXCI6XFxcIlByb3BUeXBlc1xcXCIsXFxcImNvbW1vbmpzMlxcXCI6XFxcInByb3AtdHlwZXNcXFwiLFxcXCJjb21tb25qc1xcXCI6XFxcInByb3AtdHlwZXNcXFwiLFxcXCJhbWRcXFwiOlxcXCJwcm9wLXR5cGVzXFxcIn1cXG4gKiogbW9kdWxlIGlkID0gNlxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vZXh0ZXJuYWxfJTdCJTIycm9vdCUyMjolMjJQcm9wVHlwZXMlMjIsJTIyY29tbW9uanMyJTIyOiUyMnByb3AtdHlwZXMlMjIsJTIyY29tbW9uanMlMjI6JTIycHJvcC10eXBlcyUyMiwlMjJhbWQlMjI6JTIycHJvcC10eXBlcyUyMiU3RD9cIik7XG5cbi8qKiovIH0sXG4vKiA3ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXztcXG5cXG4vKioqKioqKioqKioqKioqKipcXG4gKiogV0VCUEFDSyBGT09URVJcXG4gKiogZXh0ZXJuYWwge1xcXCJyb290XFxcIjpcXFwiUmVhY3RcXFwiLFxcXCJjb21tb25qczJcXFwiOlxcXCJyZWFjdFxcXCIsXFxcImNvbW1vbmpzXFxcIjpcXFwicmVhY3RcXFwiLFxcXCJhbWRcXFwiOlxcXCJyZWFjdFxcXCJ9XFxuICoqIG1vZHVsZSBpZCA9IDdcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTIyUmVhY3QlMjIsJTIyY29tbW9uanMyJTIyOiUyMnJlYWN0JTIyLCUyMmNvbW1vbmpzJTIyOiUyMnJlYWN0JTIyLCUyMmFtZCUyMjolMjJyZWFjdCUyMiU3RD9cIik7XG5cbi8qKiovIH0sXG4vKiA4ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXztcXG5cXG4vKioqKioqKioqKioqKioqKipcXG4gKiogV0VCUEFDSyBGT09URVJcXG4gKiogZXh0ZXJuYWwge1xcXCJyb290XFxcIjpcXFwiUmVhY3RET01cXFwiLFxcXCJjb21tb25qczJcXFwiOlxcXCJyZWFjdC1kb21cXFwiLFxcXCJjb21tb25qc1xcXCI6XFxcInJlYWN0LWRvbVxcXCIsXFxcImFtZFxcXCI6XFxcInJlYWN0LWRvbVxcXCJ9XFxuICoqIG1vZHVsZSBpZCA9IDhcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vL2V4dGVybmFsXyU3QiUyMnJvb3QlMjI6JTIyUmVhY3RET00lMjIsJTIyY29tbW9uanMyJTIyOiUyMnJlYWN0LWRvbSUyMiwlMjJjb21tb25qcyUyMjolMjJyZWFjdC1kb20lMjIsJTIyYW1kJTIyOiUyMnJlYWN0LWRvbSUyMiU3RD9cIik7XG5cbi8qKiovIH1cbi8qKioqKiovIF0pXG59KTtcbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3dsLWNhcm91c2VsMi9saWIvT3dsQ2Fyb3VzZWwuanMiLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuXHRpZighbW9kdWxlLndlYnBhY2tQb2x5ZmlsbCkge1xuXHRcdG1vZHVsZS5kZXByZWNhdGUgPSBmdW5jdGlvbigpIHt9O1xuXHRcdG1vZHVsZS5wYXRocyA9IFtdO1xuXHRcdC8vIG1vZHVsZS5wYXJlbnQgPSB1bmRlZmluZWQgYnkgZGVmYXVsdFxuXHRcdGlmKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL21vZHVsZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xudmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vY2hlY2tQcm9wVHlwZXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAvKiBnbG9iYWwgU3ltYm9sICovXG4gIHZhciBJVEVSQVRPUl9TWU1CT0wgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5pdGVyYXRvcjtcbiAgdmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGl0ZXJhdG9yIG1ldGhvZCBmdW5jdGlvbiBjb250YWluZWQgb24gdGhlIGl0ZXJhYmxlIG9iamVjdC5cbiAgICpcbiAgICogQmUgc3VyZSB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGggdGhlIGl0ZXJhYmxlIGFzIGNvbnRleHQ6XG4gICAqXG4gICAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gICAqICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgKiAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobXlJdGVyYWJsZSk7XG4gICAqICAgICAgIC4uLlxuICAgKiAgICAgfVxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBtYXliZUl0ZXJhYmxlICYmIChJVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtJVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdKTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBpdGVyYXRvckZuO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICAgKiBzdXBwbGllZCB0byBSZWFjdCBjb21wb25lbnRzLiBFeGFtcGxlIHVzYWdlOlxuICAgKlxuICAgKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gICAqICAgdmFyIE15QXJ0aWNsZSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gICAqICAgICAgIGRlc2NyaXB0aW9uOiBQcm9wcy5zdHJpbmcsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAgICogICAgICAgY2F0ZWdvcnk6IFByb3BzLm9uZU9mKFsnTmV3cycsJ1Bob3RvcyddKS5pc1JlcXVpcmVkLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAgICogICAgICAgZGlhbG9nOiBQcm9wcy5pbnN0YW5jZU9mKERpYWxvZykuaXNSZXF1aXJlZFxuICAgKiAgICAgfSxcbiAgICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gICAqICAgfSk7XG4gICAqXG4gICAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAgICpcbiAgICogICB0eXBlIDo9IGFycmF5fGJvb2x8ZnVuY3xvYmplY3R8bnVtYmVyfHN0cmluZ3xvbmVPZihbLi4uXSl8aW5zdGFuY2VPZiguLi4pXG4gICAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICAgKlxuICAgKiBFYWNoIGFuZCBldmVyeSBkZWNsYXJhdGlvbiBwcm9kdWNlcyBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgc2lnbmF0dXJlLiBUaGlzXG4gICAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogIHZhciBNeUxpbmsgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgIHByb3BUeXBlczoge1xuICAgKiAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBvciBVUkkgcHJvcCBuYW1lZCBcImhyZWZcIi5cbiAgICogICAgICBocmVmOiBmdW5jdGlvbihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAqICAgICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHByb3BWYWx1ZSAhPT0gJ3N0cmluZycgJiZcbiAgICogICAgICAgICAgICAhKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFVSSSkpIHtcbiAgICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAgICogICAgICAgICAgICAnRXhwZWN0ZWQgYSBzdHJpbmcgb3IgYW4gVVJJIGZvciAnICsgcHJvcE5hbWUgKyAnIGluICcgK1xuICAgKiAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICogICAgICAgICAgKTtcbiAgICogICAgICAgIH1cbiAgICogICAgICB9XG4gICAqICAgIH0sXG4gICAqICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7Li4ufVxuICAgKiAgfSk7XG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cblxuICB2YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG4gIC8vIEltcG9ydGFudCFcbiAgLy8gS2VlcCB0aGlzIGxpc3QgaW4gc3luYyB3aXRoIHByb2R1Y3Rpb24gdmVyc2lvbiBpbiBgLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdhcnJheScpLFxuICAgIGJvb2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdib29sZWFuJyksXG4gICAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gICAgbnVtYmVyOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignbnVtYmVyJyksXG4gICAgb2JqZWN0OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignb2JqZWN0JyksXG4gICAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG4gICAgc3ltYm9sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3ltYm9sJyksXG5cbiAgICBhbnk6IGNyZWF0ZUFueVR5cGVDaGVja2VyKCksXG4gICAgYXJyYXlPZjogY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyLFxuICAgIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICAgIGluc3RhbmNlT2Y6IGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIsXG4gICAgbm9kZTogY3JlYXRlTm9kZUNoZWNrZXIoKSxcbiAgICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgICBvbmVPZjogY3JlYXRlRW51bVR5cGVDaGVja2VyLFxuICAgIG9uZU9mVHlwZTogY3JlYXRlVW5pb25UeXBlQ2hlY2tlcixcbiAgICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcixcbiAgICBleGFjdDogY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcixcbiAgfTtcblxuICAvKipcbiAgICogaW5saW5lZCBPYmplY3QuaXMgcG9seWZpbGwgdG8gYXZvaWQgcmVxdWlyaW5nIGNvbnN1bWVycyBzaGlwIHRoZWlyIG93blxuICAgKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAgICovXG4gIC8qZXNsaW50LWRpc2FibGUgbm8tc2VsZi1jb21wYXJlKi9cbiAgZnVuY3Rpb24gaXMoeCwgeSkge1xuICAgIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgLy8gU3RlcHMgMS01LCA3LTEwXG4gICAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgICAgcmV0dXJuIHggIT09IDAgfHwgMSAvIHggPT09IDEgLyB5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdGVwIDYuYTogTmFOID09IE5hTlxuICAgICAgcmV0dXJuIHggIT09IHggJiYgeSAhPT0geTtcbiAgICB9XG4gIH1cbiAgLyplc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSovXG5cbiAgLyoqXG4gICAqIFdlIHVzZSBhbiBFcnJvci1saWtlIG9iamVjdCBmb3IgYmFja3dhcmQgY29tcGF0aWJpbGl0eSBhcyBwZW9wbGUgbWF5IGNhbGxcbiAgICogUHJvcFR5cGVzIGRpcmVjdGx5IGFuZCBpbnNwZWN0IHRoZWlyIG91dHB1dC4gSG93ZXZlciwgd2UgZG9uJ3QgdXNlIHJlYWxcbiAgICogRXJyb3JzIGFueW1vcmUuIFdlIGRvbid0IGluc3BlY3QgdGhlaXIgc3RhY2sgYW55d2F5LCBhbmQgY3JlYXRpbmcgdGhlbVxuICAgKiBpcyBwcm9oaWJpdGl2ZWx5IGV4cGVuc2l2ZSBpZiB0aGV5IGFyZSBjcmVhdGVkIHRvbyBvZnRlbiwgc3VjaCBhcyB3aGF0XG4gICAqIGhhcHBlbnMgaW4gb25lT2ZUeXBlKCkgZm9yIGFueSB0eXBlIGJlZm9yZSB0aGUgb25lIHRoYXQgbWF0Y2hlZC5cbiAgICovXG4gIGZ1bmN0aW9uIFByb3BUeXBlRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdGhpcy5zdGFjayA9ICcnO1xuICB9XG4gIC8vIE1ha2UgYGluc3RhbmNlb2YgRXJyb3JgIHN0aWxsIHdvcmsgZm9yIHJldHVybmVkIGVycm9ycy5cbiAgUHJvcFR5cGVFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlID0ge307XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPSAwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja1R5cGUoaXNSZXF1aXJlZCwgcHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgIHByb3BGdWxsTmFtZSA9IHByb3BGdWxsTmFtZSB8fCBwcm9wTmFtZTtcblxuICAgICAgaWYgKHNlY3JldCAhPT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgICAgaWYgKHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgICAgICAgICAvLyBOZXcgYmVoYXZpb3Igb25seSBmb3IgdXNlcnMgb2YgYHByb3AtdHlwZXNgIHBhY2thZ2VcbiAgICAgICAgICBpbnZhcmlhbnQoXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICdDYWxsaW5nIFByb3BUeXBlcyB2YWxpZGF0b3JzIGRpcmVjdGx5IGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICdVc2UgYFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpYCB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIE9sZCBiZWhhdmlvciBmb3IgcGVvcGxlIHVzaW5nIFJlYWN0LlByb3BUeXBlc1xuICAgICAgICAgIHZhciBjYWNoZUtleSA9IGNvbXBvbmVudE5hbWUgKyAnOicgKyBwcm9wTmFtZTtcbiAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAhbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldICYmXG4gICAgICAgICAgICAvLyBBdm9pZCBzcGFtbWluZyB0aGUgY29uc29sZSBiZWNhdXNlIHRoZXkgYXJlIG9mdGVuIG5vdCBhY3Rpb25hYmxlIGV4Y2VwdCBmb3IgbGliIGF1dGhvcnNcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50IDwgM1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgd2FybmluZyhcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgICdZb3UgYXJlIG1hbnVhbGx5IGNhbGxpbmcgYSBSZWFjdC5Qcm9wVHlwZXMgdmFsaWRhdGlvbiAnICtcbiAgICAgICAgICAgICAgJ2Z1bmN0aW9uIGZvciB0aGUgYCVzYCBwcm9wIG9uIGAlc2AuIFRoaXMgaXMgZGVwcmVjYXRlZCAnICtcbiAgICAgICAgICAgICAgJ2FuZCB3aWxsIHRocm93IGluIHRoZSBzdGFuZGFsb25lIGBwcm9wLXR5cGVzYCBwYWNrYWdlLiAnICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgYmUgc2VlaW5nIHRoaXMgd2FybmluZyBkdWUgdG8gYSB0aGlyZC1wYXJ0eSBQcm9wVHlwZXMgJyArXG4gICAgICAgICAgICAgICdsaWJyYXJ5LiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWRvbnQtY2FsbC1wcm9wdHlwZXMgJyArICdmb3IgZGV0YWlscy4nLFxuICAgICAgICAgICAgICBwcm9wRnVsbE5hbWUsXG4gICAgICAgICAgICAgIGNvbXBvbmVudE5hbWVcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQrKztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBpZiAoaXNSZXF1aXJlZCkge1xuICAgICAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgJyArICgnaW4gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYG51bGxgLicpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgdW5kZWZpbmVkYC4nKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hhaW5lZENoZWNrVHlwZSA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIGZhbHNlKTtcbiAgICBjaGFpbmVkQ2hlY2tUeXBlLmlzUmVxdWlyZWQgPSBjaGVja1R5cGUuYmluZChudWxsLCB0cnVlKTtcblxuICAgIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoZXhwZWN0ZWRUeXBlKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBzZWNyZXQpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSBleHBlY3RlZFR5cGUpIHtcbiAgICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAgIC8vIGNoZWNrLCBidXQgd2UgY2FuIG9mZmVyIGEgbW9yZSBwcmVjaXNlIGVycm9yIG1lc3NhZ2UgaGVyZSByYXRoZXIgdGhhblxuICAgICAgICAvLyAnb2YgdHlwZSBgb2JqZWN0YCcuXG4gICAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIGFycmF5T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gYXJyYXkuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBpLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJ1snICsgaSArICddJywgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgaWYgKCFpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCEocHJvcHNbcHJvcE5hbWVdIGluc3RhbmNlb2YgZXhwZWN0ZWRDbGFzcykpIHtcbiAgICAgICAgdmFyIGV4cGVjdGVkQ2xhc3NOYW1lID0gZXhwZWN0ZWRDbGFzcy5uYW1lIHx8IEFOT05ZTU9VUztcbiAgICAgICAgdmFyIGFjdHVhbENsYXNzTmFtZSA9IGdldENsYXNzTmFtZShwcm9wc1twcm9wTmFtZV0pO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBhY3R1YWxDbGFzc05hbWUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2luc3RhbmNlIG9mIGAnICsgZXhwZWN0ZWRDbGFzc05hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVudW1UeXBlQ2hlY2tlcihleHBlY3RlZFZhbHVlcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZFZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoaXMocHJvcFZhbHVlLCBleHBlY3RlZFZhbHVlc1tpXSkpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWVzU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkoZXhwZWN0ZWRWYWx1ZXMpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB2YWx1ZSBgJyArIHByb3BWYWx1ZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBvbmUgb2YgJyArIHZhbHVlc1N0cmluZyArICcuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBvYmplY3RPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHByb3BWYWx1ZSkge1xuICAgICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIoYXJyYXlPZlR5cGVDaGVja2Vycykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheU9mVHlwZUNoZWNrZXJzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZSwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJykgOiB2b2lkIDA7XG4gICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICBpZiAodHlwZW9mIGNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2FybmluZyhcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUuIEV4cGVjdGVkIGFuIGFycmF5IG9mIGNoZWNrIGZ1bmN0aW9ucywgYnV0ICcgK1xuICAgICAgICAgICdyZWNlaXZlZCAlcyBhdCBpbmRleCAlcy4nLFxuICAgICAgICAgIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyhjaGVja2VyKSxcbiAgICAgICAgICBpXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IGFycmF5T2ZUeXBlQ2hlY2tlcnNbaV07XG4gICAgICAgIGlmIChjaGVja2VyKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU5vZGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIFJlYWN0Tm9kZS4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzaGFwZVR5cGVzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGFsbCBrZXlzIGluIGNhc2Ugc29tZSBhcmUgcmVxdWlyZWQgYnV0IG1pc3NpbmcgZnJvbVxuICAgICAgLy8gcHJvcHMuXG4gICAgICB2YXIgYWxsS2V5cyA9IGFzc2lnbih7fSwgcHJvcHNbcHJvcE5hbWVdLCBzaGFwZVR5cGVzKTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBhbGxLZXlzKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgICBpZiAoIWNoZWNrZXIpIHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoXG4gICAgICAgICAgICAnSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Aga2V5IGAnICsga2V5ICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJyArXG4gICAgICAgICAgICAnXFxuQmFkIG9iamVjdDogJyArIEpTT04uc3RyaW5naWZ5KHByb3BzW3Byb3BOYW1lXSwgbnVsbCwgJyAgJykgK1xuICAgICAgICAgICAgJ1xcblZhbGlkIGtleXM6ICcgKyAgSlNPTi5zdHJpbmdpZnkoT2JqZWN0LmtleXMoc2hhcGVUeXBlcyksIG51bGwsICcgICcpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZXJyb3IgPSBjaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzTm9kZShwcm9wVmFsdWUpIHtcbiAgICBzd2l0Y2ggKHR5cGVvZiBwcm9wVmFsdWUpIHtcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgcmV0dXJuICFwcm9wVmFsdWU7XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHByb3BWYWx1ZS5ldmVyeShpc05vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wVmFsdWUgPT09IG51bGwgfHwgaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKHByb3BWYWx1ZSk7XG4gICAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKHByb3BWYWx1ZSk7XG4gICAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEl0ZXJhdG9yIHdpbGwgcHJvdmlkZSBlbnRyeSBbayx2XSB0dXBsZXMgcmF0aGVyIHRoYW4gdmFsdWVzLlxuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzTm9kZShlbnRyeVsxXSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkge1xuICAgIC8vIE5hdGl2ZSBTeW1ib2wuXG4gICAgaWYgKHByb3BUeXBlID09PSAnc3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gMTkuNC4zLjUgU3ltYm9sLnByb3RvdHlwZVtAQHRvU3RyaW5nVGFnXSA9PT0gJ1N5bWJvbCdcbiAgICBpZiAocHJvcFZhbHVlWydAQHRvU3RyaW5nVGFnJ10gPT09ICdTeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBmb3Igbm9uLXNwZWMgY29tcGxpYW50IFN5bWJvbHMgd2hpY2ggYXJlIHBvbHlmaWxsZWQuXG4gICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgcHJvcFZhbHVlIGluc3RhbmNlb2YgU3ltYm9sKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBFcXVpdmFsZW50IG9mIGB0eXBlb2ZgIGJ1dCB3aXRoIHNwZWNpYWwgaGFuZGxpbmcgZm9yIGFycmF5IGFuZCByZWdleHAuXG4gIGZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICAgIHZhciBwcm9wVHlwZSA9IHR5cGVvZiBwcm9wVmFsdWU7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdhcnJheSc7XG4gICAgfVxuICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvYmplY3QnIGZvciB0eXBlb2YgYSBSZWdFeHAuIFdlJ2xsIG5vcm1hbGl6ZSB0aGlzIGhlcmUgc28gdGhhdCAvYmxhL1xuICAgICAgLy8gcGFzc2VzIFByb3BUeXBlcy5vYmplY3QuXG4gICAgICByZXR1cm4gJ29iamVjdCc7XG4gICAgfVxuICAgIGlmIChpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSkge1xuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gIC8vIFNlZSBgY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXJgLlxuICBmdW5jdGlvbiBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHByb3BWYWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgcHJvcFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJycgKyBwcm9wVmFsdWU7XG4gICAgfVxuICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgaWYgKHByb3BUeXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgcmV0dXJuICdkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gUmV0dXJucyBhIHN0cmluZyB0aGF0IGlzIHBvc3RmaXhlZCB0byBhIHdhcm5pbmcgYWJvdXQgYW4gaW52YWxpZCB0eXBlLlxuICAvLyBGb3IgZXhhbXBsZSwgXCJ1bmRlZmluZWRcIiBvciBcIm9mIHR5cGUgYXJyYXlcIlxuICBmdW5jdGlvbiBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcodmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IGdldFByZWNpc2VUeXBlKHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgJ2FycmF5JzpcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIHJldHVybiAnYW4gJyArIHR5cGU7XG4gICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIGNhc2UgJ2RhdGUnOlxuICAgICAgY2FzZSAncmVnZXhwJzpcbiAgICAgICAgcmV0dXJuICdhICcgKyB0eXBlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0dXJucyBjbGFzcyBuYW1lIG9mIHRoZSBvYmplY3QsIGlmIGFueS5cbiAgZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICAgIGlmICghcHJvcFZhbHVlLmNvbnN0cnVjdG9yIHx8ICFwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZSkge1xuICAgICAgcmV0dXJuIEFOT05ZTU9VUztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lO1xuICB9XG5cbiAgUmVhY3RQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMgPSBjaGVja1Byb3BUeXBlcztcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMuanMiXSwic291cmNlUm9vdCI6IiJ9
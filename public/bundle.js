/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 24);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (process.env.NODE_ENV === 'production') {
  module.exports = __webpack_require__(25);
} else {
  module.exports = __webpack_require__(26);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__(18);
var isBuffer = __webpack_require__(38);

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;

/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/


/* eslint-disable no-unused-vars */

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc'); // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyObject = {};

if (process.env.NODE_ENV !== 'production') {
  Object.freeze(emptyObject);
}

module.exports = emptyObject;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var emptyFunction = __webpack_require__(3);

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== 'production') {
  var invariant = __webpack_require__(5);
  var warning = __webpack_require__(7);
  var ReactPropTypesSecret = __webpack_require__(9);
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, _typeof(typeSpecs[typeSpecName]));
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error === 'undefined' ? 'undefined' : _typeof(error));
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

function checkDCE() {
  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function') {
    return;
  }
  if (process.env.NODE_ENV !== 'production') {
    // This branch is unreachable because this function is only called
    // in production, but the condition is true only in development.
    // Therefore if the branch is still here, dead code elimination wasn't
    // properly applied.
    // Don't change the message. React DevTools relies on it. Also make sure
    // this message doesn't occur elsewhere in this function, or it will cause
    // a false positive.
    throw new Error('^_^');
  }
  try {
    // Verify that the code above has been dead code eliminated (DCE'd).
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    // DevTools shouldn't crash React, no matter what.
    // We should still report in case we break this code.
    console.error(err);
  }
}

if (process.env.NODE_ENV === 'production') {
  // DCE check should happen before ReactDOM bundle executes so that
  // DevTools can report bad minification during injection.
  checkDCE();
  module.exports = __webpack_require__(27);
} else {
  module.exports = __webpack_require__(30);
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(2);
var normalizeHeaderName = __webpack_require__(40);

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(19);
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__(19);
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;

/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var emptyFunction = __webpack_require__(3);

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      if (process.env.NODE_ENV !== 'production') {
        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
      }
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 *
 * @param {?DOMDocument} doc Defaults to current document.
 * @return {?DOMElement}
 */

function getActiveElement(doc) /*?DOMElement*/{
  doc = doc || (typeof document !== 'undefined' ? document : undefined);
  if (typeof doc === 'undefined') {
    return null;
  }
  try {
    return doc.activeElement || doc.body;
  } catch (e) {
    return doc.body;
  }
}

module.exports = getActiveElement;

/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;

/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

var isTextNode = __webpack_require__(28);

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;

/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */



/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;

/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__(2);
var settle = __webpack_require__(41);
var buildURL = __webpack_require__(43);
var parseHeaders = __webpack_require__(44);
var isURLSameOrigin = __webpack_require__(45);
var createError = __webpack_require__(20);
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__(46);

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if (process.env.NODE_ENV !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__(47);

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__(42);

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol.for && Symbol.for('react.element') || 0xeac7;

  var isValidElement = function isValidElement(object) {
    return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = __webpack_require__(64)(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(65)();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactDom = __webpack_require__(10);

var _reactDom2 = _interopRequireDefault(_reactDom);

var _app = __webpack_require__(35);

var _app2 = _interopRequireDefault(_app);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// ReactDOM.render(<App url="http://localhost:8000/api/data" />, document.querySelector('.container'));
_reactDom2.default.render(_react2.default.createElement(_app2.default, { url: 'https://maxgolubev-cv.herokuapp.com/api/data' }), document.querySelector('.container'));

/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.0
 * react.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var m = __webpack_require__(4),
    n = __webpack_require__(6),
    p = __webpack_require__(3);
function q(a) {
  for (var b = arguments.length - 1, e = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    e += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}
var r = { isMounted: function isMounted() {
    return !1;
  }, enqueueForceUpdate: function enqueueForceUpdate() {}, enqueueReplaceState: function enqueueReplaceState() {}, enqueueSetState: function enqueueSetState() {} };function t(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}t.prototype.isReactComponent = {};t.prototype.setState = function (a, b) {
  "object" !== (typeof a === "undefined" ? "undefined" : _typeof(a)) && "function" !== typeof a && null != a ? q("85") : void 0;this.updater.enqueueSetState(this, a, b, "setState");
};t.prototype.forceUpdate = function (a) {
  this.updater.enqueueForceUpdate(this, a, "forceUpdate");
};
function u(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}function v() {}v.prototype = t.prototype;var w = u.prototype = new v();w.constructor = u;m(w, t.prototype);w.isPureReactComponent = !0;function x(a, b, e) {
  this.props = a;this.context = b;this.refs = n;this.updater = e || r;
}var y = x.prototype = new v();y.constructor = x;m(y, t.prototype);y.unstable_isAsyncReactComponent = !0;y.render = function () {
  return this.props.children;
};
var z = { current: null },
    A = Object.prototype.hasOwnProperty,
    B = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    C = { key: !0, ref: !0, __self: !0, __source: !0 };
function D(a, b, e) {
  var d,
      c = {},
      h = null,
      k = null;if (null != b) for (d in void 0 !== b.ref && (k = b.ref), void 0 !== b.key && (h = "" + b.key), b) {
    A.call(b, d) && !C.hasOwnProperty(d) && (c[d] = b[d]);
  }var f = arguments.length - 2;if (1 === f) c.children = e;else if (1 < f) {
    for (var g = Array(f), l = 0; l < f; l++) {
      g[l] = arguments[l + 2];
    }c.children = g;
  }if (a && a.defaultProps) for (d in f = a.defaultProps, f) {
    void 0 === c[d] && (c[d] = f[d]);
  }return { $$typeof: B, type: a, key: h, ref: k, props: c, _owner: z.current };
}function E(a) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && a.$$typeof === B;
}
var F = "function" === typeof Symbol && Symbol.iterator,
    G = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.element") || 60103,
    H = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.portal") || 60106;function escape(a) {
  var b = { "\x3d": "\x3d0", ":": "\x3d2" };return "$" + ("" + a).replace(/[=:]/g, function (a) {
    return b[a];
  });
}var I = /\/+/g,
    J = [];
function K(a, b, e, d) {
  if (J.length) {
    var c = J.pop();c.result = a;c.keyPrefix = b;c.func = e;c.context = d;c.count = 0;return c;
  }return { result: a, keyPrefix: b, func: e, context: d, count: 0 };
}function L(a) {
  a.result = null;a.keyPrefix = null;a.func = null;a.context = null;a.count = 0;10 > J.length && J.push(a);
}
function M(a, b, e, d) {
  var c = typeof a === "undefined" ? "undefined" : _typeof(a);if ("undefined" === c || "boolean" === c) a = null;if (null === a || "string" === c || "number" === c || "object" === c && a.$$typeof === G || "object" === c && a.$$typeof === H) return e(d, a, "" === b ? "." + N(a, 0) : b), 1;var h = 0;b = "" === b ? "." : b + ":";if (Array.isArray(a)) for (var k = 0; k < a.length; k++) {
    c = a[k];var f = b + N(c, k);h += M(c, f, e, d);
  } else if (f = F && a[F] || a["@@iterator"], "function" === typeof f) for (a = f.call(a), k = 0; !(c = a.next()).done;) {
    c = c.value, f = b + N(c, k++), h += M(c, f, e, d);
  } else "object" === c && (e = "" + a, q("31", "[object Object]" === e ? "object with keys {" + Object.keys(a).join(", ") + "}" : e, ""));return h;
}function N(a, b) {
  return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && null !== a && null != a.key ? escape(a.key) : b.toString(36);
}function O(a, b) {
  a.func.call(a.context, b, a.count++);
}
function P(a, b, e) {
  var d = a.result,
      c = a.keyPrefix;a = a.func.call(a.context, b, a.count++);Array.isArray(a) ? Q(a, d, e, p.thatReturnsArgument) : null != a && (E(a) && (b = c + (!a.key || b && b.key === a.key ? "" : ("" + a.key).replace(I, "$\x26/") + "/") + e, a = { $$typeof: B, type: a.type, key: b, ref: a.ref, props: a.props, _owner: a._owner }), d.push(a));
}function Q(a, b, e, d, c) {
  var h = "";null != e && (h = ("" + e).replace(I, "$\x26/") + "/");b = K(b, h, d, c);null == a || M(a, "", P, b);L(b);
}"function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.fragment");
var R = { Children: { map: function map(a, b, e) {
      if (null == a) return a;var d = [];Q(a, d, null, b, e);return d;
    }, forEach: function forEach(a, b, e) {
      if (null == a) return a;b = K(null, null, b, e);null == a || M(a, "", O, b);L(b);
    }, count: function count(a) {
      return null == a ? 0 : M(a, "", p.thatReturnsNull, null);
    }, toArray: function toArray(a) {
      var b = [];Q(a, b, null, p.thatReturnsArgument);return b;
    }, only: function only(a) {
      E(a) ? void 0 : q("143");return a;
    } }, Component: t, PureComponent: u, unstable_AsyncComponent: x, createElement: D, cloneElement: function cloneElement(a, b, e) {
    var d = m({}, a.props),
        c = a.key,
        h = a.ref,
        k = a._owner;if (null != b) {
      void 0 !== b.ref && (h = b.ref, k = z.current);void 0 !== b.key && (c = "" + b.key);if (a.type && a.type.defaultProps) var f = a.type.defaultProps;for (g in b) {
        A.call(b, g) && !C.hasOwnProperty(g) && (d[g] = void 0 === b[g] && void 0 !== f ? f[g] : b[g]);
      }
    }var g = arguments.length - 2;if (1 === g) d.children = e;else if (1 < g) {
      f = Array(g);for (var l = 0; l < g; l++) {
        f[l] = arguments[l + 2];
      }d.children = f;
    }return { $$typeof: B, type: a.type, key: c, ref: h, props: d, _owner: k };
  }, createFactory: function createFactory(a) {
    var b = D.bind(null, a);b.type = a;return b;
  }, isValidElement: E,
  version: "16.1.0", __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { ReactCurrentOwner: z, assign: m } },
    S = Object.freeze({ default: R }),
    T = S && R || S;module.exports = T["default"] ? T["default"] : T;

/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.1.0
 * react.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

if (process.env.NODE_ENV !== "production") {
  (function () {
    'use strict';

    var _assign = __webpack_require__(4);
    var invariant = __webpack_require__(5);
    var emptyObject = __webpack_require__(6);
    var warning = __webpack_require__(7);
    var emptyFunction = __webpack_require__(3);
    var checkPropTypes = __webpack_require__(8);

    // TODO: this is special because it gets imported during build.

    var ReactVersion = '16.1.0';

    /**
     * WARNING: DO NOT manually require this module.
     * This is a replacement for `invariant(...)` used by the error code system
     * and will _only_ be required by the corresponding babel pass.
     * It always throws.
     */

    // Exports React.Fragment
    var enableReactFragment = false;
    // Exports ReactDOM.createRoot


    // Mutating mode (React DOM, React ART, React Native):

    // Experimental noop mode (currently unused):

    // Experimental persistent mode (CS):


    // Only used in www builds.

    /**
     * Forked from fbjs/warning:
     * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
     *
     * Only change is we use console.warn instead of console.error,
     * and do nothing when 'console' is not supported.
     * This really simplifies the code.
     * ---
     * Similar to invariant but only logs a warning if the condition is not met.
     * This can be used to log issues in development environments in critical
     * paths. Removing the logging code for production environments will keep the
     * same logic and follow the same code paths.
     */

    var lowPriorityWarning = function lowPriorityWarning() {};

    {
      var printWarning = function printWarning(format) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var argIndex = 0;
        var message = 'Warning: ' + format.replace(/%s/g, function () {
          return args[argIndex++];
        });
        if (typeof console !== 'undefined') {
          console.warn(message);
        }
        try {
          // --- Welcome to debugging React ---
          // This error was thrown as a convenience so that you can use this stack
          // to find the callsite that caused this warning to fire.
          throw new Error(message);
        } catch (x) {}
      };

      lowPriorityWarning = function lowPriorityWarning(condition, format) {
        if (format === undefined) {
          throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
        }
        if (!condition) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          printWarning.apply(undefined, [format].concat(args));
        }
      };
    }

    var lowPriorityWarning$1 = lowPriorityWarning;

    var didWarnStateUpdateForUnmountedComponent = {};

    function warnNoop(publicInstance, callerName) {
      {
        var constructor = publicInstance.constructor;
        var componentName = constructor && (constructor.displayName || constructor.name) || 'ReactClass';
        var warningKey = componentName + '.' + callerName;
        if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
          return;
        }
        warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op.\n\nPlease check the code for the %s component.', callerName, callerName, componentName);
        didWarnStateUpdateForUnmountedComponent[warningKey] = true;
      }
    }

    /**
     * This is the abstract API for an update queue.
     */
    var ReactNoopUpdateQueue = {
      /**
       * Checks whether or not this composite component is mounted.
       * @param {ReactClass} publicInstance The instance we want to test.
       * @return {boolean} True if mounted, false otherwise.
       * @protected
       * @final
       */
      isMounted: function isMounted(publicInstance) {
        return false;
      },

      /**
       * Forces an update. This should only be invoked when it is known with
       * certainty that we are **not** in a DOM transaction.
       *
       * You may want to call this when you know that some deeper aspect of the
       * component's state has changed but `setState` was not called.
       *
       * This will not invoke `shouldComponentUpdate`, but it will invoke
       * `componentWillUpdate` and `componentDidUpdate`.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueForceUpdate: function enqueueForceUpdate(publicInstance, callback, callerName) {
        warnNoop(publicInstance, 'forceUpdate');
      },

      /**
       * Replaces all of the state. Always use this or `setState` to mutate state.
       * You should treat `this.state` as immutable.
       *
       * There is no guarantee that `this.state` will be immediately updated, so
       * accessing `this.state` after calling this method may return the old value.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} completeState Next state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} callerName name of the calling function in the public API.
       * @internal
       */
      enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState, callback, callerName) {
        warnNoop(publicInstance, 'replaceState');
      },

      /**
       * Sets a subset of the state. This only exists because _pendingState is
       * internal. This provides a merging strategy that is not available to deep
       * properties which is confusing. TODO: Expose pendingState or don't use it
       * during the merge.
       *
       * @param {ReactClass} publicInstance The instance that should rerender.
       * @param {object} partialState Next partial state to be merged with state.
       * @param {?function} callback Called after component is updated.
       * @param {?string} Name of the calling function in the public API.
       * @internal
       */
      enqueueSetState: function enqueueSetState(publicInstance, partialState, callback, callerName) {
        warnNoop(publicInstance, 'setState');
      }
    };

    /**
     * Base class helpers for the updating state of a component.
     */
    function Component(props, context, updater) {
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    Component.prototype.isReactComponent = {};

    /**
     * Sets a subset of the state. Always use this to mutate
     * state. You should treat `this.state` as immutable.
     *
     * There is no guarantee that `this.state` will be immediately updated, so
     * accessing `this.state` after calling this method may return the old value.
     *
     * There is no guarantee that calls to `setState` will run synchronously,
     * as they may eventually be batched together.  You can provide an optional
     * callback that will be executed when the call to setState is actually
     * completed.
     *
     * When a function is provided to setState, it will be called at some point in
     * the future (not synchronously). It will be called with the up to date
     * component arguments (state, props, context). These values can be different
     * from this.* because your function may be called after receiveProps but before
     * shouldComponentUpdate, and this new state, props, and context will not yet be
     * assigned to this.
     *
     * @param {object|function} partialState Next partial state or function to
     *        produce next partial state to be merged with current state.
     * @param {?function} callback Called after state is updated.
     * @final
     * @protected
     */
    Component.prototype.setState = function (partialState, callback) {
      !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? invariant(false, 'setState(...): takes an object of state variables to update or a function which returns an object of state variables.') : void 0;
      this.updater.enqueueSetState(this, partialState, callback, 'setState');
    };

    /**
     * Forces an update. This should only be invoked when it is known with
     * certainty that we are **not** in a DOM transaction.
     *
     * You may want to call this when you know that some deeper aspect of the
     * component's state has changed but `setState` was not called.
     *
     * This will not invoke `shouldComponentUpdate`, but it will invoke
     * `componentWillUpdate` and `componentDidUpdate`.
     *
     * @param {?function} callback Called after update is complete.
     * @final
     * @protected
     */
    Component.prototype.forceUpdate = function (callback) {
      this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');
    };

    /**
     * Deprecated APIs. These APIs used to exist on classic React classes but since
     * we would like to deprecate them, we're not going to move them over to this
     * modern base class. Instead, we define a getter that warns if it's accessed.
     */
    {
      var deprecatedAPIs = {
        isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
        replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']
      };
      var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
        Object.defineProperty(Component.prototype, methodName, {
          get: function get() {
            lowPriorityWarning$1(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);
            return undefined;
          }
        });
      };
      for (var fnName in deprecatedAPIs) {
        if (deprecatedAPIs.hasOwnProperty(fnName)) {
          defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
        }
      }
    }

    /**
     * Base class helpers for the updating state of a component.
     */
    function PureComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    function ComponentDummy() {}
    ComponentDummy.prototype = Component.prototype;
    var pureComponentPrototype = PureComponent.prototype = new ComponentDummy();
    pureComponentPrototype.constructor = PureComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(pureComponentPrototype, Component.prototype);
    pureComponentPrototype.isPureReactComponent = true;

    function AsyncComponent(props, context, updater) {
      // Duplicated from Component.
      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      // We initialize the default updater but the real one gets injected by the
      // renderer.
      this.updater = updater || ReactNoopUpdateQueue;
    }

    var asyncComponentPrototype = AsyncComponent.prototype = new ComponentDummy();
    asyncComponentPrototype.constructor = AsyncComponent;
    // Avoid an extra prototype jump for these methods.
    _assign(asyncComponentPrototype, Component.prototype);
    asyncComponentPrototype.unstable_isAsyncReactComponent = true;
    asyncComponentPrototype.render = function () {
      return this.props.children;
    };

    /**
     * Keeps track of the current owner.
     *
     * The current owner is the component who should own any components that are
     * currently being constructed.
     */
    var ReactCurrentOwner = {
      /**
       * @internal
       * @type {ReactComponent}
       */
      current: null
    };

    var hasOwnProperty = Object.prototype.hasOwnProperty;

    // The Symbol used to tag the ReactElement type. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

    var RESERVED_PROPS = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    };

    var specialPropKeyWarningShown;
    var specialPropRefWarningShown;

    function hasValidRef(config) {
      {
        if (hasOwnProperty.call(config, 'ref')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.ref !== undefined;
    }

    function hasValidKey(config) {
      {
        if (hasOwnProperty.call(config, 'key')) {
          var getter = Object.getOwnPropertyDescriptor(config, 'key').get;
          if (getter && getter.isReactWarning) {
            return false;
          }
        }
      }
      return config.key !== undefined;
    }

    function defineKeyPropWarningGetter(props, displayName) {
      var warnAboutAccessingKey = function warnAboutAccessingKey() {
        if (!specialPropKeyWarningShown) {
          specialPropKeyWarningShown = true;
          warning(false, '%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingKey.isReactWarning = true;
      Object.defineProperty(props, 'key', {
        get: warnAboutAccessingKey,
        configurable: true
      });
    }

    function defineRefPropWarningGetter(props, displayName) {
      var warnAboutAccessingRef = function warnAboutAccessingRef() {
        if (!specialPropRefWarningShown) {
          specialPropRefWarningShown = true;
          warning(false, '%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://fb.me/react-special-props)', displayName);
        }
      };
      warnAboutAccessingRef.isReactWarning = true;
      Object.defineProperty(props, 'ref', {
        get: warnAboutAccessingRef,
        configurable: true
      });
    }

    /**
     * Factory method to create a new React element. This no longer adheres to
     * the class pattern, so do not use new to call it. Also, no instanceof check
     * will work. Instead test $$typeof field against Symbol.for('react.element') to check
     * if something is a React Element.
     *
     * @param {*} type
     * @param {*} key
     * @param {string|object} ref
     * @param {*} self A *temporary* helper to detect places where `this` is
     * different from the `owner` when React.createElement is called, so that we
     * can warn. We want to get rid of owner and replace string `ref`s with arrow
     * functions, and as long as `this` and owner are the same, there will be no
     * change in behavior.
     * @param {*} source An annotation object (added by a transpiler or otherwise)
     * indicating filename, line number, and/or other information.
     * @param {*} owner
     * @param {*} props
     * @internal
     */
    var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
      var element = {
        // This tag allow us to uniquely identify this as a React Element
        $$typeof: REACT_ELEMENT_TYPE$1,

        // Built-in properties that belong on the element
        type: type,
        key: key,
        ref: ref,
        props: props,

        // Record the component responsible for creating this element.
        _owner: owner
      };

      {
        // The validation flag is currently mutative. We put it on
        // an external backing store so that we can freeze the whole object.
        // This can be replaced with a WeakMap once they are implemented in
        // commonly used development environments.
        element._store = {};

        // To make comparing ReactElements easier for testing purposes, we make
        // the validation flag non-enumerable (where possible, which should
        // include every environment we run tests in), so the test framework
        // ignores it.
        Object.defineProperty(element._store, 'validated', {
          configurable: false,
          enumerable: false,
          writable: true,
          value: false
        });
        // self and source are DEV only properties.
        Object.defineProperty(element, '_self', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: self
        });
        // Two elements created in two different places should be considered
        // equal for testing purposes and therefore we hide it from enumeration.
        Object.defineProperty(element, '_source', {
          configurable: false,
          enumerable: false,
          writable: false,
          value: source
        });
        if (Object.freeze) {
          Object.freeze(element.props);
          Object.freeze(element);
        }
      }

      return element;
    };

    /**
     * Create and return a new ReactElement of the given type.
     * See https://reactjs.org/docs/react-api.html#createelement
     */
    function createElement(type, config, children) {
      var propName;

      // Reserved names are extracted
      var props = {};

      var key = null;
      var ref = null;
      var self = null;
      var source = null;

      if (config != null) {
        if (hasValidRef(config)) {
          ref = config.ref;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        self = config.__self === undefined ? null : config.__self;
        source = config.__source === undefined ? null : config.__source;
        // Remaining properties are added to a new props object
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            props[propName] = config[propName];
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        {
          if (Object.freeze) {
            Object.freeze(childArray);
          }
        }
        props.children = childArray;
      }

      // Resolve default props
      if (type && type.defaultProps) {
        var defaultProps = type.defaultProps;
        for (propName in defaultProps) {
          if (props[propName] === undefined) {
            props[propName] = defaultProps[propName];
          }
        }
      }
      {
        if (key || ref) {
          if (typeof props.$$typeof === 'undefined' || props.$$typeof !== REACT_ELEMENT_TYPE$1) {
            var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
      }
      return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
    }

    /**
     * Return a function that produces ReactElements of a given type.
     * See https://reactjs.org/docs/react-api.html#createfactory
     */

    function cloneAndReplaceKey(oldElement, newKey) {
      var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

      return newElement;
    }

    /**
     * Clone and return a new ReactElement using element as the starting point.
     * See https://reactjs.org/docs/react-api.html#cloneelement
     */
    function cloneElement(element, config, children) {
      var propName;

      // Original props are copied
      var props = _assign({}, element.props);

      // Reserved names are extracted
      var key = element.key;
      var ref = element.ref;
      // Self is preserved since the owner is preserved.
      var self = element._self;
      // Source is preserved since cloneElement is unlikely to be targeted by a
      // transpiler, and the original source is probably a better indicator of the
      // true owner.
      var source = element._source;

      // Owner will be preserved, unless ref is overridden
      var owner = element._owner;

      if (config != null) {
        if (hasValidRef(config)) {
          // Silently steal the ref from the parent.
          ref = config.ref;
          owner = ReactCurrentOwner.current;
        }
        if (hasValidKey(config)) {
          key = '' + config.key;
        }

        // Remaining properties override existing props
        var defaultProps;
        if (element.type && element.type.defaultProps) {
          defaultProps = element.type.defaultProps;
        }
        for (propName in config) {
          if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
            if (config[propName] === undefined && defaultProps !== undefined) {
              // Resolve default props
              props[propName] = defaultProps[propName];
            } else {
              props[propName] = config[propName];
            }
          }
        }
      }

      // Children can be more than one argument, and those are transferred onto
      // the newly allocated props object.
      var childrenLength = arguments.length - 2;
      if (childrenLength === 1) {
        props.children = children;
      } else if (childrenLength > 1) {
        var childArray = Array(childrenLength);
        for (var i = 0; i < childrenLength; i++) {
          childArray[i] = arguments[i + 2];
        }
        props.children = childArray;
      }

      return ReactElement(element.type, key, ref, self, source, owner, props);
    }

    /**
     * Verifies the object is a ReactElement.
     * See https://reactjs.org/docs/react-api.html#isvalidelement
     * @param {?object} object
     * @return {boolean} True if `object` is a valid component.
     * @final
     */
    function isValidElement(object) {
      return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE$1;
    }

    var ReactDebugCurrentFrame = {};

    {
      // Component that is being worked on
      ReactDebugCurrentFrame.getCurrentStack = null;

      ReactDebugCurrentFrame.getStackAddendum = function () {
        var impl = ReactDebugCurrentFrame.getCurrentStack;
        if (impl) {
          return impl();
        }
        return null;
      };
    }

    var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    // The Symbol used to tag the ReactElement type. If there is no native Symbol
    // nor polyfill, then a plain number is used for performance.
    var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
    var REACT_PORTAL_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.portal') || 0xeaca;
    var SEPARATOR = '.';
    var SUBSEPARATOR = ':';

    /**
     * Escape and wrap key so it is safe to use as a reactid
     *
     * @param {string} key to be escaped.
     * @return {string} the escaped key.
     */
    function escape(key) {
      var escapeRegex = /[=:]/g;
      var escaperLookup = {
        '=': '=0',
        ':': '=2'
      };
      var escapedString = ('' + key).replace(escapeRegex, function (match) {
        return escaperLookup[match];
      });

      return '$' + escapedString;
    }

    /**
     * TODO: Test that a single child and an array with one item have the same key
     * pattern.
     */

    var didWarnAboutMaps = false;

    var userProvidedKeyEscapeRegex = /\/+/g;
    function escapeUserProvidedKey(text) {
      return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
    }

    var POOL_SIZE = 10;
    var traverseContextPool = [];
    function getPooledTraverseContext(mapResult, keyPrefix, mapFunction, mapContext) {
      if (traverseContextPool.length) {
        var traverseContext = traverseContextPool.pop();
        traverseContext.result = mapResult;
        traverseContext.keyPrefix = keyPrefix;
        traverseContext.func = mapFunction;
        traverseContext.context = mapContext;
        traverseContext.count = 0;
        return traverseContext;
      } else {
        return {
          result: mapResult,
          keyPrefix: keyPrefix,
          func: mapFunction,
          context: mapContext,
          count: 0
        };
      }
    }

    function releaseTraverseContext(traverseContext) {
      traverseContext.result = null;
      traverseContext.keyPrefix = null;
      traverseContext.func = null;
      traverseContext.context = null;
      traverseContext.count = 0;
      if (traverseContextPool.length < POOL_SIZE) {
        traverseContextPool.push(traverseContext);
      }
    }

    /**
     * @param {?*} children Children tree container.
     * @param {!string} nameSoFar Name of the key path so far.
     * @param {!function} callback Callback to invoke with each child found.
     * @param {?*} traverseContext Used to pass information throughout the traversal
     * process.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
      var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);

      if (type === 'undefined' || type === 'boolean') {
        // All of the above are perceived as null.
        children = null;
      }

      if (children === null || type === 'string' || type === 'number' ||
      // The following is inlined from ReactElement. This means we can optimize
      // some checks. React Fiber also inlines this logic for similar purposes.
      type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE || type === 'object' && children.$$typeof === REACT_PORTAL_TYPE) {
        callback(traverseContext, children,
        // If it's the only child, treat the name as if it was wrapped in an array
        // so that it's consistent if the number of children grows.
        nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
        return 1;
      }

      var child;
      var nextName;
      var subtreeCount = 0; // Count of children found in the current subtree.
      var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

      if (Array.isArray(children)) {
        for (var i = 0; i < children.length; i++) {
          child = children[i];
          nextName = nextNamePrefix + getComponentKey(child, i);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        var iteratorFn = ITERATOR_SYMBOL && children[ITERATOR_SYMBOL] || children[FAUX_ITERATOR_SYMBOL];
        if (typeof iteratorFn === 'function') {
          {
            // Warn about using Maps as children
            if (iteratorFn === children.entries) {
              warning(didWarnAboutMaps, 'Using Maps as children is unsupported and will likely yield ' + 'unexpected results. Convert it to a sequence/iterable of keyed ' + 'ReactElements instead.%s', ReactDebugCurrentFrame.getStackAddendum());
              didWarnAboutMaps = true;
            }
          }

          var iterator = iteratorFn.call(children);
          var step;
          var ii = 0;
          while (!(step = iterator.next()).done) {
            child = step.value;
            nextName = nextNamePrefix + getComponentKey(child, ii++);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        } else if (type === 'object') {
          var addendum = '';
          {
            addendum = ' If you meant to render a collection of children, use an array ' + 'instead.' + ReactDebugCurrentFrame.getStackAddendum();
          }
          var childrenString = '' + children;
          invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
        }
      }

      return subtreeCount;
    }

    /**
     * Traverses children that are typically specified as `props.children`, but
     * might also be specified through attributes:
     *
     * - `traverseAllChildren(this.props.children, ...)`
     * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
     *
     * The `traverseContext` is an optional argument that is passed through the
     * entire traversal. It can be used to store accumulations or anything else that
     * the callback might find relevant.
     *
     * @param {?*} children Children tree object.
     * @param {!function} callback To invoke upon traversing each child.
     * @param {?*} traverseContext Context for traversal.
     * @return {!number} The number of children in this subtree.
     */
    function traverseAllChildren(children, callback, traverseContext) {
      if (children == null) {
        return 0;
      }

      return traverseAllChildrenImpl(children, '', callback, traverseContext);
    }

    /**
     * Generate a key string that identifies a component within a set.
     *
     * @param {*} component A component that could contain a manual key.
     * @param {number} index Index that is used if a manual key is not provided.
     * @return {string}
     */
    function getComponentKey(component, index) {
      // Do some typechecking here since we call this blindly. We want to ensure
      // that we don't block potential future ES APIs.
      if ((typeof component === 'undefined' ? 'undefined' : _typeof(component)) === 'object' && component !== null && component.key != null) {
        // Explicit key
        return escape(component.key);
      }
      // Implicit key determined by the index in the set
      return index.toString(36);
    }

    function forEachSingleChild(bookKeeping, child, name) {
      var func = bookKeeping.func,
          context = bookKeeping.context;

      func.call(context, child, bookKeeping.count++);
    }

    /**
     * Iterates through children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.foreach
     *
     * The provided forEachFunc(child, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} forEachFunc
     * @param {*} forEachContext Context for forEachContext.
     */
    function forEachChildren(children, forEachFunc, forEachContext) {
      if (children == null) {
        return children;
      }
      var traverseContext = getPooledTraverseContext(null, null, forEachFunc, forEachContext);
      traverseAllChildren(children, forEachSingleChild, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    function mapSingleChildIntoContext(bookKeeping, child, childKey) {
      var result = bookKeeping.result,
          keyPrefix = bookKeeping.keyPrefix,
          func = bookKeeping.func,
          context = bookKeeping.context;

      var mappedChild = func.call(context, child, bookKeeping.count++);
      if (Array.isArray(mappedChild)) {
        mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
      } else if (mappedChild != null) {
        if (isValidElement(mappedChild)) {
          mappedChild = cloneAndReplaceKey(mappedChild,
          // Keep both the (mapped) and old keys if they differ, just as
          // traverseAllChildren used to do for objects as children
          keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
        }
        result.push(mappedChild);
      }
    }

    function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
      var escapedPrefix = '';
      if (prefix != null) {
        escapedPrefix = escapeUserProvidedKey(prefix) + '/';
      }
      var traverseContext = getPooledTraverseContext(array, escapedPrefix, func, context);
      traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
      releaseTraverseContext(traverseContext);
    }

    /**
     * Maps children that are typically specified as `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.map
     *
     * The provided mapFunction(child, key, index) will be called for each
     * leaf child.
     *
     * @param {?*} children Children tree container.
     * @param {function(*, int)} func The map function.
     * @param {*} context Context for mapFunction.
     * @return {object} Object containing the ordered map of results.
     */
    function mapChildren(children, func, context) {
      if (children == null) {
        return children;
      }
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, func, context);
      return result;
    }

    /**
     * Count the number of children that are typically specified as
     * `props.children`.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.count
     *
     * @param {?*} children Children tree container.
     * @return {number} The number of children.
     */
    function countChildren(children, context) {
      return traverseAllChildren(children, emptyFunction.thatReturnsNull, null);
    }

    /**
     * Flatten a children object (typically specified as `props.children`) and
     * return an array with appropriately re-keyed children.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.toarray
     */
    function toArray(children) {
      var result = [];
      mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
      return result;
    }

    /**
     * Returns the first child in a collection of children and verifies that there
     * is only one child in the collection.
     *
     * See https://reactjs.org/docs/react-api.html#react.children.only
     *
     * The current implementation of this function assumes that a single child gets
     * passed without a wrapper, but the purpose of this helper function is to
     * abstract away the particular structure of children.
     *
     * @param {?object} children Child collection structure.
     * @return {ReactElement} The first and only `ReactElement` contained in the
     * structure.
     */
    function onlyChild(children) {
      !isValidElement(children) ? invariant(false, 'React.Children.only expected to receive a single React element child.') : void 0;
      return children;
    }

    var describeComponentFrame = function describeComponentFrame(name, source, ownerName) {
      return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
    };

    function getComponentName(fiber) {
      var type = fiber.type;

      if (typeof type === 'string') {
        return type;
      }
      if (typeof type === 'function') {
        return type.displayName || type.name;
      }
      return null;
    }

    /**
     * ReactElementValidator provides a wrapper around a element factory
     * which validates the props passed to the element. This is intended to be
     * used only in DEV and could be replaced by a static type checker for languages
     * that support it.
     */

    {
      var currentlyValidatingElement = null;

      var getDisplayName = function getDisplayName(element) {
        if (element == null) {
          return '#empty';
        } else if (typeof element === 'string' || typeof element === 'number') {
          return '#text';
        } else if (typeof element.type === 'string') {
          return element.type;
        } else if (element.type === REACT_FRAGMENT_TYPE$1) {
          return 'React.Fragment';
        } else {
          return element.type.displayName || element.type.name || 'Unknown';
        }
      };

      var getStackAddendum = function getStackAddendum() {
        var stack = '';
        if (currentlyValidatingElement) {
          var name = getDisplayName(currentlyValidatingElement);
          var owner = currentlyValidatingElement._owner;
          stack += describeComponentFrame(name, currentlyValidatingElement._source, owner && getComponentName(owner));
        }
        stack += ReactDebugCurrentFrame.getStackAddendum() || '';
        return stack;
      };

      var REACT_FRAGMENT_TYPE$1 = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

      var VALID_FRAGMENT_PROPS = new Map([['children', true], ['key', true]]);
    }

    var ITERATOR_SYMBOL$1 = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL$1 = '@@iterator'; // Before Symbol spec.

    function getDeclarationErrorAddendum() {
      if (ReactCurrentOwner.current) {
        var name = getComponentName(ReactCurrentOwner.current);
        if (name) {
          return '\n\nCheck the render method of `' + name + '`.';
        }
      }
      return '';
    }

    function getSourceInfoErrorAddendum(elementProps) {
      if (elementProps !== null && elementProps !== undefined && elementProps.__source !== undefined) {
        var source = elementProps.__source;
        var fileName = source.fileName.replace(/^.*[\\\/]/, '');
        var lineNumber = source.lineNumber;
        return '\n\nCheck your code at ' + fileName + ':' + lineNumber + '.';
      }
      return '';
    }

    /**
     * Warn if there's no key explicitly set on dynamic arrays of children or
     * object keys are not valid. This allows us to keep track of children between
     * updates.
     */
    var ownerHasKeyUseWarning = {};

    function getCurrentComponentErrorInfo(parentType) {
      var info = getDeclarationErrorAddendum();

      if (!info) {
        var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
        if (parentName) {
          info = '\n\nCheck the top-level render call using <' + parentName + '>.';
        }
      }
      return info;
    }

    /**
     * Warn if the element doesn't have an explicit key assigned to it.
     * This element is in an array. The array could grow and shrink or be
     * reordered. All children that haven't already been validated are required to
     * have a "key" property assigned to it. Error statuses are cached so a warning
     * will only be shown once.
     *
     * @internal
     * @param {ReactElement} element Element that requires a key.
     * @param {*} parentType element's parent's type.
     */
    function validateExplicitKey(element, parentType) {
      if (!element._store || element._store.validated || element.key != null) {
        return;
      }
      element._store.validated = true;

      var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
      if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
        return;
      }
      ownerHasKeyUseWarning[currentComponentErrorInfo] = true;

      // Usually the current owner is the offender, but if it accepts children as a
      // property, it may be the creator of the child that's responsible for
      // assigning it a key.
      var childOwner = '';
      if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
        // Give the component that originally created this child.
        childOwner = ' It was passed a child from ' + getComponentName(element._owner) + '.';
      }

      currentlyValidatingElement = element;
      {
        warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s See https://fb.me/react-warning-keys for more information.%s', currentComponentErrorInfo, childOwner, getStackAddendum());
      }
      currentlyValidatingElement = null;
    }

    /**
     * Ensure that every element either is passed in a static location, in an
     * array with an explicit keys property defined, or in an object literal
     * with valid key property.
     *
     * @internal
     * @param {ReactNode} node Statically passed child of any type.
     * @param {*} parentType node's parent's type.
     */
    function validateChildKeys(node, parentType) {
      if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
        return;
      }
      if (Array.isArray(node)) {
        for (var i = 0; i < node.length; i++) {
          var child = node[i];
          if (isValidElement(child)) {
            validateExplicitKey(child, parentType);
          }
        }
      } else if (isValidElement(node)) {
        // This element was passed in a valid location.
        if (node._store) {
          node._store.validated = true;
        }
      } else if (node) {
        var iteratorFn = ITERATOR_SYMBOL$1 && node[ITERATOR_SYMBOL$1] || node[FAUX_ITERATOR_SYMBOL$1];
        if (typeof iteratorFn === 'function') {
          // Entry iterators used to provide implicit keys,
          // but now we print a separate warning for them later.
          if (iteratorFn !== node.entries) {
            var iterator = iteratorFn.call(node);
            var step;
            while (!(step = iterator.next()).done) {
              if (isValidElement(step.value)) {
                validateExplicitKey(step.value, parentType);
              }
            }
          }
        }
      }
    }

    /**
     * Given an element, validate that its props follow the propTypes definition,
     * provided by the type.
     *
     * @param {ReactElement} element
     */
    function validatePropTypes(element) {
      var componentClass = element.type;
      if (typeof componentClass !== 'function') {
        return;
      }
      var name = componentClass.displayName || componentClass.name;
      var propTypes = componentClass.propTypes;

      if (propTypes) {
        currentlyValidatingElement = element;
        checkPropTypes(propTypes, element.props, 'prop', name, getStackAddendum);
        currentlyValidatingElement = null;
      }
      if (typeof componentClass.getDefaultProps === 'function') {
        warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');
      }
    }

    /**
     * Given a fragment, validate that it can only be provided with fragment props
     * @param {ReactElement} fragment
     */
    function validateFragmentProps(fragment) {
      currentlyValidatingElement = fragment;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = Object.keys(fragment.props)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var key = _step.value;

          if (!VALID_FRAGMENT_PROPS.has(key)) {
            warning(false, 'Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.%s', key, getStackAddendum());
            break;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator['return']) {
            _iterator['return']();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (fragment.ref !== null) {
        warning(false, 'Invalid attribute `ref` supplied to `React.Fragment`.%s', getStackAddendum());
      }

      currentlyValidatingElement = null;
    }

    function createElementWithValidation(type, props, children) {
      var validType = typeof type === 'string' || typeof type === 'function' || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' || typeof type === 'number';
      // We warn in this case but don't throw. We expect the element creation to
      // succeed and there will likely be errors in render.
      if (!validType) {
        var info = '';
        if (type === undefined || (typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'object' && type !== null && Object.keys(type).length === 0) {
          info += ' You likely forgot to export your component from the file ' + "it's defined in.";
        }

        var sourceInfo = getSourceInfoErrorAddendum(props);
        if (sourceInfo) {
          info += sourceInfo;
        } else {
          info += getDeclarationErrorAddendum();
        }

        info += getStackAddendum() || '';

        warning(false, 'React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', type == null ? type : typeof type === 'undefined' ? 'undefined' : _typeof(type), info);
      }

      var element = createElement.apply(this, arguments);

      // The result can be nullish if a mock or a custom function is used.
      // TODO: Drop this when these are no longer allowed as the type argument.
      if (element == null) {
        return element;
      }

      // Skip key warning if the type isn't valid since our key validation logic
      // doesn't expect a non-string/function type and can throw confusing errors.
      // We don't want exception behavior to differ between dev and prod.
      // (Rendering will throw with a helpful message and as soon as the type is
      // fixed, the key warnings will appear.)
      if (validType) {
        for (var i = 2; i < arguments.length; i++) {
          validateChildKeys(arguments[i], type);
        }
      }

      if ((typeof type === 'undefined' ? 'undefined' : _typeof(type)) === 'symbol' && type === REACT_FRAGMENT_TYPE$1) {
        validateFragmentProps(element);
      } else {
        validatePropTypes(element);
      }

      return element;
    }

    function createFactoryWithValidation(type) {
      var validatedFactory = createElementWithValidation.bind(null, type);
      // Legacy hook TODO: Warn if this is accessed
      validatedFactory.type = type;

      {
        Object.defineProperty(validatedFactory, 'type', {
          enumerable: false,
          get: function get() {
            lowPriorityWarning$1(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');
            Object.defineProperty(this, 'type', {
              value: type
            });
            return type;
          }
        });
      }

      return validatedFactory;
    }

    function cloneElementWithValidation(element, props, children) {
      var newElement = cloneElement.apply(this, arguments);
      for (var i = 2; i < arguments.length; i++) {
        validateChildKeys(arguments[i], newElement.type);
      }
      validatePropTypes(newElement);
      return newElement;
    }

    var REACT_FRAGMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.fragment') || 0xeacb;

    var React = {
      Children: {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray: toArray,
        only: onlyChild
      },

      Component: Component,
      PureComponent: PureComponent,
      unstable_AsyncComponent: AsyncComponent,

      createElement: createElementWithValidation,
      cloneElement: cloneElementWithValidation,
      createFactory: createFactoryWithValidation,
      isValidElement: isValidElement,

      version: ReactVersion,

      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
        ReactCurrentOwner: ReactCurrentOwner,
        // Used by renderers to avoid bundling object-assign twice in UMD bundles:
        assign: _assign
      }
    };

    if (enableReactFragment) {
      React.Fragment = REACT_FRAGMENT_TYPE;
    }

    {
      _assign(React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, {
        // These should not be included in production.
        ReactDebugCurrentFrame: ReactDebugCurrentFrame,
        // Shim for React DOM 16.0.0 which still destructured (but not used) this.
        // TODO: remove in React 17.0.
        ReactComponentTreeHook: {}
      });
    }

    var React$2 = Object.freeze({
      default: React
    });

    var React$3 = React$2 && React || React$2;

    // TODO: decide on the top-level export form.
    // This is hacky but makes it work with both Rollup and Jest.
    var react = React$3['default'] ? React$3['default'] : React$3;

    module.exports = react;
  })();
}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/** @license React v16.1.0
 * react-dom.production.min.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
/*
 Modernizr 3.0.0pre (Custom Build) | MIT
*/


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var aa = __webpack_require__(0),
    m = __webpack_require__(12),
    A = __webpack_require__(4),
    B = __webpack_require__(3),
    ca = __webpack_require__(13),
    da = __webpack_require__(14),
    ea = __webpack_require__(15),
    ha = __webpack_require__(16),
    ia = __webpack_require__(17),
    C = __webpack_require__(6);
function D(a) {
  for (var b = arguments.length - 1, c = "Minified React error #" + a + "; visit http://facebook.github.io/react/docs/error-decoder.html?invariant\x3d" + a, d = 0; d < b; d++) {
    c += "\x26args[]\x3d" + encodeURIComponent(arguments[d + 1]);
  }b = Error(c + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.");b.name = "Invariant Violation";b.framesToPop = 1;throw b;
}aa ? void 0 : D("227");
var la = { children: !0, dangerouslySetInnerHTML: !0, defaultValue: !0, defaultChecked: !0, innerHTML: !0, suppressContentEditableWarning: !0, suppressHydrationWarning: !0, style: !0 };function qa(a, b) {
  return (a & b) === b;
}
var ra = { MUST_USE_PROPERTY: 1, HAS_BOOLEAN_VALUE: 4, HAS_NUMERIC_VALUE: 8, HAS_POSITIVE_NUMERIC_VALUE: 24, HAS_OVERLOADED_BOOLEAN_VALUE: 32, HAS_STRING_BOOLEAN_VALUE: 64, injectDOMPropertyConfig: function injectDOMPropertyConfig(a) {
    var b = ra,
        c = a.Properties || {},
        d = a.DOMAttributeNamespaces || {},
        e = a.DOMAttributeNames || {};a = a.DOMMutationMethods || {};for (var f in c) {
      sa.hasOwnProperty(f) ? D("48", f) : void 0;var g = f.toLowerCase(),
          k = c[f];g = { attributeName: g, attributeNamespace: null, propertyName: f, mutationMethod: null, mustUseProperty: qa(k, b.MUST_USE_PROPERTY),
        hasBooleanValue: qa(k, b.HAS_BOOLEAN_VALUE), hasNumericValue: qa(k, b.HAS_NUMERIC_VALUE), hasPositiveNumericValue: qa(k, b.HAS_POSITIVE_NUMERIC_VALUE), hasOverloadedBooleanValue: qa(k, b.HAS_OVERLOADED_BOOLEAN_VALUE), hasStringBooleanValue: qa(k, b.HAS_STRING_BOOLEAN_VALUE) };1 >= g.hasBooleanValue + g.hasNumericValue + g.hasOverloadedBooleanValue ? void 0 : D("50", f);e.hasOwnProperty(f) && (g.attributeName = e[f]);d.hasOwnProperty(f) && (g.attributeNamespace = d[f]);a.hasOwnProperty(f) && (g.mutationMethod = a[f]);sa[f] = g;
    }
  } },
    sa = {};
function ta(a, b) {
  if (la.hasOwnProperty(a) || 2 < a.length && ("o" === a[0] || "O" === a[0]) && ("n" === a[1] || "N" === a[1])) return !1;if (null === b) return !0;switch (typeof b === "undefined" ? "undefined" : _typeof(b)) {case "boolean":
      return la.hasOwnProperty(a) ? a = !0 : (b = ua(a)) ? a = b.hasBooleanValue || b.hasStringBooleanValue || b.hasOverloadedBooleanValue : (a = a.toLowerCase().slice(0, 5), a = "data-" === a || "aria-" === a), a;case "undefined":case "number":case "string":case "object":
      return !0;default:
      return !1;}
}function ua(a) {
  return sa.hasOwnProperty(a) ? sa[a] : null;
}
var va = ra,
    wa = va.MUST_USE_PROPERTY,
    H = va.HAS_BOOLEAN_VALUE,
    xa = va.HAS_NUMERIC_VALUE,
    ya = va.HAS_POSITIVE_NUMERIC_VALUE,
    za = va.HAS_STRING_BOOLEAN_VALUE,
    Aa = { Properties: { allowFullScreen: H, autoFocus: za, async: H, autoPlay: H, capture: H, checked: wa | H, cols: ya, contentEditable: za, controls: H, "default": H, defer: H, disabled: H, download: va.HAS_OVERLOADED_BOOLEAN_VALUE, draggable: za, formNoValidate: H, hidden: H, loop: H, multiple: wa | H, muted: wa | H, noValidate: H, open: H, playsInline: H, readOnly: H, required: H, reversed: H, rows: ya, rowSpan: xa,
    scoped: H, seamless: H, selected: wa | H, size: ya, start: xa, span: ya, spellCheck: za, style: 0, tabIndex: 0, itemScope: H, acceptCharset: 0, className: 0, htmlFor: 0, httpEquiv: 0, value: za }, DOMAttributeNames: { acceptCharset: "accept-charset", className: "class", htmlFor: "for", httpEquiv: "http-equiv" }, DOMMutationMethods: { value: function value(a, b) {
      if (null == b) return a.removeAttribute("value");"number" !== a.type || !1 === a.hasAttribute("value") ? a.setAttribute("value", "" + b) : a.validity && !a.validity.badInput && a.ownerDocument.activeElement !== a && a.setAttribute("value", "" + b);
    } } },
    Ba = va.HAS_STRING_BOOLEAN_VALUE,
    K = { xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace" },
    Ca = { Properties: { autoReverse: Ba, externalResourcesRequired: Ba, preserveAlpha: Ba }, DOMAttributeNames: { autoReverse: "autoReverse", externalResourcesRequired: "externalResourcesRequired", preserveAlpha: "preserveAlpha" }, DOMAttributeNamespaces: { xlinkActuate: K.xlink, xlinkArcrole: K.xlink, xlinkHref: K.xlink, xlinkRole: K.xlink, xlinkShow: K.xlink, xlinkTitle: K.xlink, xlinkType: K.xlink,
    xmlBase: K.xml, xmlLang: K.xml, xmlSpace: K.xml } },
    Da = /[\-\:]([a-z])/g;function Ea(a) {
  return a[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode x-height xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type xml:base xmlns:xlink xml:lang xml:space".split(" ").forEach(function (a) {
  var b = a.replace(Da, Ea);Ca.Properties[b] = 0;Ca.DOMAttributeNames[b] = a;
});va.injectDOMPropertyConfig(Aa);va.injectDOMPropertyConfig(Ca);
var N = { _caughtError: null, _hasCaughtError: !1, _rethrowError: null, _hasRethrowError: !1, injection: { injectErrorUtils: function injectErrorUtils(a) {
      "function" !== typeof a.invokeGuardedCallback ? D("197") : void 0;Ha = a.invokeGuardedCallback;
    } }, invokeGuardedCallback: function invokeGuardedCallback(a, b, c, d, e, f, g, k, h) {
    Ha.apply(N, arguments);
  }, invokeGuardedCallbackAndCatchFirstError: function invokeGuardedCallbackAndCatchFirstError(a, b, c, d, e, f, g, k, h) {
    N.invokeGuardedCallback.apply(this, arguments);if (N.hasCaughtError()) {
      var r = N.clearCaughtError();N._hasRethrowError || (N._hasRethrowError = !0, N._rethrowError = r);
    }
  }, rethrowCaughtError: function rethrowCaughtError() {
    return Ia.apply(N, arguments);
  }, hasCaughtError: function hasCaughtError() {
    return N._hasCaughtError;
  }, clearCaughtError: function clearCaughtError() {
    if (N._hasCaughtError) {
      var a = N._caughtError;N._caughtError = null;N._hasCaughtError = !1;return a;
    }D("198");
  } };function Ha(a, b, c, d, e, f, g, k, h) {
  N._hasCaughtError = !1;N._caughtError = null;var r = Array.prototype.slice.call(arguments, 3);try {
    b.apply(c, r);
  } catch (n) {
    N._caughtError = n, N._hasCaughtError = !0;
  }
}
function Ia() {
  if (N._hasRethrowError) {
    var a = N._rethrowError;N._rethrowError = null;N._hasRethrowError = !1;throw a;
  }
}var Ja = null,
    Ka = {};
function La() {
  if (Ja) for (var a in Ka) {
    var b = Ka[a],
        c = Ja.indexOf(a);-1 < c ? void 0 : D("96", a);if (!Ma[c]) {
      b.extractEvents ? void 0 : D("97", a);Ma[c] = b;c = b.eventTypes;for (var d in c) {
        var e = void 0;var f = c[d],
            g = b,
            k = d;Na.hasOwnProperty(k) ? D("99", k) : void 0;Na[k] = f;var h = f.phasedRegistrationNames;if (h) {
          for (e in h) {
            h.hasOwnProperty(e) && Oa(h[e], g, k);
          }e = !0;
        } else f.registrationName ? (Oa(f.registrationName, g, k), e = !0) : e = !1;e ? void 0 : D("98", d, a);
      }
    }
  }
}
function Oa(a, b, c) {
  Pa[a] ? D("100", a) : void 0;Pa[a] = b;Qa[a] = b.eventTypes[c].dependencies;
}var Ma = [],
    Na = {},
    Pa = {},
    Qa = {};function Ra(a) {
  Ja ? D("101") : void 0;Ja = Array.prototype.slice.call(a);La();
}function Sa(a) {
  var b = !1,
      c;for (c in a) {
    if (a.hasOwnProperty(c)) {
      var d = a[c];Ka.hasOwnProperty(c) && Ka[c] === d || (Ka[c] ? D("102", c) : void 0, Ka[c] = d, b = !0);
    }
  }b && La();
}
var Ta = Object.freeze({ plugins: Ma, eventNameDispatchConfigs: Na, registrationNameModules: Pa, registrationNameDependencies: Qa, possibleRegistrationNames: null, injectEventPluginOrder: Ra, injectEventPluginsByName: Sa }),
    Ua = null,
    Va = null,
    Wa = null;function Xa(a, b, c, d) {
  b = a.type || "unknown-event";a.currentTarget = Wa(d);N.invokeGuardedCallbackAndCatchFirstError(b, c, void 0, a);a.currentTarget = null;
}
function Ya(a, b) {
  null == b ? D("30") : void 0;if (null == a) return b;if (Array.isArray(a)) {
    if (Array.isArray(b)) return a.push.apply(a, b), a;a.push(b);return a;
  }return Array.isArray(b) ? [a].concat(b) : [a, b];
}function Za(a, b, c) {
  Array.isArray(a) ? a.forEach(b, c) : a && b.call(c, a);
}var $a = null;
function ab(a, b) {
  if (a) {
    var c = a._dispatchListeners,
        d = a._dispatchInstances;if (Array.isArray(c)) for (var e = 0; e < c.length && !a.isPropagationStopped(); e++) {
      Xa(a, b, c[e], d[e]);
    } else c && Xa(a, b, c, d);a._dispatchListeners = null;a._dispatchInstances = null;a.isPersistent() || a.constructor.release(a);
  }
}function bb(a) {
  return ab(a, !0);
}function cb(a) {
  return ab(a, !1);
}var db = { injectEventPluginOrder: Ra, injectEventPluginsByName: Sa };
function eb(a, b) {
  var c = a.stateNode;if (!c) return null;var d = Ua(c);if (!d) return null;c = d[b];a: switch (b) {case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":
      (d = !d.disabled) || (a = a.type, d = !("button" === a || "input" === a || "select" === a || "textarea" === a));a = !d;break a;default:
      a = !1;}if (a) return null;c && "function" !== typeof c ? D("231", b, typeof c === "undefined" ? "undefined" : _typeof(c)) : void 0;
  return c;
}function jb(a, b, c, d) {
  for (var e, f = 0; f < Ma.length; f++) {
    var g = Ma[f];g && (g = g.extractEvents(a, b, c, d)) && (e = Ya(e, g));
  }return e;
}function kb(a) {
  a && ($a = Ya($a, a));
}function lb(a) {
  var b = $a;$a = null;a ? Za(b, bb) : Za(b, cb);$a ? D("95") : void 0;N.rethrowCaughtError();
}var mb = Object.freeze({ injection: db, getListener: eb, extractEvents: jb, enqueueEvents: kb, processEventQueue: lb }),
    nb = Math.random().toString(36).slice(2),
    O = "__reactInternalInstance$" + nb,
    ob = "__reactEventHandlers$" + nb;
function pb(a) {
  if (a[O]) return a[O];for (var b = []; !a[O];) {
    if (b.push(a), a.parentNode) a = a.parentNode;else return null;
  }var c = void 0,
      d = a[O];if (5 === d.tag || 6 === d.tag) return d;for (; a && (d = a[O]); a = b.pop()) {
    c = d;
  }return c;
}function qb(a) {
  if (5 === a.tag || 6 === a.tag) return a.stateNode;D("33");
}function rb(a) {
  return a[ob] || null;
}
var sb = Object.freeze({ precacheFiberNode: function precacheFiberNode(a, b) {
    b[O] = a;
  }, getClosestInstanceFromNode: pb, getInstanceFromNode: function getInstanceFromNode(a) {
    a = a[O];return !a || 5 !== a.tag && 6 !== a.tag ? null : a;
  }, getNodeFromInstance: qb, getFiberCurrentPropsFromNode: rb, updateFiberProps: function updateFiberProps(a, b) {
    a[ob] = b;
  } });function Q(a) {
  do {
    a = a["return"];
  } while (a && 5 !== a.tag);return a ? a : null;
}function tb(a, b, c) {
  for (var d = []; a;) {
    d.push(a), a = Q(a);
  }for (a = d.length; 0 < a--;) {
    b(d[a], "captured", c);
  }for (a = 0; a < d.length; a++) {
    b(d[a], "bubbled", c);
  }
}
function ub(a, b, c) {
  if (b = eb(a, c.dispatchConfig.phasedRegistrationNames[b])) c._dispatchListeners = Ya(c._dispatchListeners, b), c._dispatchInstances = Ya(c._dispatchInstances, a);
}function vb(a) {
  a && a.dispatchConfig.phasedRegistrationNames && tb(a._targetInst, ub, a);
}function wb(a) {
  if (a && a.dispatchConfig.phasedRegistrationNames) {
    var b = a._targetInst;b = b ? Q(b) : null;tb(b, ub, a);
  }
}
function xb(a, b, c) {
  a && c && c.dispatchConfig.registrationName && (b = eb(a, c.dispatchConfig.registrationName)) && (c._dispatchListeners = Ya(c._dispatchListeners, b), c._dispatchInstances = Ya(c._dispatchInstances, a));
}function yb(a) {
  a && a.dispatchConfig.registrationName && xb(a._targetInst, null, a);
}function zb(a) {
  Za(a, vb);
}
function Ab(a, b, c, d) {
  if (c && d) a: {
    var e = c;for (var f = d, g = 0, k = e; k; k = Q(k)) {
      g++;
    }k = 0;for (var h = f; h; h = Q(h)) {
      k++;
    }for (; 0 < g - k;) {
      e = Q(e), g--;
    }for (; 0 < k - g;) {
      f = Q(f), k--;
    }for (; g--;) {
      if (e === f || e === f.alternate) break a;e = Q(e);f = Q(f);
    }e = null;
  } else e = null;f = e;for (e = []; c && c !== f;) {
    g = c.alternate;if (null !== g && g === f) break;e.push(c);c = Q(c);
  }for (c = []; d && d !== f;) {
    g = d.alternate;if (null !== g && g === f) break;c.push(d);d = Q(d);
  }for (d = 0; d < e.length; d++) {
    xb(e[d], "bubbled", a);
  }for (a = c.length; 0 < a--;) {
    xb(c[a], "captured", b);
  }
}
var Bb = Object.freeze({ accumulateTwoPhaseDispatches: zb, accumulateTwoPhaseDispatchesSkipTarget: function accumulateTwoPhaseDispatchesSkipTarget(a) {
    Za(a, wb);
  }, accumulateEnterLeaveDispatches: Ab, accumulateDirectDispatches: function accumulateDirectDispatches(a) {
    Za(a, yb);
  } }),
    Cb = null;function Db() {
  !Cb && m.canUseDOM && (Cb = "textContent" in document.documentElement ? "textContent" : "innerText");return Cb;
}var R = { _root: null, _startText: null, _fallbackText: null };
function Eb() {
  if (R._fallbackText) return R._fallbackText;var a,
      b = R._startText,
      c = b.length,
      d,
      e = Fb(),
      f = e.length;for (a = 0; a < c && b[a] === e[a]; a++) {}var g = c - a;for (d = 1; d <= g && b[c - d] === e[f - d]; d++) {}R._fallbackText = e.slice(a, 1 < d ? 1 - d : void 0);return R._fallbackText;
}function Fb() {
  return "value" in R._root ? R._root.value : R._root[Db()];
}
var Gb = "dispatchConfig _targetInst nativeEvent isDefaultPrevented isPropagationStopped _dispatchListeners _dispatchInstances".split(" "),
    Hb = { type: null, target: null, currentTarget: B.thatReturnsNull, eventPhase: null, bubbles: null, cancelable: null, timeStamp: function timeStamp(a) {
    return a.timeStamp || Date.now();
  }, defaultPrevented: null, isTrusted: null };
function S(a, b, c, d) {
  this.dispatchConfig = a;this._targetInst = b;this.nativeEvent = c;a = this.constructor.Interface;for (var e in a) {
    a.hasOwnProperty(e) && ((b = a[e]) ? this[e] = b(c) : "target" === e ? this.target = d : this[e] = c[e]);
  }this.isDefaultPrevented = (null != c.defaultPrevented ? c.defaultPrevented : !1 === c.returnValue) ? B.thatReturnsTrue : B.thatReturnsFalse;this.isPropagationStopped = B.thatReturnsFalse;return this;
}
A(S.prototype, { preventDefault: function preventDefault() {
    this.defaultPrevented = !0;var a = this.nativeEvent;a && (a.preventDefault ? a.preventDefault() : "unknown" !== typeof a.returnValue && (a.returnValue = !1), this.isDefaultPrevented = B.thatReturnsTrue);
  }, stopPropagation: function stopPropagation() {
    var a = this.nativeEvent;a && (a.stopPropagation ? a.stopPropagation() : "unknown" !== typeof a.cancelBubble && (a.cancelBubble = !0), this.isPropagationStopped = B.thatReturnsTrue);
  }, persist: function persist() {
    this.isPersistent = B.thatReturnsTrue;
  }, isPersistent: B.thatReturnsFalse,
  destructor: function destructor() {
    var a = this.constructor.Interface,
        b;for (b in a) {
      this[b] = null;
    }for (a = 0; a < Gb.length; a++) {
      this[Gb[a]] = null;
    }
  } });S.Interface = Hb;S.augmentClass = function (a, b) {
  function c() {}c.prototype = this.prototype;var d = new c();A(d, a.prototype);a.prototype = d;a.prototype.constructor = a;a.Interface = A({}, this.Interface, b);a.augmentClass = this.augmentClass;Ib(a);
};Ib(S);function Jb(a, b, c, d) {
  if (this.eventPool.length) {
    var e = this.eventPool.pop();this.call(e, a, b, c, d);return e;
  }return new this(a, b, c, d);
}
function Qb(a) {
  a instanceof this ? void 0 : D("223");a.destructor();10 > this.eventPool.length && this.eventPool.push(a);
}function Ib(a) {
  a.eventPool = [];a.getPooled = Jb;a.release = Qb;
}function Rb(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Rb, { data: null });function Sb(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Sb, { data: null });var Tb = [9, 13, 27, 32],
    Ub = m.canUseDOM && "CompositionEvent" in window,
    Vb = null;m.canUseDOM && "documentMode" in document && (Vb = document.documentMode);var Wb;
if (Wb = m.canUseDOM && "TextEvent" in window && !Vb) {
  var Xb = window.opera;Wb = !("object" === (typeof Xb === "undefined" ? "undefined" : _typeof(Xb)) && "function" === typeof Xb.version && 12 >= parseInt(Xb.version(), 10));
}
var Yb = Wb,
    Zb = m.canUseDOM && (!Ub || Vb && 8 < Vb && 11 >= Vb),
    $b = String.fromCharCode(32),
    ac = { beforeInput: { phasedRegistrationNames: { bubbled: "onBeforeInput", captured: "onBeforeInputCapture" }, dependencies: ["topCompositionEnd", "topKeyPress", "topTextInput", "topPaste"] }, compositionEnd: { phasedRegistrationNames: { bubbled: "onCompositionEnd", captured: "onCompositionEndCapture" }, dependencies: "topBlur topCompositionEnd topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionStart: { phasedRegistrationNames: { bubbled: "onCompositionStart",
      captured: "onCompositionStartCapture" }, dependencies: "topBlur topCompositionStart topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") }, compositionUpdate: { phasedRegistrationNames: { bubbled: "onCompositionUpdate", captured: "onCompositionUpdateCapture" }, dependencies: "topBlur topCompositionUpdate topKeyDown topKeyPress topKeyUp topMouseDown".split(" ") } },
    bc = !1;
function cc(a, b) {
  switch (a) {case "topKeyUp":
      return -1 !== Tb.indexOf(b.keyCode);case "topKeyDown":
      return 229 !== b.keyCode;case "topKeyPress":case "topMouseDown":case "topBlur":
      return !0;default:
      return !1;}
}function dc(a) {
  a = a.detail;return "object" === (typeof a === "undefined" ? "undefined" : _typeof(a)) && "data" in a ? a.data : null;
}var ec = !1;function fc(a, b) {
  switch (a) {case "topCompositionEnd":
      return dc(b);case "topKeyPress":
      if (32 !== b.which) return null;bc = !0;return $b;case "topTextInput":
      return a = b.data, a === $b && bc ? null : a;default:
      return null;}
}
function gc(a, b) {
  if (ec) return "topCompositionEnd" === a || !Ub && cc(a, b) ? (a = Eb(), R._root = null, R._startText = null, R._fallbackText = null, ec = !1, a) : null;switch (a) {case "topPaste":
      return null;case "topKeyPress":
      if (!(b.ctrlKey || b.altKey || b.metaKey) || b.ctrlKey && b.altKey) {
        if (b.char && 1 < b.char.length) return b.char;if (b.which) return String.fromCharCode(b.which);
      }return null;case "topCompositionEnd":
      return Zb ? null : b.data;default:
      return null;}
}
var hc = { eventTypes: ac, extractEvents: function extractEvents(a, b, c, d) {
    var e;if (Ub) b: {
      switch (a) {case "topCompositionStart":
          var f = ac.compositionStart;break b;case "topCompositionEnd":
          f = ac.compositionEnd;break b;case "topCompositionUpdate":
          f = ac.compositionUpdate;break b;}f = void 0;
    } else ec ? cc(a, c) && (f = ac.compositionEnd) : "topKeyDown" === a && 229 === c.keyCode && (f = ac.compositionStart);f ? (Zb && (ec || f !== ac.compositionStart ? f === ac.compositionEnd && ec && (e = Eb()) : (R._root = d, R._startText = Fb(), ec = !0)), f = Rb.getPooled(f, b, c, d), e ? f.data = e : (e = dc(c), null !== e && (f.data = e)), zb(f), e = f) : e = null;(a = Yb ? fc(a, c) : gc(a, c)) ? (b = Sb.getPooled(ac.beforeInput, b, c, d), b.data = a, zb(b)) : b = null;return [e, b];
  } },
    ic = null,
    jc = null,
    kc = null;function lc(a) {
  if (a = Va(a)) {
    ic && "function" === typeof ic.restoreControlledState ? void 0 : D("194");var b = Ua(a.stateNode);ic.restoreControlledState(a.stateNode, a.type, b);
  }
}var mc = { injectFiberControlledHostComponent: function injectFiberControlledHostComponent(a) {
    ic = a;
  } };function nc(a) {
  jc ? kc ? kc.push(a) : kc = [a] : jc = a;
}
function oc() {
  if (jc) {
    var a = jc,
        b = kc;kc = jc = null;lc(a);if (b) for (a = 0; a < b.length; a++) {
      lc(b[a]);
    }
  }
}var pc = Object.freeze({ injection: mc, enqueueStateRestore: nc, restoreStateIfNeeded: oc });function qc(a, b) {
  return a(b);
}var rc = !1;function sc(a, b) {
  if (rc) return qc(a, b);rc = !0;try {
    return qc(a, b);
  } finally {
    rc = !1, oc();
  }
}var tc = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
function uc(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return "input" === b ? !!tc[a.type] : "textarea" === b ? !0 : !1;
}function vc(a) {
  a = a.target || a.srcElement || window;a.correspondingUseElement && (a = a.correspondingUseElement);return 3 === a.nodeType ? a.parentNode : a;
}var wc;m.canUseDOM && (wc = document.implementation && document.implementation.hasFeature && !0 !== document.implementation.hasFeature("", ""));
function xc(a, b) {
  if (!m.canUseDOM || b && !("addEventListener" in document)) return !1;b = "on" + a;var c = b in document;c || (c = document.createElement("div"), c.setAttribute(b, "return;"), c = "function" === typeof c[b]);!c && wc && "wheel" === a && (c = document.implementation.hasFeature("Events.wheel", "3.0"));return c;
}function yc(a) {
  var b = a.type;return (a = a.nodeName) && "input" === a.toLowerCase() && ("checkbox" === b || "radio" === b);
}
function zc(a) {
  var b = yc(a) ? "checked" : "value",
      c = Object.getOwnPropertyDescriptor(a.constructor.prototype, b),
      d = "" + a[b];if (!a.hasOwnProperty(b) && "function" === typeof c.get && "function" === typeof c.set) return Object.defineProperty(a, b, { enumerable: c.enumerable, configurable: !0, get: function get() {
      return c.get.call(this);
    }, set: function set(a) {
      d = "" + a;c.set.call(this, a);
    } }), { getValue: function getValue() {
      return d;
    }, setValue: function setValue(a) {
      d = "" + a;
    }, stopTracking: function stopTracking() {
      a._valueTracker = null;delete a[b];
    } };
}
function Ac(a) {
  a._valueTracker || (a._valueTracker = zc(a));
}function Bc(a) {
  if (!a) return !1;var b = a._valueTracker;if (!b) return !0;var c = b.getValue();var d = "";a && (d = yc(a) ? a.checked ? "true" : "false" : a.value);a = d;return a !== c ? (b.setValue(a), !0) : !1;
}var Cc = { change: { phasedRegistrationNames: { bubbled: "onChange", captured: "onChangeCapture" }, dependencies: "topBlur topChange topClick topFocus topInput topKeyDown topKeyUp topSelectionChange".split(" ") } };
function Dc(a, b, c) {
  a = S.getPooled(Cc.change, a, b, c);a.type = "change";nc(c);zb(a);return a;
}var Ec = null,
    Fc = null;function Gc(a) {
  kb(a);lb(!1);
}function Hc(a) {
  var b = qb(a);if (Bc(b)) return a;
}function Ic(a, b) {
  if ("topChange" === a) return b;
}var Jc = !1;m.canUseDOM && (Jc = xc("input") && (!document.documentMode || 9 < document.documentMode));function Qc() {
  Ec && (Ec.detachEvent("onpropertychange", Rc), Fc = Ec = null);
}function Rc(a) {
  "value" === a.propertyName && Hc(Fc) && (a = Dc(Fc, a, vc(a)), sc(Gc, a));
}
function Sc(a, b, c) {
  "topFocus" === a ? (Qc(), Ec = b, Fc = c, Ec.attachEvent("onpropertychange", Rc)) : "topBlur" === a && Qc();
}function Tc(a) {
  if ("topSelectionChange" === a || "topKeyUp" === a || "topKeyDown" === a) return Hc(Fc);
}function Uc(a, b) {
  if ("topClick" === a) return Hc(b);
}function Vc(a, b) {
  if ("topInput" === a || "topChange" === a) return Hc(b);
}
var Wc = { eventTypes: Cc, _isInputEventSupported: Jc, extractEvents: function extractEvents(a, b, c, d) {
    var e = b ? qb(b) : window,
        f = e.nodeName && e.nodeName.toLowerCase();if ("select" === f || "input" === f && "file" === e.type) var g = Ic;else if (uc(e)) {
      if (Jc) g = Vc;else {
        g = Tc;var k = Sc;
      }
    } else f = e.nodeName, !f || "input" !== f.toLowerCase() || "checkbox" !== e.type && "radio" !== e.type || (g = Uc);if (g && (g = g(a, b))) return Dc(g, c, d);k && k(a, e, b);"topBlur" === a && null != b && (a = b._wrapperState || e._wrapperState) && a.controlled && "number" === e.type && (a = "" + e.value, e.getAttribute("value") !== a && e.setAttribute("value", a));
  } };function Xc(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Xc, { view: null, detail: null });var Yc = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };function Zc(a) {
  var b = this.nativeEvent;return b.getModifierState ? b.getModifierState(a) : (a = Yc[a]) ? !!b[a] : !1;
}function $c() {
  return Zc;
}function ad(a, b, c, d) {
  return S.call(this, a, b, c, d);
}
Xc.augmentClass(ad, { screenX: null, screenY: null, clientX: null, clientY: null, pageX: null, pageY: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, getModifierState: $c, button: null, buttons: null, relatedTarget: function relatedTarget(a) {
    return a.relatedTarget || (a.fromElement === a.srcElement ? a.toElement : a.fromElement);
  } });
var bd = { mouseEnter: { registrationName: "onMouseEnter", dependencies: ["topMouseOut", "topMouseOver"] }, mouseLeave: { registrationName: "onMouseLeave", dependencies: ["topMouseOut", "topMouseOver"] } },
    cd = { eventTypes: bd, extractEvents: function extractEvents(a, b, c, d) {
    if ("topMouseOver" === a && (c.relatedTarget || c.fromElement) || "topMouseOut" !== a && "topMouseOver" !== a) return null;var e = d.window === d ? d : (e = d.ownerDocument) ? e.defaultView || e.parentWindow : window;"topMouseOut" === a ? (a = b, b = (b = c.relatedTarget || c.toElement) ? pb(b) : null) : a = null;if (a === b) return null;var f = null == a ? e : qb(a);e = null == b ? e : qb(b);var g = ad.getPooled(bd.mouseLeave, a, c, d);g.type = "mouseleave";g.target = f;g.relatedTarget = e;c = ad.getPooled(bd.mouseEnter, b, c, d);c.type = "mouseenter";c.target = e;c.relatedTarget = f;Ab(g, c, a, b);return [g, c];
  } },
    dd = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner;function ed(a) {
  a = a.type;return "string" === typeof a ? a : "function" === typeof a ? a.displayName || a.name : null;
}
function fd(a) {
  var b = a;if (a.alternate) for (; b["return"];) {
    b = b["return"];
  } else {
    if (0 !== (b.effectTag & 2)) return 1;for (; b["return"];) {
      if (b = b["return"], 0 !== (b.effectTag & 2)) return 1;
    }
  }return 3 === b.tag ? 2 : 3;
}function gd(a) {
  return (a = a._reactInternalFiber) ? 2 === fd(a) : !1;
}function hd(a) {
  2 !== fd(a) ? D("188") : void 0;
}
function id(a) {
  var b = a.alternate;if (!b) return b = fd(a), 3 === b ? D("188") : void 0, 1 === b ? null : a;for (var c = a, d = b;;) {
    var e = c["return"],
        f = e ? e.alternate : null;if (!e || !f) break;if (e.child === f.child) {
      for (var g = e.child; g;) {
        if (g === c) return hd(e), a;if (g === d) return hd(e), b;g = g.sibling;
      }D("188");
    }if (c["return"] !== d["return"]) c = e, d = f;else {
      g = !1;for (var k = e.child; k;) {
        if (k === c) {
          g = !0;c = e;d = f;break;
        }if (k === d) {
          g = !0;d = e;c = f;break;
        }k = k.sibling;
      }if (!g) {
        for (k = f.child; k;) {
          if (k === c) {
            g = !0;c = f;d = e;break;
          }if (k === d) {
            g = !0;d = f;c = e;break;
          }k = k.sibling;
        }g ? void 0 : D("189");
      }
    }c.alternate !== d ? D("190") : void 0;
  }3 !== c.tag ? D("188") : void 0;return c.stateNode.current === c ? a : b;
}function jd(a) {
  a = id(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}
function kd(a) {
  a = id(a);if (!a) return null;for (var b = a;;) {
    if (5 === b.tag || 6 === b.tag) return b;if (b.child && 4 !== b.tag) b.child["return"] = b, b = b.child;else {
      if (b === a) break;for (; !b.sibling;) {
        if (!b["return"] || b["return"] === a) return null;b = b["return"];
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }return null;
}var ld = [];
function md(a) {
  var b = a.targetInst;do {
    if (!b) {
      a.ancestors.push(b);break;
    }var c;for (c = b; c["return"];) {
      c = c["return"];
    }c = 3 !== c.tag ? null : c.stateNode.containerInfo;if (!c) break;a.ancestors.push(b);b = pb(c);
  } while (b);for (c = 0; c < a.ancestors.length; c++) {
    b = a.ancestors[c], nd(a.topLevelType, b, a.nativeEvent, vc(a.nativeEvent));
  }
}var od = !0,
    nd = void 0;function pd(a) {
  od = !!a;
}function U(a, b, c) {
  return c ? ca.listen(c, b, qd.bind(null, a)) : null;
}function rd(a, b, c) {
  return c ? ca.capture(c, b, qd.bind(null, a)) : null;
}
function qd(a, b) {
  if (od) {
    var c = vc(b);c = pb(c);null === c || "number" !== typeof c.tag || 2 === fd(c) || (c = null);if (ld.length) {
      var d = ld.pop();d.topLevelType = a;d.nativeEvent = b;d.targetInst = c;a = d;
    } else a = { topLevelType: a, nativeEvent: b, targetInst: c, ancestors: [] };try {
      sc(md, a);
    } finally {
      a.topLevelType = null, a.nativeEvent = null, a.targetInst = null, a.ancestors.length = 0, 10 > ld.length && ld.push(a);
    }
  }
}
var sd = Object.freeze({ get _enabled() {
    return od;
  }, get _handleTopLevel() {
    return nd;
  }, setHandleTopLevel: function setHandleTopLevel(a) {
    nd = a;
  }, setEnabled: pd, isEnabled: function isEnabled() {
    return od;
  }, trapBubbledEvent: U, trapCapturedEvent: rd, dispatchEvent: qd });function td(a, b) {
  var c = {};c[a.toLowerCase()] = b.toLowerCase();c["Webkit" + a] = "webkit" + b;c["Moz" + a] = "moz" + b;c["ms" + a] = "MS" + b;c["O" + a] = "o" + b.toLowerCase();return c;
}
var ud = { animationend: td("Animation", "AnimationEnd"), animationiteration: td("Animation", "AnimationIteration"), animationstart: td("Animation", "AnimationStart"), transitionend: td("Transition", "TransitionEnd") },
    vd = {},
    wd = {};m.canUseDOM && (wd = document.createElement("div").style, "AnimationEvent" in window || (delete ud.animationend.animation, delete ud.animationiteration.animation, delete ud.animationstart.animation), "TransitionEvent" in window || delete ud.transitionend.transition);
function xd(a) {
  if (vd[a]) return vd[a];if (!ud[a]) return a;var b = ud[a],
      c;for (c in b) {
    if (b.hasOwnProperty(c) && c in wd) return vd[a] = b[c];
  }return "";
}
var yd = { topAbort: "abort", topAnimationEnd: xd("animationend") || "animationend", topAnimationIteration: xd("animationiteration") || "animationiteration", topAnimationStart: xd("animationstart") || "animationstart", topBlur: "blur", topCancel: "cancel", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topChange: "change", topClick: "click", topClose: "close", topCompositionEnd: "compositionend", topCompositionStart: "compositionstart", topCompositionUpdate: "compositionupdate", topContextMenu: "contextmenu", topCopy: "copy",
  topCut: "cut", topDoubleClick: "dblclick", topDrag: "drag", topDragEnd: "dragend", topDragEnter: "dragenter", topDragExit: "dragexit", topDragLeave: "dragleave", topDragOver: "dragover", topDragStart: "dragstart", topDrop: "drop", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topFocus: "focus", topInput: "input", topKeyDown: "keydown", topKeyPress: "keypress", topKeyUp: "keyup", topLoadedData: "loadeddata", topLoad: "load", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart",
  topMouseDown: "mousedown", topMouseMove: "mousemove", topMouseOut: "mouseout", topMouseOver: "mouseover", topMouseUp: "mouseup", topPaste: "paste", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topScroll: "scroll", topSeeked: "seeked", topSeeking: "seeking", topSelectionChange: "selectionchange", topStalled: "stalled", topSuspend: "suspend", topTextInput: "textInput", topTimeUpdate: "timeupdate", topToggle: "toggle", topTouchCancel: "touchcancel", topTouchEnd: "touchend", topTouchMove: "touchmove",
  topTouchStart: "touchstart", topTransitionEnd: xd("transitionend") || "transitionend", topVolumeChange: "volumechange", topWaiting: "waiting", topWheel: "wheel" },
    zd = {},
    Ad = 0,
    Bd = "_reactListenersID" + ("" + Math.random()).slice(2);function Cd(a) {
  Object.prototype.hasOwnProperty.call(a, Bd) || (a[Bd] = Ad++, zd[a[Bd]] = {});return zd[a[Bd]];
}function Dd(a) {
  for (; a && a.firstChild;) {
    a = a.firstChild;
  }return a;
}
function Ed(a, b) {
  var c = Dd(a);a = 0;for (var d; c;) {
    if (3 === c.nodeType) {
      d = a + c.textContent.length;if (a <= b && d >= b) return { node: c, offset: b - a };a = d;
    }a: {
      for (; c;) {
        if (c.nextSibling) {
          c = c.nextSibling;break a;
        }c = c.parentNode;
      }c = void 0;
    }c = Dd(c);
  }
}function Fd(a) {
  var b = a && a.nodeName && a.nodeName.toLowerCase();return b && ("input" === b && "text" === a.type || "textarea" === b || "true" === a.contentEditable);
}
var Gd = m.canUseDOM && "documentMode" in document && 11 >= document.documentMode,
    Hd = { select: { phasedRegistrationNames: { bubbled: "onSelect", captured: "onSelectCapture" }, dependencies: "topBlur topContextMenu topFocus topKeyDown topKeyUp topMouseDown topMouseUp topSelectionChange".split(" ") } },
    Id = null,
    Jd = null,
    Kd = null,
    Ld = !1;
function Md(a, b) {
  if (Ld || null == Id || Id !== da()) return null;var c = Id;"selectionStart" in c && Fd(c) ? c = { start: c.selectionStart, end: c.selectionEnd } : window.getSelection ? (c = window.getSelection(), c = { anchorNode: c.anchorNode, anchorOffset: c.anchorOffset, focusNode: c.focusNode, focusOffset: c.focusOffset }) : c = void 0;return Kd && ea(Kd, c) ? null : (Kd = c, a = S.getPooled(Hd.select, Jd, a, b), a.type = "select", a.target = Id, zb(a), a);
}
var Nd = { eventTypes: Hd, extractEvents: function extractEvents(a, b, c, d) {
    var e = d.window === d ? d.document : 9 === d.nodeType ? d : d.ownerDocument,
        f;if (!(f = !e)) {
      a: {
        e = Cd(e);f = Qa.onSelect;for (var g = 0; g < f.length; g++) {
          var k = f[g];if (!e.hasOwnProperty(k) || !e[k]) {
            e = !1;break a;
          }
        }e = !0;
      }f = !e;
    }if (f) return null;e = b ? qb(b) : window;switch (a) {case "topFocus":
        if (uc(e) || "true" === e.contentEditable) Id = e, Jd = b, Kd = null;break;case "topBlur":
        Kd = Jd = Id = null;break;case "topMouseDown":
        Ld = !0;break;case "topContextMenu":case "topMouseUp":
        return Ld = !1, Md(c, d);case "topSelectionChange":
        if (Gd) break;
      case "topKeyDown":case "topKeyUp":
        return Md(c, d);}return null;
  } };function Od(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Od, { animationName: null, elapsedTime: null, pseudoElement: null });function Pd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Pd, { clipboardData: function clipboardData(a) {
    return "clipboardData" in a ? a.clipboardData : window.clipboardData;
  } });function Qd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}Xc.augmentClass(Qd, { relatedTarget: null });
function Rd(a) {
  var b = a.keyCode;"charCode" in a ? (a = a.charCode, 0 === a && 13 === b && (a = 13)) : a = b;return 32 <= a || 13 === a ? a : 0;
}
var Sd = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" },
    Td = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4",
  116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" };function Ud(a, b, c, d) {
  return S.call(this, a, b, c, d);
}
Xc.augmentClass(Ud, { key: function key(a) {
    if (a.key) {
      var b = Sd[a.key] || a.key;if ("Unidentified" !== b) return b;
    }return "keypress" === a.type ? (a = Rd(a), 13 === a ? "Enter" : String.fromCharCode(a)) : "keydown" === a.type || "keyup" === a.type ? Td[a.keyCode] || "Unidentified" : "";
  }, location: null, ctrlKey: null, shiftKey: null, altKey: null, metaKey: null, repeat: null, locale: null, getModifierState: $c, charCode: function charCode(a) {
    return "keypress" === a.type ? Rd(a) : 0;
  }, keyCode: function keyCode(a) {
    return "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  }, which: function which(a) {
    return "keypress" === a.type ? Rd(a) : "keydown" === a.type || "keyup" === a.type ? a.keyCode : 0;
  } });function Vd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}ad.augmentClass(Vd, { dataTransfer: null });function Wd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}Xc.augmentClass(Wd, { touches: null, targetTouches: null, changedTouches: null, altKey: null, metaKey: null, ctrlKey: null, shiftKey: null, getModifierState: $c });function Xd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}S.augmentClass(Xd, { propertyName: null, elapsedTime: null, pseudoElement: null });
function Yd(a, b, c, d) {
  return S.call(this, a, b, c, d);
}ad.augmentClass(Yd, { deltaX: function deltaX(a) {
    return "deltaX" in a ? a.deltaX : "wheelDeltaX" in a ? -a.wheelDeltaX : 0;
  }, deltaY: function deltaY(a) {
    return "deltaY" in a ? a.deltaY : "wheelDeltaY" in a ? -a.wheelDeltaY : "wheelDelta" in a ? -a.wheelDelta : 0;
  }, deltaZ: null, deltaMode: null });var Zd = {},
    $d = {};
"abort animationEnd animationIteration animationStart blur cancel canPlay canPlayThrough click close contextMenu copy cut doubleClick drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error focus input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing progress rateChange reset scroll seeked seeking stalled submit suspend timeUpdate toggle touchCancel touchEnd touchMove touchStart transitionEnd volumeChange waiting wheel".split(" ").forEach(function (a) {
  var b = a[0].toUpperCase() + a.slice(1),
      c = "on" + b;b = "top" + b;c = { phasedRegistrationNames: { bubbled: c, captured: c + "Capture" }, dependencies: [b] };Zd[a] = c;$d[b] = c;
});
var ae = { eventTypes: Zd, extractEvents: function extractEvents(a, b, c, d) {
    var e = $d[a];if (!e) return null;switch (a) {case "topKeyPress":
        if (0 === Rd(c)) return null;case "topKeyDown":case "topKeyUp":
        a = Ud;break;case "topBlur":case "topFocus":
        a = Qd;break;case "topClick":
        if (2 === c.button) return null;case "topDoubleClick":case "topMouseDown":case "topMouseMove":case "topMouseUp":case "topMouseOut":case "topMouseOver":case "topContextMenu":
        a = ad;break;case "topDrag":case "topDragEnd":case "topDragEnter":case "topDragExit":case "topDragLeave":case "topDragOver":case "topDragStart":case "topDrop":
        a = Vd;break;case "topTouchCancel":case "topTouchEnd":case "topTouchMove":case "topTouchStart":
        a = Wd;break;case "topAnimationEnd":case "topAnimationIteration":case "topAnimationStart":
        a = Od;break;case "topTransitionEnd":
        a = Xd;break;case "topScroll":
        a = Xc;break;case "topWheel":
        a = Yd;break;case "topCopy":case "topCut":case "topPaste":
        a = Pd;break;default:
        a = S;}b = a.getPooled(e, b, c, d);zb(b);return b;
  } };nd = function nd(a, b, c, d) {
  a = jb(a, b, c, d);kb(a);lb(!1);
};db.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin TapEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" "));
Ua = sb.getFiberCurrentPropsFromNode;Va = sb.getInstanceFromNode;Wa = sb.getNodeFromInstance;db.injectEventPluginsByName({ SimpleEventPlugin: ae, EnterLeaveEventPlugin: cd, ChangeEventPlugin: Wc, SelectEventPlugin: Nd, BeforeInputEventPlugin: hc });var be = [],
    ce = -1;function V(a) {
  0 > ce || (a.current = be[ce], be[ce] = null, ce--);
}function W(a, b) {
  ce++;be[ce] = a.current;a.current = b;
}new Set();var de = { current: C },
    X = { current: !1 },
    ee = C;function fe(a) {
  return ge(a) ? ee : de.current;
}
function he(a, b) {
  var c = a.type.contextTypes;if (!c) return C;var d = a.stateNode;if (d && d.__reactInternalMemoizedUnmaskedChildContext === b) return d.__reactInternalMemoizedMaskedChildContext;var e = {},
      f;for (f in c) {
    e[f] = b[f];
  }d && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = b, a.__reactInternalMemoizedMaskedChildContext = e);return e;
}function ge(a) {
  return 2 === a.tag && null != a.type.childContextTypes;
}function ie(a) {
  ge(a) && (V(X, a), V(de, a));
}
function je(a, b, c) {
  null != de.cursor ? D("168") : void 0;W(de, b, a);W(X, c, a);
}function ke(a, b) {
  var c = a.stateNode,
      d = a.type.childContextTypes;if ("function" !== typeof c.getChildContext) return b;c = c.getChildContext();for (var e in c) {
    e in d ? void 0 : D("108", ed(a) || "Unknown", e);
  }return A({}, b, c);
}function le(a) {
  if (!ge(a)) return !1;var b = a.stateNode;b = b && b.__reactInternalMemoizedMergedChildContext || C;ee = de.current;W(de, b, a);W(X, X.current, a);return !0;
}
function me(a, b) {
  var c = a.stateNode;c ? void 0 : D("169");if (b) {
    var d = ke(a, ee);c.__reactInternalMemoizedMergedChildContext = d;V(X, a);V(de, a);W(de, d, a);
  } else V(X, a);W(X, b, a);
}
function Y(a, b, c) {
  this.tag = a;this.key = b;this.stateNode = this.type = null;this.sibling = this.child = this["return"] = null;this.index = 0;this.memoizedState = this.updateQueue = this.memoizedProps = this.pendingProps = this.ref = null;this.internalContextTag = c;this.effectTag = 0;this.lastEffect = this.firstEffect = this.nextEffect = null;this.expirationTime = 0;this.alternate = null;
}
function ne(a, b, c) {
  var d = a.alternate;null === d ? (d = new Y(a.tag, a.key, a.internalContextTag), d.type = a.type, d.stateNode = a.stateNode, d.alternate = a, a.alternate = d) : (d.effectTag = 0, d.nextEffect = null, d.firstEffect = null, d.lastEffect = null);d.expirationTime = c;d.pendingProps = b;d.child = a.child;d.memoizedProps = a.memoizedProps;d.memoizedState = a.memoizedState;d.updateQueue = a.updateQueue;d.sibling = a.sibling;d.index = a.index;d.ref = a.ref;return d;
}
function oe(a, b, c) {
  var d = void 0,
      e = a.type,
      f = a.key;"function" === typeof e ? (d = e.prototype && e.prototype.isReactComponent ? new Y(2, f, b) : new Y(0, f, b), d.type = e, d.pendingProps = a.props) : "string" === typeof e ? (d = new Y(5, f, b), d.type = e, d.pendingProps = a.props) : "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e && "number" === typeof e.tag ? (d = e, d.pendingProps = a.props) : D("130", null == e ? e : typeof e === "undefined" ? "undefined" : _typeof(e), "");d.expirationTime = c;return d;
}function pe(a, b, c, d) {
  b = new Y(10, d, b);b.pendingProps = a;b.expirationTime = c;return b;
}
function qe(a, b, c) {
  b = new Y(6, null, b);b.pendingProps = a;b.expirationTime = c;return b;
}function re(a, b, c) {
  b = new Y(7, a.key, b);b.type = a.handler;b.pendingProps = a;b.expirationTime = c;return b;
}function se(a, b, c) {
  a = new Y(9, null, b);a.expirationTime = c;return a;
}function te(a, b, c) {
  b = new Y(4, a.key, b);b.pendingProps = a.children || [];b.expirationTime = c;b.stateNode = { containerInfo: a.containerInfo, pendingChildren: null, implementation: a.implementation };return b;
}var ue = null,
    ve = null;
function we(a) {
  return function (b) {
    try {
      return a(b);
    } catch (c) {}
  };
}function xe(a) {
  if ("undefined" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;var b = __REACT_DEVTOOLS_GLOBAL_HOOK__;if (b.isDisabled || !b.supportsFiber) return !0;try {
    var c = b.inject(a);ue = we(function (a) {
      return b.onCommitFiberRoot(c, a);
    });ve = we(function (a) {
      return b.onCommitFiberUnmount(c, a);
    });
  } catch (d) {}return !0;
}function ye(a) {
  "function" === typeof ue && ue(a);
}function ze(a) {
  "function" === typeof ve && ve(a);
}
function Ae(a) {
  return { baseState: a, expirationTime: 0, first: null, last: null, callbackList: null, hasForceUpdate: !1, isInitialized: !1 };
}function Be(a, b) {
  null === a.last ? a.first = a.last = b : (a.last.next = b, a.last = b);if (0 === a.expirationTime || a.expirationTime > b.expirationTime) a.expirationTime = b.expirationTime;
}
function Ce(a, b) {
  var c = a.alternate,
      d = a.updateQueue;null === d && (d = a.updateQueue = Ae(null));null !== c ? (a = c.updateQueue, null === a && (a = c.updateQueue = Ae(null))) : a = null;a = a !== d ? a : null;null === a ? Be(d, b) : null === d.last || null === a.last ? (Be(d, b), Be(a, b)) : (Be(d, b), a.last = b);
}function De(a, b, c, d) {
  a = a.partialState;return "function" === typeof a ? a.call(b, c, d) : a;
}
function Ke(a, b, c, d, e, f) {
  null !== a && a.updateQueue === c && (c = b.updateQueue = { baseState: c.baseState, expirationTime: c.expirationTime, first: c.first, last: c.last, isInitialized: c.isInitialized, callbackList: null, hasForceUpdate: !1 });c.expirationTime = 0;c.isInitialized ? a = c.baseState : (a = c.baseState = b.memoizedState, c.isInitialized = !0);for (var g = !0, k = c.first, h = !1; null !== k;) {
    var r = k.expirationTime;if (r > f) {
      var n = c.expirationTime;if (0 === n || n > r) c.expirationTime = r;h || (h = !0, c.baseState = a);
    } else {
      h || (c.first = k.next, null === c.first && (c.last = null));if (k.isReplace) a = De(k, d, a, e), g = !0;else if (r = De(k, d, a, e)) a = g ? A({}, a, r) : A(a, r), g = !1;k.isForced && (c.hasForceUpdate = !0);null !== k.callback && (r = c.callbackList, null === r && (r = c.callbackList = []), r.push(k));
    }k = k.next;
  }null !== c.callbackList ? b.effectTag |= 32 : null !== c.first || c.hasForceUpdate || (b.updateQueue = null);h || (c.baseState = a);return a;
}
function Le(a, b) {
  var c = a.callbackList;if (null !== c) for (a.callbackList = null, a = 0; a < c.length; a++) {
    var d = c[a],
        e = d.callback;d.callback = null;"function" !== typeof e ? D("191", e) : void 0;e.call(b);
  }
}
function Me(a, b, c, d) {
  function e(a, b) {
    b.updater = f;a.stateNode = b;b._reactInternalFiber = a;
  }var f = { isMounted: gd, enqueueSetState: function enqueueSetState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var g = b(c);Ce(c, { expirationTime: g, partialState: d, callback: e, isReplace: !1, isForced: !1, nextCallback: null, next: null });a(c, g);
    }, enqueueReplaceState: function enqueueReplaceState(c, d, e) {
      c = c._reactInternalFiber;e = void 0 === e ? null : e;var f = b(c);Ce(c, { expirationTime: f, partialState: d, callback: e, isReplace: !0, isForced: !1, nextCallback: null, next: null });
      a(c, f);
    }, enqueueForceUpdate: function enqueueForceUpdate(c, d) {
      c = c._reactInternalFiber;d = void 0 === d ? null : d;var e = b(c);Ce(c, { expirationTime: e, partialState: null, callback: d, isReplace: !1, isForced: !0, nextCallback: null, next: null });a(c, e);
    } };return { adoptClassInstance: e, constructClassInstance: function constructClassInstance(a, b) {
      var c = a.type,
          d = fe(a),
          f = 2 === a.tag && null != a.type.contextTypes,
          g = f ? he(a, d) : C;b = new c(b, g);e(a, b);f && (a = a.stateNode, a.__reactInternalMemoizedUnmaskedChildContext = d, a.__reactInternalMemoizedMaskedChildContext = g);return b;
    }, mountClassInstance: function mountClassInstance(a, b) {
      var c = a.alternate,
          d = a.stateNode,
          e = d.state || null,
          g = a.pendingProps;g ? void 0 : D("158");var k = fe(a);d.props = g;d.state = a.memoizedState = e;d.refs = C;d.context = he(a, k);null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent && (a.internalContextTag |= 1);"function" === typeof d.componentWillMount && (e = d.state, d.componentWillMount(), e !== d.state && f.enqueueReplaceState(d, d.state, null), e = a.updateQueue, null !== e && (d.state = Ke(c, a, e, d, g, b)));"function" === typeof d.componentDidMount && (a.effectTag |= 4);
    }, updateClassInstance: function updateClassInstance(a, b, e) {
      var g = b.stateNode;g.props = b.memoizedProps;g.state = b.memoizedState;var k = b.memoizedProps,
          h = b.pendingProps;h || (h = k, null == h ? D("159") : void 0);var u = g.context,
          x = fe(b);x = he(b, x);"function" !== typeof g.componentWillReceiveProps || k === h && u === x || (u = g.state, g.componentWillReceiveProps(h, x), g.state !== u && f.enqueueReplaceState(g, g.state, null));u = b.memoizedState;e = null !== b.updateQueue ? Ke(a, b, b.updateQueue, g, h, e) : u;if (!(k !== h || u !== e || X.current || null !== b.updateQueue && b.updateQueue.hasForceUpdate)) return "function" !== typeof g.componentDidUpdate || k === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), !1;var F = h;if (null === k || null !== b.updateQueue && b.updateQueue.hasForceUpdate) F = !0;else {
        var L = b.stateNode,
            G = b.type;F = "function" === typeof L.shouldComponentUpdate ? L.shouldComponentUpdate(F, e, x) : G.prototype && G.prototype.isPureReactComponent ? !ea(k, F) || !ea(u, e) : !0;
      }F ? ("function" === typeof g.componentWillUpdate && g.componentWillUpdate(h, e, x), "function" === typeof g.componentDidUpdate && (b.effectTag |= 4)) : ("function" !== typeof g.componentDidUpdate || k === a.memoizedProps && u === a.memoizedState || (b.effectTag |= 4), c(b, h), d(b, e));g.props = h;g.state = e;g.context = x;return F;
    } };
}var Ne = "function" === typeof Symbol && Symbol["for"] && Symbol["for"]("react.portal") || 60106;function Oe(a, b, c) {
  var d = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;return { $$typeof: Ne, key: null == d ? null : "" + d, children: a, containerInfo: b, implementation: c };
}var Pe = Array.isArray,
    Qe = "function" === typeof Symbol && Symbol.iterator,
    Re,
    Se,
    Te,
    Ue;
"function" === typeof Symbol && Symbol["for"] ? (Re = Symbol["for"]("react.element"), Se = Symbol["for"]("react.call"), Te = Symbol["for"]("react.return"), Ue = Symbol["for"]("react.fragment")) : (Re = 60103, Se = 60104, Te = 60105, Ue = 60107);function Ve(a) {
  if (null === a || "undefined" === typeof a) return null;a = Qe && a[Qe] || a["@@iterator"];return "function" === typeof a ? a : null;
}
function We(a, b) {
  var c = b.ref;if (null !== c && "function" !== typeof c) {
    if (b._owner) {
      b = b._owner;var d = void 0;b && (2 !== b.tag ? D("110") : void 0, d = b.stateNode);d ? void 0 : D("147", c);var e = "" + c;if (null !== a && null !== a.ref && a.ref._stringRef === e) return a.ref;a = function a(_a) {
        var b = d.refs === C ? d.refs = {} : d.refs;null === _a ? delete b[e] : b[e] = _a;
      };a._stringRef = e;return a;
    }"string" !== typeof c ? D("148") : void 0;b._owner ? void 0 : D("149", c);
  }return c;
}
function Xe(a, b) {
  "textarea" !== a.type && D("31", "[object Object]" === Object.prototype.toString.call(b) ? "object with keys {" + Object.keys(b).join(", ") + "}" : b, "");
}
function Ye(a, b) {
  function c(c, d) {
    if (b) {
      if (!a) {
        if (null === d.alternate) return;d = d.alternate;
      }var p = c.lastEffect;null !== p ? (p.nextEffect = d, c.lastEffect = d) : c.firstEffect = c.lastEffect = d;d.nextEffect = null;d.effectTag = 8;
    }
  }function d(a, d) {
    if (!b) return null;for (; null !== d;) {
      c(a, d), d = d.sibling;
    }return null;
  }function e(a, b) {
    for (a = new Map(); null !== b;) {
      null !== b.key ? a.set(b.key, b) : a.set(b.index, b), b = b.sibling;
    }return a;
  }function f(b, c, d) {
    if (a) return b = ne(b, c, d), b.index = 0, b.sibling = null, b;b.expirationTime = d;b.effectTag = 0;b.index = 0;b.sibling = null;b.pendingProps = c;return b;
  }function g(a, c, d) {
    a.index = d;if (!b) return c;d = a.alternate;if (null !== d) return d = d.index, d < c ? (a.effectTag = 2, c) : d;a.effectTag = 2;return c;
  }function k(a) {
    b && null === a.alternate && (a.effectTag = 2);return a;
  }function h(a, b, c, d) {
    if (null === b || 6 !== b.tag) return b = qe(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function r(a, b, c, d) {
    if (null !== b && b.type === c.type) return d = f(b, c.props, d), d.ref = We(b, c), d["return"] = a, d;d = oe(c, a.internalContextTag, d);
    d.ref = We(b, c);d["return"] = a;return d;
  }function n(a, b, c, d) {
    if (null === b || 7 !== b.tag) return b = re(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function y(a, b, c, d) {
    if (null === b || 9 !== b.tag) return b = se(c, a.internalContextTag, d), b.type = c.value, b["return"] = a, b;b = f(b, null, d);b.type = c.value;b["return"] = a;return b;
  }function u(a, b, c, d) {
    if (null === b || 4 !== b.tag || b.stateNode.containerInfo !== c.containerInfo || b.stateNode.implementation !== c.implementation) return b = te(c, a.internalContextTag, d), b["return"] = a, b;b = f(b, c.children || [], d);b["return"] = a;return b;
  }function x(a, b, c, d, e) {
    if (null === b || 10 !== b.tag) return b = pe(c, a.internalContextTag, d, e), b["return"] = a, b;b = f(b, c, d);b["return"] = a;return b;
  }function F(a, b, c) {
    if ("string" === typeof b || "number" === typeof b) return b = qe("" + b, a.internalContextTag, c), b["return"] = a, b;if ("object" === (typeof b === "undefined" ? "undefined" : _typeof(b)) && null !== b) {
      switch (b.$$typeof) {case Re:
          if (b.type === Ue) return b = pe(b.props.children, a.internalContextTag, c, b.key), b["return"] = a, b;c = oe(b, a.internalContextTag, c);
          c.ref = We(null, b);c["return"] = a;return c;case Se:
          return b = re(b, a.internalContextTag, c), b["return"] = a, b;case Te:
          return c = se(b, a.internalContextTag, c), c.type = b.value, c["return"] = a, c;case Ne:
          return b = te(b, a.internalContextTag, c), b["return"] = a, b;}if (Pe(b) || Ve(b)) return b = pe(b, a.internalContextTag, c, null), b["return"] = a, b;Xe(a, b);
    }return null;
  }function L(a, b, c, d) {
    var e = null !== b ? b.key : null;if ("string" === typeof c || "number" === typeof c) return null !== e ? null : h(a, b, "" + c, d);if ("object" === (typeof c === "undefined" ? "undefined" : _typeof(c)) && null !== c) {
      switch (c.$$typeof) {case Re:
          return c.key === e ? c.type === Ue ? x(a, b, c.props.children, d, e) : r(a, b, c, d) : null;case Se:
          return c.key === e ? n(a, b, c, d) : null;case Te:
          return null === e ? y(a, b, c, d) : null;case Ne:
          return c.key === e ? u(a, b, c, d) : null;}if (Pe(c) || Ve(c)) return null !== e ? null : x(a, b, c, d, null);Xe(a, c);
    }return null;
  }function G(a, b, c, d, e) {
    if ("string" === typeof d || "number" === typeof d) return a = a.get(c) || null, h(b, a, "" + d, e);if ("object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d) {
      switch (d.$$typeof) {case Re:
          return a = a.get(null === d.key ? c : d.key) || null, d.type === Ue ? x(b, a, d.props.children, e, d.key) : r(b, a, d, e);case Se:
          return a = a.get(null === d.key ? c : d.key) || null, n(b, a, d, e);case Te:
          return a = a.get(c) || null, y(b, a, d, e);case Ne:
          return a = a.get(null === d.key ? c : d.key) || null, u(b, a, d, e);}if (Pe(d) || Ve(d)) return a = a.get(c) || null, x(b, a, d, e, null);Xe(b, d);
    }return null;
  }function T(a, f, v, k) {
    for (var p = null, z = null, l = f, h = f = 0, t = null; null !== l && h < v.length; h++) {
      l.index > h ? (t = l, l = null) : t = l.sibling;var w = L(a, l, v[h], k);if (null === w) {
        null === l && (l = t);break;
      }b && l && null === w.alternate && c(a, l);f = g(w, f, h);null === z ? p = w : z.sibling = w;z = w;
      l = t;
    }if (h === v.length) return d(a, l), p;if (null === l) {
      for (; h < v.length; h++) {
        if (l = F(a, v[h], k)) f = g(l, f, h), null === z ? p = l : z.sibling = l, z = l;
      }return p;
    }for (l = e(a, l); h < v.length; h++) {
      if (t = G(l, a, h, v[h], k)) {
        if (b && null !== t.alternate) l["delete"](null === t.key ? h : t.key);f = g(t, f, h);null === z ? p = t : z.sibling = t;z = t;
      }
    }b && l.forEach(function (b) {
      return c(a, b);
    });return p;
  }function I(a, f, v, k) {
    var p = Ve(v);"function" !== typeof p ? D("150") : void 0;v = p.call(v);null == v ? D("151") : void 0;for (var h = p = null, l = f, z = f = 0, t = null, w = v.next(); null !== l && !w.done; z++, w = v.next()) {
      l.index > z ? (t = l, l = null) : t = l.sibling;var n = L(a, l, w.value, k);if (null === n) {
        l || (l = t);break;
      }b && l && null === n.alternate && c(a, l);f = g(n, f, z);null === h ? p = n : h.sibling = n;h = n;l = t;
    }if (w.done) return d(a, l), p;if (null === l) {
      for (; !w.done; z++, w = v.next()) {
        w = F(a, w.value, k), null !== w && (f = g(w, f, z), null === h ? p = w : h.sibling = w, h = w);
      }return p;
    }for (l = e(a, l); !w.done; z++, w = v.next()) {
      if (w = G(l, a, z, w.value, k), null !== w) {
        if (b && null !== w.alternate) l["delete"](null === w.key ? z : w.key);f = g(w, f, z);null === h ? p = w : h.sibling = w;h = w;
      }
    }b && l.forEach(function (b) {
      return c(a, b);
    });return p;
  }return function (a, b, e, g) {
    var h = "object" === (typeof e === "undefined" ? "undefined" : _typeof(e)) && null !== e;if (h) switch (e.$$typeof) {case Re:
        a: {
          var v = e.key;for (h = b; null !== h;) {
            if (h.key === v) {
              if (10 === h.tag ? e.type === Ue : h.type === e.type) {
                d(a, h.sibling);b = f(h, e.type === Ue ? e.props.children : e.props, g);b.ref = We(h, e);b["return"] = a;a = b;break a;
              } else {
                d(a, h);break;
              }
            } else c(a, h);h = h.sibling;
          }e.type === Ue ? (e = pe(e.props.children, a.internalContextTag, g, e.key), e["return"] = a, a = e) : (g = oe(e, a.internalContextTag, g), g.ref = We(b, e), g["return"] = a, a = g);
        }return k(a);
      case Se:
        a: {
          for (h = e.key; null !== b;) {
            if (b.key === h) {
              if (7 === b.tag) {
                d(a, b.sibling);e = f(b, e, g);e["return"] = a;a = e;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = re(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return k(a);case Te:
        a: {
          if (null !== b) if (9 === b.tag) {
            d(a, b.sibling);b = f(b, null, g);b.type = e.value;b["return"] = a;a = b;break a;
          } else d(a, b);b = se(e, a.internalContextTag, g);b.type = e.value;b["return"] = a;a = b;
        }return k(a);case Ne:
        a: {
          for (h = e.key; null !== b;) {
            if (b.key === h) {
              if (4 === b.tag && b.stateNode.containerInfo === e.containerInfo && b.stateNode.implementation === e.implementation) {
                d(a, b.sibling);e = f(b, e.children || [], g);e["return"] = a;a = e;break a;
              } else {
                d(a, b);break;
              }
            } else c(a, b);b = b.sibling;
          }e = te(e, a.internalContextTag, g);e["return"] = a;a = e;
        }return k(a);}if ("string" === typeof e || "number" === typeof e) return e = "" + e, null !== b && 6 === b.tag ? (d(a, b.sibling), e = f(b, e, g)) : (d(a, b), e = qe(e, a.internalContextTag, g)), e["return"] = a, a = e, k(a);if (Pe(e)) return T(a, b, e, g);if (Ve(e)) return I(a, b, e, g);h && Xe(a, e);if ("undefined" === typeof e) switch (a.tag) {case 2:case 1:
        e = a.type, D("152", e.displayName || e.name || "Component");}return d(a, b);
  };
}var Ze = Ye(!0, !0),
    $e = Ye(!1, !0),
    af = Ye(!1, !1);
function bf(a, b, c, d, e) {
  function f(a, b, c) {
    g(a, b, c, b.expirationTime);
  }function g(a, b, c, d) {
    b.child = null === a ? af(b, b.child, c, d) : a.child === b.child ? Ze(b, b.child, c, d) : $e(b, b.child, c, d);
  }function k(a, b) {
    var c = b.ref;null === c || a && a.ref === c || (b.effectTag |= 128);
  }function h(a, b, c, d) {
    k(a, b);if (!c) return d && me(b, !1), n(a, b);c = b.stateNode;dd.current = b;var e = c.render();b.effectTag |= 1;f(a, b, e);b.memoizedState = c.state;b.memoizedProps = c.props;d && me(b, !0);return b.child;
  }function r(a) {
    var b = a.stateNode;b.pendingContext ? je(a, b.pendingContext, b.pendingContext !== b.context) : b.context && je(a, b.context, !1);G(a, b.containerInfo);
  }function n(a, b) {
    null !== a && b.child !== a.child ? D("153") : void 0;if (null !== b.child) {
      a = b.child;var c = ne(a, a.pendingProps, a.expirationTime);b.child = c;for (c["return"] = b; null !== a.sibling;) {
        a = a.sibling, c = c.sibling = ne(a, a.pendingProps, a.expirationTime), c["return"] = b;
      }c.sibling = null;
    }return b.child;
  }function y(a, b) {
    switch (b.tag) {case 3:
        r(b);break;case 2:
        le(b);break;case 4:
        G(b, b.stateNode.containerInfo);}return null;
  }var u = a.shouldSetTextContent,
      x = a.useSyncScheduling,
      F = a.shouldDeprioritizeSubtree,
      L = b.pushHostContext,
      G = b.pushHostContainer,
      T = c.enterHydrationState,
      I = c.resetHydrationState,
      z = c.tryToClaimNextHydratableInstance;a = Me(d, e, function (a, b) {
    a.memoizedProps = b;
  }, function (a, b) {
    a.memoizedState = b;
  });var p = a.adoptClassInstance,
      v = a.constructClassInstance,
      t = a.mountClassInstance,
      Kb = a.updateClassInstance;return { beginWork: function beginWork(a, b, c) {
      if (0 === b.expirationTime || b.expirationTime > c) return y(a, b);switch (b.tag) {case 0:
          null !== a ? D("155") : void 0;var d = b.type,
              e = b.pendingProps,
              g = fe(b);g = he(b, g);d = d(e, g);b.effectTag |= 1;"object" === (typeof d === "undefined" ? "undefined" : _typeof(d)) && null !== d && "function" === typeof d.render ? (b.tag = 2, e = le(b), p(b, d), t(b, c), b = h(a, b, !0, e)) : (b.tag = 1, f(a, b, d), b.memoizedProps = e, b = b.child);return b;case 1:
          a: {
            e = b.type;c = b.pendingProps;d = b.memoizedProps;if (X.current) null === c && (c = d);else if (null === c || d === c) {
              b = n(a, b);break a;
            }d = fe(b);d = he(b, d);e = e(c, d);b.effectTag |= 1;f(a, b, e);b.memoizedProps = c;b = b.child;
          }return b;case 2:
          return e = le(b), d = void 0, null === a ? b.stateNode ? D("153") : (v(b, b.pendingProps), t(b, c), d = !0) : d = Kb(a, b, c), h(a, b, d, e);case 3:
          return r(b), e = b.updateQueue, null !== e ? (d = b.memoizedState, e = Ke(a, b, e, null, null, c), d === e ? (I(), b = n(a, b)) : (d = e.element, g = b.stateNode, (null === a || null === a.child) && g.hydrate && T(b) ? (b.effectTag |= 2, b.child = af(b, b.child, d, c)) : (I(), f(a, b, d)), b.memoizedState = e, b = b.child)) : (I(), b = n(a, b)), b;case 5:
          L(b);null === a && z(b);e = b.type;var l = b.memoizedProps;d = b.pendingProps;null === d && (d = l, null === d ? D("154") : void 0);g = null !== a ? a.memoizedProps : null;X.current || null !== d && l !== d ? (l = d.children, u(e, d) ? l = null : g && u(e, g) && (b.effectTag |= 16), k(a, b), 2147483647 !== c && !x && F(e, d) ? (b.expirationTime = 2147483647, b = null) : (f(a, b, l), b.memoizedProps = d, b = b.child)) : b = n(a, b);return b;case 6:
          return null === a && z(b), a = b.pendingProps, null === a && (a = b.memoizedProps), b.memoizedProps = a, null;case 8:
          b.tag = 7;case 7:
          e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null === e ? D("154") : void 0);else if (null === e || b.memoizedProps === e) e = b.memoizedProps;d = e.children;b.stateNode = null === a ? af(b, b.stateNode, d, c) : a.child === b.child ? Ze(b, b.stateNode, d, c) : $e(b, b.stateNode, d, c);b.memoizedProps = e;return b.stateNode;case 9:
          return null;case 4:
          a: {
            G(b, b.stateNode.containerInfo);e = b.pendingProps;if (X.current) null === e && (e = a && a.memoizedProps, null == e ? D("154") : void 0);else if (null === e || b.memoizedProps === e) {
              b = n(a, b);break a;
            }null === a ? b.child = $e(b, b.child, e, c) : f(a, b, e);b.memoizedProps = e;b = b.child;
          }return b;case 10:
          a: {
            c = b.pendingProps;if (X.current) null === c && (c = b.memoizedProps);else if (null === c || b.memoizedProps === c) {
              b = n(a, b);break a;
            }f(a, b, c);b.memoizedProps = c;b = b.child;
          }return b;default:
          D("156");}
    }, beginFailedWork: function beginFailedWork(a, b, c) {
      switch (b.tag) {case 2:
          le(b);break;case 3:
          r(b);break;default:
          D("157");}b.effectTag |= 64;null === a ? b.child = null : b.child !== a.child && (b.child = a.child);if (0 === b.expirationTime || b.expirationTime > c) return y(a, b);b.firstEffect = null;b.lastEffect = null;g(a, b, null, c);2 === b.tag && (a = b.stateNode, b.memoizedProps = a.props, b.memoizedState = a.state);return b.child;
    } };
}
function cf(a, b, c) {
  function d(a) {
    a.effectTag |= 4;
  }var e = a.createInstance,
      f = a.createTextInstance,
      g = a.appendInitialChild,
      k = a.finalizeInitialChildren,
      h = a.prepareUpdate,
      r = a.persistence,
      n = b.getRootHostContainer,
      y = b.popHostContext,
      u = b.getHostContext,
      x = b.popHostContainer,
      F = c.prepareToHydrateHostInstance,
      L = c.prepareToHydrateHostTextInstance,
      G = c.popHydrationState,
      T = void 0,
      I = void 0,
      z = void 0;a.mutation ? (T = function T() {}, I = function I(a, b, c) {
    (b.updateQueue = c) && d(b);
  }, z = function z(a, b, c, e) {
    c !== e && d(b);
  }) : r ? D("235") : D("236");
  return { completeWork: function completeWork(a, b, c) {
      var p = b.pendingProps;if (null === p) p = b.memoizedProps;else if (2147483647 !== b.expirationTime || 2147483647 === c) b.pendingProps = null;switch (b.tag) {case 1:
          return null;case 2:
          return ie(b), null;case 3:
          x(b);V(X, b);V(de, b);p = b.stateNode;p.pendingContext && (p.context = p.pendingContext, p.pendingContext = null);if (null === a || null === a.child) G(b), b.effectTag &= -3;T(b);return null;case 5:
          y(b);c = n();var v = b.type;if (null !== a && null != b.stateNode) {
            var l = a.memoizedProps,
                t = b.stateNode,
                r = u();t = h(t, v, l, p, c, r);I(a, b, t, v, l, p, c);a.ref !== b.ref && (b.effectTag |= 128);
          } else {
            if (!p) return null === b.stateNode ? D("166") : void 0, null;a = u();if (G(b)) F(b, c, a) && d(b);else {
              a = e(v, p, c, a, b);a: for (l = b.child; null !== l;) {
                if (5 === l.tag || 6 === l.tag) g(a, l.stateNode);else if (4 !== l.tag && null !== l.child) {
                  l.child["return"] = l;l = l.child;continue;
                }if (l === b) break;for (; null === l.sibling;) {
                  if (null === l["return"] || l["return"] === b) break a;l = l["return"];
                }l.sibling["return"] = l["return"];l = l.sibling;
              }k(a, v, p, c) && d(b);b.stateNode = a;
            }null !== b.ref && (b.effectTag |= 128);
          }return null;case 6:
          if (a && null != b.stateNode) z(a, b, a.memoizedProps, p);else {
            if ("string" !== typeof p) return null === b.stateNode ? D("166") : void 0, null;a = n();c = u();G(b) ? L(b) && d(b) : b.stateNode = f(p, a, c, b);
          }return null;case 7:
          (p = b.memoizedProps) ? void 0 : D("165");b.tag = 8;v = [];a: for ((l = b.stateNode) && (l["return"] = b); null !== l;) {
            if (5 === l.tag || 6 === l.tag || 4 === l.tag) D("247");else if (9 === l.tag) v.push(l.type);else if (null !== l.child) {
              l.child["return"] = l;l = l.child;continue;
            }for (; null === l.sibling;) {
              if (null === l["return"] || l["return"] === b) break a;l = l["return"];
            }l.sibling["return"] = l["return"];l = l.sibling;
          }l = p.handler;p = l(p.props, v);b.child = Ze(b, null !== a ? a.child : null, p, c);return b.child;case 8:
          return b.tag = 7, null;case 9:
          return null;case 10:
          return null;case 4:
          return x(b), T(b), null;case 0:
          D("167");default:
          D("156");}
    } };
}
function df(a, b) {
  function c(a) {
    var c = a.ref;if (null !== c) try {
      c(null);
    } catch (v) {
      b(a, v);
    }
  }function d(a) {
    "function" === typeof ze && ze(a);switch (a.tag) {case 2:
        c(a);var d = a.stateNode;if ("function" === typeof d.componentWillUnmount) try {
          d.props = a.memoizedProps, d.state = a.memoizedState, d.componentWillUnmount();
        } catch (v) {
          b(a, v);
        }break;case 5:
        c(a);break;case 7:
        e(a.stateNode);break;case 4:
        h && g(a);}
  }function e(a) {
    for (var b = a;;) {
      if (d(b), null === b.child || h && 4 === b.tag) {
        if (b === a) break;for (; null === b.sibling;) {
          if (null === b["return"] || b["return"] === a) return;b = b["return"];
        }b.sibling["return"] = b["return"];b = b.sibling;
      } else b.child["return"] = b, b = b.child;
    }
  }function f(a) {
    return 5 === a.tag || 3 === a.tag || 4 === a.tag;
  }function g(a) {
    for (var b = a, c = !1, f = void 0, g = void 0;;) {
      if (!c) {
        c = b["return"];a: for (;;) {
          null === c ? D("160") : void 0;switch (c.tag) {case 5:
              f = c.stateNode;g = !1;break a;case 3:
              f = c.stateNode.containerInfo;g = !0;break a;case 4:
              f = c.stateNode.containerInfo;g = !0;break a;}c = c["return"];
        }c = !0;
      }if (5 === b.tag || 6 === b.tag) e(b), g ? I(f, b.stateNode) : T(f, b.stateNode);else if (4 === b.tag ? f = b.stateNode.containerInfo : d(b), null !== b.child) {
        b.child["return"] = b;b = b.child;continue;
      }if (b === a) break;for (; null === b.sibling;) {
        if (null === b["return"] || b["return"] === a) return;b = b["return"];4 === b.tag && (c = !1);
      }b.sibling["return"] = b["return"];b = b.sibling;
    }
  }var k = a.getPublicInstance,
      h = a.mutation;a = a.persistence;h || (a ? D("235") : D("236"));var r = h.commitMount,
      n = h.commitUpdate,
      y = h.resetTextContent,
      u = h.commitTextUpdate,
      x = h.appendChild,
      F = h.appendChildToContainer,
      L = h.insertBefore,
      G = h.insertInContainerBefore,
      T = h.removeChild,
      I = h.removeChildFromContainer;return { commitResetTextContent: function commitResetTextContent(a) {
      y(a.stateNode);
    }, commitPlacement: function commitPlacement(a) {
      a: {
        for (var b = a["return"]; null !== b;) {
          if (f(b)) {
            var c = b;break a;
          }b = b["return"];
        }D("160");c = void 0;
      }var d = b = void 0;switch (c.tag) {case 5:
          b = c.stateNode;d = !1;break;case 3:
          b = c.stateNode.containerInfo;d = !0;break;case 4:
          b = c.stateNode.containerInfo;d = !0;break;default:
          D("161");}c.effectTag & 16 && (y(b), c.effectTag &= -17);a: b: for (c = a;;) {
        for (; null === c.sibling;) {
          if (null === c["return"] || f(c["return"])) {
            c = null;break a;
          }c = c["return"];
        }c.sibling["return"] = c["return"];for (c = c.sibling; 5 !== c.tag && 6 !== c.tag;) {
          if (c.effectTag & 2) continue b;if (null === c.child || 4 === c.tag) continue b;else c.child["return"] = c, c = c.child;
        }if (!(c.effectTag & 2)) {
          c = c.stateNode;break a;
        }
      }for (var e = a;;) {
        if (5 === e.tag || 6 === e.tag) c ? d ? G(b, e.stateNode, c) : L(b, e.stateNode, c) : d ? F(b, e.stateNode) : x(b, e.stateNode);else if (4 !== e.tag && null !== e.child) {
          e.child["return"] = e;e = e.child;continue;
        }if (e === a) break;for (; null === e.sibling;) {
          if (null === e["return"] || e["return"] === a) return;e = e["return"];
        }e.sibling["return"] = e["return"];e = e.sibling;
      }
    }, commitDeletion: function commitDeletion(a) {
      g(a);a["return"] = null;a.child = null;a.alternate && (a.alternate.child = null, a.alternate["return"] = null);
    }, commitWork: function commitWork(a, b) {
      switch (b.tag) {case 2:
          break;case 5:
          var c = b.stateNode;if (null != c) {
            var d = b.memoizedProps;a = null !== a ? a.memoizedProps : d;var e = b.type,
                f = b.updateQueue;b.updateQueue = null;null !== f && n(c, f, e, a, d, b);
          }break;case 6:
          null === b.stateNode ? D("162") : void 0;c = b.memoizedProps;u(b.stateNode, null !== a ? a.memoizedProps : c, c);break;case 3:
          break;default:
          D("163");}
    }, commitLifeCycles: function commitLifeCycles(a, b) {
      switch (b.tag) {case 2:
          var c = b.stateNode;if (b.effectTag & 4) if (null === a) c.props = b.memoizedProps, c.state = b.memoizedState, c.componentDidMount();else {
            var d = a.memoizedProps;a = a.memoizedState;c.props = b.memoizedProps;c.state = b.memoizedState;c.componentDidUpdate(d, a);
          }b = b.updateQueue;null !== b && Le(b, c);break;case 3:
          c = b.updateQueue;null !== c && Le(c, null !== b.child ? b.child.stateNode : null);break;case 5:
          c = b.stateNode;null === a && b.effectTag & 4 && r(c, b.type, b.memoizedProps, b);break;case 6:
          break;case 4:
          break;default:
          D("163");}
    }, commitAttachRef: function commitAttachRef(a) {
      var b = a.ref;if (null !== b) {
        var c = a.stateNode;switch (a.tag) {case 5:
            b(k(c));break;default:
            b(c);}
      }
    }, commitDetachRef: function commitDetachRef(a) {
      a = a.ref;null !== a && a(null);
    } };
}var ef = {};
function ff(a) {
  function b(a) {
    a === ef ? D("174") : void 0;return a;
  }var c = a.getChildHostContext,
      d = a.getRootHostContext,
      e = { current: ef },
      f = { current: ef },
      g = { current: ef };return { getHostContext: function getHostContext() {
      return b(e.current);
    }, getRootHostContainer: function getRootHostContainer() {
      return b(g.current);
    }, popHostContainer: function popHostContainer(a) {
      V(e, a);V(f, a);V(g, a);
    }, popHostContext: function popHostContext(a) {
      f.current === a && (V(e, a), V(f, a));
    }, pushHostContainer: function pushHostContainer(a, b) {
      W(g, b, a);b = d(b);W(f, a, a);W(e, b, a);
    }, pushHostContext: function pushHostContext(a) {
      var d = b(g.current),
          k = b(e.current);
      d = c(k, a.type, d);k !== d && (W(f, a, a), W(e, d, a));
    }, resetHostContainer: function resetHostContainer() {
      e.current = ef;g.current = ef;
    } };
}
function gf(a) {
  function b(a, b) {
    var c = new Y(5, null, 0);c.type = "DELETED";c.stateNode = b;c["return"] = a;c.effectTag = 8;null !== a.lastEffect ? (a.lastEffect.nextEffect = c, a.lastEffect = c) : a.firstEffect = a.lastEffect = c;
  }function c(a, b) {
    switch (a.tag) {case 5:
        return f(b, a.type, a.pendingProps);case 6:
        return g(b, a.pendingProps);default:
        return !1;}
  }function d(a) {
    for (a = a["return"]; null !== a && 5 !== a.tag && 3 !== a.tag;) {
      a = a["return"];
    }y = a;
  }var e = a.shouldSetTextContent;a = a.hydration;if (!a) return { enterHydrationState: function enterHydrationState() {
      return !1;
    },
    resetHydrationState: function resetHydrationState() {}, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance() {}, prepareToHydrateHostInstance: function prepareToHydrateHostInstance() {
      D("175");
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance() {
      D("176");
    }, popHydrationState: function popHydrationState() {
      return !1;
    } };var f = a.canHydrateInstance,
      g = a.canHydrateTextInstance,
      k = a.getNextHydratableSibling,
      h = a.getFirstHydratableChild,
      r = a.hydrateInstance,
      n = a.hydrateTextInstance,
      y = null,
      u = null,
      x = !1;return { enterHydrationState: function enterHydrationState(a) {
      u = h(a.stateNode.containerInfo);y = a;return x = !0;
    }, resetHydrationState: function resetHydrationState() {
      u = y = null;x = !1;
    }, tryToClaimNextHydratableInstance: function tryToClaimNextHydratableInstance(a) {
      if (x) {
        var d = u;if (d) {
          if (!c(a, d)) {
            d = k(d);if (!d || !c(a, d)) {
              a.effectTag |= 2;x = !1;y = a;return;
            }b(y, u);
          }a.stateNode = d;y = a;u = h(d);
        } else a.effectTag |= 2, x = !1, y = a;
      }
    }, prepareToHydrateHostInstance: function prepareToHydrateHostInstance(a, b, c) {
      b = r(a.stateNode, a.type, a.memoizedProps, b, c, a);a.updateQueue = b;return null !== b ? !0 : !1;
    }, prepareToHydrateHostTextInstance: function prepareToHydrateHostTextInstance(a) {
      return n(a.stateNode, a.memoizedProps, a);
    }, popHydrationState: function popHydrationState(a) {
      if (a !== y) return !1;if (!x) return d(a), x = !0, !1;var c = a.type;if (5 !== a.tag || "head" !== c && "body" !== c && !e(c, a.memoizedProps)) for (c = u; c;) {
        b(a, c), c = k(c);
      }d(a);u = y ? k(a.stateNode) : null;return !0;
    } };
}
function hf(a) {
  function b(a) {
    Lb = ma = !0;var b = a.stateNode;b.current === a ? D("177") : void 0;b.isReadyForCommit = !1;dd.current = null;if (1 < a.effectTag) {
      if (null !== a.lastEffect) {
        a.lastEffect.nextEffect = a;var c = a.firstEffect;
      } else c = a;
    } else c = a.firstEffect;ug();for (q = c; null !== q;) {
      var d = !1,
          e = void 0;try {
        for (; null !== q;) {
          var f = q.effectTag;f & 16 && vg(q);if (f & 128) {
            var g = q.alternate;null !== g && wg(g);
          }switch (f & -242) {case 2:
              Ge(q);q.effectTag &= -3;break;case 6:
              Ge(q);q.effectTag &= -3;He(q.alternate, q);break;case 4:
              He(q.alternate, q);break;case 8:
              Lc = !0, xg(q), Lc = !1;}q = q.nextEffect;
        }
      } catch (Mc) {
        d = !0, e = Mc;
      }d && (null === q ? D("178") : void 0, k(q, e), null !== q && (q = q.nextEffect));
    }yg();b.current = a;for (q = c; null !== q;) {
      c = !1;d = void 0;try {
        for (; null !== q;) {
          var h = q.effectTag;h & 36 && zg(q.alternate, q);h & 128 && Ag(q);if (h & 64) switch (e = q, f = void 0, null !== P && (f = P.get(e), P["delete"](e), null == f && null !== e.alternate && (e = e.alternate, f = P.get(e), P["delete"](e))), null == f ? D("184") : void 0, e.tag) {case 2:
              e.stateNode.componentDidCatch(f.error, { componentStack: f.componentStack });
              break;case 3:
              null === ba && (ba = f.error);break;default:
              D("157");}var Fa = q.nextEffect;q.nextEffect = null;q = Fa;
        }
      } catch (Mc) {
        c = !0, d = Mc;
      }c && (null === q ? D("178") : void 0, k(q, d), null !== q && (q = q.nextEffect));
    }ma = Lb = !1;"function" === typeof ye && ye(a.stateNode);fa && (fa.forEach(F), fa = null);null !== ba && (a = ba, ba = null, v(a));b = b.current.expirationTime;0 === b && (na = P = null);return b;
  }function c(a) {
    for (;;) {
      var b = ng(a.alternate, a, J),
          c = a["return"],
          d = a.sibling;var e = a;if (2147483647 === J || 2147483647 !== e.expirationTime) {
        if (2 !== e.tag && 3 !== e.tag) var f = 0;else f = e.updateQueue, f = null === f ? 0 : f.expirationTime;for (var g = e.child; null !== g;) {
          0 !== g.expirationTime && (0 === f || f > g.expirationTime) && (f = g.expirationTime), g = g.sibling;
        }e.expirationTime = f;
      }if (null !== b) return b;null !== c && (null === c.firstEffect && (c.firstEffect = a.firstEffect), null !== a.lastEffect && (null !== c.lastEffect && (c.lastEffect.nextEffect = a.firstEffect), c.lastEffect = a.lastEffect), 1 < a.effectTag && (null !== c.lastEffect ? c.lastEffect.nextEffect = a : c.firstEffect = a, c.lastEffect = a));if (null !== d) return d;
      if (null !== c) a = c;else {
        a.stateNode.isReadyForCommit = !0;break;
      }
    }return null;
  }function d(a) {
    var b = w(a.alternate, a, J);null === b && (b = c(a));dd.current = null;return b;
  }function e(a) {
    var b = mg(a.alternate, a, J);null === b && (b = c(a));dd.current = null;return b;
  }function f(a) {
    if (null !== P) {
      if (!(0 === J || J > a)) if (J <= Nc) for (; null !== E;) {
        E = h(E) ? e(E) : d(E);
      } else for (; null !== E && !p();) {
        E = h(E) ? e(E) : d(E);
      }
    } else if (!(0 === J || J > a)) if (J <= Nc) for (; null !== E;) {
      E = d(E);
    } else for (; null !== E && !p();) {
      E = d(E);
    }
  }function g(a, b) {
    ma ? D("243") : void 0;ma = !0;a.isReadyForCommit = !1;if (a !== fb || b !== J || null === E) {
      for (; -1 < ce;) {
        be[ce] = null, ce--;
      }ee = C;de.current = C;X.current = !1;lg();fb = a;J = b;E = ne(fb.current, null, b);
    }var c = !1,
        d = null;try {
      f(b);
    } catch (Kc) {
      c = !0, d = Kc;
    }for (; c;) {
      if (gb) {
        ba = d;break;
      }var g = E;if (null === g) gb = !0;else {
        var h = k(g, d);null === h ? D("183") : void 0;if (!gb) {
          try {
            c = h;d = b;for (h = c; null !== g;) {
              switch (g.tag) {case 2:
                  ie(g);break;case 5:
                  l(g);break;case 3:
                  Ee(g);break;case 4:
                  Ee(g);}if (g === h || g.alternate === h) break;g = g["return"];
            }E = e(c);f(d);
          } catch (Kc) {
            c = !0;d = Kc;continue;
          }break;
        }
      }
    }b = ba;gb = ma = !1;
    ba = null;null !== b && v(b);return a.isReadyForCommit ? a.current.alternate : null;
  }function k(a, b) {
    var c = dd.current = null,
        d = !1,
        e = !1,
        f = null;if (3 === a.tag) c = a, r(a) && (gb = !0);else for (var g = a["return"]; null !== g && null === c;) {
      2 === g.tag ? "function" === typeof g.stateNode.componentDidCatch && (d = !0, f = ed(g), c = g, e = !0) : 3 === g.tag && (c = g);if (r(g)) {
        if (Lc || null !== fa && (fa.has(g) || null !== g.alternate && fa.has(g.alternate))) return null;c = null;e = !1;
      }g = g["return"];
    }if (null !== c) {
      null === na && (na = new Set());na.add(c);var h = "";g = a;do {
        a: switch (g.tag) {case 0:case 1:case 2:case 5:
            var k = g._debugOwner,
                l = g._debugSource;var Fa = ed(g);var n = null;k && (n = ed(k));k = l;Fa = "\n    in " + (Fa || "Unknown") + (k ? " (at " + k.fileName.replace(/^.*[\\\/]/, "") + ":" + k.lineNumber + ")" : n ? " (created by " + n + ")" : "");break a;default:
            Fa = "";}h += Fa;g = g["return"];
      } while (g);g = h;a = ed(a);null === P && (P = new Map());b = { componentName: a, componentStack: g, error: b, errorBoundary: d ? c.stateNode : null, errorBoundaryFound: d, errorBoundaryName: f, willRetry: e };P.set(c, b);try {
        console.error(b.error);
      } catch (Bg) {
        console.error(Bg);
      }Lb ? (null === fa && (fa = new Set()), fa.add(c)) : F(c);return c;
    }null === ba && (ba = b);return null;
  }function h(a) {
    return null !== P && (P.has(a) || null !== a.alternate && P.has(a.alternate));
  }function r(a) {
    return null !== na && (na.has(a) || null !== a.alternate && na.has(a.alternate));
  }function n() {
    return 20 * (((L() + 100) / 20 | 0) + 1);
  }function y(a) {
    return 0 !== ja ? ja : ma ? Lb ? 1 : J : !Cg || a.internalContextTag & 1 ? n() : 1;
  }function u(a, b) {
    return x(a, b, !1);
  }function x(a, b) {
    for (; null !== a;) {
      if (0 === a.expirationTime || a.expirationTime > b) a.expirationTime = b;null !== a.alternate && (0 === a.alternate.expirationTime || a.alternate.expirationTime > b) && (a.alternate.expirationTime = b);if (null === a["return"]) if (3 === a.tag) {
        var c = a.stateNode;!ma && c === fb && b <= J && (E = fb = null, J = 0);var d = b;Mb > Dg && D("185");if (null === c.nextScheduledRoot) c.remainingExpirationTime = d, null === M ? (oa = M = c, c.nextScheduledRoot = c) : (M = M.nextScheduledRoot = c, M.nextScheduledRoot = oa);else {
          var e = c.remainingExpirationTime;if (0 === e || d < e) c.remainingExpirationTime = d;
        }Ga || (ka ? Nb && z(c, 1) : 1 === d ? I(1, null) : hb || (hb = !0, Ie(T)));
      } else break;a = a["return"];
    }
  }function F(a) {
    x(a, 1, !0);
  }function L() {
    return Nc = ((Je() - Eg) / 10 | 0) + 2;
  }function G() {
    var a = 0,
        b = null;if (null !== M) for (var c = M, d = oa; null !== d;) {
      var e = d.remainingExpirationTime;if (0 === e) {
        null === c || null === M ? D("244") : void 0;if (d === d.nextScheduledRoot) {
          oa = M = d.nextScheduledRoot = null;break;
        } else if (d === oa) oa = e = d.nextScheduledRoot, M.nextScheduledRoot = e, d.nextScheduledRoot = null;else if (d === M) {
          M = c;M.nextScheduledRoot = oa;d.nextScheduledRoot = null;break;
        } else c.nextScheduledRoot = d.nextScheduledRoot, d.nextScheduledRoot = null;d = c.nextScheduledRoot;
      } else {
        if (0 === a || e < a) a = e, b = d;if (d === M) break;c = d;d = d.nextScheduledRoot;
      }
    }c = pa;null !== c && c === b ? Mb++ : Mb = 0;pa = b;Ob = a;
  }function T(a) {
    I(0, a);
  }function I(a, b) {
    ib = b;for (G(); null !== pa && 0 !== Ob && (0 === a || Ob <= a) && !Oc;) {
      z(pa, Ob), G();
    }null !== ib && (hb = !1);null === pa || hb || (hb = !0, Ie(T));ib = null;Oc = !1;Mb = 0;if (Pb) throw a = Pc, Pc = null, Pb = !1, a;
  }function z(a, c) {
    Ga ? D("245") : void 0;Ga = !0;if (c <= L()) {
      var d = a.finishedWork;null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (a.remainingExpirationTime = b(d)));
    } else d = a.finishedWork, null !== d ? (a.finishedWork = null, a.remainingExpirationTime = b(d)) : (a.finishedWork = null, d = g(a, c), null !== d && (p() ? a.finishedWork = d : a.remainingExpirationTime = b(d)));Ga = !1;
  }function p() {
    return null === ib || ib.timeRemaining() > Fg ? !1 : Oc = !0;
  }function v(a) {
    null === pa ? D("246") : void 0;pa.remainingExpirationTime = 0;Pb || (Pb = !0, Pc = a);
  }var t = ff(a),
      Kb = gf(a),
      Ee = t.popHostContainer,
      l = t.popHostContext,
      lg = t.resetHostContainer,
      Fe = bf(a, t, Kb, u, y),
      w = Fe.beginWork,
      mg = Fe.beginFailedWork,
      ng = cf(a, t, Kb).completeWork;
  t = df(a, k);var vg = t.commitResetTextContent,
      Ge = t.commitPlacement,
      xg = t.commitDeletion,
      He = t.commitWork,
      zg = t.commitLifeCycles,
      Ag = t.commitAttachRef,
      wg = t.commitDetachRef,
      Je = a.now,
      Ie = a.scheduleDeferredCallback,
      Cg = a.useSyncScheduling,
      ug = a.prepareForCommit,
      yg = a.resetAfterCommit,
      Eg = Je(),
      Nc = 2,
      ja = 0,
      ma = !1,
      E = null,
      fb = null,
      J = 0,
      q = null,
      P = null,
      na = null,
      fa = null,
      ba = null,
      gb = !1,
      Lb = !1,
      Lc = !1,
      oa = null,
      M = null,
      hb = !1,
      Ga = !1,
      pa = null,
      Ob = 0,
      Oc = !1,
      Pb = !1,
      Pc = null,
      ib = null,
      ka = !1,
      Nb = !1,
      Dg = 1E3,
      Mb = 0,
      Fg = 1;return { computeAsyncExpiration: n, computeExpirationForFiber: y,
    scheduleWork: u, batchedUpdates: function batchedUpdates(a, b) {
      var c = ka;ka = !0;try {
        return a(b);
      } finally {
        (ka = c) || Ga || I(1, null);
      }
    }, unbatchedUpdates: function unbatchedUpdates(a) {
      if (ka && !Nb) {
        Nb = !0;try {
          return a();
        } finally {
          Nb = !1;
        }
      }return a();
    }, flushSync: function flushSync(a) {
      var b = ka;ka = !0;try {
        a: {
          var c = ja;ja = 1;try {
            var d = a();break a;
          } finally {
            ja = c;
          }d = void 0;
        }return d;
      } finally {
        ka = b, Ga ? D("187") : void 0, I(1, null);
      }
    }, deferredUpdates: function deferredUpdates(a) {
      var b = ja;ja = n();try {
        return a();
      } finally {
        ja = b;
      }
    } };
}
function jf(a) {
  function b(a) {
    a = jd(a);return null === a ? null : a.stateNode;
  }var c = a.getPublicInstance;a = hf(a);var d = a.computeAsyncExpiration,
      e = a.computeExpirationForFiber,
      f = a.scheduleWork;return { createContainer: function createContainer(a, b) {
      var c = new Y(3, null, 0);a = { current: c, containerInfo: a, pendingChildren: null, remainingExpirationTime: 0, isReadyForCommit: !1, finishedWork: null, context: null, pendingContext: null, hydrate: b, nextScheduledRoot: null };return c.stateNode = a;
    }, updateContainer: function updateContainer(a, b, c, r) {
      var g = b.current;if (c) {
        c = c._reactInternalFiber;var h;b: {
          2 === fd(c) && 2 === c.tag ? void 0 : D("170");for (h = c; 3 !== h.tag;) {
            if (ge(h)) {
              h = h.stateNode.__reactInternalMemoizedMergedChildContext;break b;
            }(h = h["return"]) ? void 0 : D("171");
          }h = h.stateNode.context;
        }c = ge(c) ? ke(c, h) : h;
      } else c = C;null === b.context ? b.context = c : b.pendingContext = c;b = r;b = void 0 === b ? null : b;r = null != a && null != a.type && null != a.type.prototype && !0 === a.type.prototype.unstable_isAsyncReactComponent ? d() : e(g);Ce(g, { expirationTime: r, partialState: { element: a }, callback: b, isReplace: !1, isForced: !1,
        nextCallback: null, next: null });f(g, r);
    }, batchedUpdates: a.batchedUpdates, unbatchedUpdates: a.unbatchedUpdates, deferredUpdates: a.deferredUpdates, flushSync: a.flushSync, getPublicRootInstance: function getPublicRootInstance(a) {
      a = a.current;if (!a.child) return null;switch (a.child.tag) {case 5:
          return c(a.child.stateNode);default:
          return a.child.stateNode;}
    }, findHostInstance: b, findHostInstanceWithNoPortals: function findHostInstanceWithNoPortals(a) {
      a = kd(a);return null === a ? null : a.stateNode;
    }, injectIntoDevTools: function injectIntoDevTools(a) {
      var c = a.findFiberByHostInstance;return xe(A({}, a, { findHostInstanceByFiber: function findHostInstanceByFiber(a) {
          return b(a);
        }, findFiberByHostInstance: function findFiberByHostInstance(a) {
          return c ? c(a) : null;
        } }));
    } };
}var kf = Object.freeze({ default: jf }),
    lf = kf && jf || kf,
    mf = lf["default"] ? lf["default"] : lf,
    nf = "object" === (typeof performance === "undefined" ? "undefined" : _typeof(performance)) && "function" === typeof performance.now,
    of = void 0;of = nf ? function () {
  return performance.now();
} : function () {
  return Date.now();
};var pf = void 0;
if (m.canUseDOM) {
  if ("function" !== typeof requestIdleCallback) {
    var qf = null,
        rf = !1,
        sf = !1,
        tf = 0,
        uf = 33,
        vf = 33,
        wf;wf = nf ? { timeRemaining: function timeRemaining() {
        return tf - performance.now();
      } } : { timeRemaining: function timeRemaining() {
        return tf - Date.now();
      } };var xf = "__reactIdleCallback$" + Math.random().toString(36).slice(2);window.addEventListener("message", function (a) {
      a.source === window && a.data === xf && (rf = !1, a = qf, qf = null, null !== a && a(wf));
    }, !1);var yf = function yf(a) {
      sf = !1;var b = a - tf + vf;b < vf && uf < vf ? (8 > b && (b = 8), vf = b < uf ? uf : b) : uf = b;tf = a + vf;rf || (rf = !0, window.postMessage(xf, "*"));
    };pf = function pf(a) {
      qf = a;sf || (sf = !0, requestAnimationFrame(yf));return 0;
    };
  } else pf = requestIdleCallback;
} else pf = function pf(a) {
  setTimeout(function () {
    a({ timeRemaining: function timeRemaining() {
        return Infinity;
      } });
  });return 0;
};
var zf = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
    Af = {},
    Bf = {};function Cf(a) {
  if (Bf.hasOwnProperty(a)) return !0;if (Af.hasOwnProperty(a)) return !1;if (zf.test(a)) return Bf[a] = !0;Af[a] = !0;return !1;
}
function Df(a, b, c) {
  var d = ua(b);if (d && ta(b, c)) {
    var e = d.mutationMethod;e ? e(a, c) : null == c || d.hasBooleanValue && !c || d.hasNumericValue && isNaN(c) || d.hasPositiveNumericValue && 1 > c || d.hasOverloadedBooleanValue && !1 === c ? Ef(a, b) : d.mustUseProperty ? a[d.propertyName] = c : (b = d.attributeName, (e = d.attributeNamespace) ? a.setAttributeNS(e, b, "" + c) : d.hasBooleanValue || d.hasOverloadedBooleanValue && !0 === c ? a.setAttribute(b, "") : a.setAttribute(b, "" + c));
  } else Ff(a, b, ta(b, c) ? c : null);
}
function Ff(a, b, c) {
  Cf(b) && (null == c ? a.removeAttribute(b) : a.setAttribute(b, "" + c));
}function Ef(a, b) {
  var c = ua(b);c ? (b = c.mutationMethod) ? b(a, void 0) : c.mustUseProperty ? a[c.propertyName] = c.hasBooleanValue ? !1 : "" : a.removeAttribute(c.attributeName) : a.removeAttribute(b);
}
function Gf(a, b) {
  var c = b.value,
      d = b.checked;return A({ type: void 0, step: void 0, min: void 0, max: void 0 }, b, { defaultChecked: void 0, defaultValue: void 0, value: null != c ? c : a._wrapperState.initialValue, checked: null != d ? d : a._wrapperState.initialChecked });
}function Hf(a, b) {
  var c = b.defaultValue;a._wrapperState = { initialChecked: null != b.checked ? b.checked : b.defaultChecked, initialValue: null != b.value ? b.value : c, controlled: "checkbox" === b.type || "radio" === b.type ? null != b.checked : null != b.value };
}
function If(a, b) {
  var c = b.checked;null != c && Df(a, "checked", c || !1);c = b.value;if (null != c) {
    if (0 === c && "" === a.value) a.value = "0";else if ("number" === b.type) {
      if (b = parseFloat(a.value) || 0, c != b || c == b && a.value != c) a.value = "" + c;
    } else a.value !== "" + c && (a.value = "" + c);
  } else null == b.value && null != b.defaultValue && a.defaultValue !== "" + b.defaultValue && (a.defaultValue = "" + b.defaultValue), null == b.checked && null != b.defaultChecked && (a.defaultChecked = !!b.defaultChecked);
}
function Jf(a, b) {
  switch (b.type) {case "submit":case "reset":
      break;case "color":case "date":case "datetime":case "datetime-local":case "month":case "time":case "week":
      a.value = "";a.value = a.defaultValue;break;default:
      a.value = a.value;}b = a.name;"" !== b && (a.name = "");a.defaultChecked = !a.defaultChecked;a.defaultChecked = !a.defaultChecked;"" !== b && (a.name = b);
}function Kf(a) {
  var b = "";aa.Children.forEach(a, function (a) {
    null == a || "string" !== typeof a && "number" !== typeof a || (b += a);
  });return b;
}
function Lf(a, b) {
  a = A({ children: void 0 }, b);if (b = Kf(b.children)) a.children = b;return a;
}function Mf(a, b, c, d) {
  a = a.options;if (b) {
    b = {};for (var e = 0; e < c.length; e++) {
      b["$" + c[e]] = !0;
    }for (c = 0; c < a.length; c++) {
      e = b.hasOwnProperty("$" + a[c].value), a[c].selected !== e && (a[c].selected = e), e && d && (a[c].defaultSelected = !0);
    }
  } else {
    c = "" + c;b = null;for (e = 0; e < a.length; e++) {
      if (a[e].value === c) {
        a[e].selected = !0;d && (a[e].defaultSelected = !0);return;
      }null !== b || a[e].disabled || (b = a[e]);
    }null !== b && (b.selected = !0);
  }
}
function Nf(a, b) {
  var c = b.value;a._wrapperState = { initialValue: null != c ? c : b.defaultValue, wasMultiple: !!b.multiple };
}function Of(a, b) {
  null != b.dangerouslySetInnerHTML ? D("91") : void 0;return A({}, b, { value: void 0, defaultValue: void 0, children: "" + a._wrapperState.initialValue });
}function Pf(a, b) {
  var c = b.value,
      d = c;null == c && (c = b.defaultValue, b = b.children, null != b && (null != c ? D("92") : void 0, Array.isArray(b) && (1 >= b.length ? void 0 : D("93"), b = b[0]), c = "" + b), null == c && (c = ""), d = c);a._wrapperState = { initialValue: "" + d };
}
function Qf(a, b) {
  var c = b.value;null != c && (c = "" + c, c !== a.value && (a.value = c), null == b.defaultValue && (a.defaultValue = c));null != b.defaultValue && (a.defaultValue = b.defaultValue);
}function Rf(a) {
  var b = a.textContent;b === a._wrapperState.initialValue && (a.value = b);
}var Sf = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg" };
function Tf(a) {
  switch (a) {case "svg":
      return "http://www.w3.org/2000/svg";case "math":
      return "http://www.w3.org/1998/Math/MathML";default:
      return "http://www.w3.org/1999/xhtml";}
}function Uf(a, b) {
  return null == a || "http://www.w3.org/1999/xhtml" === a ? Tf(b) : "http://www.w3.org/2000/svg" === a && "foreignObject" === b ? "http://www.w3.org/1999/xhtml" : a;
}
var Vf = void 0,
    Wf = function (a) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function (b, c, d, e) {
    MSApp.execUnsafeLocalFunction(function () {
      return a(b, c, d, e);
    });
  } : a;
}(function (a, b) {
  if (a.namespaceURI !== Sf.svg || "innerHTML" in a) a.innerHTML = b;else {
    Vf = Vf || document.createElement("div");Vf.innerHTML = "\x3csvg\x3e" + b + "\x3c/svg\x3e";for (b = Vf.firstChild; a.firstChild;) {
      a.removeChild(a.firstChild);
    }for (; b.firstChild;) {
      a.appendChild(b.firstChild);
    }
  }
}),
    Xf = /["'&<>]/;
function Yf(a, b) {
  if (b) {
    var c = a.firstChild;if (c && c === a.lastChild && 3 === c.nodeType) {
      c.nodeValue = b;return;
    }
  }a.textContent = b;
}
m.canUseDOM && ("textContent" in document.documentElement || (Yf = function Yf(a, b) {
  if (3 === a.nodeType) a.nodeValue = b;else {
    if ("boolean" === typeof b || "number" === typeof b) b = "" + b;else {
      b = "" + b;var c = Xf.exec(b);if (c) {
        var d = "",
            e,
            f = 0;for (e = c.index; e < b.length; e++) {
          switch (b.charCodeAt(e)) {case 34:
              c = "\x26quot;";break;case 38:
              c = "\x26amp;";break;case 39:
              c = "\x26#x27;";break;case 60:
              c = "\x26lt;";break;case 62:
              c = "\x26gt;";break;default:
              continue;}f !== e && (d += b.substring(f, e));f = e + 1;d += c;
        }b = f !== e ? d + b.substring(f, e) : d;
      }
    }Wf(a, b);
  }
}));
var Zf = Yf,
    $f = { animationIterationCount: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0,
  floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 },
    ag = ["Webkit", "ms", "Moz", "O"];Object.keys($f).forEach(function (a) {
  ag.forEach(function (b) {
    b = b + a.charAt(0).toUpperCase() + a.substring(1);$f[b] = $f[a];
  });
});
function bg(a, b) {
  a = a.style;for (var c in b) {
    if (b.hasOwnProperty(c)) {
      var d = 0 === c.indexOf("--");var e = c;var f = b[c];e = null == f || "boolean" === typeof f || "" === f ? "" : d || "number" !== typeof f || 0 === f || $f.hasOwnProperty(e) && $f[e] ? ("" + f).trim() : f + "px";"float" === c && (c = "cssFloat");d ? a.setProperty(c, e) : a[c] = e;
    }
  }
}var cg = A({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
function dg(a, b, c) {
  b && (cg[a] && (null != b.children || null != b.dangerouslySetInnerHTML ? D("137", a, c()) : void 0), null != b.dangerouslySetInnerHTML && (null != b.children ? D("60") : void 0, "object" === _typeof(b.dangerouslySetInnerHTML) && "__html" in b.dangerouslySetInnerHTML ? void 0 : D("61")), null != b.style && "object" !== _typeof(b.style) ? D("62", c()) : void 0);
}
function eg(a, b) {
  if (-1 === a.indexOf("-")) return "string" === typeof b.is;switch (a) {case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":
      return !1;default:
      return !0;}
}var fg = Sf.html,
    gg = B.thatReturns("");
function hg(a, b) {
  a = 9 === a.nodeType || 11 === a.nodeType ? a : a.ownerDocument;var c = Cd(a);b = Qa[b];for (var d = 0; d < b.length; d++) {
    var e = b[d];c.hasOwnProperty(e) && c[e] || ("topWheel" === e ? xc("wheel") ? U("topWheel", "wheel", a) : xc("mousewheel") ? U("topWheel", "mousewheel", a) : U("topWheel", "DOMMouseScroll", a) : "topScroll" === e ? rd("topScroll", "scroll", a) : "topFocus" === e || "topBlur" === e ? (rd("topFocus", "focus", a), rd("topBlur", "blur", a), c.topBlur = !0, c.topFocus = !0) : "topCancel" === e ? (xc("cancel", !0) && rd("topCancel", "cancel", a), c.topCancel = !0) : "topClose" === e ? (xc("close", !0) && rd("topClose", "close", a), c.topClose = !0) : yd.hasOwnProperty(e) && U(e, yd[e], a), c[e] = !0);
  }
}
var ig = { topAbort: "abort", topCanPlay: "canplay", topCanPlayThrough: "canplaythrough", topDurationChange: "durationchange", topEmptied: "emptied", topEncrypted: "encrypted", topEnded: "ended", topError: "error", topLoadedData: "loadeddata", topLoadedMetadata: "loadedmetadata", topLoadStart: "loadstart", topPause: "pause", topPlay: "play", topPlaying: "playing", topProgress: "progress", topRateChange: "ratechange", topSeeked: "seeked", topSeeking: "seeking", topStalled: "stalled", topSuspend: "suspend", topTimeUpdate: "timeupdate", topVolumeChange: "volumechange",
  topWaiting: "waiting" };function jg(a, b, c, d) {
  c = 9 === c.nodeType ? c : c.ownerDocument;d === fg && (d = Tf(a));d === fg ? "script" === a ? (a = c.createElement("div"), a.innerHTML = "\x3cscript\x3e\x3c/script\x3e", a = a.removeChild(a.firstChild)) : a = "string" === typeof b.is ? c.createElement(a, { is: b.is }) : c.createElement(a) : a = c.createElementNS(d, a);return a;
}function kg(a, b) {
  return (9 === b.nodeType ? b : b.ownerDocument).createTextNode(a);
}
function og(a, b, c, d) {
  var e = eg(b, c);switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);var f = c;break;case "video":case "audio":
      for (f in ig) {
        ig.hasOwnProperty(f) && U(f, ig[f], a);
      }f = c;break;case "source":
      U("topError", "error", a);f = c;break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);f = c;break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);f = c;break;case "details":
      U("topToggle", "toggle", a);f = c;break;case "input":
      Hf(a, c);f = Gf(a, c);U("topInvalid", "invalid", a);
      hg(d, "onChange");break;case "option":
      f = Lf(a, c);break;case "select":
      Nf(a, c);f = A({}, c, { value: void 0 });U("topInvalid", "invalid", a);hg(d, "onChange");break;case "textarea":
      Pf(a, c);f = Of(a, c);U("topInvalid", "invalid", a);hg(d, "onChange");break;default:
      f = c;}dg(b, f, gg);var g = f,
      k;for (k in g) {
    if (g.hasOwnProperty(k)) {
      var h = g[k];"style" === k ? bg(a, h, gg) : "dangerouslySetInnerHTML" === k ? (h = h ? h.__html : void 0, null != h && Wf(a, h)) : "children" === k ? "string" === typeof h ? ("textarea" !== b || "" !== h) && Zf(a, h) : "number" === typeof h && Zf(a, "" + h) : "suppressContentEditableWarning" !== k && "suppressHydrationWarning" !== k && "autoFocus" !== k && (Pa.hasOwnProperty(k) ? null != h && hg(d, k) : e ? Ff(a, k, h) : null != h && Df(a, k, h));
    }
  }switch (b) {case "input":
      Ac(a);Jf(a, c);break;case "textarea":
      Ac(a);Rf(a, c);break;case "option":
      null != c.value && a.setAttribute("value", c.value);break;case "select":
      a.multiple = !!c.multiple;b = c.value;null != b ? Mf(a, !!c.multiple, b, !1) : null != c.defaultValue && Mf(a, !!c.multiple, c.defaultValue, !0);break;default:
      "function" === typeof f.onClick && (a.onclick = B);}
}
function pg(a, b, c, d, e) {
  var f = null;switch (b) {case "input":
      c = Gf(a, c);d = Gf(a, d);f = [];break;case "option":
      c = Lf(a, c);d = Lf(a, d);f = [];break;case "select":
      c = A({}, c, { value: void 0 });d = A({}, d, { value: void 0 });f = [];break;case "textarea":
      c = Of(a, c);d = Of(a, d);f = [];break;default:
      "function" !== typeof c.onClick && "function" === typeof d.onClick && (a.onclick = B);}dg(b, d, gg);var g, k;a = null;for (g in c) {
    if (!d.hasOwnProperty(g) && c.hasOwnProperty(g) && null != c[g]) if ("style" === g) for (k in b = c[g], b) {
      b.hasOwnProperty(k) && (a || (a = {}), a[k] = "");
    } else "dangerouslySetInnerHTML" !== g && "children" !== g && "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && "autoFocus" !== g && (Pa.hasOwnProperty(g) ? f || (f = []) : (f = f || []).push(g, null));
  }for (g in d) {
    var h = d[g];b = null != c ? c[g] : void 0;if (d.hasOwnProperty(g) && h !== b && (null != h || null != b)) if ("style" === g) {
      if (b) {
        for (k in b) {
          !b.hasOwnProperty(k) || h && h.hasOwnProperty(k) || (a || (a = {}), a[k] = "");
        }for (k in h) {
          h.hasOwnProperty(k) && b[k] !== h[k] && (a || (a = {}), a[k] = h[k]);
        }
      } else a || (f || (f = []), f.push(g, a)), a = h;
    } else "dangerouslySetInnerHTML" === g ? (h = h ? h.__html : void 0, b = b ? b.__html : void 0, null != h && b !== h && (f = f || []).push(g, "" + h)) : "children" === g ? b === h || "string" !== typeof h && "number" !== typeof h || (f = f || []).push(g, "" + h) : "suppressContentEditableWarning" !== g && "suppressHydrationWarning" !== g && (Pa.hasOwnProperty(g) ? (null != h && hg(e, g), f || b === h || (f = [])) : (f = f || []).push(g, h));
  }a && (f = f || []).push("style", a);return f;
}
function qg(a, b, c, d, e) {
  eg(c, d);d = eg(c, e);for (var f = 0; f < b.length; f += 2) {
    var g = b[f],
        k = b[f + 1];"style" === g ? bg(a, k, gg) : "dangerouslySetInnerHTML" === g ? Wf(a, k) : "children" === g ? Zf(a, k) : d ? null != k ? Ff(a, g, k) : a.removeAttribute(g) : null != k ? Df(a, g, k) : Ef(a, g);
  }switch (c) {case "input":
      If(a, e);Bc(a);break;case "textarea":
      Qf(a, e);break;case "select":
      a._wrapperState.initialValue = void 0, b = a._wrapperState.wasMultiple, a._wrapperState.wasMultiple = !!e.multiple, c = e.value, null != c ? Mf(a, !!e.multiple, c, !1) : b !== !!e.multiple && (null != e.defaultValue ? Mf(a, !!e.multiple, e.defaultValue, !0) : Mf(a, !!e.multiple, e.multiple ? [] : "", !1));}
}
function rg(a, b, c, d, e) {
  switch (b) {case "iframe":case "object":
      U("topLoad", "load", a);break;case "video":case "audio":
      for (var f in ig) {
        ig.hasOwnProperty(f) && U(f, ig[f], a);
      }break;case "source":
      U("topError", "error", a);break;case "img":case "image":
      U("topError", "error", a);U("topLoad", "load", a);break;case "form":
      U("topReset", "reset", a);U("topSubmit", "submit", a);break;case "details":
      U("topToggle", "toggle", a);break;case "input":
      Hf(a, c);U("topInvalid", "invalid", a);hg(e, "onChange");break;case "select":
      Nf(a, c);
      U("topInvalid", "invalid", a);hg(e, "onChange");break;case "textarea":
      Pf(a, c), U("topInvalid", "invalid", a), hg(e, "onChange");}dg(b, c, gg);d = null;for (var g in c) {
    c.hasOwnProperty(g) && (f = c[g], "children" === g ? "string" === typeof f ? a.textContent !== f && (d = ["children", f]) : "number" === typeof f && a.textContent !== "" + f && (d = ["children", "" + f]) : Pa.hasOwnProperty(g) && null != f && hg(e, g));
  }switch (b) {case "input":
      Ac(a);Jf(a, c);break;case "textarea":
      Ac(a);Rf(a, c);break;case "select":case "option":
      break;default:
      "function" === typeof c.onClick && (a.onclick = B);}return d;
}function sg(a, b) {
  return a.nodeValue !== b;
}
var tg = Object.freeze({ createElement: jg, createTextNode: kg, setInitialProperties: og, diffProperties: pg, updateProperties: qg, diffHydratedProperties: rg, diffHydratedText: sg, warnForUnmatchedText: function warnForUnmatchedText() {}, warnForDeletedHydratableElement: function warnForDeletedHydratableElement() {}, warnForDeletedHydratableText: function warnForDeletedHydratableText() {}, warnForInsertedHydratedElement: function warnForInsertedHydratedElement() {}, warnForInsertedHydratedText: function warnForInsertedHydratedText() {}, restoreControlledState: function restoreControlledState(a, b, c) {
    switch (b) {case "input":
        If(a, c);b = c.name;if ("radio" === c.type && null != b) {
          for (c = a; c.parentNode;) {
            c = c.parentNode;
          }c = c.querySelectorAll("input[name\x3d" + JSON.stringify("" + b) + '][type\x3d"radio"]');for (b = 0; b < c.length; b++) {
            var d = c[b];if (d !== a && d.form === a.form) {
              var e = rb(d);e ? void 0 : D("90");If(d, e);
            }
          }
        }break;case "textarea":
        Qf(a, c);break;case "select":
        b = c.value, null != b && Mf(a, !!c.multiple, b, !1);}
  } });mc.injectFiberControlledHostComponent(tg);var Gg = null,
    Hg = null;function Ig(a) {
  return !(!a || 1 !== a.nodeType && 9 !== a.nodeType && 11 !== a.nodeType && (8 !== a.nodeType || " react-mount-point-unstable " !== a.nodeValue));
}
function Jg(a) {
  a = a ? 9 === a.nodeType ? a.documentElement : a.firstChild : null;return !(!a || 1 !== a.nodeType || !a.hasAttribute("data-reactroot"));
}
var Z = mf({ getRootHostContext: function getRootHostContext(a) {
    var b = a.nodeType;switch (b) {case 9:case 11:
        a = (a = a.documentElement) ? a.namespaceURI : Uf(null, "");break;default:
        b = 8 === b ? a.parentNode : a, a = b.namespaceURI || null, b = b.tagName, a = Uf(a, b);}return a;
  }, getChildHostContext: function getChildHostContext(a, b) {
    return Uf(a, b);
  }, getPublicInstance: function getPublicInstance(a) {
    return a;
  }, prepareForCommit: function prepareForCommit() {
    Gg = od;var a = da();if (Fd(a)) {
      if ("selectionStart" in a) var b = { start: a.selectionStart, end: a.selectionEnd };else a: {
        var c = window.getSelection && window.getSelection();
        if (c && 0 !== c.rangeCount) {
          b = c.anchorNode;var d = c.anchorOffset,
              e = c.focusNode;c = c.focusOffset;try {
            b.nodeType, e.nodeType;
          } catch (x) {
            b = null;break a;
          }var f = 0,
              g = -1,
              k = -1,
              h = 0,
              r = 0,
              n = a,
              y = null;b: for (;;) {
            for (var u;;) {
              n !== b || 0 !== d && 3 !== n.nodeType || (g = f + d);n !== e || 0 !== c && 3 !== n.nodeType || (k = f + c);3 === n.nodeType && (f += n.nodeValue.length);if (null === (u = n.firstChild)) break;y = n;n = u;
            }for (;;) {
              if (n === a) break b;y === b && ++h === d && (g = f);y === e && ++r === c && (k = f);if (null !== (u = n.nextSibling)) break;n = y;y = n.parentNode;
            }n = u;
          }b = -1 === g || -1 === k ? null : { start: g, end: k };
        } else b = null;
      }b = b || { start: 0, end: 0 };
    } else b = null;Hg = { focusedElem: a, selectionRange: b };pd(!1);
  }, resetAfterCommit: function resetAfterCommit() {
    var a = Hg,
        b = da(),
        c = a.focusedElem,
        d = a.selectionRange;if (b !== c && ha(document.documentElement, c)) {
      if (Fd(c)) if (b = d.start, a = d.end, void 0 === a && (a = b), "selectionStart" in c) c.selectionStart = b, c.selectionEnd = Math.min(a, c.value.length);else if (window.getSelection) {
        b = window.getSelection();var e = c[Db()].length;a = Math.min(d.start, e);d = void 0 === d.end ? a : Math.min(d.end, e);!b.extend && a > d && (e = d, d = a, a = e);e = Ed(c, a);var f = Ed(c, d);if (e && f && (1 !== b.rangeCount || b.anchorNode !== e.node || b.anchorOffset !== e.offset || b.focusNode !== f.node || b.focusOffset !== f.offset)) {
          var g = document.createRange();g.setStart(e.node, e.offset);b.removeAllRanges();a > d ? (b.addRange(g), b.extend(f.node, f.offset)) : (g.setEnd(f.node, f.offset), b.addRange(g));
        }
      }b = [];for (a = c; a = a.parentNode;) {
        1 === a.nodeType && b.push({ element: a, left: a.scrollLeft, top: a.scrollTop });
      }ia(c);for (c = 0; c < b.length; c++) {
        a = b[c], a.element.scrollLeft = a.left, a.element.scrollTop = a.top;
      }
    }Hg = null;pd(Gg);Gg = null;
  }, createInstance: function createInstance(a, b, c, d, e) {
    a = jg(a, b, c, d);a[O] = e;a[ob] = b;return a;
  }, appendInitialChild: function appendInitialChild(a, b) {
    a.appendChild(b);
  }, finalizeInitialChildren: function finalizeInitialChildren(a, b, c, d) {
    og(a, b, c, d);a: {
      switch (b) {case "button":case "input":case "select":case "textarea":
          a = !!c.autoFocus;break a;}a = !1;
    }return a;
  }, prepareUpdate: function prepareUpdate(a, b, c, d, e) {
    return pg(a, b, c, d, e);
  }, shouldSetTextContent: function shouldSetTextContent(a, b) {
    return "textarea" === a || "string" === typeof b.children || "number" === typeof b.children || "object" === _typeof(b.dangerouslySetInnerHTML) && null !== b.dangerouslySetInnerHTML && "string" === typeof b.dangerouslySetInnerHTML.__html;
  }, shouldDeprioritizeSubtree: function shouldDeprioritizeSubtree(a, b) {
    return !!b.hidden;
  }, createTextInstance: function createTextInstance(a, b, c, d) {
    a = kg(a, b);a[O] = d;return a;
  }, now: of, mutation: { commitMount: function commitMount(a) {
      a.focus();
    }, commitUpdate: function commitUpdate(a, b, c, d, e) {
      a[ob] = e;qg(a, b, c, d, e);
    }, resetTextContent: function resetTextContent(a) {
      a.textContent = "";
    }, commitTextUpdate: function commitTextUpdate(a, b, c) {
      a.nodeValue = c;
    }, appendChild: function appendChild(a, b) {
      a.appendChild(b);
    }, appendChildToContainer: function appendChildToContainer(a, b) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, a) : a.appendChild(b);
    }, insertBefore: function insertBefore(a, b, c) {
      a.insertBefore(b, c);
    }, insertInContainerBefore: function insertInContainerBefore(a, b, c) {
      8 === a.nodeType ? a.parentNode.insertBefore(b, c) : a.insertBefore(b, c);
    }, removeChild: function removeChild(a, b) {
      a.removeChild(b);
    }, removeChildFromContainer: function removeChildFromContainer(a, b) {
      8 === a.nodeType ? a.parentNode.removeChild(b) : a.removeChild(b);
    } }, hydration: { canHydrateInstance: function canHydrateInstance(a, b) {
      return 1 === a.nodeType && b.toLowerCase() === a.nodeName.toLowerCase();
    }, canHydrateTextInstance: function canHydrateTextInstance(a, b) {
      return "" === b ? !1 : 3 === a.nodeType;
    }, getNextHydratableSibling: function getNextHydratableSibling(a) {
      for (a = a.nextSibling; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, getFirstHydratableChild: function getFirstHydratableChild(a) {
      for (a = a.firstChild; a && 1 !== a.nodeType && 3 !== a.nodeType;) {
        a = a.nextSibling;
      }return a;
    }, hydrateInstance: function hydrateInstance(a, b, c, d, e, f) {
      a[O] = f;a[ob] = c;return rg(a, b, c, e, d);
    }, hydrateTextInstance: function hydrateTextInstance(a, b, c) {
      a[O] = c;return sg(a, b);
    }, didNotMatchHydratedContainerTextInstance: function didNotMatchHydratedContainerTextInstance() {}, didNotMatchHydratedTextInstance: function didNotMatchHydratedTextInstance() {},
    didNotHydrateContainerInstance: function didNotHydrateContainerInstance() {}, didNotHydrateInstance: function didNotHydrateInstance() {}, didNotFindHydratableContainerInstance: function didNotFindHydratableContainerInstance() {}, didNotFindHydratableContainerTextInstance: function didNotFindHydratableContainerTextInstance() {}, didNotFindHydratableInstance: function didNotFindHydratableInstance() {}, didNotFindHydratableTextInstance: function didNotFindHydratableTextInstance() {} }, scheduleDeferredCallback: pf, useSyncScheduling: !0 });qc = Z.batchedUpdates;
function Kg(a, b, c, d, e) {
  Ig(c) ? void 0 : D("200");var f = c._reactRootContainer;if (f) Z.updateContainer(b, f, a, e);else {
    d = d || Jg(c);if (!d) for (f = void 0; f = c.lastChild;) {
      c.removeChild(f);
    }var g = Z.createContainer(c, d);f = c._reactRootContainer = g;Z.unbatchedUpdates(function () {
      Z.updateContainer(b, g, a, e);
    });
  }return Z.getPublicRootInstance(f);
}function Lg(a, b) {
  var c = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;Ig(b) ? void 0 : D("200");return Oe(a, b, null, c);
}
function Mg(a, b) {
  this._reactRootContainer = Z.createContainer(a, b);
}Mg.prototype.render = function (a, b) {
  Z.updateContainer(a, this._reactRootContainer, null, b);
};Mg.prototype.unmount = function (a) {
  Z.updateContainer(null, this._reactRootContainer, null, a);
};
var Ng = { createPortal: Lg, findDOMNode: function findDOMNode(a) {
    if (null == a) return null;if (1 === a.nodeType) return a;var b = a._reactInternalFiber;if (b) return Z.findHostInstance(b);"function" === typeof a.render ? D("188") : D("213", Object.keys(a));
  }, hydrate: function hydrate(a, b, c) {
    return Kg(null, a, b, !0, c);
  }, render: function render(a, b, c) {
    return Kg(null, a, b, !1, c);
  }, unstable_renderSubtreeIntoContainer: function unstable_renderSubtreeIntoContainer(a, b, c, d) {
    null == a || void 0 === a._reactInternalFiber ? D("38") : void 0;return Kg(a, b, c, !1, d);
  }, unmountComponentAtNode: function unmountComponentAtNode(a) {
    Ig(a) ? void 0 : D("40");return a._reactRootContainer ? (Z.unbatchedUpdates(function () {
      Kg(null, null, a, !1, function () {
        a._reactRootContainer = null;
      });
    }), !0) : !1;
  }, unstable_createPortal: Lg, unstable_batchedUpdates: sc, unstable_deferredUpdates: Z.deferredUpdates, flushSync: Z.flushSync, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: { EventPluginHub: mb, EventPluginRegistry: Ta, EventPropagators: Bb, ReactControlledComponent: pc, ReactDOMComponentTree: sb, ReactDOMEventListener: sd } };
Z.injectIntoDevTools({ findFiberByHostInstance: pb, bundleType: 0, version: "16.1.0", rendererPackageName: "react-dom" });var Og = Object.freeze({ default: Ng }),
    Pg = Og && Ng || Og;module.exports = Pg["default"] ? Pg["default"] : Pg;

/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var isNode = __webpack_require__(29);

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;

/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function isNode(object) {
  var doc = object ? object.ownerDocument || object : document;
  var defaultView = doc.defaultView || window;
  return !!(object && (typeof defaultView.Node === 'function' ? object instanceof defaultView.Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;

/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/** @license React v16.1.0
 * react-dom.development.js
 *
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};if(process.env.NODE_ENV!=="production"){(function(){'use strict';var React=__webpack_require__(0);var invariant=__webpack_require__(5);var warning=__webpack_require__(7);var ExecutionEnvironment=__webpack_require__(12);var _assign=__webpack_require__(4);var emptyFunction$1=__webpack_require__(3);var EventListener=__webpack_require__(13);var getActiveElement=__webpack_require__(14);var shallowEqual=__webpack_require__(15);var containsNode=__webpack_require__(16);var focusNode=__webpack_require__(17);var emptyObject=__webpack_require__(6);var checkPropTypes=__webpack_require__(8);var hyphenateStyleName=__webpack_require__(31);var camelizeStyleName=__webpack_require__(33);/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */!React?invariant(false,'ReactDOM was loaded before React. Make sure you load the React package before loading ReactDOM.'):void 0;// These attributes should be all lowercase to allow for
// case insensitive checks
var RESERVED_PROPS={children:true,dangerouslySetInnerHTML:true,defaultValue:true,defaultChecked:true,innerHTML:true,suppressContentEditableWarning:true,suppressHydrationWarning:true,style:true};function checkMask(value,bitmask){return(value&bitmask)===bitmask;}var DOMPropertyInjection={/**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */MUST_USE_PROPERTY:0x1,HAS_BOOLEAN_VALUE:0x4,HAS_NUMERIC_VALUE:0x8,HAS_POSITIVE_NUMERIC_VALUE:0x10|0x8,HAS_OVERLOADED_BOOLEAN_VALUE:0x20,HAS_STRING_BOOLEAN_VALUE:0x40,/**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */injectDOMPropertyConfig:function injectDOMPropertyConfig(domPropertyConfig){var Injection=DOMPropertyInjection;var Properties=domPropertyConfig.Properties||{};var DOMAttributeNamespaces=domPropertyConfig.DOMAttributeNamespaces||{};var DOMAttributeNames=domPropertyConfig.DOMAttributeNames||{};var DOMMutationMethods=domPropertyConfig.DOMMutationMethods||{};for(var propName in Properties){!!properties.hasOwnProperty(propName)?invariant(false,"injectDOMPropertyConfig(...): You're trying to inject DOM property '%s' which has already been injected. You may be accidentally injecting the same DOM property config twice, or you may be injecting two configs that have conflicting property names.",propName):void 0;var lowerCased=propName.toLowerCase();var propConfig=Properties[propName];var propertyInfo={attributeName:lowerCased,attributeNamespace:null,propertyName:propName,mutationMethod:null,mustUseProperty:checkMask(propConfig,Injection.MUST_USE_PROPERTY),hasBooleanValue:checkMask(propConfig,Injection.HAS_BOOLEAN_VALUE),hasNumericValue:checkMask(propConfig,Injection.HAS_NUMERIC_VALUE),hasPositiveNumericValue:checkMask(propConfig,Injection.HAS_POSITIVE_NUMERIC_VALUE),hasOverloadedBooleanValue:checkMask(propConfig,Injection.HAS_OVERLOADED_BOOLEAN_VALUE),hasStringBooleanValue:checkMask(propConfig,Injection.HAS_STRING_BOOLEAN_VALUE)};!(propertyInfo.hasBooleanValue+propertyInfo.hasNumericValue+propertyInfo.hasOverloadedBooleanValue<=1)?invariant(false,"DOMProperty: Value can be one of boolean, overloaded boolean, or numeric value, but not a combination: %s",propName):void 0;if(DOMAttributeNames.hasOwnProperty(propName)){var attributeName=DOMAttributeNames[propName];propertyInfo.attributeName=attributeName;}if(DOMAttributeNamespaces.hasOwnProperty(propName)){propertyInfo.attributeNamespace=DOMAttributeNamespaces[propName];}if(DOMMutationMethods.hasOwnProperty(propName)){propertyInfo.mutationMethod=DOMMutationMethods[propName];}// Downcase references to whitelist properties to check for membership
// without case-sensitivity. This allows the whitelist to pick up
// `allowfullscreen`, which should be written using the property configuration
// for `allowFullscreen`
properties[propName]=propertyInfo;}}};/* eslint-disable max-len */var ATTRIBUTE_NAME_START_CHAR=':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';/* eslint-enable max-len */var ATTRIBUTE_NAME_CHAR=ATTRIBUTE_NAME_START_CHAR+'\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040';var ROOT_ATTRIBUTE_NAME='data-reactroot';/**
 * Map from property "standard name" to an object with info about how to set
 * the property in the DOM. Each object contains:
 *
 * attributeName:
 *   Used when rendering markup or with `*Attribute()`.
 * attributeNamespace
 * propertyName:
 *   Used on DOM node instances. (This includes properties that mutate due to
 *   external factors.)
 * mutationMethod:
 *   If non-null, used instead of the property or `setAttribute()` after
 *   initial render.
 * mustUseProperty:
 *   Whether the property must be accessed and mutated as an object property.
 * hasBooleanValue:
 *   Whether the property should be removed when set to a falsey value.
 * hasNumericValue:
 *   Whether the property must be numeric or parse as a numeric and should be
 *   removed when set to a falsey value.
 * hasPositiveNumericValue:
 *   Whether the property must be positive numeric or parse as a positive
 *   numeric and should be removed when set to a falsey value.
 * hasOverloadedBooleanValue:
 *   Whether the property can be used as a flag as well as with a value.
 *   Removed when strictly equal to false; present without a value when
 *   strictly equal to true; present with a value otherwise.
 */var properties={};/**
 * Checks whether a property name is a writeable attribute.
 * @method
 */function shouldSetAttribute(name,value){if(isReservedProp(name)){return false;}if(name.length>2&&(name[0]==='o'||name[0]==='O')&&(name[1]==='n'||name[1]==='N')){return false;}if(value===null){return true;}switch(typeof value==='undefined'?'undefined':_typeof(value)){case'boolean':return shouldAttributeAcceptBooleanValue(name);case'undefined':case'number':case'string':case'object':return true;default:// function, symbol
return false;}}function getPropertyInfo(name){return properties.hasOwnProperty(name)?properties[name]:null;}function shouldAttributeAcceptBooleanValue(name){if(isReservedProp(name)){return true;}var propertyInfo=getPropertyInfo(name);if(propertyInfo){return propertyInfo.hasBooleanValue||propertyInfo.hasStringBooleanValue||propertyInfo.hasOverloadedBooleanValue;}var prefix=name.toLowerCase().slice(0,5);return prefix==='data-'||prefix==='aria-';}/**
 * Checks to see if a property name is within the list of properties
 * reserved for internal React operations. These properties should
 * not be set on an HTML element.
 *
 * @private
 * @param {string} name
 * @return {boolean} If the name is within reserved props
 */function isReservedProp(name){return RESERVED_PROPS.hasOwnProperty(name);}var injection=DOMPropertyInjection;var MUST_USE_PROPERTY=injection.MUST_USE_PROPERTY;var HAS_BOOLEAN_VALUE=injection.HAS_BOOLEAN_VALUE;var HAS_NUMERIC_VALUE=injection.HAS_NUMERIC_VALUE;var HAS_POSITIVE_NUMERIC_VALUE=injection.HAS_POSITIVE_NUMERIC_VALUE;var HAS_OVERLOADED_BOOLEAN_VALUE=injection.HAS_OVERLOADED_BOOLEAN_VALUE;var HAS_STRING_BOOLEAN_VALUE=injection.HAS_STRING_BOOLEAN_VALUE;var HTMLDOMPropertyConfig={// When adding attributes to this list, be sure to also add them to
// the `possibleStandardNames` module to ensure casing and incorrect
// name warnings.
Properties:{allowFullScreen:HAS_BOOLEAN_VALUE,autoFocus:HAS_STRING_BOOLEAN_VALUE,// specifies target context for links with `preload` type
async:HAS_BOOLEAN_VALUE,// autoFocus is polyfilled/normalized by AutoFocusUtils
// autoFocus: HAS_BOOLEAN_VALUE,
autoPlay:HAS_BOOLEAN_VALUE,capture:HAS_BOOLEAN_VALUE,checked:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,cols:HAS_POSITIVE_NUMERIC_VALUE,contentEditable:HAS_STRING_BOOLEAN_VALUE,controls:HAS_BOOLEAN_VALUE,'default':HAS_BOOLEAN_VALUE,defer:HAS_BOOLEAN_VALUE,disabled:HAS_BOOLEAN_VALUE,download:HAS_OVERLOADED_BOOLEAN_VALUE,draggable:HAS_STRING_BOOLEAN_VALUE,formNoValidate:HAS_BOOLEAN_VALUE,hidden:HAS_BOOLEAN_VALUE,loop:HAS_BOOLEAN_VALUE,// Caution; `option.selected` is not updated if `select.multiple` is
// disabled with `removeAttribute`.
multiple:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,muted:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,noValidate:HAS_BOOLEAN_VALUE,open:HAS_BOOLEAN_VALUE,playsInline:HAS_BOOLEAN_VALUE,readOnly:HAS_BOOLEAN_VALUE,required:HAS_BOOLEAN_VALUE,reversed:HAS_BOOLEAN_VALUE,rows:HAS_POSITIVE_NUMERIC_VALUE,rowSpan:HAS_NUMERIC_VALUE,scoped:HAS_BOOLEAN_VALUE,seamless:HAS_BOOLEAN_VALUE,selected:MUST_USE_PROPERTY|HAS_BOOLEAN_VALUE,size:HAS_POSITIVE_NUMERIC_VALUE,start:HAS_NUMERIC_VALUE,// support for projecting regular DOM Elements via V1 named slots ( shadow dom )
span:HAS_POSITIVE_NUMERIC_VALUE,spellCheck:HAS_STRING_BOOLEAN_VALUE,// Style must be explicitly set in the attribute list. React components
// expect a style object
style:0,// Keep it in the whitelist because it is case-sensitive for SVG.
tabIndex:0,// itemScope is for for Microdata support.
// See http://schema.org/docs/gs.html
itemScope:HAS_BOOLEAN_VALUE,// These attributes must stay in the white-list because they have
// different attribute names (see DOMAttributeNames below)
acceptCharset:0,className:0,htmlFor:0,httpEquiv:0,// Attributes with mutation methods must be specified in the whitelist
// Set the string boolean flag to allow the behavior
value:HAS_STRING_BOOLEAN_VALUE},DOMAttributeNames:{acceptCharset:'accept-charset',className:'class',htmlFor:'for',httpEquiv:'http-equiv'},DOMMutationMethods:{value:function value(node,_value){if(_value==null){return node.removeAttribute('value');}// Number inputs get special treatment due to some edge cases in
// Chrome. Let everything else assign the value attribute as normal.
// https://github.com/facebook/react/issues/7253#issuecomment-236074326
if(node.type!=='number'||node.hasAttribute('value')===false){node.setAttribute('value',''+_value);}else if(node.validity&&!node.validity.badInput&&node.ownerDocument.activeElement!==node){// Don't assign an attribute if validation reports bad
// input. Chrome will clear the value. Additionally, don't
// operate on inputs that have focus, otherwise Chrome might
// strip off trailing decimal places and cause the user's
// cursor position to jump to the beginning of the input.
//
// In ReactDOMInput, we have an onBlur event that will trigger
// this function again when focus is lost.
node.setAttribute('value',''+_value);}}}};var HAS_STRING_BOOLEAN_VALUE$1=injection.HAS_STRING_BOOLEAN_VALUE;var NS={xlink:'http://www.w3.org/1999/xlink',xml:'http://www.w3.org/XML/1998/namespace'};/**
 * This is a list of all SVG attributes that need special casing,
 * namespacing, or boolean value assignment.
 *
 * When adding attributes to this list, be sure to also add them to
 * the `possibleStandardNames` module to ensure casing and incorrect
 * name warnings.
 *
 * SVG Attributes List:
 * https://www.w3.org/TR/SVG/attindex.html
 * SMIL Spec:
 * https://www.w3.org/TR/smil
 */var ATTRS=['accent-height','alignment-baseline','arabic-form','baseline-shift','cap-height','clip-path','clip-rule','color-interpolation','color-interpolation-filters','color-profile','color-rendering','dominant-baseline','enable-background','fill-opacity','fill-rule','flood-color','flood-opacity','font-family','font-size','font-size-adjust','font-stretch','font-style','font-variant','font-weight','glyph-name','glyph-orientation-horizontal','glyph-orientation-vertical','horiz-adv-x','horiz-origin-x','image-rendering','letter-spacing','lighting-color','marker-end','marker-mid','marker-start','overline-position','overline-thickness','paint-order','panose-1','pointer-events','rendering-intent','shape-rendering','stop-color','stop-opacity','strikethrough-position','strikethrough-thickness','stroke-dasharray','stroke-dashoffset','stroke-linecap','stroke-linejoin','stroke-miterlimit','stroke-opacity','stroke-width','text-anchor','text-decoration','text-rendering','underline-position','underline-thickness','unicode-bidi','unicode-range','units-per-em','v-alphabetic','v-hanging','v-ideographic','v-mathematical','vector-effect','vert-adv-y','vert-origin-x','vert-origin-y','word-spacing','writing-mode','x-height','xlink:actuate','xlink:arcrole','xlink:href','xlink:role','xlink:show','xlink:title','xlink:type','xml:base','xmlns:xlink','xml:lang','xml:space'];var SVGDOMPropertyConfig={Properties:{autoReverse:HAS_STRING_BOOLEAN_VALUE$1,externalResourcesRequired:HAS_STRING_BOOLEAN_VALUE$1,preserveAlpha:HAS_STRING_BOOLEAN_VALUE$1},DOMAttributeNames:{autoReverse:'autoReverse',externalResourcesRequired:'externalResourcesRequired',preserveAlpha:'preserveAlpha'},DOMAttributeNamespaces:{xlinkActuate:NS.xlink,xlinkArcrole:NS.xlink,xlinkHref:NS.xlink,xlinkRole:NS.xlink,xlinkShow:NS.xlink,xlinkTitle:NS.xlink,xlinkType:NS.xlink,xmlBase:NS.xml,xmlLang:NS.xml,xmlSpace:NS.xml}};var CAMELIZE=/[\-\:]([a-z])/g;var capitalize=function capitalize(token){return token[1].toUpperCase();};ATTRS.forEach(function(original){var reactName=original.replace(CAMELIZE,capitalize);SVGDOMPropertyConfig.Properties[reactName]=0;SVGDOMPropertyConfig.DOMAttributeNames[reactName]=original;});injection.injectDOMPropertyConfig(HTMLDOMPropertyConfig);injection.injectDOMPropertyConfig(SVGDOMPropertyConfig);var ReactErrorUtils={// Used by Fiber to simulate a try-catch.
_caughtError:null,_hasCaughtError:false,// Used by event system to capture/rethrow the first error.
_rethrowError:null,_hasRethrowError:false,injection:{injectErrorUtils:function injectErrorUtils(injectedErrorUtils){!(typeof injectedErrorUtils.invokeGuardedCallback==='function')?invariant(false,'Injected invokeGuardedCallback() must be a function.'):void 0;_invokeGuardedCallback=injectedErrorUtils.invokeGuardedCallback;}},/**
   * Call a function while guarding against errors that happens within it.
   * Returns an error if it throws, otherwise null.
   *
   * In production, this is implemented using a try-catch. The reason we don't
   * use a try-catch directly is so that we can swap out a different
   * implementation in DEV mode.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallback:function invokeGuardedCallback(name,func,context,a,b,c,d,e,f){_invokeGuardedCallback.apply(ReactErrorUtils,arguments);},/**
   * Same as invokeGuardedCallback, but instead of returning an error, it stores
   * it in a global so it can be rethrown by `rethrowCaughtError` later.
   * TODO: See if _caughtError and _rethrowError can be unified.
   *
   * @param {String} name of the guard to use for logging or debugging
   * @param {Function} func The function to invoke
   * @param {*} context The context to use when calling the function
   * @param {...*} args Arguments for function
   */invokeGuardedCallbackAndCatchFirstError:function invokeGuardedCallbackAndCatchFirstError(name,func,context,a,b,c,d,e,f){ReactErrorUtils.invokeGuardedCallback.apply(this,arguments);if(ReactErrorUtils.hasCaughtError()){var error=ReactErrorUtils.clearCaughtError();if(!ReactErrorUtils._hasRethrowError){ReactErrorUtils._hasRethrowError=true;ReactErrorUtils._rethrowError=error;}}},/**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */rethrowCaughtError:function rethrowCaughtError(){return _rethrowCaughtError.apply(ReactErrorUtils,arguments);},hasCaughtError:function hasCaughtError(){return ReactErrorUtils._hasCaughtError;},clearCaughtError:function clearCaughtError(){if(ReactErrorUtils._hasCaughtError){var error=ReactErrorUtils._caughtError;ReactErrorUtils._caughtError=null;ReactErrorUtils._hasCaughtError=false;return error;}else{invariant(false,'clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.');}}};var _invokeGuardedCallback=function _invokeGuardedCallback(name,func,context,a,b,c,d,e,f){ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs);}catch(error){ReactErrorUtils._caughtError=error;ReactErrorUtils._hasCaughtError=true;}};{// In DEV mode, we swap out invokeGuardedCallback for a special version
// that plays more nicely with the browser's DevTools. The idea is to preserve
// "Pause on exceptions" behavior. Because React wraps all user-provided
// functions in invokeGuardedCallback, and the production version of
// invokeGuardedCallback uses a try-catch, all user exceptions are treated
// like caught exceptions, and the DevTools won't pause unless the developer
// takes the extra step of enabling pause on caught exceptions. This is
// untintuitive, though, because even though React has caught the error, from
// the developer's perspective, the error is uncaught.
//
// To preserve the expected "Pause on exceptions" behavior, we don't use a
// try-catch in DEV. Instead, we synchronously dispatch a fake event to a fake
// DOM node, and call the user-provided callback from inside an event handler
// for that fake event. If the callback throws, the error is "captured" using
// a global event handler. But because the error happens in a different
// event loop context, it does not interrupt the normal program flow.
// Effectively, this gives us try-catch behavior without actually using
// try-catch. Neat!
// Check that the browser supports the APIs we need to implement our special
// DEV version of invokeGuardedCallback
if(typeof window!=='undefined'&&typeof window.dispatchEvent==='function'&&typeof document!=='undefined'&&typeof document.createEvent==='function'){var fakeNode=document.createElement('react');var invokeGuardedCallbackDev=function invokeGuardedCallbackDev(name,func,context,a,b,c,d,e,f){// Keeps track of whether the user-provided callback threw an error. We
// set this to true at the beginning, then set it to false right after
// calling the function. If the function errors, `didError` will never be
// set to false. This strategy works even if the browser is flaky and
// fails to call our global error handler, because it doesn't rely on
// the error event at all.
var didError=true;// Create an event handler for our fake event. We will synchronously
// dispatch our fake event using `dispatchEvent`. Inside the handler, we
// call the user-provided callback.
var funcArgs=Array.prototype.slice.call(arguments,3);function callCallback(){// We immediately remove the callback from event listeners so that
// nested `invokeGuardedCallback` calls do not clash. Otherwise, a
// nested call would trigger the fake event handlers of any call higher
// in the stack.
fakeNode.removeEventListener(evtType,callCallback,false);func.apply(context,funcArgs);didError=false;}// Create a global error event handler. We use this to capture the value
// that was thrown. It's possible that this error handler will fire more
// than once; for example, if non-React code also calls `dispatchEvent`
// and a handler for that event throws. We should be resilient to most of
// those cases. Even if our error event handler fires more than once, the
// last error event is always used. If the callback actually does error,
// we know that the last error event is the correct one, because it's not
// possible for anything else to have happened in between our callback
// erroring and the code that follows the `dispatchEvent` call below. If
// the callback doesn't error, but the error event was fired, we know to
// ignore it because `didError` will be false, as described above.
var error=void 0;// Use this to track whether the error event is ever called.
var didSetError=false;var isCrossOriginError=false;function onError(event){error=event.error;didSetError=true;if(error===null&&event.colno===0&&event.lineno===0){isCrossOriginError=true;}}// Create a fake event type.
var evtType='react-'+(name?name:'invokeguardedcallback');// Attach our event handlers
window.addEventListener('error',onError);fakeNode.addEventListener(evtType,callCallback,false);// Synchronously dispatch our fake event. If the user-provided function
// errors, it will trigger our global error handler.
var evt=document.createEvent('Event');evt.initEvent(evtType,false,false);fakeNode.dispatchEvent(evt);if(didError){if(!didSetError){// The callback errored, but the error event never fired.
error=new Error('An error was thrown inside one of your components, but React '+"doesn't know what it was. This is likely due to browser "+'flakiness. React does its best to preserve the "Pause on '+'exceptions" behavior of the DevTools, which requires some '+"DEV-mode only tricks. It's possible that these don't work in "+'your browser. Try triggering the error in production mode, '+'or switching to a modern browser. If you suspect that this is '+'actually an issue with React, please file an issue.');}else if(isCrossOriginError){error=new Error("A cross-origin error was thrown. React doesn't have access to "+'the actual error object in development. '+'See https://fb.me/react-crossorigin-error for more information.');}ReactErrorUtils._hasCaughtError=true;ReactErrorUtils._caughtError=error;}else{ReactErrorUtils._hasCaughtError=false;ReactErrorUtils._caughtError=null;}// Remove our event listeners
window.removeEventListener('error',onError);};_invokeGuardedCallback=invokeGuardedCallbackDev;}}var _rethrowCaughtError=function _rethrowCaughtError(){if(ReactErrorUtils._hasRethrowError){var error=ReactErrorUtils._rethrowError;ReactErrorUtils._rethrowError=null;ReactErrorUtils._hasRethrowError=false;throw error;}};/**
 * Injectable ordering of event plugins.
 */var eventPluginOrder=null;/**
 * Injectable mapping from names to event plugin modules.
 */var namesToPlugins={};/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */function recomputePluginOrdering(){if(!eventPluginOrder){// Wait until an `eventPluginOrder` is injected.
return;}for(var pluginName in namesToPlugins){var pluginModule=namesToPlugins[pluginName];var pluginIndex=eventPluginOrder.indexOf(pluginName);!(pluginIndex>-1)?invariant(false,'EventPluginRegistry: Cannot inject event plugins that do not exist in the plugin ordering, `%s`.',pluginName):void 0;if(plugins[pluginIndex]){continue;}!pluginModule.extractEvents?invariant(false,'EventPluginRegistry: Event plugins must implement an `extractEvents` method, but `%s` does not.',pluginName):void 0;plugins[pluginIndex]=pluginModule;var publishedEvents=pluginModule.eventTypes;for(var eventName in publishedEvents){!publishEventForPlugin(publishedEvents[eventName],pluginModule,eventName)?invariant(false,'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.',eventName,pluginName):void 0;}}}/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */function publishEventForPlugin(dispatchConfig,pluginModule,eventName){!!eventNameDispatchConfigs.hasOwnProperty(eventName)?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same event name, `%s`.',eventName):void 0;eventNameDispatchConfigs[eventName]=dispatchConfig;var phasedRegistrationNames=dispatchConfig.phasedRegistrationNames;if(phasedRegistrationNames){for(var phaseName in phasedRegistrationNames){if(phasedRegistrationNames.hasOwnProperty(phaseName)){var phasedRegistrationName=phasedRegistrationNames[phaseName];publishRegistrationName(phasedRegistrationName,pluginModule,eventName);}}return true;}else if(dispatchConfig.registrationName){publishRegistrationName(dispatchConfig.registrationName,pluginModule,eventName);return true;}return false;}/**
 * Publishes a registration name that is used to identify dispatched events.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */function publishRegistrationName(registrationName,pluginModule,eventName){!!registrationNameModules[registrationName]?invariant(false,'EventPluginHub: More than one plugin attempted to publish the same registration name, `%s`.',registrationName):void 0;registrationNameModules[registrationName]=pluginModule;registrationNameDependencies[registrationName]=pluginModule.eventTypes[eventName].dependencies;{var lowerCasedName=registrationName.toLowerCase();possibleRegistrationNames[lowerCasedName]=registrationName;if(registrationName==='onDoubleClick'){possibleRegistrationNames.ondblclick=registrationName;}}}/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 *//**
 * Ordered list of injected plugins.
 */var plugins=[];/**
 * Mapping from event name to dispatch config
 */var eventNameDispatchConfigs={};/**
 * Mapping from registration name to plugin module
 */var registrationNameModules={};/**
 * Mapping from registration name to event name
 */var registrationNameDependencies={};/**
 * Mapping from lowercase registration names to the properly cased version,
 * used to warn in the case of missing event handlers. Available
 * only in true.
 * @type {Object}
 */var possibleRegistrationNames={};// Trust the developer to only use possibleRegistrationNames in true
/**
 * Injects an ordering of plugins (by plugin name). This allows the ordering
 * to be decoupled from injection of the actual plugins so that ordering is
 * always deterministic regardless of packaging, on-the-fly injection, etc.
 *
 * @param {array} InjectedEventPluginOrder
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginOrder}
 */function injectEventPluginOrder(injectedEventPluginOrder){!!eventPluginOrder?invariant(false,'EventPluginRegistry: Cannot inject event plugin ordering more than once. You are likely trying to load more than one copy of React.'):void 0;// Clone the ordering so it cannot be dynamically mutated.
eventPluginOrder=Array.prototype.slice.call(injectedEventPluginOrder);recomputePluginOrdering();}/**
 * Injects plugins to be used by `EventPluginHub`. The plugin names must be
 * in the ordering injected by `injectEventPluginOrder`.
 *
 * Plugins can be injected as part of page initialization or on-the-fly.
 *
 * @param {object} injectedNamesToPlugins Map from names to plugin modules.
 * @internal
 * @see {EventPluginHub.injection.injectEventPluginsByName}
 */function injectEventPluginsByName(injectedNamesToPlugins){var isOrderingDirty=false;for(var pluginName in injectedNamesToPlugins){if(!injectedNamesToPlugins.hasOwnProperty(pluginName)){continue;}var pluginModule=injectedNamesToPlugins[pluginName];if(!namesToPlugins.hasOwnProperty(pluginName)||namesToPlugins[pluginName]!==pluginModule){!!namesToPlugins[pluginName]?invariant(false,'EventPluginRegistry: Cannot inject two different event plugins using the same name, `%s`.',pluginName):void 0;namesToPlugins[pluginName]=pluginModule;isOrderingDirty=true;}}if(isOrderingDirty){recomputePluginOrdering();}}var EventPluginRegistry=Object.freeze({plugins:plugins,eventNameDispatchConfigs:eventNameDispatchConfigs,registrationNameModules:registrationNameModules,registrationNameDependencies:registrationNameDependencies,possibleRegistrationNames:possibleRegistrationNames,injectEventPluginOrder:injectEventPluginOrder,injectEventPluginsByName:injectEventPluginsByName});var getFiberCurrentPropsFromNode=null;var getInstanceFromNode=null;var getNodeFromInstance=null;var injection$2={injectComponentTree:function injectComponentTree(Injected){getFiberCurrentPropsFromNode=Injected.getFiberCurrentPropsFromNode;getInstanceFromNode=Injected.getInstanceFromNode;getNodeFromInstance=Injected.getNodeFromInstance;{warning(getNodeFromInstance&&getInstanceFromNode,'EventPluginUtils.injection.injectComponentTree(...): Injected '+'module is missing getNodeFromInstance or getInstanceFromNode.');}}};var validateEventDispatches;{validateEventDispatches=function validateEventDispatches(event){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;var listenersIsArr=Array.isArray(dispatchListeners);var listenersLen=listenersIsArr?dispatchListeners.length:dispatchListeners?1:0;var instancesIsArr=Array.isArray(dispatchInstances);var instancesLen=instancesIsArr?dispatchInstances.length:dispatchInstances?1:0;warning(instancesIsArr===listenersIsArr&&instancesLen===listenersLen,'EventPluginUtils: Invalid `event`.');};}/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */function executeDispatch(event,simulated,listener,inst){var type=event.type||'unknown-event';event.currentTarget=getNodeFromInstance(inst);ReactErrorUtils.invokeGuardedCallbackAndCatchFirstError(type,listener,undefined,event);event.currentTarget=null;}/**
 * Standard/simple iteration through an event's collected dispatches.
 */function executeDispatchesInOrder(event,simulated){var dispatchListeners=event._dispatchListeners;var dispatchInstances=event._dispatchInstances;{validateEventDispatches(event);}if(Array.isArray(dispatchListeners)){for(var i=0;i<dispatchListeners.length;i++){if(event.isPropagationStopped()){break;}// Listeners and Instances are two parallel arrays that are always in sync.
executeDispatch(event,simulated,dispatchListeners[i],dispatchInstances[i]);}}else if(dispatchListeners){executeDispatch(event,simulated,dispatchListeners,dispatchInstances);}event._dispatchListeners=null;event._dispatchInstances=null;}/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 *//**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 *//**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 *//**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */function accumulateInto(current,next){!(next!=null)?invariant(false,'accumulateInto(...): Accumulated items must not be null or undefined.'):void 0;if(current==null){return next;}// Both are not empty. Warning: Never call x.concat(y) when you are not
// certain that x is an Array (x could be a string with concat method).
if(Array.isArray(current)){if(Array.isArray(next)){current.push.apply(current,next);return current;}current.push(next);return current;}if(Array.isArray(next)){// A bit too dangerous to mutate `next`.
return[current].concat(next);}return[current,next];}/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 * @param {function} cb Callback invoked with each element or a collection.
 * @param {?} [scope] Scope used as `this` in a callback.
 */function forEachAccumulated(arr,cb,scope){if(Array.isArray(arr)){arr.forEach(cb,scope);}else if(arr){cb.call(scope,arr);}}/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */var eventQueue=null;/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */var executeDispatchesAndRelease=function executeDispatchesAndRelease(event,simulated){if(event){executeDispatchesInOrder(event,simulated);if(!event.isPersistent()){event.constructor.release(event);}}};var executeDispatchesAndReleaseSimulated=function executeDispatchesAndReleaseSimulated(e){return executeDispatchesAndRelease(e,true);};var executeDispatchesAndReleaseTopLevel=function executeDispatchesAndReleaseTopLevel(e){return executeDispatchesAndRelease(e,false);};function isInteractive(tag){return tag==='button'||tag==='input'||tag==='select'||tag==='textarea';}function shouldPreventMouseEvent(name,type,props){switch(name){case'onClick':case'onClickCapture':case'onDoubleClick':case'onDoubleClickCapture':case'onMouseDown':case'onMouseDownCapture':case'onMouseMove':case'onMouseMoveCapture':case'onMouseUp':case'onMouseUpCapture':return!!(props.disabled&&isInteractive(type));default:return false;}}/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 *//**
 * Methods for injecting dependencies.
 */var injection$1={/**
   * @param {array} InjectedEventPluginOrder
   * @public
   */injectEventPluginOrder:injectEventPluginOrder,/**
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   */injectEventPluginsByName:injectEventPluginsByName};/**
 * @param {object} inst The instance, which is the source of events.
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @return {?function} The stored callback.
 */function getListener(inst,registrationName){var listener;// TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
// live here; needs to be moved to a better place soon
var stateNode=inst.stateNode;if(!stateNode){// Work in progress (ex: onload events in incremental mode).
return null;}var props=getFiberCurrentPropsFromNode(stateNode);if(!props){// Work in progress.
return null;}listener=props[registrationName];if(shouldPreventMouseEvent(registrationName,inst.type,props)){return null;}!(!listener||typeof listener==='function')?invariant(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener)):void 0;return listener;}/**
 * Allows registered plugins an opportunity to extract events from top-level
 * native browser events.
 *
 * @return {*} An accumulation of synthetic events.
 * @internal
 */function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events;for(var i=0;i<plugins.length;i++){// Not every plugin in the ordering may be loaded at runtime.
var possiblePlugin=plugins[i];if(possiblePlugin){var extractedEvents=possiblePlugin.extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);if(extractedEvents){events=accumulateInto(events,extractedEvents);}}}return events;}/**
 * Enqueues a synthetic event that should be dispatched when
 * `processEventQueue` is invoked.
 *
 * @param {*} events An accumulation of synthetic events.
 * @internal
 */function enqueueEvents(events){if(events){eventQueue=accumulateInto(eventQueue,events);}}/**
 * Dispatches all synthetic events on the event queue.
 *
 * @internal
 */function processEventQueue(simulated){// Set `eventQueue` to null before processing it so that we can tell if more
// events get enqueued while processing.
var processingEventQueue=eventQueue;eventQueue=null;if(simulated){forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseSimulated);}else{forEachAccumulated(processingEventQueue,executeDispatchesAndReleaseTopLevel);}!!eventQueue?invariant(false,'processEventQueue(): Additional events were enqueued while processing an event queue. Support for this has not yet been implemented.'):void 0;// This would be a good time to rethrow if any of the event handlers threw.
ReactErrorUtils.rethrowCaughtError();}var EventPluginHub=Object.freeze({injection:injection$1,getListener:getListener,extractEvents:extractEvents,enqueueEvents:enqueueEvents,processEventQueue:processEventQueue});var IndeterminateComponent=0;// Before we know whether it is functional or class
var FunctionalComponent=1;var ClassComponent=2;var HostRoot=3;// Root of a host tree. Could be nested inside another node.
var HostPortal=4;// A subtree. Could be an entry point to a different renderer.
var HostComponent=5;var HostText=6;var CallComponent=7;var CallHandlerPhase=8;var ReturnComponent=9;var Fragment=10;var randomKey=Math.random().toString(36).slice(2);var internalInstanceKey='__reactInternalInstance$'+randomKey;var internalEventHandlersKey='__reactEventHandlers$'+randomKey;function precacheFiberNode$1(hostInst,node){node[internalInstanceKey]=hostInst;}/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */function getClosestInstanceFromNode(node){if(node[internalInstanceKey]){return node[internalInstanceKey];}// Walk up the tree until we find an ancestor whose instance we have cached.
var parents=[];while(!node[internalInstanceKey]){parents.push(node);if(node.parentNode){node=node.parentNode;}else{// Top of the tree. This node must not be part of a React tree (or is
// unmounted, potentially).
return null;}}var closest=void 0;var inst=node[internalInstanceKey];if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber, this will always be the deepest root.
return inst;}for(;node&&(inst=node[internalInstanceKey]);node=parents.pop()){closest=inst;}return closest;}/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */function getInstanceFromNode$1(node){var inst=node[internalInstanceKey];if(inst){if(inst.tag===HostComponent||inst.tag===HostText){return inst;}else{return null;}}return null;}/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */function getNodeFromInstance$1(inst){if(inst.tag===HostComponent||inst.tag===HostText){// In Fiber this, is just the state node right now. We assume it will be
// a host component or host text.
return inst.stateNode;}// Without this first invariant, passing a non-DOM-component triggers the next
// invariant for a missing parent, which is super confusing.
invariant(false,'getNodeFromInstance: Invalid argument.');}function getFiberCurrentPropsFromNode$1(node){return node[internalEventHandlersKey]||null;}function updateFiberProps$1(node,props){node[internalEventHandlersKey]=props;}var ReactDOMComponentTree=Object.freeze({precacheFiberNode:precacheFiberNode$1,getClosestInstanceFromNode:getClosestInstanceFromNode,getInstanceFromNode:getInstanceFromNode$1,getNodeFromInstance:getNodeFromInstance$1,getFiberCurrentPropsFromNode:getFiberCurrentPropsFromNode$1,updateFiberProps:updateFiberProps$1});function getParent(inst){do{inst=inst['return'];// TODO: If this is a HostRoot we might want to bail out.
// That is depending on if we want nested subtrees (layers) to bubble
// events to their parent. We could also go through parentNode on the
// host node but that wouldn't work for React Native and doesn't let us
// do the portal feature.
}while(inst&&inst.tag!==HostComponent);if(inst){return inst;}return null;}/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */function getLowestCommonAncestor(instA,instB){var depthA=0;for(var tempA=instA;tempA;tempA=getParent(tempA)){depthA++;}var depthB=0;for(var tempB=instB;tempB;tempB=getParent(tempB)){depthB++;}// If A is deeper, crawl up.
while(depthA-depthB>0){instA=getParent(instA);depthA--;}// If B is deeper, crawl up.
while(depthB-depthA>0){instB=getParent(instB);depthB--;}// Walk in lockstep until we find a match.
var depth=depthA;while(depth--){if(instA===instB||instA===instB.alternate){return instA;}instA=getParent(instA);instB=getParent(instB);}return null;}/**
 * Return if A is an ancestor of B.
 *//**
 * Return the parent instance of the passed-in instance.
 */function getParentInstance(inst){return getParent(inst);}/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */function traverseTwoPhase(inst,fn,arg){var path=[];while(inst){path.push(inst);inst=getParent(inst);}var i;for(i=path.length;i-->0;){fn(path[i],'captured',arg);}for(i=0;i<path.length;i++){fn(path[i],'bubbled',arg);}}/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */function traverseEnterLeave(from,to,fn,argFrom,argTo){var common=from&&to?getLowestCommonAncestor(from,to):null;var pathFrom=[];while(true){if(!from){break;}if(from===common){break;}var alternate=from.alternate;if(alternate!==null&&alternate===common){break;}pathFrom.push(from);from=getParent(from);}var pathTo=[];while(true){if(!to){break;}if(to===common){break;}var _alternate=to.alternate;if(_alternate!==null&&_alternate===common){break;}pathTo.push(to);to=getParent(to);}for(var i=0;i<pathFrom.length;i++){fn(pathFrom[i],'bubbled',argFrom);}for(var _i=pathTo.length;_i-->0;){fn(pathTo[_i],'captured',argTo);}}/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */function listenerAtPhase(inst,event,propagationPhase){var registrationName=event.dispatchConfig.phasedRegistrationNames[propagationPhase];return getListener(inst,registrationName);}/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing even a
 * single one.
 *//**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */function accumulateDirectionalDispatches(inst,phase,event){{warning(inst,'Dispatching inst must not be null');}var listener=listenerAtPhase(inst,event,phase);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */function accumulateTwoPhaseDispatchesSingle(event){if(event&&event.dispatchConfig.phasedRegistrationNames){traverseTwoPhase(event._targetInst,accumulateDirectionalDispatches,event);}}/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */function accumulateTwoPhaseDispatchesSingleSkipTarget(event){if(event&&event.dispatchConfig.phasedRegistrationNames){var targetInst=event._targetInst;var parentInst=targetInst?getParentInstance(targetInst):null;traverseTwoPhase(parentInst,accumulateDirectionalDispatches,event);}}/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */function accumulateDispatches(inst,ignoredDirection,event){if(inst&&event&&event.dispatchConfig.registrationName){var registrationName=event.dispatchConfig.registrationName;var listener=getListener(inst,registrationName);if(listener){event._dispatchListeners=accumulateInto(event._dispatchListeners,listener);event._dispatchInstances=accumulateInto(event._dispatchInstances,inst);}}}/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */function accumulateDirectDispatchesSingle(event){if(event&&event.dispatchConfig.registrationName){accumulateDispatches(event._targetInst,null,event);}}function accumulateTwoPhaseDispatches(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingle);}function accumulateTwoPhaseDispatchesSkipTarget(events){forEachAccumulated(events,accumulateTwoPhaseDispatchesSingleSkipTarget);}function accumulateEnterLeaveDispatches(leave,enter,from,to){traverseEnterLeave(from,to,accumulateDispatches,leave,enter);}function accumulateDirectDispatches(events){forEachAccumulated(events,accumulateDirectDispatchesSingle);}var EventPropagators=Object.freeze({accumulateTwoPhaseDispatches:accumulateTwoPhaseDispatches,accumulateTwoPhaseDispatchesSkipTarget:accumulateTwoPhaseDispatchesSkipTarget,accumulateEnterLeaveDispatches:accumulateEnterLeaveDispatches,accumulateDirectDispatches:accumulateDirectDispatches});var contentKey=null;/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */function getTextContentAccessor(){if(!contentKey&&ExecutionEnvironment.canUseDOM){// Prefer textContent to innerText because many browsers support both but
// SVG <text> elements don't support innerText even when <div> does.
contentKey='textContent'in document.documentElement?'textContent':'innerText';}return contentKey;}/**
 * This helper object stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 *
 */var compositionState={_root:null,_startText:null,_fallbackText:null};function initialize(nativeEventTarget){compositionState._root=nativeEventTarget;compositionState._startText=getText();return true;}function reset(){compositionState._root=null;compositionState._startText=null;compositionState._fallbackText=null;}function getData(){if(compositionState._fallbackText){return compositionState._fallbackText;}var start;var startValue=compositionState._startText;var startLength=startValue.length;var end;var endValue=getText();var endLength=endValue.length;for(start=0;start<startLength;start++){if(startValue[start]!==endValue[start]){break;}}var minEnd=startLength-start;for(end=1;end<=minEnd;end++){if(startValue[startLength-end]!==endValue[endLength-end]){break;}}var sliceTail=end>1?1-end:undefined;compositionState._fallbackText=endValue.slice(start,sliceTail);return compositionState._fallbackText;}function getText(){if('value'in compositionState._root){return compositionState._root.value;}return compositionState._root[getTextContentAccessor()];}/* eslint valid-typeof: 0 */var didWarnForAddedNewProperty=false;var isProxySupported=typeof Proxy==='function';var EVENT_POOL_SIZE=10;var shouldBeReleasedProperties=['dispatchConfig','_targetInst','nativeEvent','isDefaultPrevented','isPropagationStopped','_dispatchListeners','_dispatchInstances'];/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var EventInterface={type:null,target:null,// currentTarget is set when dispatching; no use in copying it here
currentTarget:emptyFunction$1.thatReturnsNull,eventPhase:null,bubbles:null,cancelable:null,timeStamp:function timeStamp(event){return event.timeStamp||Date.now();},defaultPrevented:null,isTrusted:null};/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */function SyntheticEvent(dispatchConfig,targetInst,nativeEvent,nativeEventTarget){{// these have a getter/setter for warnings
delete this.nativeEvent;delete this.preventDefault;delete this.stopPropagation;}this.dispatchConfig=dispatchConfig;this._targetInst=targetInst;this.nativeEvent=nativeEvent;var Interface=this.constructor.Interface;for(var propName in Interface){if(!Interface.hasOwnProperty(propName)){continue;}{delete this[propName];// this has a getter/setter for warnings
}var normalize=Interface[propName];if(normalize){this[propName]=normalize(nativeEvent);}else{if(propName==='target'){this.target=nativeEventTarget;}else{this[propName]=nativeEvent[propName];}}}var defaultPrevented=nativeEvent.defaultPrevented!=null?nativeEvent.defaultPrevented:nativeEvent.returnValue===false;if(defaultPrevented){this.isDefaultPrevented=emptyFunction$1.thatReturnsTrue;}else{this.isDefaultPrevented=emptyFunction$1.thatReturnsFalse;}this.isPropagationStopped=emptyFunction$1.thatReturnsFalse;return this;}_assign(SyntheticEvent.prototype,{preventDefault:function preventDefault(){this.defaultPrevented=true;var event=this.nativeEvent;if(!event){return;}if(event.preventDefault){event.preventDefault();}else if(typeof event.returnValue!=='unknown'){event.returnValue=false;}this.isDefaultPrevented=emptyFunction$1.thatReturnsTrue;},stopPropagation:function stopPropagation(){var event=this.nativeEvent;if(!event){return;}if(event.stopPropagation){event.stopPropagation();}else if(typeof event.cancelBubble!=='unknown'){// The ChangeEventPlugin registers a "propertychange" event for
// IE. This event does not support bubbling or cancelling, and
// any references to cancelBubble throw "Member not found".  A
// typeof check of "unknown" circumvents this issue (and is also
// IE specific).
event.cancelBubble=true;}this.isPropagationStopped=emptyFunction$1.thatReturnsTrue;},/**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */persist:function persist(){this.isPersistent=emptyFunction$1.thatReturnsTrue;},/**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */isPersistent:emptyFunction$1.thatReturnsFalse,/**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */destructor:function destructor(){var Interface=this.constructor.Interface;for(var propName in Interface){{Object.defineProperty(this,propName,getPooledWarningPropertyDefinition(propName,Interface[propName]));}}for(var i=0;i<shouldBeReleasedProperties.length;i++){this[shouldBeReleasedProperties[i]]=null;}{Object.defineProperty(this,'nativeEvent',getPooledWarningPropertyDefinition('nativeEvent',null));Object.defineProperty(this,'preventDefault',getPooledWarningPropertyDefinition('preventDefault',emptyFunction$1));Object.defineProperty(this,'stopPropagation',getPooledWarningPropertyDefinition('stopPropagation',emptyFunction$1));}}});SyntheticEvent.Interface=EventInterface;/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */SyntheticEvent.augmentClass=function(Class,Interface){var Super=this;var E=function E(){};E.prototype=Super.prototype;var prototype=new E();_assign(prototype,Class.prototype);Class.prototype=prototype;Class.prototype.constructor=Class;Class.Interface=_assign({},Super.Interface,Interface);Class.augmentClass=Super.augmentClass;addEventPoolingTo(Class);};/** Proxying after everything set on SyntheticEvent
 * to resolve Proxy issue on some WebKit browsers
 * in which some Event properties are set to undefined (GH#10010)
 */{if(isProxySupported){/*eslint-disable no-func-assign */SyntheticEvent=new Proxy(SyntheticEvent,{construct:function construct(target,args){return this.apply(target,Object.create(target.prototype),args);},apply:function apply(constructor,that,args){return new Proxy(constructor.apply(that,args),{set:function set(target,prop,value){if(prop!=='isPersistent'&&!target.constructor.Interface.hasOwnProperty(prop)&&shouldBeReleasedProperties.indexOf(prop)===-1){warning(didWarnForAddedNewProperty||target.isPersistent(),"This synthetic event is reused for performance reasons. If you're "+"seeing this, you're adding a new property in the synthetic event object. "+'The property is never released. See '+'https://fb.me/react-event-pooling for more information.');didWarnForAddedNewProperty=true;}target[prop]=value;return true;}});}});/*eslint-enable no-func-assign */}}addEventPoolingTo(SyntheticEvent);/**
 * Helper to nullify syntheticEvent instance properties when destructing
 *
 * @param {String} propName
 * @param {?object} getVal
 * @return {object} defineProperty object
 */function getPooledWarningPropertyDefinition(propName,getVal){var isFunction=typeof getVal==='function';return{configurable:true,set:set,get:get};function set(val){var action=isFunction?'setting the method':'setting the property';warn(action,'This is effectively a no-op');return val;}function get(){var action=isFunction?'accessing the method':'accessing the property';var result=isFunction?'This is a no-op function':'This is set to null';warn(action,result);return getVal;}function warn(action,result){var warningCondition=false;warning(warningCondition,"This synthetic event is reused for performance reasons. If you're seeing this, "+"you're %s `%s` on a released/nullified synthetic event. %s. "+'If you must keep the original synthetic event around, use event.persist(). '+'See https://fb.me/react-event-pooling for more information.',action,propName,result);}}function getPooledEvent(dispatchConfig,targetInst,nativeEvent,nativeInst){var EventConstructor=this;if(EventConstructor.eventPool.length){var instance=EventConstructor.eventPool.pop();EventConstructor.call(instance,dispatchConfig,targetInst,nativeEvent,nativeInst);return instance;}return new EventConstructor(dispatchConfig,targetInst,nativeEvent,nativeInst);}function releasePooledEvent(event){var EventConstructor=this;!(event instanceof EventConstructor)?invariant(false,'Trying to release an event instance  into a pool of a different type.'):void 0;event.destructor();if(EventConstructor.eventPool.length<EVENT_POOL_SIZE){EventConstructor.eventPool.push(event);}}function addEventPoolingTo(EventConstructor){EventConstructor.eventPool=[];EventConstructor.getPooled=getPooledEvent;EventConstructor.release=releasePooledEvent;}var SyntheticEvent$1=SyntheticEvent;/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */var CompositionEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticCompositionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticCompositionEvent,CompositionEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */var InputEventInterface={data:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticInputEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticInputEvent,InputEventInterface);var END_KEYCODES=[9,13,27,32];// Tab, Return, Esc, Space
var START_KEYCODE=229;var canUseCompositionEvent=ExecutionEnvironment.canUseDOM&&'CompositionEvent'in window;var documentMode=null;if(ExecutionEnvironment.canUseDOM&&'documentMode'in document){documentMode=document.documentMode;}// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent=ExecutionEnvironment.canUseDOM&&'TextEvent'in window&&!documentMode&&!isPresto();// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData=ExecutionEnvironment.canUseDOM&&(!canUseCompositionEvent||documentMode&&documentMode>8&&documentMode<=11);/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */function isPresto(){var opera=window.opera;return(typeof opera==='undefined'?'undefined':_typeof(opera))==='object'&&typeof opera.version==='function'&&parseInt(opera.version(),10)<=12;}var SPACEBAR_CODE=32;var SPACEBAR_CHAR=String.fromCharCode(SPACEBAR_CODE);// Events and their corresponding property names.
var eventTypes={beforeInput:{phasedRegistrationNames:{bubbled:'onBeforeInput',captured:'onBeforeInputCapture'},dependencies:['topCompositionEnd','topKeyPress','topTextInput','topPaste']},compositionEnd:{phasedRegistrationNames:{bubbled:'onCompositionEnd',captured:'onCompositionEndCapture'},dependencies:['topBlur','topCompositionEnd','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionStart:{phasedRegistrationNames:{bubbled:'onCompositionStart',captured:'onCompositionStartCapture'},dependencies:['topBlur','topCompositionStart','topKeyDown','topKeyPress','topKeyUp','topMouseDown']},compositionUpdate:{phasedRegistrationNames:{bubbled:'onCompositionUpdate',captured:'onCompositionUpdateCapture'},dependencies:['topBlur','topCompositionUpdate','topKeyDown','topKeyPress','topKeyUp','topMouseDown']}};// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress=false;/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */function isKeypressCommand(nativeEvent){return(nativeEvent.ctrlKey||nativeEvent.altKey||nativeEvent.metaKey)&&// ctrlKey && altKey is equivalent to AltGr, and is not a command.
!(nativeEvent.ctrlKey&&nativeEvent.altKey);}/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */function getCompositionEventType(topLevelType){switch(topLevelType){case'topCompositionStart':return eventTypes.compositionStart;case'topCompositionEnd':return eventTypes.compositionEnd;case'topCompositionUpdate':return eventTypes.compositionUpdate;}}/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionStart(topLevelType,nativeEvent){return topLevelType==='topKeyDown'&&nativeEvent.keyCode===START_KEYCODE;}/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */function isFallbackCompositionEnd(topLevelType,nativeEvent){switch(topLevelType){case'topKeyUp':// Command keys insert or clear IME input.
return END_KEYCODES.indexOf(nativeEvent.keyCode)!==-1;case'topKeyDown':// Expect IME keyCode on each keydown. If we get any other
// code we must have exited earlier.
return nativeEvent.keyCode!==START_KEYCODE;case'topKeyPress':case'topMouseDown':case'topBlur':// Events are not possible without cancelling IME.
return true;default:return false;}}/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */function getDataFromCustomEvent(nativeEvent){var detail=nativeEvent.detail;if((typeof detail==='undefined'?'undefined':_typeof(detail))==='object'&&'data'in detail){return detail.data;}return null;}// Track the current IME composition status, if any.
var isComposing=false;/**
 * @return {?object} A SyntheticCompositionEvent.
 */function extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var eventType;var fallbackData;if(canUseCompositionEvent){eventType=getCompositionEventType(topLevelType);}else if(!isComposing){if(isFallbackCompositionStart(topLevelType,nativeEvent)){eventType=eventTypes.compositionStart;}}else if(isFallbackCompositionEnd(topLevelType,nativeEvent)){eventType=eventTypes.compositionEnd;}if(!eventType){return null;}if(useFallbackCompositionData){// The current composition is stored statically and must not be
// overwritten while composition continues.
if(!isComposing&&eventType===eventTypes.compositionStart){isComposing=initialize(nativeEventTarget);}else if(eventType===eventTypes.compositionEnd){if(isComposing){fallbackData=getData();}}}var event=SyntheticCompositionEvent.getPooled(eventType,targetInst,nativeEvent,nativeEventTarget);if(fallbackData){// Inject data generated from fallback path into the synthetic event.
// This matches the property of native CompositionEventInterface.
event.data=fallbackData;}else{var customData=getDataFromCustomEvent(nativeEvent);if(customData!==null){event.data=customData;}}accumulateTwoPhaseDispatches(event);return event;}/**
 * @param {TopLevelTypes} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */function getNativeBeforeInputChars(topLevelType,nativeEvent){switch(topLevelType){case'topCompositionEnd':return getDataFromCustomEvent(nativeEvent);case'topKeyPress':/**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */var which=nativeEvent.which;if(which!==SPACEBAR_CODE){return null;}hasSpaceKeypress=true;return SPACEBAR_CHAR;case'topTextInput':// Record the characters to be added to the DOM.
var chars=nativeEvent.data;// If it's a spacebar character, assume that we have already handled
// it at the keypress level and bail immediately. Android Chrome
// doesn't give us keycodes, so we need to blacklist it.
if(chars===SPACEBAR_CHAR&&hasSpaceKeypress){return null;}return chars;default:// For other native event types, do nothing.
return null;}}/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */function getFallbackBeforeInputChars(topLevelType,nativeEvent){// If we are currently composing (IME) and using a fallback to do so,
// try to extract the composed characters from the fallback object.
// If composition event is available, we extract a string only at
// compositionevent, otherwise extract it at fallback events.
if(isComposing){if(topLevelType==='topCompositionEnd'||!canUseCompositionEvent&&isFallbackCompositionEnd(topLevelType,nativeEvent)){var chars=getData();reset();isComposing=false;return chars;}return null;}switch(topLevelType){case'topPaste':// If a paste event occurs after a keypress, throw out the input
// chars. Paste events should not lead to BeforeInput events.
return null;case'topKeyPress':/**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */if(!isKeypressCommand(nativeEvent)){// IE fires the `keypress` event when a user types an emoji via
// Touch keyboard of Windows.  In such a case, the `char` property
// holds an emoji character like `\uD83D\uDE0A`.  Because its length
// is 2, the property `which` does not represent an emoji correctly.
// In such a case, we directly return the `char` property instead of
// using `which`.
if(nativeEvent.char&&nativeEvent.char.length>1){return nativeEvent.char;}else if(nativeEvent.which){return String.fromCharCode(nativeEvent.which);}}return null;case'topCompositionEnd':return useFallbackCompositionData?null:nativeEvent.data;default:return null;}}/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */function extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget){var chars;if(canUseTextInputEvent){chars=getNativeBeforeInputChars(topLevelType,nativeEvent);}else{chars=getFallbackBeforeInputChars(topLevelType,nativeEvent);}// If no characters are being inserted, no BeforeInput event should
// be fired.
if(!chars){return null;}var event=SyntheticInputEvent.getPooled(eventTypes.beforeInput,targetInst,nativeEvent,nativeEventTarget);event.data=chars;accumulateTwoPhaseDispatches(event);return event;}/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */var BeforeInputEventPlugin={eventTypes:eventTypes,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){return[extractCompositionEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget),extractBeforeInputEvent(topLevelType,targetInst,nativeEvent,nativeEventTarget)];}};// Use to restore controlled state after a change event has fired.
var fiberHostComponent=null;var ReactControlledComponentInjection={injectFiberControlledHostComponent:function injectFiberControlledHostComponent(hostComponentImpl){// The fiber implementation doesn't use dynamic dispatch so we need to
// inject the implementation.
fiberHostComponent=hostComponentImpl;}};var restoreTarget=null;var restoreQueue=null;function restoreStateOfTarget(target){// We perform this translation at the end of the event loop so that we
// always receive the correct fiber here
var internalInstance=getInstanceFromNode(target);if(!internalInstance){// Unmounted
return;}!(fiberHostComponent&&typeof fiberHostComponent.restoreControlledState==='function')?invariant(false,'Fiber needs to be injected to handle a fiber target for controlled events. This error is likely caused by a bug in React. Please file an issue.'):void 0;var props=getFiberCurrentPropsFromNode(internalInstance.stateNode);fiberHostComponent.restoreControlledState(internalInstance.stateNode,internalInstance.type,props);}var injection$3=ReactControlledComponentInjection;function enqueueStateRestore(target){if(restoreTarget){if(restoreQueue){restoreQueue.push(target);}else{restoreQueue=[target];}}else{restoreTarget=target;}}function restoreStateIfNeeded(){if(!restoreTarget){return;}var target=restoreTarget;var queuedTargets=restoreQueue;restoreTarget=null;restoreQueue=null;restoreStateOfTarget(target);if(queuedTargets){for(var i=0;i<queuedTargets.length;i++){restoreStateOfTarget(queuedTargets[i]);}}}var ReactControlledComponent=Object.freeze({injection:injection$3,enqueueStateRestore:enqueueStateRestore,restoreStateIfNeeded:restoreStateIfNeeded});// Used as a way to call batchedUpdates when we don't have a reference to
// the renderer. Such as when we're dispatching events or if third party
// libraries need to call batchedUpdates. Eventually, this API will go away when
// everything is batched by default. We'll then have a similar API to opt-out of
// scheduled work and instead do synchronous work.
// Defaults
var fiberBatchedUpdates=function fiberBatchedUpdates(fn,bookkeeping){return fn(bookkeeping);};var isNestingBatched=false;function batchedUpdates(fn,bookkeeping){if(isNestingBatched){// If we are currently inside another batch, we need to wait until it
// fully completes before restoring state. Therefore, we add the target to
// a queue of work.
return fiberBatchedUpdates(fn,bookkeeping);}isNestingBatched=true;try{return fiberBatchedUpdates(fn,bookkeeping);}finally{// Here we wait until all updates have propagated, which is important
// when using controlled components within layers:
// https://github.com/facebook/react/issues/1698
// Then we restore state of any controlled component.
isNestingBatched=false;restoreStateIfNeeded();}}var ReactGenericBatchingInjection={injectFiberBatchedUpdates:function injectFiberBatchedUpdates(_batchedUpdates){fiberBatchedUpdates=_batchedUpdates;}};var injection$4=ReactGenericBatchingInjection;/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */var supportedInputTypes={color:true,date:true,datetime:true,'datetime-local':true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function isTextInputElement(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();if(nodeName==='input'){return!!supportedInputTypes[elem.type];}if(nodeName==='textarea'){return true;}return false;}/**
 * HTML nodeType values that represent the type of the node
 */var ELEMENT_NODE=1;var TEXT_NODE=3;var COMMENT_NODE=8;var DOCUMENT_NODE=9;var DOCUMENT_FRAGMENT_NODE=11;/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */function getEventTarget(nativeEvent){var target=nativeEvent.target||nativeEvent.srcElement||window;// Normalize SVG <use> element events #4963
if(target.correspondingUseElement){target=target.correspondingUseElement;}// Safari may fire events on text nodes (Node.TEXT_NODE is 3).
// @see http://www.quirksmode.org/js/events_properties.html
return target.nodeType===TEXT_NODE?target.parentNode:target;}var useHasFeature;if(ExecutionEnvironment.canUseDOM){useHasFeature=document.implementation&&document.implementation.hasFeature&&// always returns true in newer browsers as per the standard.
// @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
document.implementation.hasFeature('','')!==true;}/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */function isEventSupported(eventNameSuffix,capture){if(!ExecutionEnvironment.canUseDOM||capture&&!('addEventListener'in document)){return false;}var eventName='on'+eventNameSuffix;var isSupported=eventName in document;if(!isSupported){var element=document.createElement('div');element.setAttribute(eventName,'return;');isSupported=typeof element[eventName]==='function';}if(!isSupported&&useHasFeature&&eventNameSuffix==='wheel'){// This is the only way to test support for the `wheel` event in IE9+.
isSupported=document.implementation.hasFeature('Events.wheel','3.0');}return isSupported;}function isCheckable(elem){var type=elem.type;var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(type==='checkbox'||type==='radio');}function getTracker(node){return node._valueTracker;}function detachTracker(node){node._valueTracker=null;}function getValueFromNode(node){var value='';if(!node){return value;}if(isCheckable(node)){value=node.checked?'true':'false';}else{value=node.value;}return value;}function trackValueOnNode(node){var valueField=isCheckable(node)?'checked':'value';var descriptor=Object.getOwnPropertyDescriptor(node.constructor.prototype,valueField);var currentValue=''+node[valueField];// if someone has already defined a value or Safari, then bail
// and don't track value will cause over reporting of changes,
// but it's better then a hard failure
// (needed for certain tests that spyOn input values and Safari)
if(node.hasOwnProperty(valueField)||typeof descriptor.get!=='function'||typeof descriptor.set!=='function'){return;}Object.defineProperty(node,valueField,{enumerable:descriptor.enumerable,configurable:true,get:function get(){return descriptor.get.call(this);},set:function set(value){currentValue=''+value;descriptor.set.call(this,value);}});var tracker={getValue:function getValue(){return currentValue;},setValue:function setValue(value){currentValue=''+value;},stopTracking:function stopTracking(){detachTracker(node);delete node[valueField];}};return tracker;}function track(node){if(getTracker(node)){return;}// TODO: Once it's just Fiber we can move this to node._wrapperState
node._valueTracker=trackValueOnNode(node);}function updateValueIfChanged(node){if(!node){return false;}var tracker=getTracker(node);// if there is no tracker at this point it's unlikely
// that trying again will succeed
if(!tracker){return true;}var lastValue=tracker.getValue();var nextValue=getValueFromNode(node);if(nextValue!==lastValue){tracker.setValue(nextValue);return true;}return false;}var eventTypes$1={change:{phasedRegistrationNames:{bubbled:'onChange',captured:'onChangeCapture'},dependencies:['topBlur','topChange','topClick','topFocus','topInput','topKeyDown','topKeyUp','topSelectionChange']}};function createAndAccumulateChangeEvent(inst,nativeEvent,target){var event=SyntheticEvent$1.getPooled(eventTypes$1.change,inst,nativeEvent,target);event.type='change';// Flag this event loop as needing state restore.
enqueueStateRestore(target);accumulateTwoPhaseDispatches(event);return event;}/**
 * For IE shims
 */var activeElement=null;var activeElementInst=null;/**
 * SECTION: handle `change` event
 */function shouldUseChangeEvent(elem){var nodeName=elem.nodeName&&elem.nodeName.toLowerCase();return nodeName==='select'||nodeName==='input'&&elem.type==='file';}function manualDispatchChangeEvent(nativeEvent){var event=createAndAccumulateChangeEvent(activeElementInst,nativeEvent,getEventTarget(nativeEvent));// If change and propertychange bubbled, we'd just bind to it like all the
// other events and have it go through ReactBrowserEventEmitter. Since it
// doesn't, we manually listen for the events and so we have to enqueue and
// process the abstract event manually.
//
// Batching is necessary here in order to ensure that all event handlers run
// before the next rerender (including event handlers attached to ancestor
// elements instead of directly on the input). Without this, controlled
// components don't work properly in conjunction with event bubbling because
// the component is rerendered and the value reverted before all the event
// handlers can run. See https://github.com/facebook/react/issues/708.
batchedUpdates(runEventInBatch,event);}function runEventInBatch(event){enqueueEvents(event);processEventQueue(false);}function getInstIfValueChanged(targetInst){var targetNode=getNodeFromInstance$1(targetInst);if(updateValueIfChanged(targetNode)){return targetInst;}}function getTargetInstForChangeEvent(topLevelType,targetInst){if(topLevelType==='topChange'){return targetInst;}}/**
 * SECTION: handle `input` event
 */var isInputEventSupported=false;if(ExecutionEnvironment.canUseDOM){// IE9 claims to support the input event but fails to trigger it when
// deleting text, so we ignore its input events.
isInputEventSupported=isEventSupported('input')&&(!document.documentMode||document.documentMode>9);}/**
 * (For IE <=9) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */function startWatchingForValueChange(target,targetInst){activeElement=target;activeElementInst=targetInst;activeElement.attachEvent('onpropertychange',handlePropertyChange);}/**
 * (For IE <=9) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */function stopWatchingForValueChange(){if(!activeElement){return;}activeElement.detachEvent('onpropertychange',handlePropertyChange);activeElement=null;activeElementInst=null;}/**
 * (For IE <=9) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */function handlePropertyChange(nativeEvent){if(nativeEvent.propertyName!=='value'){return;}if(getInstIfValueChanged(activeElementInst)){manualDispatchChangeEvent(nativeEvent);}}function handleEventsForInputEventPolyfill(topLevelType,target,targetInst){if(topLevelType==='topFocus'){// In IE9, propertychange fires for most input events but is buggy and
// doesn't fire when text is deleted, but conveniently, selectionchange
// appears to fire in all of the remaining cases so we catch those and
// forward the event if the value has changed
// In either case, we don't want to call the event handler if the value
// is changed from JS so we redefine a setter for `.value` that updates
// our activeElementValue variable, allowing us to ignore those changes
//
// stopWatching() should be a noop here but we call it just in case we
// missed a blur event somehow.
stopWatchingForValueChange();startWatchingForValueChange(target,targetInst);}else if(topLevelType==='topBlur'){stopWatchingForValueChange();}}// For IE8 and IE9.
function getTargetInstForInputEventPolyfill(topLevelType,targetInst){if(topLevelType==='topSelectionChange'||topLevelType==='topKeyUp'||topLevelType==='topKeyDown'){// On the selectionchange event, the target is just document which isn't
// helpful for us so just check activeElement instead.
//
// 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
// propertychange on the first input event after setting `value` from a
// script and fires only keydown, keypress, keyup. Catching keyup usually
// gets it and catching keydown lets us fire an event for the first
// keystroke if user does a key repeat (it'll be a little delayed: right
// before the second keystroke). Other input methods (e.g., paste) seem to
// fire selectionchange normally.
return getInstIfValueChanged(activeElementInst);}}/**
 * SECTION: handle `click` event
 */function shouldUseClickEvent(elem){// Use the `click` event to detect changes to checkbox and radio inputs.
// This approach works across all browsers, whereas `change` does not fire
// until `blur` in IE8.
var nodeName=elem.nodeName;return nodeName&&nodeName.toLowerCase()==='input'&&(elem.type==='checkbox'||elem.type==='radio');}function getTargetInstForClickEvent(topLevelType,targetInst){if(topLevelType==='topClick'){return getInstIfValueChanged(targetInst);}}function getTargetInstForInputOrChangeEvent(topLevelType,targetInst){if(topLevelType==='topInput'||topLevelType==='topChange'){return getInstIfValueChanged(targetInst);}}function handleControlledInputBlur(inst,node){// TODO: In IE, inst is occasionally null. Why?
if(inst==null){return;}// Fiber and ReactDOM keep wrapper state in separate places
var state=inst._wrapperState||node._wrapperState;if(!state||!state.controlled||node.type!=='number'){return;}// If controlled, assign the value attribute to the current value on blur
var value=''+node.value;if(node.getAttribute('value')!==value){node.setAttribute('value',value);}}/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */var ChangeEventPlugin={eventTypes:eventTypes$1,_isInputEventSupported:isInputEventSupported,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;var getTargetInstFunc,handleEventFunc;if(shouldUseChangeEvent(targetNode)){getTargetInstFunc=getTargetInstForChangeEvent;}else if(isTextInputElement(targetNode)){if(isInputEventSupported){getTargetInstFunc=getTargetInstForInputOrChangeEvent;}else{getTargetInstFunc=getTargetInstForInputEventPolyfill;handleEventFunc=handleEventsForInputEventPolyfill;}}else if(shouldUseClickEvent(targetNode)){getTargetInstFunc=getTargetInstForClickEvent;}if(getTargetInstFunc){var inst=getTargetInstFunc(topLevelType,targetInst);if(inst){var event=createAndAccumulateChangeEvent(inst,nativeEvent,nativeEventTarget);return event;}}if(handleEventFunc){handleEventFunc(topLevelType,targetNode,targetInst);}// When blurring, set the value attribute for number inputs
if(topLevelType==='topBlur'){handleControlledInputBlur(targetInst,targetNode);}}};/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */var DOMEventPluginOrder=['ResponderEventPlugin','SimpleEventPlugin','TapEventPlugin','EnterLeaveEventPlugin','ChangeEventPlugin','SelectEventPlugin','BeforeInputEventPlugin'];/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var UIEventInterface={view:null,detail:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticUIEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticUIEvent,UIEventInterface);/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */var modifierKeyToProp={Alt:'altKey',Control:'ctrlKey',Meta:'metaKey',Shift:'shiftKey'};// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg){var syntheticEvent=this;var nativeEvent=syntheticEvent.nativeEvent;if(nativeEvent.getModifierState){return nativeEvent.getModifierState(keyArg);}var keyProp=modifierKeyToProp[keyArg];return keyProp?!!nativeEvent[keyProp]:false;}function getEventModifierState(nativeEvent){return modifierStateGetter;}/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var MouseEventInterface={screenX:null,screenY:null,clientX:null,clientY:null,pageX:null,pageY:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,getModifierState:getEventModifierState,button:null,buttons:null,relatedTarget:function relatedTarget(event){return event.relatedTarget||(event.fromElement===event.srcElement?event.toElement:event.fromElement);}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticMouseEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticMouseEvent,MouseEventInterface);var eventTypes$2={mouseEnter:{registrationName:'onMouseEnter',dependencies:['topMouseOut','topMouseOver']},mouseLeave:{registrationName:'onMouseLeave',dependencies:['topMouseOut','topMouseOver']}};var EnterLeaveEventPlugin={eventTypes:eventTypes$2,/**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){if(topLevelType==='topMouseOver'&&(nativeEvent.relatedTarget||nativeEvent.fromElement)){return null;}if(topLevelType!=='topMouseOut'&&topLevelType!=='topMouseOver'){// Must not be a mouse in or mouse out - ignoring.
return null;}var win;if(nativeEventTarget.window===nativeEventTarget){// `nativeEventTarget` is probably a window object.
win=nativeEventTarget;}else{// TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
var doc=nativeEventTarget.ownerDocument;if(doc){win=doc.defaultView||doc.parentWindow;}else{win=window;}}var from;var to;if(topLevelType==='topMouseOut'){from=targetInst;var related=nativeEvent.relatedTarget||nativeEvent.toElement;to=related?getClosestInstanceFromNode(related):null;}else{// Moving to a node from outside the window.
from=null;to=targetInst;}if(from===to){// Nothing pertains to our managed components.
return null;}var fromNode=from==null?win:getNodeFromInstance$1(from);var toNode=to==null?win:getNodeFromInstance$1(to);var leave=SyntheticMouseEvent.getPooled(eventTypes$2.mouseLeave,from,nativeEvent,nativeEventTarget);leave.type='mouseleave';leave.target=fromNode;leave.relatedTarget=toNode;var enter=SyntheticMouseEvent.getPooled(eventTypes$2.mouseEnter,to,nativeEvent,nativeEventTarget);enter.type='mouseenter';enter.target=toNode;enter.relatedTarget=fromNode;accumulateEnterLeaveDispatches(leave,enter,from,to);return[leave,enter];}};/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 *
 * Note that this module is currently shared and assumed to be stateless.
 * If this becomes an actual Map, that will break.
 *//**
 * This API should be called `delete` but we'd have to make sure to always
 * transform these to strings for IE support. When this transform is fully
 * supported we can rename it.
 */function get(key){return key._reactInternalFiber;}function has(key){return key._reactInternalFiber!==undefined;}function set(key,value){key._reactInternalFiber=value;}var ReactInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;var ReactCurrentOwner=ReactInternals.ReactCurrentOwner;var ReactDebugCurrentFrame=ReactInternals.ReactDebugCurrentFrame;function getComponentName(fiber){var type=fiber.type;if(typeof type==='string'){return type;}if(typeof type==='function'){return type.displayName||type.name;}return null;}// Don't change these two values:
var NoEffect=0;//           0b00000000
var PerformedWork=1;//      0b00000001
// You can change the rest (and add more).
var Placement=2;//          0b00000010
var Update=4;//             0b00000100
var PlacementAndUpdate=6;// 0b00000110
var Deletion=8;//           0b00001000
var ContentReset=16;//      0b00010000
var Callback=32;//          0b00100000
var Err=64;//               0b01000000
var Ref=128;//              0b10000000
var MOUNTING=1;var MOUNTED=2;var UNMOUNTED=3;function isFiberMountedImpl(fiber){var node=fiber;if(!fiber.alternate){// If there is no alternate, this might be a new tree that isn't inserted
// yet. If it is, then it will have a pending insertion effect on it.
if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}while(node['return']){node=node['return'];if((node.effectTag&Placement)!==NoEffect){return MOUNTING;}}}else{while(node['return']){node=node['return'];}}if(node.tag===HostRoot){// TODO: Check if this was a nested HostRoot when used with
// renderContainerIntoSubtree.
return MOUNTED;}// If we didn't hit the root, that means that we're in an disconnected tree
// that has been unmounted.
return UNMOUNTED;}function isFiberMounted(fiber){return isFiberMountedImpl(fiber)===MOUNTED;}function isMounted(component){{var owner=ReactCurrentOwner.current;if(owner!==null&&owner.tag===ClassComponent){var ownerFiber=owner;var instance=ownerFiber.stateNode;warning(instance._warnedAboutRefsInRender,'%s is accessing isMounted inside its render() function. '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(ownerFiber)||'A component');instance._warnedAboutRefsInRender=true;}}var fiber=get(component);if(!fiber){return false;}return isFiberMountedImpl(fiber)===MOUNTED;}function assertIsMounted(fiber){!(isFiberMountedImpl(fiber)===MOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){// If there is no alternate, then we only need to check if it is mounted.
var state=isFiberMountedImpl(fiber);!(state!==UNMOUNTED)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(state===MOUNTING){return null;}return fiber;}// If we have two possible branches, we'll walk backwards up to the root
// to see what path the root points to. On the way we may hit one of the
// special cases and we'll deal with them.
var a=fiber;var b=alternate;while(true){var parentA=a['return'];var parentB=parentA?parentA.alternate:null;if(!parentA||!parentB){// We're at the root.
break;}// If both copies of the parent fiber point to the same child, we can
// assume that the child is current. This happens when we bailout on low
// priority: the bailed out fiber's child reuses the current child.
if(parentA.child===parentB.child){var child=parentA.child;while(child){if(child===a){// We've determined that A is the current branch.
assertIsMounted(parentA);return fiber;}if(child===b){// We've determined that B is the current branch.
assertIsMounted(parentA);return alternate;}child=child.sibling;}// We should never have an alternate for any mounting node. So the only
// way this could possibly happen is if this was unmounted, if at all.
invariant(false,'Unable to find node on an unmounted component.');}if(a['return']!==b['return']){// The return pointer of A and the return pointer of B point to different
// fibers. We assume that return pointers never criss-cross, so A must
// belong to the child set of A.return, and B must belong to the child
// set of B.return.
a=parentA;b=parentB;}else{// The return pointers point to the same fiber. We'll have to use the
// default, slow path: scan the child sets of each parent alternate to see
// which child belongs to which set.
//
// Search parent A's child set
var didFindChild=false;var _child=parentA.child;while(_child){if(_child===a){didFindChild=true;a=parentA;b=parentB;break;}if(_child===b){didFindChild=true;b=parentA;a=parentB;break;}_child=_child.sibling;}if(!didFindChild){// Search parent B's child set
_child=parentB.child;while(_child){if(_child===a){didFindChild=true;a=parentB;b=parentA;break;}if(_child===b){didFindChild=true;b=parentB;a=parentA;break;}_child=_child.sibling;}!didFindChild?invariant(false,'Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.'):void 0;}}!(a.alternate===b)?invariant(false,'Return fibers should always be each others\' alternates. This error is likely caused by a bug in React. Please file an issue.'):void 0;}// If the root is not a host container, we're in a disconnected tree. I.e.
// unmounted.
!(a.tag===HostRoot)?invariant(false,'Unable to find node on an unmounted component.'):void 0;if(a.stateNode.current===a){// We've determined that A is the current branch.
return fiber;}// Otherwise B has to be current branch.
return alternate;}function findCurrentHostFiber(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}function findCurrentHostFiberWithNoPortals(parent){var currentParent=findCurrentFiberUsingSlowPath(parent);if(!currentParent){return null;}// Next we'll drill down this component to find the first HostComponent/Text.
var node=currentParent;while(true){if(node.tag===HostComponent||node.tag===HostText){return node;}else if(node.child&&node.tag!==HostPortal){node.child['return']=node;node=node.child;continue;}if(node===currentParent){return null;}while(!node.sibling){if(!node['return']||node['return']===currentParent){return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}// Flow needs the return null here, but ESLint complains about it.
// eslint-disable-next-line no-unreachable
return null;}var CALLBACK_BOOKKEEPING_POOL_SIZE=10;var callbackBookkeepingPool=[];/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */function findRootContainerNode(inst){// TODO: It may be a good idea to cache this to prevent unnecessary DOM
// traversal, but caching is difficult to do correctly without using a
// mutation observer to listen for all DOM changes.
while(inst['return']){inst=inst['return'];}if(inst.tag!==HostRoot){// This can happen if we're in a detached tree.
return null;}return inst.stateNode.containerInfo;}// Used to store ancestor hierarchy in top level callback
function getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst){if(callbackBookkeepingPool.length){var instance=callbackBookkeepingPool.pop();instance.topLevelType=topLevelType;instance.nativeEvent=nativeEvent;instance.targetInst=targetInst;return instance;}return{topLevelType:topLevelType,nativeEvent:nativeEvent,targetInst:targetInst,ancestors:[]};}function releaseTopLevelCallbackBookKeeping(instance){instance.topLevelType=null;instance.nativeEvent=null;instance.targetInst=null;instance.ancestors.length=0;if(callbackBookkeepingPool.length<CALLBACK_BOOKKEEPING_POOL_SIZE){callbackBookkeepingPool.push(instance);}}function handleTopLevelImpl(bookKeeping){var targetInst=bookKeeping.targetInst;// Loop through the hierarchy, in case there's any nested components.
// It's important that we build the array of ancestors before calling any
// event handlers, because event handlers can modify the DOM, leading to
// inconsistencies with ReactMount's node cache. See #1105.
var ancestor=targetInst;do{if(!ancestor){bookKeeping.ancestors.push(ancestor);break;}var root=findRootContainerNode(ancestor);if(!root){break;}bookKeeping.ancestors.push(ancestor);ancestor=getClosestInstanceFromNode(root);}while(ancestor);for(var i=0;i<bookKeeping.ancestors.length;i++){targetInst=bookKeeping.ancestors[i];_handleTopLevel(bookKeeping.topLevelType,targetInst,bookKeeping.nativeEvent,getEventTarget(bookKeeping.nativeEvent));}}// TODO: can we stop exporting these?
var _enabled=true;var _handleTopLevel=void 0;function setHandleTopLevel(handleTopLevel){_handleTopLevel=handleTopLevel;}function setEnabled(enabled){_enabled=!!enabled;}function isEnabled(){return _enabled;}/**
 * Traps top-level events by using event bubbling.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapBubbledEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.listen(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}/**
 * Traps a top-level event by using event capturing.
 *
 * @param {string} topLevelType Record from `BrowserEventConstants`.
 * @param {string} handlerBaseName Event name (e.g. "click").
 * @param {object} element Element on which to attach listener.
 * @return {?object} An object with a remove function which will forcefully
 *                  remove the listener.
 * @internal
 */function trapCapturedEvent(topLevelType,handlerBaseName,element){if(!element){return null;}return EventListener.capture(element,handlerBaseName,dispatchEvent.bind(null,topLevelType));}function dispatchEvent(topLevelType,nativeEvent){if(!_enabled){return;}var nativeEventTarget=getEventTarget(nativeEvent);var targetInst=getClosestInstanceFromNode(nativeEventTarget);if(targetInst!==null&&typeof targetInst.tag==='number'&&!isFiberMounted(targetInst)){// If we get an event (ex: img onload) before committing that
// component's mount, ignore it for now (that is, treat it as if it was an
// event on a non-React tree). We might also consider queueing events and
// dispatching them after the mount.
targetInst=null;}var bookKeeping=getTopLevelCallbackBookKeeping(topLevelType,nativeEvent,targetInst);try{// Event queue being processed in the same cycle allows
// `preventDefault`.
batchedUpdates(handleTopLevelImpl,bookKeeping);}finally{releaseTopLevelCallbackBookKeeping(bookKeeping);}}var ReactDOMEventListener=Object.freeze({get _enabled(){return _enabled;},get _handleTopLevel(){return _handleTopLevel;},setHandleTopLevel:setHandleTopLevel,setEnabled:setEnabled,isEnabled:isEnabled,trapBubbledEvent:trapBubbledEvent,trapCapturedEvent:trapCapturedEvent,dispatchEvent:dispatchEvent});/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */function makePrefixMap(styleProp,eventName){var prefixes={};prefixes[styleProp.toLowerCase()]=eventName.toLowerCase();prefixes['Webkit'+styleProp]='webkit'+eventName;prefixes['Moz'+styleProp]='moz'+eventName;prefixes['ms'+styleProp]='MS'+eventName;prefixes['O'+styleProp]='o'+eventName.toLowerCase();return prefixes;}/**
 * A list of event names to a configurable list of vendor prefixes.
 */var vendorPrefixes={animationend:makePrefixMap('Animation','AnimationEnd'),animationiteration:makePrefixMap('Animation','AnimationIteration'),animationstart:makePrefixMap('Animation','AnimationStart'),transitionend:makePrefixMap('Transition','TransitionEnd')};/**
 * Event names that have already been detected and prefixed (if applicable).
 */var prefixedEventNames={};/**
 * Element to check for prefixes on.
 */var style={};/**
 * Bootstrap if a DOM exists.
 */if(ExecutionEnvironment.canUseDOM){style=document.createElement('div').style;// On some platforms, in particular some releases of Android 4.x,
// the un-prefixed "animation" and "transition" properties are defined on the
// style object but the events that fire will still be prefixed, so we need
// to check if the un-prefixed events are usable, and if not remove them from the map.
if(!('AnimationEvent'in window)){delete vendorPrefixes.animationend.animation;delete vendorPrefixes.animationiteration.animation;delete vendorPrefixes.animationstart.animation;}// Same as above
if(!('TransitionEvent'in window)){delete vendorPrefixes.transitionend.transition;}}/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */function getVendorPrefixedEventName(eventName){if(prefixedEventNames[eventName]){return prefixedEventNames[eventName];}else if(!vendorPrefixes[eventName]){return eventName;}var prefixMap=vendorPrefixes[eventName];for(var styleProp in prefixMap){if(prefixMap.hasOwnProperty(styleProp)&&styleProp in style){return prefixedEventNames[eventName]=prefixMap[styleProp];}}return'';}/**
 * Types of raw signals from the browser caught at the top level.
 *
 * For events like 'submit' which don't consistently bubble (which we
 * trap at a lower node than `document`), binding at `document` would
 * cause duplicate events so we don't include them here.
 */var topLevelTypes$1={topAbort:'abort',topAnimationEnd:getVendorPrefixedEventName('animationend')||'animationend',topAnimationIteration:getVendorPrefixedEventName('animationiteration')||'animationiteration',topAnimationStart:getVendorPrefixedEventName('animationstart')||'animationstart',topBlur:'blur',topCancel:'cancel',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topChange:'change',topClick:'click',topClose:'close',topCompositionEnd:'compositionend',topCompositionStart:'compositionstart',topCompositionUpdate:'compositionupdate',topContextMenu:'contextmenu',topCopy:'copy',topCut:'cut',topDoubleClick:'dblclick',topDrag:'drag',topDragEnd:'dragend',topDragEnter:'dragenter',topDragExit:'dragexit',topDragLeave:'dragleave',topDragOver:'dragover',topDragStart:'dragstart',topDrop:'drop',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topFocus:'focus',topInput:'input',topKeyDown:'keydown',topKeyPress:'keypress',topKeyUp:'keyup',topLoadedData:'loadeddata',topLoad:'load',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topMouseDown:'mousedown',topMouseMove:'mousemove',topMouseOut:'mouseout',topMouseOver:'mouseover',topMouseUp:'mouseup',topPaste:'paste',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topScroll:'scroll',topSeeked:'seeked',topSeeking:'seeking',topSelectionChange:'selectionchange',topStalled:'stalled',topSuspend:'suspend',topTextInput:'textInput',topTimeUpdate:'timeupdate',topToggle:'toggle',topTouchCancel:'touchcancel',topTouchEnd:'touchend',topTouchMove:'touchmove',topTouchStart:'touchstart',topTransitionEnd:getVendorPrefixedEventName('transitionend')||'transitionend',topVolumeChange:'volumechange',topWaiting:'waiting',topWheel:'wheel'};var BrowserEventConstants={topLevelTypes:topLevelTypes$1};function runEventQueueInBatch(events){enqueueEvents(events);processEventQueue(false);}/**
 * Streams a fired top-level event to `EventPluginHub` where plugins have the
 * opportunity to create `ReactEvent`s to be dispatched.
 */function handleTopLevel(topLevelType,targetInst,nativeEvent,nativeEventTarget){var events=extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget);runEventQueueInBatch(events);}var topLevelTypes=BrowserEventConstants.topLevelTypes;/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactDOMEventListener, which is injected and can therefore support
 *    pluggable event sources. This is the only work that occurs in the main
 *    thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */var alreadyListeningTo={};var reactTopListenersCounter=0;/**
 * To ensure no conflicts with other potential React instances on the page
 */var topListenersIDKey='_reactListenersID'+(''+Math.random()).slice(2);function getListeningForDocument(mountAt){// In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
// directly.
if(!Object.prototype.hasOwnProperty.call(mountAt,topListenersIDKey)){mountAt[topListenersIDKey]=reactTopListenersCounter++;alreadyListeningTo[mountAt[topListenersIDKey]]={};}return alreadyListeningTo[mountAt[topListenersIDKey]];}/**
 * We listen for bubbled touch events on the document object.
 *
 * Firefox v8.01 (and possibly others) exhibited strange behavior when
 * mounting `onmousemove` events at some node that was not the document
 * element. The symptoms were that if your mouse is not moving over something
 * contained within that mount point (for example on the background) the
 * top-level listeners for `onmousemove` won't be called. However, if you
 * register the `mousemove` on the document object, then it will of course
 * catch all `mousemove`s. This along with iOS quirks, justifies restricting
 * top-level listeners to the document object only, at least for these
 * movement types of events and possibly all events.
 *
 * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
 *
 * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
 * they bubble to document.
 *
 * @param {string} registrationName Name of listener (e.g. `onClick`).
 * @param {object} contentDocumentHandle Document which owns the container
 */function listenTo(registrationName,contentDocumentHandle){var mountAt=contentDocumentHandle;var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){if(dependency==='topWheel'){if(isEventSupported('wheel')){trapBubbledEvent('topWheel','wheel',mountAt);}else if(isEventSupported('mousewheel')){trapBubbledEvent('topWheel','mousewheel',mountAt);}else{// Firefox needs to capture a different mouse scroll event.
// @see http://www.quirksmode.org/dom/events/tests/scroll.html
trapBubbledEvent('topWheel','DOMMouseScroll',mountAt);}}else if(dependency==='topScroll'){trapCapturedEvent('topScroll','scroll',mountAt);}else if(dependency==='topFocus'||dependency==='topBlur'){trapCapturedEvent('topFocus','focus',mountAt);trapCapturedEvent('topBlur','blur',mountAt);// to make sure blur and focus event listeners are only attached once
isListening.topBlur=true;isListening.topFocus=true;}else if(dependency==='topCancel'){if(isEventSupported('cancel',true)){trapCapturedEvent('topCancel','cancel',mountAt);}isListening.topCancel=true;}else if(dependency==='topClose'){if(isEventSupported('close',true)){trapCapturedEvent('topClose','close',mountAt);}isListening.topClose=true;}else if(topLevelTypes.hasOwnProperty(dependency)){trapBubbledEvent(dependency,topLevelTypes[dependency],mountAt);}isListening[dependency]=true;}}}function isListeningToAllDependencies(registrationName,mountAt){var isListening=getListeningForDocument(mountAt);var dependencies=registrationNameDependencies[registrationName];for(var i=0;i<dependencies.length;i++){var dependency=dependencies[i];if(!(isListening.hasOwnProperty(dependency)&&isListening[dependency])){return false;}}return true;}/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */function getLeafNode(node){while(node&&node.firstChild){node=node.firstChild;}return node;}/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */function getSiblingNode(node){while(node){if(node.nextSibling){return node.nextSibling;}node=node.parentNode;}}/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */function getNodeForCharacterOffset(root,offset){var node=getLeafNode(root);var nodeStart=0;var nodeEnd=0;while(node){if(node.nodeType===TEXT_NODE){nodeEnd=nodeStart+node.textContent.length;if(nodeStart<=offset&&nodeEnd>=offset){return{node:node,offset:offset-nodeStart};}nodeStart=nodeEnd;}node=getLeafNode(getSiblingNode(node));}}/**
 * @param {DOMElement} outerNode
 * @return {?object}
 */function getOffsets(outerNode){var selection=window.getSelection&&window.getSelection();if(!selection||selection.rangeCount===0){return null;}var anchorNode=selection.anchorNode;var anchorOffset=selection.anchorOffset;var focusNode$$1=selection.focusNode;var focusOffset=selection.focusOffset;// In Firefox, anchorNode and focusNode can be "anonymous divs", e.g. the
// up/down buttons on an <input type="number">. Anonymous divs do not seem to
// expose properties, triggering a "Permission denied error" if any of its
// properties are accessed. The only seemingly possible way to avoid erroring
// is to access a property that typically works for non-anonymous divs and
// catch any error that may otherwise arise. See
// https://bugzilla.mozilla.org/show_bug.cgi?id=208427
try{/* eslint-disable no-unused-expressions */anchorNode.nodeType;focusNode$$1.nodeType;/* eslint-enable no-unused-expressions */}catch(e){return null;}return getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset);}/**
 * Returns {start, end} where `start` is the character/codepoint index of
 * (anchorNode, anchorOffset) within the textContent of `outerNode`, and
 * `end` is the index of (focusNode, focusOffset).
 *
 * Returns null if you pass in garbage input but we should probably just crash.
 *
 * Exported only for testing.
 */function getModernOffsetsFromPoints(outerNode,anchorNode,anchorOffset,focusNode$$1,focusOffset){var length=0;var start=-1;var end=-1;var indexWithinAnchor=0;var indexWithinFocus=0;var node=outerNode;var parentNode=null;outer:while(true){var next=null;while(true){if(node===anchorNode&&(anchorOffset===0||node.nodeType===TEXT_NODE)){start=length+anchorOffset;}if(node===focusNode$$1&&(focusOffset===0||node.nodeType===TEXT_NODE)){end=length+focusOffset;}if(node.nodeType===TEXT_NODE){length+=node.nodeValue.length;}if((next=node.firstChild)===null){break;}// Moving from `node` to its first child `next`.
parentNode=node;node=next;}while(true){if(node===outerNode){// If `outerNode` has children, this is always the second time visiting
// it. If it has no children, this is still the first loop, and the only
// valid selection is anchorNode and focusNode both equal to this node
// and both offsets 0, in which case we will have handled above.
break outer;}if(parentNode===anchorNode&&++indexWithinAnchor===anchorOffset){start=length;}if(parentNode===focusNode$$1&&++indexWithinFocus===focusOffset){end=length;}if((next=node.nextSibling)!==null){break;}node=parentNode;parentNode=node.parentNode;}// Moving from `node` to its next sibling `next`.
node=next;}if(start===-1||end===-1){// This should never happen. (Would happen if the anchor/focus nodes aren't
// actually inside the passed-in node.)
return null;}return{start:start,end:end};}/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */function setOffsets(node,offsets){if(!window.getSelection){return;}var selection=window.getSelection();var length=node[getTextContentAccessor()].length;var start=Math.min(offsets.start,length);var end=offsets.end===undefined?start:Math.min(offsets.end,length);// IE 11 uses modern selection, but doesn't support the extend method.
// Flip backward selections, so we can set with a single range.
if(!selection.extend&&start>end){var temp=end;end=start;start=temp;}var startMarker=getNodeForCharacterOffset(node,start);var endMarker=getNodeForCharacterOffset(node,end);if(startMarker&&endMarker){if(selection.rangeCount===1&&selection.anchorNode===startMarker.node&&selection.anchorOffset===startMarker.offset&&selection.focusNode===endMarker.node&&selection.focusOffset===endMarker.offset){return;}var range=document.createRange();range.setStart(startMarker.node,startMarker.offset);selection.removeAllRanges();if(start>end){selection.addRange(range);selection.extend(endMarker.node,endMarker.offset);}else{range.setEnd(endMarker.node,endMarker.offset);selection.addRange(range);}}}function isInDocument(node){return containsNode(document.documentElement,node);}/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */function hasSelectionCapabilities(elem){var nodeName=elem&&elem.nodeName&&elem.nodeName.toLowerCase();return nodeName&&(nodeName==='input'&&elem.type==='text'||nodeName==='textarea'||elem.contentEditable==='true');}function getSelectionInformation(){var focusedElem=getActiveElement();return{focusedElem:focusedElem,selectionRange:hasSelectionCapabilities(focusedElem)?getSelection$1(focusedElem):null};}/**
 * @restoreSelection: If any selection information was potentially lost,
 * restore it. This is useful when performing operations that could remove dom
 * nodes and place them back in, resulting in focus being lost.
 */function restoreSelection(priorSelectionInformation){var curFocusedElem=getActiveElement();var priorFocusedElem=priorSelectionInformation.focusedElem;var priorSelectionRange=priorSelectionInformation.selectionRange;if(curFocusedElem!==priorFocusedElem&&isInDocument(priorFocusedElem)){if(hasSelectionCapabilities(priorFocusedElem)){setSelection(priorFocusedElem,priorSelectionRange);}// Focusing a node can change the scroll position, which is undesirable
var ancestors=[];var ancestor=priorFocusedElem;while(ancestor=ancestor.parentNode){if(ancestor.nodeType===ELEMENT_NODE){ancestors.push({element:ancestor,left:ancestor.scrollLeft,top:ancestor.scrollTop});}}focusNode(priorFocusedElem);for(var i=0;i<ancestors.length;i++){var info=ancestors[i];info.element.scrollLeft=info.left;info.element.scrollTop=info.top;}}}/**
 * @getSelection: Gets the selection bounds of a focused textarea, input or
 * contentEditable node.
 * -@input: Look up selection bounds of this input
 * -@return {start: selectionStart, end: selectionEnd}
 */function getSelection$1(input){var selection=void 0;if('selectionStart'in input){// Modern browser with input or textarea.
selection={start:input.selectionStart,end:input.selectionEnd};}else{// Content editable or old IE textarea.
selection=getOffsets(input);}return selection||{start:0,end:0};}/**
 * @setSelection: Sets the selection bounds of a textarea or input and focuses
 * the input.
 * -@input     Set selection bounds of this input or textarea
 * -@offsets   Object of same form that is returned from get*
 */function setSelection(input,offsets){var start=offsets.start,end=offsets.end;if(end===undefined){end=start;}if('selectionStart'in input){input.selectionStart=start;input.selectionEnd=Math.min(end,input.value.length);}else{setOffsets(input,offsets);}}var skipSelectionChangeEvent=ExecutionEnvironment.canUseDOM&&'documentMode'in document&&document.documentMode<=11;var eventTypes$3={select:{phasedRegistrationNames:{bubbled:'onSelect',captured:'onSelectCapture'},dependencies:['topBlur','topContextMenu','topFocus','topKeyDown','topKeyUp','topMouseDown','topMouseUp','topSelectionChange']}};var activeElement$1=null;var activeElementInst$1=null;var lastSelection=null;var mouseDown=false;/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */function getSelection(node){if('selectionStart'in node&&hasSelectionCapabilities(node)){return{start:node.selectionStart,end:node.selectionEnd};}else if(window.getSelection){var selection=window.getSelection();return{anchorNode:selection.anchorNode,anchorOffset:selection.anchorOffset,focusNode:selection.focusNode,focusOffset:selection.focusOffset};}}/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */function constructSelectEvent(nativeEvent,nativeEventTarget){// Ensure we have the right element, and that the user is not dragging a
// selection (this matches native `select` event behavior). In HTML5, select
// fires only on input and textarea thus if there's no focused element we
// won't dispatch.
if(mouseDown||activeElement$1==null||activeElement$1!==getActiveElement()){return null;}// Only fire when selection has actually changed.
var currentSelection=getSelection(activeElement$1);if(!lastSelection||!shallowEqual(lastSelection,currentSelection)){lastSelection=currentSelection;var syntheticEvent=SyntheticEvent$1.getPooled(eventTypes$3.select,activeElementInst$1,nativeEvent,nativeEventTarget);syntheticEvent.type='select';syntheticEvent.target=activeElement$1;accumulateTwoPhaseDispatches(syntheticEvent);return syntheticEvent;}return null;}/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */var SelectEventPlugin={eventTypes:eventTypes$3,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var doc=nativeEventTarget.window===nativeEventTarget?nativeEventTarget.document:nativeEventTarget.nodeType===DOCUMENT_NODE?nativeEventTarget:nativeEventTarget.ownerDocument;// Track whether all listeners exists for this plugin. If none exist, we do
// not extract events. See #3639.
if(!doc||!isListeningToAllDependencies('onSelect',doc)){return null;}var targetNode=targetInst?getNodeFromInstance$1(targetInst):window;switch(topLevelType){// Track the input node that has focus.
case'topFocus':if(isTextInputElement(targetNode)||targetNode.contentEditable==='true'){activeElement$1=targetNode;activeElementInst$1=targetInst;lastSelection=null;}break;case'topBlur':activeElement$1=null;activeElementInst$1=null;lastSelection=null;break;// Don't fire the event while the user is dragging. This matches the
// semantics of the native select event.
case'topMouseDown':mouseDown=true;break;case'topContextMenu':case'topMouseUp':mouseDown=false;return constructSelectEvent(nativeEvent,nativeEventTarget);// Chrome and IE fire non-standard event when selection is changed (and
// sometimes when it hasn't). IE's event fires out of order with respect
// to key and input events on deletion, so we discard it.
//
// Firefox doesn't support selectionchange, so check selection status
// after each key entry. The selection changes after keydown and before
// keyup, but we check on keydown as well in the case of holding down a
// key, when multiple keydown events are fired but only one keyup is.
// This is also our approach for IE handling, for the reason above.
case'topSelectionChange':if(skipSelectionChangeEvent){break;}// falls through
case'topKeyDown':case'topKeyUp':return constructSelectEvent(nativeEvent,nativeEventTarget);}return null;}};/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */var AnimationEventInterface={animationName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticAnimationEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticAnimationEvent,AnimationEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */var ClipboardEventInterface={clipboardData:function clipboardData(event){return'clipboardData'in event?event.clipboardData:window.clipboardData;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticClipboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticClipboardEvent,ClipboardEventInterface);/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var FocusEventInterface={relatedTarget:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticFocusEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticFocusEvent,FocusEventInterface);/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */function getEventCharCode(nativeEvent){var charCode;var keyCode=nativeEvent.keyCode;if('charCode'in nativeEvent){charCode=nativeEvent.charCode;// FF does not set `charCode` for the Enter-key, check against `keyCode`.
if(charCode===0&&keyCode===13){charCode=13;}}else{// IE8 does not implement `charCode`, but `keyCode` has the correct value.
charCode=keyCode;}// Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
// Must not discard the (non-)printable Enter-key.
if(charCode>=32||charCode===13){return charCode;}return 0;}/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var normalizeKey={Esc:'Escape',Spacebar:' ',Left:'ArrowLeft',Up:'ArrowUp',Right:'ArrowRight',Down:'ArrowDown',Del:'Delete',Win:'OS',Menu:'ContextMenu',Apps:'ContextMenu',Scroll:'ScrollLock',MozPrintableKey:'Unidentified'};/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */var translateToKey={'8':'Backspace','9':'Tab','12':'Clear','13':'Enter','16':'Shift','17':'Control','18':'Alt','19':'Pause','20':'CapsLock','27':'Escape','32':' ','33':'PageUp','34':'PageDown','35':'End','36':'Home','37':'ArrowLeft','38':'ArrowUp','39':'ArrowRight','40':'ArrowDown','45':'Insert','46':'Delete','112':'F1','113':'F2','114':'F3','115':'F4','116':'F5','117':'F6','118':'F7','119':'F8','120':'F9','121':'F10','122':'F11','123':'F12','144':'NumLock','145':'ScrollLock','224':'Meta'};/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */function getEventKey(nativeEvent){if(nativeEvent.key){// Normalize inconsistent values reported by browsers due to
// implementations of a working draft specification.
// FireFox implements `key` but returns `MozPrintableKey` for all
// printable characters (normalized to `Unidentified`), ignore it.
var key=normalizeKey[nativeEvent.key]||nativeEvent.key;if(key!=='Unidentified'){return key;}}// Browser does not implement `key`, polyfill as much of it as we can.
if(nativeEvent.type==='keypress'){var charCode=getEventCharCode(nativeEvent);// The enter-key is technically both printable and non-printable and can
// thus be captured by `keypress`, no other non-printable key should.
return charCode===13?'Enter':String.fromCharCode(charCode);}if(nativeEvent.type==='keydown'||nativeEvent.type==='keyup'){// While user keyboard layout determines the actual meaning of each
// `keyCode` value, almost all function keys have a universal value.
return translateToKey[nativeEvent.keyCode]||'Unidentified';}return'';}/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var KeyboardEventInterface={key:getEventKey,location:null,ctrlKey:null,shiftKey:null,altKey:null,metaKey:null,repeat:null,locale:null,getModifierState:getEventModifierState,// Legacy Interface
charCode:function charCode(event){// `charCode` is the result of a KeyPress event and represents the value of
// the actual printable character.
// KeyPress is deprecated, but its replacement is not yet final and not
// implemented in any major browser. Only KeyPress has charCode.
if(event.type==='keypress'){return getEventCharCode(event);}return 0;},keyCode:function keyCode(event){// `keyCode` is the result of a KeyDown/Up event and represents the value of
// physical keyboard key.
// The actual meaning of the value depends on the users' keyboard layout
// which cannot be detected. Assuming that it is a US keyboard layout
// provides a surprisingly accurate mapping for US and European users.
// Due to this, it is left to the user to implement at this time.
if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;},which:function which(event){// `which` is an alias for either `keyCode` or `charCode` depending on the
// type of the event.
if(event.type==='keypress'){return getEventCharCode(event);}if(event.type==='keydown'||event.type==='keyup'){return event.keyCode;}return 0;}};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticKeyboardEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent,KeyboardEventInterface);/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var DragEventInterface={dataTransfer:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticDragEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticDragEvent,DragEventInterface);/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */var TouchEventInterface={touches:null,targetTouches:null,changedTouches:null,altKey:null,metaKey:null,ctrlKey:null,shiftKey:null,getModifierState:getEventModifierState};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */function SyntheticTouchEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticUIEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticUIEvent.augmentClass(SyntheticTouchEvent,TouchEventInterface);/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */var TransitionEventInterface={propertyName:null,elapsedTime:null,pseudoElement:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */function SyntheticTransitionEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticEvent$1.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticEvent$1.augmentClass(SyntheticTransitionEvent,TransitionEventInterface);/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */var WheelEventInterface={deltaX:function deltaX(event){return'deltaX'in event?event.deltaX:// Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
'wheelDeltaX'in event?-event.wheelDeltaX:0;},deltaY:function deltaY(event){return'deltaY'in event?event.deltaY:// Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
'wheelDeltaY'in event?-event.wheelDeltaY:// Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
'wheelDelta'in event?-event.wheelDelta:0;},deltaZ:null,// Browsers without "deltaMode" is reporting in raw wheel delta where one
// notch on the scroll is always +/- 120, roughly equivalent to pixels.
// A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
// ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
deltaMode:null};/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */function SyntheticWheelEvent(dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget){return SyntheticMouseEvent.call(this,dispatchConfig,dispatchMarker,nativeEvent,nativeEventTarget);}SyntheticMouseEvent.augmentClass(SyntheticWheelEvent,WheelEventInterface);/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */var eventTypes$4={};var topLevelEventsToDispatchConfig={};['abort','animationEnd','animationIteration','animationStart','blur','cancel','canPlay','canPlayThrough','click','close','contextMenu','copy','cut','doubleClick','drag','dragEnd','dragEnter','dragExit','dragLeave','dragOver','dragStart','drop','durationChange','emptied','encrypted','ended','error','focus','input','invalid','keyDown','keyPress','keyUp','load','loadedData','loadedMetadata','loadStart','mouseDown','mouseMove','mouseOut','mouseOver','mouseUp','paste','pause','play','playing','progress','rateChange','reset','scroll','seeked','seeking','stalled','submit','suspend','timeUpdate','toggle','touchCancel','touchEnd','touchMove','touchStart','transitionEnd','volumeChange','waiting','wheel'].forEach(function(event){var capitalizedEvent=event[0].toUpperCase()+event.slice(1);var onEvent='on'+capitalizedEvent;var topEvent='top'+capitalizedEvent;var type={phasedRegistrationNames:{bubbled:onEvent,captured:onEvent+'Capture'},dependencies:[topEvent]};eventTypes$4[event]=type;topLevelEventsToDispatchConfig[topEvent]=type;});// Only used in DEV for exhaustiveness validation.
var knownHTMLTopLevelTypes=['topAbort','topCancel','topCanPlay','topCanPlayThrough','topClose','topDurationChange','topEmptied','topEncrypted','topEnded','topError','topInput','topInvalid','topLoad','topLoadedData','topLoadedMetadata','topLoadStart','topPause','topPlay','topPlaying','topProgress','topRateChange','topReset','topSeeked','topSeeking','topStalled','topSubmit','topSuspend','topTimeUpdate','topToggle','topVolumeChange','topWaiting'];var SimpleEventPlugin={eventTypes:eventTypes$4,extractEvents:function extractEvents(topLevelType,targetInst,nativeEvent,nativeEventTarget){var dispatchConfig=topLevelEventsToDispatchConfig[topLevelType];if(!dispatchConfig){return null;}var EventConstructor;switch(topLevelType){case'topKeyPress':// Firefox creates a keypress event for function keys too. This removes
// the unwanted keypress events. Enter is however both printable and
// non-printable. One would expect Tab to be as well (but it isn't).
if(getEventCharCode(nativeEvent)===0){return null;}/* falls through */case'topKeyDown':case'topKeyUp':EventConstructor=SyntheticKeyboardEvent;break;case'topBlur':case'topFocus':EventConstructor=SyntheticFocusEvent;break;case'topClick':// Firefox creates a click event on right mouse clicks. This removes the
// unwanted click events.
if(nativeEvent.button===2){return null;}/* falls through */case'topDoubleClick':case'topMouseDown':case'topMouseMove':case'topMouseUp':// TODO: Disabled elements should not respond to mouse events
/* falls through */case'topMouseOut':case'topMouseOver':case'topContextMenu':EventConstructor=SyntheticMouseEvent;break;case'topDrag':case'topDragEnd':case'topDragEnter':case'topDragExit':case'topDragLeave':case'topDragOver':case'topDragStart':case'topDrop':EventConstructor=SyntheticDragEvent;break;case'topTouchCancel':case'topTouchEnd':case'topTouchMove':case'topTouchStart':EventConstructor=SyntheticTouchEvent;break;case'topAnimationEnd':case'topAnimationIteration':case'topAnimationStart':EventConstructor=SyntheticAnimationEvent;break;case'topTransitionEnd':EventConstructor=SyntheticTransitionEvent;break;case'topScroll':EventConstructor=SyntheticUIEvent;break;case'topWheel':EventConstructor=SyntheticWheelEvent;break;case'topCopy':case'topCut':case'topPaste':EventConstructor=SyntheticClipboardEvent;break;default:{if(knownHTMLTopLevelTypes.indexOf(topLevelType)===-1){warning(false,'SimpleEventPlugin: Unhandled event type, `%s`. This warning '+'is likely caused by a bug in React. Please file an issue.',topLevelType);}}// HTML Events
// @see http://www.w3.org/TR/html5/index.html#events-0
EventConstructor=SyntheticEvent$1;break;}var event=EventConstructor.getPooled(dispatchConfig,targetInst,nativeEvent,nativeEventTarget);accumulateTwoPhaseDispatches(event);return event;}};setHandleTopLevel(handleTopLevel);/**
 * Inject modules for resolving DOM hierarchy and plugin ordering.
 */injection$1.injectEventPluginOrder(DOMEventPluginOrder);injection$2.injectComponentTree(ReactDOMComponentTree);/**
 * Some important event plugins included by default (without having to require
 * them).
 */injection$1.injectEventPluginsByName({SimpleEventPlugin:SimpleEventPlugin,EnterLeaveEventPlugin:EnterLeaveEventPlugin,ChangeEventPlugin:ChangeEventPlugin,SelectEventPlugin:SelectEventPlugin,BeforeInputEventPlugin:BeforeInputEventPlugin});var enableAsyncSubtreeAPI=true;var enableAsyncSchedulingByDefaultInReactDOM=false;// Exports React.Fragment
var enableReactFragment=false;// Exports ReactDOM.createRoot
var enableCreateRoot=false;var enableUserTimingAPI=true;// Mutating mode (React DOM, React ART, React Native):
var enableMutatingReconciler=true;// Experimental noop mode (currently unused):
var enableNoopReconciler=false;// Experimental persistent mode (CS):
var enablePersistentReconciler=false;// Only used in www builds.
var valueStack=[];{var fiberStack=[];}var index=-1;function createCursor(defaultValue){return{current:defaultValue};}function pop(cursor,fiber){if(index<0){{warning(false,'Unexpected pop.');}return;}{if(fiber!==fiberStack[index]){warning(false,'Unexpected Fiber popped.');}}cursor.current=valueStack[index];valueStack[index]=null;{fiberStack[index]=null;}index--;}function push(cursor,value,fiber){index++;valueStack[index]=cursor.current;{fiberStack[index]=fiber;}cursor.current=value;}function reset$1(){while(index>-1){valueStack[index]=null;{fiberStack[index]=null;}index--;}}var describeComponentFrame=function describeComponentFrame(name,source,ownerName){return'\n    in '+(name||'Unknown')+(source?' (at '+source.fileName.replace(/^.*[\\\/]/,'')+':'+source.lineNumber+')':ownerName?' (created by '+ownerName+')':'');};function describeFiber(fiber){switch(fiber.tag){case IndeterminateComponent:case FunctionalComponent:case ClassComponent:case HostComponent:var owner=fiber._debugOwner;var source=fiber._debugSource;var name=getComponentName(fiber);var ownerName=null;if(owner){ownerName=getComponentName(owner);}return describeComponentFrame(name,source,ownerName);default:return'';}}// This function can only be called with a work-in-progress fiber and
// only during begin or complete phase. Do not call it under any other
// circumstances.
function getStackAddendumByWorkInProgressFiber(workInProgress){var info='';var node=workInProgress;do{info+=describeFiber(node);// Otherwise this return pointer might point to the wrong tree:
node=node['return'];}while(node);return info;}function getCurrentFiberOwnerName(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}var owner=fiber._debugOwner;if(owner!==null&&typeof owner!=='undefined'){return getComponentName(owner);}}return null;}function getCurrentFiberStackAddendum(){{var fiber=ReactDebugCurrentFiber.current;if(fiber===null){return null;}// Safe because if current fiber exists, we are reconciling,
// and it is guaranteed to be the work-in-progress version.
return getStackAddendumByWorkInProgressFiber(fiber);}return null;}function resetCurrentFiber(){ReactDebugCurrentFrame.getCurrentStack=null;ReactDebugCurrentFiber.current=null;ReactDebugCurrentFiber.phase=null;}function setCurrentFiber(fiber){ReactDebugCurrentFrame.getCurrentStack=getCurrentFiberStackAddendum;ReactDebugCurrentFiber.current=fiber;ReactDebugCurrentFiber.phase=null;}function setCurrentPhase(phase){ReactDebugCurrentFiber.phase=phase;}var ReactDebugCurrentFiber={current:null,phase:null,resetCurrentFiber:resetCurrentFiber,setCurrentFiber:setCurrentFiber,setCurrentPhase:setCurrentPhase,getCurrentFiberOwnerName:getCurrentFiberOwnerName,getCurrentFiberStackAddendum:getCurrentFiberStackAddendum};// Prefix measurements so that it's possible to filter them.
// Longer prefixes are hard to read in DevTools.
var reactEmoji='\u269B';var warningEmoji='\u26D4';var supportsUserTiming=typeof performance!=='undefined'&&typeof performance.mark==='function'&&typeof performance.clearMarks==='function'&&typeof performance.measure==='function'&&typeof performance.clearMeasures==='function';// Keep track of current fiber so that we know the path to unwind on pause.
// TODO: this looks the same as nextUnitOfWork in scheduler. Can we unify them?
var currentFiber=null;// If we're in the middle of user code, which fiber and method is it?
// Reusing `currentFiber` would be confusing for this because user code fiber
// can change during commit phase too, but we don't need to unwind it (since
// lifecycles in the commit phase don't resemble a tree).
var currentPhase=null;var currentPhaseFiber=null;// Did lifecycle hook schedule an update? This is often a performance problem,
// so we will keep track of it, and include it in the report.
// Track commits caused by cascading updates.
var isCommitting=false;var hasScheduledUpdateInCurrentCommit=false;var hasScheduledUpdateInCurrentPhase=false;var commitCountInCurrentWorkLoop=0;var effectCountInCurrentCommit=0;// During commits, we only show a measurement once per method name
// to avoid stretch the commit phase with measurement overhead.
var labelsInCurrentCommit=new Set();var formatMarkName=function formatMarkName(markName){return reactEmoji+' '+markName;};var formatLabel=function formatLabel(label,warning$$1){var prefix=warning$$1?warningEmoji+' ':reactEmoji+' ';var suffix=warning$$1?' Warning: '+warning$$1:'';return''+prefix+label+suffix;};var beginMark=function beginMark(markName){performance.mark(formatMarkName(markName));};var clearMark=function clearMark(markName){performance.clearMarks(formatMarkName(markName));};var endMark=function endMark(label,markName,warning$$1){var formattedMarkName=formatMarkName(markName);var formattedLabel=formatLabel(label,warning$$1);try{performance.measure(formattedLabel,formattedMarkName);}catch(err){}// If previous mark was missing for some reason, this will throw.
// This could only happen if React crashed in an unexpected place earlier.
// Don't pile on with more errors.
// Clear marks immediately to avoid growing buffer.
performance.clearMarks(formattedMarkName);performance.clearMeasures(formattedLabel);};var getFiberMarkName=function getFiberMarkName(label,debugID){return label+' (#'+debugID+')';};var getFiberLabel=function getFiberLabel(componentName,isMounted,phase){if(phase===null){// These are composite component total time measurements.
return componentName+' ['+(isMounted?'update':'mount')+']';}else{// Composite component methods.
return componentName+'.'+phase;}};var beginFiberMark=function beginFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);if(isCommitting&&labelsInCurrentCommit.has(label)){// During the commit phase, we don't show duplicate labels because
// there is a fixed overhead for every measurement, and we don't
// want to stretch the commit phase beyond necessary.
return false;}labelsInCurrentCommit.add(label);var markName=getFiberMarkName(label,debugID);beginMark(markName);return true;};var clearFiberMark=function clearFiberMark(fiber,phase){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);clearMark(markName);};var endFiberMark=function endFiberMark(fiber,phase,warning$$1){var componentName=getComponentName(fiber)||'Unknown';var debugID=fiber._debugID;var isMounted=fiber.alternate!==null;var label=getFiberLabel(componentName,isMounted,phase);var markName=getFiberMarkName(label,debugID);endMark(label,markName,warning$$1);};var shouldIgnoreFiber=function shouldIgnoreFiber(fiber){// Host components should be skipped in the timeline.
// We could check typeof fiber.type, but does this work with RN?
switch(fiber.tag){case HostRoot:case HostComponent:case HostText:case HostPortal:case ReturnComponent:case Fragment:return true;default:return false;}};var clearPendingPhaseMeasurement=function clearPendingPhaseMeasurement(){if(currentPhase!==null&&currentPhaseFiber!==null){clearFiberMark(currentPhaseFiber,currentPhase);}currentPhaseFiber=null;currentPhase=null;hasScheduledUpdateInCurrentPhase=false;};var pauseTimers=function pauseTimers(){// Stops all currently active measurements so that they can be resumed
// if we continue in a later deferred loop from the same unit of work.
var fiber=currentFiber;while(fiber){if(fiber._debugIsCurrentlyTiming){endFiberMark(fiber,null,null);}fiber=fiber['return'];}};var resumeTimersRecursively=function resumeTimersRecursively(fiber){if(fiber['return']!==null){resumeTimersRecursively(fiber['return']);}if(fiber._debugIsCurrentlyTiming){beginFiberMark(fiber,null);}};var resumeTimers=function resumeTimers(){// Resumes all measurements that were active during the last deferred loop.
if(currentFiber!==null){resumeTimersRecursively(currentFiber);}};function recordEffect(){if(enableUserTimingAPI){effectCountInCurrentCommit++;}}function recordScheduleUpdate(){if(enableUserTimingAPI){if(isCommitting){hasScheduledUpdateInCurrentCommit=true;}if(currentPhase!==null&&currentPhase!=='componentWillMount'&&currentPhase!=='componentWillReceiveProps'){hasScheduledUpdateInCurrentPhase=true;}}}function startWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, this is the fiber to unwind from.
currentFiber=fiber;if(!beginFiberMark(fiber,null)){return;}fiber._debugIsCurrentlyTiming=true;}}function cancelWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// Remember we shouldn't complete measurement for this fiber.
// Otherwise flamechart will be deep even for small updates.
fiber._debugIsCurrentlyTiming=false;clearFiberMark(fiber,null);}}function stopWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;endFiberMark(fiber,null,null);}}function stopFailedWorkTimer(fiber){if(enableUserTimingAPI){if(!supportsUserTiming||shouldIgnoreFiber(fiber)){return;}// If we pause, its parent is the fiber to unwind from.
currentFiber=fiber['return'];if(!fiber._debugIsCurrentlyTiming){return;}fiber._debugIsCurrentlyTiming=false;var warning$$1='An error was thrown inside this error boundary';endFiberMark(fiber,null,warning$$1);}}function startPhaseTimer(fiber,phase){if(enableUserTimingAPI){if(!supportsUserTiming){return;}clearPendingPhaseMeasurement();if(!beginFiberMark(fiber,phase)){return;}currentPhaseFiber=fiber;currentPhase=phase;}}function stopPhaseTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}if(currentPhase!==null&&currentPhaseFiber!==null){var warning$$1=hasScheduledUpdateInCurrentPhase?'Scheduled a cascading update':null;endFiberMark(currentPhaseFiber,currentPhase,warning$$1);}currentPhase=null;currentPhaseFiber=null;}}function startWorkLoopTimer(nextUnitOfWork){if(enableUserTimingAPI){currentFiber=nextUnitOfWork;if(!supportsUserTiming){return;}commitCountInCurrentWorkLoop=0;// This is top level call.
// Any other measurements are performed within.
beginMark('(React Tree Reconciliation)');// Resume any measurements that were in progress during the last loop.
resumeTimers();}}function stopWorkLoopTimer(interruptedBy){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(interruptedBy!==null){if(interruptedBy.tag===HostRoot){warning$$1='A top-level update interrupted the previous render';}else{var componentName=getComponentName(interruptedBy)||'Unknown';warning$$1='An update to '+componentName+' interrupted the previous render';}}else if(commitCountInCurrentWorkLoop>1){warning$$1='There were cascading updates';}commitCountInCurrentWorkLoop=0;// Pause any measurements until the next loop.
pauseTimers();endMark('(React Tree Reconciliation)','(React Tree Reconciliation)',warning$$1);}}function startCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}isCommitting=true;hasScheduledUpdateInCurrentCommit=false;labelsInCurrentCommit.clear();beginMark('(Committing Changes)');}}function stopCommitTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var warning$$1=null;if(hasScheduledUpdateInCurrentCommit){warning$$1='Lifecycle hook scheduled a cascading update';}else if(commitCountInCurrentWorkLoop>0){warning$$1='Caused by a cascading update in earlier commit';}hasScheduledUpdateInCurrentCommit=false;commitCountInCurrentWorkLoop++;isCommitting=false;labelsInCurrentCommit.clear();endMark('(Committing Changes)','(Committing Changes)',warning$$1);}}function startCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Committing Host Effects)');}}function stopCommitHostEffectsTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Committing Host Effects: '+count+' Total)','(Committing Host Effects)',null);}}function startCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}effectCountInCurrentCommit=0;beginMark('(Calling Lifecycle Methods)');}}function stopCommitLifeCyclesTimer(){if(enableUserTimingAPI){if(!supportsUserTiming){return;}var count=effectCountInCurrentCommit;effectCountInCurrentCommit=0;endMark('(Calling Lifecycle Methods: '+count+' Total)','(Calling Lifecycle Methods)',null);}}{var warnedAboutMissingGetChildContext={};}// A cursor to the current merged context object on the stack.
var contextStackCursor=createCursor(emptyObject);// A cursor to a boolean indicating whether the context has changed.
var didPerformWorkStackCursor=createCursor(false);// Keep track of the previous context object that was on the stack.
// We use this to get access to the parent context after we have already
// pushed the next context provider, and now need to merge their contexts.
var previousContext=emptyObject;function getUnmaskedContext(workInProgress){var hasOwnContext=isContextProvider(workInProgress);if(hasOwnContext){// If the fiber is a context provider itself, when we read its context
// we have already pushed its own child context on the stack. A context
// provider should not "see" its own child context. Therefore we read the
// previous (parent) context instead for a context provider.
return previousContext;}return contextStackCursor.current;}function cacheContext(workInProgress,unmaskedContext,maskedContext){var instance=workInProgress.stateNode;instance.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext;instance.__reactInternalMemoizedMaskedChildContext=maskedContext;}function getMaskedContext(workInProgress,unmaskedContext){var type=workInProgress.type;var contextTypes=type.contextTypes;if(!contextTypes){return emptyObject;}// Avoid recreating masked context unless unmasked context has changed.
// Failing to do this will result in unnecessary calls to componentWillReceiveProps.
// This may trigger infinite loops if componentWillReceiveProps calls setState.
var instance=workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext){return instance.__reactInternalMemoizedMaskedChildContext;}var context={};for(var key in contextTypes){context[key]=unmaskedContext[key];}{var name=getComponentName(workInProgress)||'Unknown';checkPropTypes(contextTypes,context,'context',name,ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}// Cache unmasked context so we can avoid recreating masked context unless necessary.
// Context is created before the class component is instantiated so check for instance.
if(instance){cacheContext(workInProgress,unmaskedContext,context);}return context;}function hasContextChanged(){return didPerformWorkStackCursor.current;}function isContextConsumer(fiber){return fiber.tag===ClassComponent&&fiber.type.contextTypes!=null;}function isContextProvider(fiber){return fiber.tag===ClassComponent&&fiber.type.childContextTypes!=null;}function popContextProvider(fiber){if(!isContextProvider(fiber)){return;}pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber);}function pushTopLevelContextObject(fiber,context,didChange){!(contextStackCursor.cursor==null)?invariant(false,'Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.'):void 0;push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber);}function processChildContext(fiber,parentContext){var instance=fiber.stateNode;var childContextTypes=fiber.type.childContextTypes;// TODO (bvaughn) Replace this behavior with an invariant() in the future.
// It has only been added in Fiber to match the (unintentional) behavior in Stack.
if(typeof instance.getChildContext!=='function'){{var componentName=getComponentName(fiber)||'Unknown';if(!warnedAboutMissingGetChildContext[componentName]){warnedAboutMissingGetChildContext[componentName]=true;warning(false,'%s.childContextTypes is specified but there is no getChildContext() method '+'on the instance. You can either define getChildContext() on %s or remove '+'childContextTypes from it.',componentName,componentName);}}return parentContext;}var childContext=void 0;{ReactDebugCurrentFiber.setCurrentPhase('getChildContext');}startPhaseTimer(fiber,'getChildContext');childContext=instance.getChildContext();stopPhaseTimer();{ReactDebugCurrentFiber.setCurrentPhase(null);}for(var contextKey in childContext){!(contextKey in childContextTypes)?invariant(false,'%s.getChildContext(): key "%s" is not defined in childContextTypes.',getComponentName(fiber)||'Unknown',contextKey):void 0;}{var name=getComponentName(fiber)||'Unknown';checkPropTypes(childContextTypes,childContext,'child context',name,// In practice, there is one case in which we won't get a stack. It's when
// somebody calls unstable_renderSubtreeIntoContainer() and we process
// context from the parent component instance. The stack will be missing
// because it's outside of the reconciliation, and so the pointer has not
// been set. This is rare and doesn't matter. We'll also remove that API.
ReactDebugCurrentFiber.getCurrentFiberStackAddendum);}return _assign({},parentContext,childContext);}function pushContextProvider(workInProgress){if(!isContextProvider(workInProgress)){return false;}var instance=workInProgress.stateNode;// We push the context as early as possible to ensure stack integrity.
// If the instance does not exist yet, we will push null at first,
// and replace it on the stack later when invalidating the context.
var memoizedMergedChildContext=instance&&instance.__reactInternalMemoizedMergedChildContext||emptyObject;// Remember the parent context so we can merge with it later.
// Inherit the parent's did-perform-work value to avoid inadvertently blocking updates.
previousContext=contextStackCursor.current;push(contextStackCursor,memoizedMergedChildContext,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return true;}function invalidateContextProvider(workInProgress,didChange){var instance=workInProgress.stateNode;!instance?invariant(false,'Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didChange){// Merge parent and own context.
// Skip this if we're not updating due to sCU.
// This avoids unnecessarily recomputing memoized values.
var mergedContext=processChildContext(workInProgress,previousContext);instance.__reactInternalMemoizedMergedChildContext=mergedContext;// Replace the old (or empty) context with the new one.
// It is important to unwind the context in the reverse order.
pop(didPerformWorkStackCursor,workInProgress);pop(contextStackCursor,workInProgress);// Now push the new context and mark that it has changed.
push(contextStackCursor,mergedContext,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}else{pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress);}}function resetContext(){previousContext=emptyObject;contextStackCursor.current=emptyObject;didPerformWorkStackCursor.current=false;}function findCurrentUnmaskedContext(fiber){// Currently this is only used with renderSubtreeIntoContainer; not sure if it
// makes sense elsewhere
!(isFiberMounted(fiber)&&fiber.tag===ClassComponent)?invariant(false,'Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.'):void 0;var node=fiber;while(node.tag!==HostRoot){if(isContextProvider(node)){return node.stateNode.__reactInternalMemoizedMergedChildContext;}var parent=node['return'];!parent?invariant(false,'Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;node=parent;}return node.stateNode.context;}var NoWork=0;// TODO: Use an opaque type once ESLint et al support the syntax
var Sync=1;var Never=2147483647;// Max int32: Math.pow(2, 31) - 1
var UNIT_SIZE=10;var MAGIC_NUMBER_OFFSET=2;// 1 unit of expiration time represents 10ms.
function msToExpirationTime(ms){// Always add an offset so that we don't clash with the magic number for NoWork.
return(ms/UNIT_SIZE|0)+MAGIC_NUMBER_OFFSET;}function ceiling(num,precision){return((num/precision|0)+1)*precision;}function computeExpirationBucket(currentTime,expirationInMs,bucketSizeMs){return ceiling(currentTime+expirationInMs/UNIT_SIZE,bucketSizeMs/UNIT_SIZE);}var NoContext=0;var AsyncUpdates=1;{var hasBadMapPolyfill=false;try{var nonExtensibleObject=Object.preventExtensions({});/* eslint-disable no-new */new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject]);/* eslint-enable no-new */}catch(e){// TODO: Consider warning about bad polyfills
hasBadMapPolyfill=true;}}// A Fiber is work on a Component that needs to be done or was done. There can
// be more than one per component.
{var debugCounter=1;}function FiberNode(tag,key,internalContextTag){// Instance
this.tag=tag;this.key=key;this.type=null;this.stateNode=null;// Fiber
this['return']=null;this.child=null;this.sibling=null;this.index=0;this.ref=null;this.pendingProps=null;this.memoizedProps=null;this.updateQueue=null;this.memoizedState=null;this.internalContextTag=internalContextTag;// Effects
this.effectTag=NoEffect;this.nextEffect=null;this.firstEffect=null;this.lastEffect=null;this.expirationTime=NoWork;this.alternate=null;{this._debugID=debugCounter++;this._debugSource=null;this._debugOwner=null;this._debugIsCurrentlyTiming=false;if(!hasBadMapPolyfill&&typeof Object.preventExtensions==='function'){Object.preventExtensions(this);}}}// This is a constructor function, rather than a POJO constructor, still
// please ensure we do the following:
// 1) Nobody should add any instance methods on this. Instance methods can be
//    more difficult to predict when they get optimized and they are almost
//    never inlined properly in static compilers.
// 2) Nobody should rely on `instanceof Fiber` for type testing. We should
//    always know when it is a fiber.
// 3) We might want to experiment with using numeric keys since they are easier
//    to optimize in a non-JIT environment.
// 4) We can easily go from a constructor to a createFiber object literal if that
//    is faster.
// 5) It should be easy to port this to a C struct and keep a C implementation
//    compatible.
var createFiber=function createFiber(tag,key,internalContextTag){// $FlowFixMe: the shapes are exact here but Flow doesn't like constructors
return new FiberNode(tag,key,internalContextTag);};function shouldConstruct(Component){return!!(Component.prototype&&Component.prototype.isReactComponent);}// This is used to create an alternate fiber to do work on.
function createWorkInProgress(current,pendingProps,expirationTime){var workInProgress=current.alternate;if(workInProgress===null){// We use a double buffering pooling technique because we know that we'll
// only ever need at most two versions of a tree. We pool the "other" unused
// node that we're free to reuse. This is lazily created to avoid allocating
// extra objects for things that are never updated. It also allow us to
// reclaim the extra memory if needed.
workInProgress=createFiber(current.tag,current.key,current.internalContextTag);workInProgress.type=current.type;workInProgress.stateNode=current.stateNode;{// DEV-only fields
workInProgress._debugID=current._debugID;workInProgress._debugSource=current._debugSource;workInProgress._debugOwner=current._debugOwner;}workInProgress.alternate=current;current.alternate=workInProgress;}else{// We already have an alternate.
// Reset the effect tag.
workInProgress.effectTag=NoEffect;// The effect list is no longer valid.
workInProgress.nextEffect=null;workInProgress.firstEffect=null;workInProgress.lastEffect=null;}workInProgress.expirationTime=expirationTime;workInProgress.pendingProps=pendingProps;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;// These will be overridden during the parent's reconciliation
workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;return workInProgress;}function createHostRootFiber(){var fiber=createFiber(HostRoot,null,NoContext);return fiber;}function createFiberFromElement(element,internalContextTag,expirationTime){var owner=null;{owner=element._owner;}var fiber=void 0;var type=element.type,key=element.key;if(typeof type==='function'){fiber=shouldConstruct(type)?createFiber(ClassComponent,key,internalContextTag):createFiber(IndeterminateComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if(typeof type==='string'){fiber=createFiber(HostComponent,key,internalContextTag);fiber.type=type;fiber.pendingProps=element.props;}else if((typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&typeof type.tag==='number'){// Currently assumed to be a continuation and therefore is a fiber already.
// TODO: The yield system is currently broken for updates in some cases.
// The reified yield stores a fiber, but we don't know which fiber that is;
// the current or a workInProgress? When the continuation gets rendered here
// we don't know if we can reuse that fiber or if we need to clone it.
// There is probably a clever way to restructure this.
fiber=type;fiber.pendingProps=element.props;}else{var info='';{if(type===undefined||(typeof type==='undefined'?'undefined':_typeof(type))==='object'&&type!==null&&Object.keys(type).length===0){info+=' You likely forgot to export your component from the file '+"it's defined in.";}var ownerName=owner?getComponentName(owner):null;if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}}invariant(false,'Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s',type==null?type:typeof type==='undefined'?'undefined':_typeof(type),info);}{fiber._debugSource=element._source;fiber._debugOwner=element._owner;}fiber.expirationTime=expirationTime;return fiber;}function createFiberFromFragment(elements,internalContextTag,expirationTime,key){var fiber=createFiber(Fragment,key,internalContextTag);fiber.pendingProps=elements;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromText(content,internalContextTag,expirationTime){var fiber=createFiber(HostText,null,internalContextTag);fiber.pendingProps=content;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromHostInstanceForDeletion(){var fiber=createFiber(HostComponent,null,NoContext);fiber.type='DELETED';return fiber;}function createFiberFromCall(call,internalContextTag,expirationTime){var fiber=createFiber(CallComponent,call.key,internalContextTag);fiber.type=call.handler;fiber.pendingProps=call;fiber.expirationTime=expirationTime;return fiber;}function createFiberFromReturn(returnNode,internalContextTag,expirationTime){var fiber=createFiber(ReturnComponent,null,internalContextTag);fiber.expirationTime=expirationTime;return fiber;}function createFiberFromPortal(portal,internalContextTag,expirationTime){var fiber=createFiber(HostPortal,portal.key,internalContextTag);fiber.pendingProps=portal.children||[];fiber.expirationTime=expirationTime;fiber.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,// Used by persistent updates
implementation:portal.implementation};return fiber;}function createFiberRoot(containerInfo,hydrate){// Cyclic construction. This cheats the type system right now because
// stateNode is any.
var uninitializedFiber=createHostRootFiber();var root={current:uninitializedFiber,containerInfo:containerInfo,pendingChildren:null,remainingExpirationTime:NoWork,isReadyForCommit:false,finishedWork:null,context:null,pendingContext:null,hydrate:hydrate,nextScheduledRoot:null};uninitializedFiber.stateNode=root;return root;}var onCommitFiberRoot=null;var onCommitFiberUnmount=null;var hasLoggedError=false;function catchErrors(fn){return function(arg){try{return fn(arg);}catch(err){if(true&&!hasLoggedError){hasLoggedError=true;warning(false,'React DevTools encountered an error: %s',err);}}};}function injectInternals(internals){if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__==='undefined'){// No DevTools
return false;}var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled){// This isn't a real property on the hook, but it can be set to opt out
// of DevTools integration and associated warnings and logs.
// https://github.com/facebook/react/issues/3877
return true;}if(!hook.supportsFiber){{warning(false,'The installed version of React DevTools is too old and will not work '+'with the current version of React. Please update React DevTools. '+'https://fb.me/react-devtools');}// DevTools exists, even though it doesn't support Fiber.
return true;}try{var rendererID=hook.inject(internals);// We have successfully injected, so now it is safe to set up hooks.
onCommitFiberRoot=catchErrors(function(root){return hook.onCommitFiberRoot(rendererID,root);});onCommitFiberUnmount=catchErrors(function(fiber){return hook.onCommitFiberUnmount(rendererID,fiber);});}catch(err){// Catch all errors because it is unsafe to throw during initialization.
{warning(false,'React DevTools encountered an error: %s.',err);}}// DevTools exists
return true;}function onCommitRoot(root){if(typeof onCommitFiberRoot==='function'){onCommitFiberRoot(root);}}function onCommitUnmount(fiber){if(typeof onCommitFiberUnmount==='function'){onCommitFiberUnmount(fiber);}}{var didWarnUpdateInsideUpdate=false;}// Callbacks are not validated until invocation
// Singly linked-list of updates. When an update is scheduled, it is added to
// the queue of the current fiber and the work-in-progress fiber. The two queues
// are separate but they share a persistent structure.
//
// During reconciliation, updates are removed from the work-in-progress fiber,
// but they remain on the current fiber. That ensures that if a work-in-progress
// is aborted, the aborted updates are recovered by cloning from current.
//
// The work-in-progress queue is always a subset of the current queue.
//
// When the tree is committed, the work-in-progress becomes the current.
function createUpdateQueue(baseState){var queue={baseState:baseState,expirationTime:NoWork,first:null,last:null,callbackList:null,hasForceUpdate:false,isInitialized:false};{queue.isProcessing=false;}return queue;}function insertUpdateIntoQueue(queue,update){// Append the update to the end of the list.
if(queue.last===null){// Queue is empty
queue.first=queue.last=update;}else{queue.last.next=update;queue.last=update;}if(queue.expirationTime===NoWork||queue.expirationTime>update.expirationTime){queue.expirationTime=update.expirationTime;}}function insertUpdateIntoFiber(fiber,update){// We'll have at least one and at most two distinct update queues.
var alternateFiber=fiber.alternate;var queue1=fiber.updateQueue;if(queue1===null){// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
queue1=fiber.updateQueue=createUpdateQueue(null);}var queue2=void 0;if(alternateFiber!==null){queue2=alternateFiber.updateQueue;if(queue2===null){queue2=alternateFiber.updateQueue=createUpdateQueue(null);}}else{queue2=null;}queue2=queue2!==queue1?queue2:null;// Warn if an update is scheduled from inside an updater function.
{if((queue1.isProcessing||queue2!==null&&queue2.isProcessing)&&!didWarnUpdateInsideUpdate){warning(false,'An update (setState, replaceState, or forceUpdate) was scheduled '+'from inside an update function. Update functions should be pure, '+'with zero side-effects. Consider using componentDidUpdate or a '+'callback.');didWarnUpdateInsideUpdate=true;}}// If there's only one queue, add the update to that queue and exit.
if(queue2===null){insertUpdateIntoQueue(queue1,update);return;}// If either queue is empty, we need to add to both queues.
if(queue1.last===null||queue2.last===null){insertUpdateIntoQueue(queue1,update);insertUpdateIntoQueue(queue2,update);return;}// If both lists are not empty, the last update is the same for both lists
// because of structural sharing. So, we should only append to one of
// the lists.
insertUpdateIntoQueue(queue1,update);// But we still need to update the `last` pointer of queue2.
queue2.last=update;}function getUpdateExpirationTime(fiber){if(fiber.tag!==ClassComponent&&fiber.tag!==HostRoot){return NoWork;}var updateQueue=fiber.updateQueue;if(updateQueue===null){return NoWork;}return updateQueue.expirationTime;}function getStateFromUpdate(update,instance,prevState,props){var partialState=update.partialState;if(typeof partialState==='function'){var updateFn=partialState;return updateFn.call(instance,prevState,props);}else{return partialState;}}function processUpdateQueue(current,workInProgress,queue,instance,props,renderExpirationTime){if(current!==null&&current.updateQueue===queue){// We need to create a work-in-progress queue, by cloning the current queue.
var currentQueue=queue;queue=workInProgress.updateQueue={baseState:currentQueue.baseState,expirationTime:currentQueue.expirationTime,first:currentQueue.first,last:currentQueue.last,isInitialized:currentQueue.isInitialized,// These fields are no longer valid because they were already committed.
// Reset them.
callbackList:null,hasForceUpdate:false};}{// Set this flag so we can warn if setState is called inside the update
// function of another setState.
queue.isProcessing=true;}// Reset the remaining expiration time. If we skip over any updates, we'll
// increase this accordingly.
queue.expirationTime=NoWork;// TODO: We don't know what the base state will be until we begin work.
// It depends on which fiber is the next current. Initialize with an empty
// base state, then set to the memoizedState when rendering. Not super
// happy with this approach.
var state=void 0;if(queue.isInitialized){state=queue.baseState;}else{state=queue.baseState=workInProgress.memoizedState;queue.isInitialized=true;}var dontMutatePrevState=true;var update=queue.first;var didSkip=false;while(update!==null){var updateExpirationTime=update.expirationTime;if(updateExpirationTime>renderExpirationTime){// This update does not have sufficient priority. Skip it.
var remainingExpirationTime=queue.expirationTime;if(remainingExpirationTime===NoWork||remainingExpirationTime>updateExpirationTime){// Update the remaining expiration time.
queue.expirationTime=updateExpirationTime;}if(!didSkip){didSkip=true;queue.baseState=state;}// Continue to the next update.
update=update.next;continue;}// This update does have sufficient priority.
// If no previous updates were skipped, drop this update from the queue by
// advancing the head of the list.
if(!didSkip){queue.first=update.next;if(queue.first===null){queue.last=null;}}// Process the update
var _partialState=void 0;if(update.isReplace){state=getStateFromUpdate(update,instance,state,props);dontMutatePrevState=true;}else{_partialState=getStateFromUpdate(update,instance,state,props);if(_partialState){if(dontMutatePrevState){// $FlowFixMe: Idk how to type this properly.
state=_assign({},state,_partialState);}else{state=_assign(state,_partialState);}dontMutatePrevState=false;}}if(update.isForced){queue.hasForceUpdate=true;}if(update.callback!==null){// Append to list of callbacks.
var _callbackList=queue.callbackList;if(_callbackList===null){_callbackList=queue.callbackList=[];}_callbackList.push(update);}update=update.next;}if(queue.callbackList!==null){workInProgress.effectTag|=Callback;}else if(queue.first===null&&!queue.hasForceUpdate){// The queue is empty. We can reset it.
workInProgress.updateQueue=null;}if(!didSkip){didSkip=true;queue.baseState=state;}{// No longer processing.
queue.isProcessing=false;}return state;}function commitCallbacks(queue,context){var callbackList=queue.callbackList;if(callbackList===null){return;}// Set the list to null to make sure they don't get called more than once.
queue.callbackList=null;for(var i=0;i<callbackList.length;i++){var update=callbackList[i];var _callback=update.callback;// This update might be processed again. Clear the callback so it's only
// called once.
update.callback=null;!(typeof _callback==='function')?invariant(false,'Invalid argument passed as callback. Expected a function. Instead received: %s',_callback):void 0;_callback.call(context);}}var fakeInternalInstance={};var isArray=Array.isArray;{var didWarnAboutStateAssignmentForComponent={};var warnOnInvalidCallback=function warnOnInvalidCallback(callback,callerName){warning(callback===null||typeof callback==='function','%s(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callerName,callback);};// This is so gross but it's at least non-critical and can be removed if
// it causes problems. This is meant to give a nicer error message for
// ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,
// ...)) which otherwise throws a "_processChildContext is not a function"
// exception.
Object.defineProperty(fakeInternalInstance,'_processChildContext',{enumerable:false,value:function value(){invariant(false,'_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn\'t supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).');}});Object.freeze(fakeInternalInstance);}var ReactFiberClassComponent=function ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState){// Class component state updater
var updater={isMounted:isMounted,enqueueSetState:function enqueueSetState(instance,partialState,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'setState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:partialState,callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueReplaceState:function enqueueReplaceState(instance,state,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'replaceState');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:state,callback:callback,isReplace:true,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);},enqueueForceUpdate:function enqueueForceUpdate(instance,callback){var fiber=get(instance);callback=callback===undefined?null:callback;{warnOnInvalidCallback(callback,'forceUpdate');}var expirationTime=computeExpirationForFiber(fiber);var update={expirationTime:expirationTime,partialState:null,callback:callback,isReplace:false,isForced:true,nextCallback:null,next:null};insertUpdateIntoFiber(fiber,update);scheduleWork(fiber,expirationTime);}};function checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext){if(oldProps===null||workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate){// If the workInProgress already has an Update effect, return true
return true;}var instance=workInProgress.stateNode;var type=workInProgress.type;if(typeof instance.shouldComponentUpdate==='function'){startPhaseTimer(workInProgress,'shouldComponentUpdate');var shouldUpdate=instance.shouldComponentUpdate(newProps,newState,newContext);stopPhaseTimer();{warning(shouldUpdate!==undefined,'%s.shouldComponentUpdate(): Returned undefined instead of a '+'boolean value. Make sure to return true or false.',getComponentName(workInProgress)||'Unknown');}return shouldUpdate;}if(type.prototype&&type.prototype.isPureReactComponent){return!shallowEqual(oldProps,newProps)||!shallowEqual(oldState,newState);}return true;}function checkClassInstance(workInProgress){var instance=workInProgress.stateNode;var type=workInProgress.type;{var name=getComponentName(workInProgress);var renderPresent=instance.render;if(!renderPresent){if(type.prototype&&typeof type.prototype.render==='function'){warning(false,'%s(...): No `render` method found on the returned component '+'instance: did you accidentally return an object from the constructor?',name);}else{warning(false,'%s(...): No `render` method found on the returned component '+'instance: you may have forgotten to define `render`.',name);}}var noGetInitialStateOnES6=!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state;warning(noGetInitialStateOnES6,'getInitialState was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Did you mean to define a state property instead?',name);var noGetDefaultPropsOnES6=!instance.getDefaultProps||instance.getDefaultProps.isReactClassApproved;warning(noGetDefaultPropsOnES6,'getDefaultProps was defined on %s, a plain JavaScript class. '+'This is only supported for classes created using React.createClass. '+'Use a static property to define defaultProps instead.',name);var noInstancePropTypes=!instance.propTypes;warning(noInstancePropTypes,'propTypes was defined as an instance property on %s. Use a static '+'property to define propTypes instead.',name);var noInstanceContextTypes=!instance.contextTypes;warning(noInstanceContextTypes,'contextTypes was defined as an instance property on %s. Use a static '+'property to define contextTypes instead.',name);var noComponentShouldUpdate=typeof instance.componentShouldUpdate!=='function';warning(noComponentShouldUpdate,'%s has a method called '+'componentShouldUpdate(). Did you mean shouldComponentUpdate()? '+'The name is phrased as a question because the function is '+'expected to return a value.',name);if(type.prototype&&type.prototype.isPureReactComponent&&typeof instance.shouldComponentUpdate!=='undefined'){warning(false,'%s has a method called shouldComponentUpdate(). '+'shouldComponentUpdate should not be used when extending React.PureComponent. '+'Please extend React.Component if shouldComponentUpdate is used.',getComponentName(workInProgress)||'A pure component');}var noComponentDidUnmount=typeof instance.componentDidUnmount!=='function';warning(noComponentDidUnmount,'%s has a method called '+'componentDidUnmount(). But there is no such lifecycle method. '+'Did you mean componentWillUnmount()?',name);var noComponentDidReceiveProps=typeof instance.componentDidReceiveProps!=='function';warning(noComponentDidReceiveProps,'%s has a method called '+'componentDidReceiveProps(). But there is no such lifecycle method. '+'If you meant to update the state in response to changing props, '+'use componentWillReceiveProps(). If you meant to fetch data or '+'run side-effects or mutations after React has updated the UI, use componentDidUpdate().',name);var noComponentWillRecieveProps=typeof instance.componentWillRecieveProps!=='function';warning(noComponentWillRecieveProps,'%s has a method called '+'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?',name);var hasMutatedProps=instance.props!==workInProgress.pendingProps;warning(instance.props===undefined||!hasMutatedProps,'%s(...): When calling super() in `%s`, make sure to pass '+"up the same props that your component's constructor was passed.",name,name);var noInstanceDefaultProps=!instance.defaultProps;warning(noInstanceDefaultProps,'Setting defaultProps as an instance property on %s is not supported and will be ignored.'+' Instead, define defaultProps as a static property on %s.',name,name);}var state=instance.state;if(state&&((typeof state==='undefined'?'undefined':_typeof(state))!=='object'||isArray(state))){invariant(false,'%s.state: must be set to an object or null',getComponentName(workInProgress));}if(typeof instance.getChildContext==='function'){!(_typeof(workInProgress.type.childContextTypes)==='object')?invariant(false,'%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().',getComponentName(workInProgress)):void 0;}}function resetInputPointers(workInProgress,instance){instance.props=workInProgress.memoizedProps;instance.state=workInProgress.memoizedState;}function adoptClassInstance(workInProgress,instance){instance.updater=updater;workInProgress.stateNode=instance;// The instance needs access to the fiber so that it can schedule updates
set(instance,workInProgress);{instance._reactInternalInstance=fakeInternalInstance;}}function constructClassInstance(workInProgress,props){var ctor=workInProgress.type;var unmaskedContext=getUnmaskedContext(workInProgress);var needsContext=isContextConsumer(workInProgress);var context=needsContext?getMaskedContext(workInProgress,unmaskedContext):emptyObject;var instance=new ctor(props,context);adoptClassInstance(workInProgress,instance);// Cache unmasked context so we can avoid recreating masked context unless necessary.
// ReactFiberContext usually updates this cache but can't for newly-created instances.
if(needsContext){cacheContext(workInProgress,unmaskedContext,context);}return instance;}function callComponentWillMount(workInProgress,instance){startPhaseTimer(workInProgress,'componentWillMount');var oldState=instance.state;instance.componentWillMount();stopPhaseTimer();if(oldState!==instance.state){{warning(false,'%s.componentWillMount(): Assigning directly to this.state is '+"deprecated (except inside a component's "+'constructor). Use setState instead.',getComponentName(workInProgress));}updater.enqueueReplaceState(instance,instance.state,null);}}function callComponentWillReceiveProps(workInProgress,instance,newProps,newContext){startPhaseTimer(workInProgress,'componentWillReceiveProps');var oldState=instance.state;instance.componentWillReceiveProps(newProps,newContext);stopPhaseTimer();if(instance.state!==oldState){{var componentName=getComponentName(workInProgress)||'Component';if(!didWarnAboutStateAssignmentForComponent[componentName]){warning(false,'%s.componentWillReceiveProps(): Assigning directly to '+"this.state is deprecated (except inside a component's "+'constructor). Use setState instead.',componentName);didWarnAboutStateAssignmentForComponent[componentName]=true;}}updater.enqueueReplaceState(instance,instance.state,null);}}// Invokes the mount life-cycles on a previously never rendered instance.
function mountClassInstance(workInProgress,renderExpirationTime){var current=workInProgress.alternate;{checkClassInstance(workInProgress);}var instance=workInProgress.stateNode;var state=instance.state||null;var props=workInProgress.pendingProps;!props?invariant(false,'There must be pending props for an initial mount. This error is likely caused by a bug in React. Please file an issue.'):void 0;var unmaskedContext=getUnmaskedContext(workInProgress);instance.props=props;instance.state=workInProgress.memoizedState=state;instance.refs=emptyObject;instance.context=getMaskedContext(workInProgress,unmaskedContext);if(enableAsyncSubtreeAPI&&workInProgress.type!=null&&workInProgress.type.prototype!=null&&workInProgress.type.prototype.unstable_isAsyncReactComponent===true){workInProgress.internalContextTag|=AsyncUpdates;}if(typeof instance.componentWillMount==='function'){callComponentWillMount(workInProgress,instance);// If we had additional state updates during this life-cycle, let's
// process them now.
var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){instance.state=processUpdateQueue(current,workInProgress,updateQueue,instance,props,renderExpirationTime);}}if(typeof instance.componentDidMount==='function'){workInProgress.effectTag|=Update;}}// Called on a preexisting class instance. Returns false if a resumed render
// could be reused.
// function resumeMountClassInstance(
//   workInProgress: Fiber,
//   priorityLevel: PriorityLevel,
// ): boolean {
//   const instance = workInProgress.stateNode;
//   resetInputPointers(workInProgress, instance);
//   let newState = workInProgress.memoizedState;
//   let newProps = workInProgress.pendingProps;
//   if (!newProps) {
//     // If there isn't any new props, then we'll reuse the memoized props.
//     // This could be from already completed work.
//     newProps = workInProgress.memoizedProps;
//     invariant(
//       newProps != null,
//       'There should always be pending or memoized props. This error is ' +
//         'likely caused by a bug in React. Please file an issue.',
//     );
//   }
//   const newUnmaskedContext = getUnmaskedContext(workInProgress);
//   const newContext = getMaskedContext(workInProgress, newUnmaskedContext);
//   const oldContext = instance.context;
//   const oldProps = workInProgress.memoizedProps;
//   if (
//     typeof instance.componentWillReceiveProps === 'function' &&
//     (oldProps !== newProps || oldContext !== newContext)
//   ) {
//     callComponentWillReceiveProps(
//       workInProgress,
//       instance,
//       newProps,
//       newContext,
//     );
//   }
//   // Process the update queue before calling shouldComponentUpdate
//   const updateQueue = workInProgress.updateQueue;
//   if (updateQueue !== null) {
//     newState = processUpdateQueue(
//       workInProgress,
//       updateQueue,
//       instance,
//       newState,
//       newProps,
//       priorityLevel,
//     );
//   }
//   // TODO: Should we deal with a setState that happened after the last
//   // componentWillMount and before this componentWillMount? Probably
//   // unsupported anyway.
//   if (
//     !checkShouldComponentUpdate(
//       workInProgress,
//       workInProgress.memoizedProps,
//       newProps,
//       workInProgress.memoizedState,
//       newState,
//       newContext,
//     )
//   ) {
//     // Update the existing instance's state, props, and context pointers even
//     // though we're bailing out.
//     instance.props = newProps;
//     instance.state = newState;
//     instance.context = newContext;
//     return false;
//   }
//   // Update the input pointers now so that they are correct when we call
//   // componentWillMount
//   instance.props = newProps;
//   instance.state = newState;
//   instance.context = newContext;
//   if (typeof instance.componentWillMount === 'function') {
//     callComponentWillMount(workInProgress, instance);
//     // componentWillMount may have called setState. Process the update queue.
//     const newUpdateQueue = workInProgress.updateQueue;
//     if (newUpdateQueue !== null) {
//       newState = processUpdateQueue(
//         workInProgress,
//         newUpdateQueue,
//         instance,
//         newState,
//         newProps,
//         priorityLevel,
//       );
//     }
//   }
//   if (typeof instance.componentDidMount === 'function') {
//     workInProgress.effectTag |= Update;
//   }
//   instance.state = newState;
//   return true;
// }
// Invokes the update life-cycles and returns false if it shouldn't rerender.
function updateClassInstance(current,workInProgress,renderExpirationTime){var instance=workInProgress.stateNode;resetInputPointers(workInProgress,instance);var oldProps=workInProgress.memoizedProps;var newProps=workInProgress.pendingProps;if(!newProps){// If there aren't any new props, then we'll reuse the memoized props.
// This could be from already completed work.
newProps=oldProps;!(newProps!=null)?invariant(false,'There should always be pending or memoized props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var oldContext=instance.context;var newUnmaskedContext=getUnmaskedContext(workInProgress);var newContext=getMaskedContext(workInProgress,newUnmaskedContext);// Note: During these life-cycles, instance.props/instance.state are what
// ever the previously attempted to render - not the "current". However,
// during componentDidUpdate we pass the "current" props.
if(typeof instance.componentWillReceiveProps==='function'&&(oldProps!==newProps||oldContext!==newContext)){callComponentWillReceiveProps(workInProgress,instance,newProps,newContext);}// Compute the next state using the memoized state and the update queue.
var oldState=workInProgress.memoizedState;// TODO: Previous state can be null.
var newState=void 0;if(workInProgress.updateQueue!==null){newState=processUpdateQueue(current,workInProgress,workInProgress.updateQueue,instance,newProps,renderExpirationTime);}else{newState=oldState;}if(oldProps===newProps&&oldState===newState&&!hasContextChanged()&&!(workInProgress.updateQueue!==null&&workInProgress.updateQueue.hasForceUpdate)){// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}return false;}var shouldUpdate=checkShouldComponentUpdate(workInProgress,oldProps,newProps,oldState,newState,newContext);if(shouldUpdate){if(typeof instance.componentWillUpdate==='function'){startPhaseTimer(workInProgress,'componentWillUpdate');instance.componentWillUpdate(newProps,newState,newContext);stopPhaseTimer();}if(typeof instance.componentDidUpdate==='function'){workInProgress.effectTag|=Update;}}else{// If an update was already in progress, we should schedule an Update
// effect even though we're bailing out, so that cWU/cDU are called.
if(typeof instance.componentDidUpdate==='function'){if(oldProps!==current.memoizedProps||oldState!==current.memoizedState){workInProgress.effectTag|=Update;}}// If shouldComponentUpdate returned false, we should still update the
// memoized props/state to indicate that this work can be reused.
memoizeProps(workInProgress,newProps);memoizeState(workInProgress,newState);}// Update the existing instance's state, props, and context pointers even
// if shouldComponentUpdate returns false.
instance.props=newProps;instance.state=newState;instance.context=newContext;return shouldUpdate;}return{adoptClassInstance:adoptClassInstance,constructClassInstance:constructClassInstance,mountClassInstance:mountClassInstance,// resumeMountClassInstance,
updateClassInstance:updateClassInstance};};// The Symbol used to tag the special React types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_PORTAL_TYPE=typeof Symbol==='function'&&Symbol['for']&&Symbol['for']('react.portal')||0xeaca;function createPortal$1(children,containerInfo,// TODO: figure out the API for cross-renderer implementation.
implementation){var key=arguments.length>3&&arguments[3]!==undefined?arguments[3]:null;return{// This tag allow us to uniquely identify this as a React Portal
$$typeof:REACT_PORTAL_TYPE,key:key==null?null:''+key,children:children,containerInfo:containerInfo,implementation:implementation};}var getCurrentFiberStackAddendum$1=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnAboutMaps=false;/**
   * Warn if there's no key explicitly set on dynamic arrays of children or
   * object keys are not valid. This allows us to keep track of children between
   * updates.
   */var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};var warnForMissingKey=function warnForMissingKey(child){if(child===null||(typeof child==='undefined'?'undefined':_typeof(child))!=='object'){return;}if(!child._store||child._store.validated||child.key!=null){return;}!(_typeof(child._store)==='object')?invariant(false,'React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.'):void 0;child._store.validated=true;var currentComponentErrorInfo='Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasKeyUseWarning[currentComponentErrorInfo]){return;}ownerHasKeyUseWarning[currentComponentErrorInfo]=true;warning(false,'Each child in an array or iterator should have a unique '+'"key" prop. See https://fb.me/react-warning-keys for '+'more information.%s',getCurrentFiberStackAddendum$1());};}var isArray$1=Array.isArray;var ITERATOR_SYMBOL=typeof Symbol==='function'&&Symbol.iterator;var FAUX_ITERATOR_SYMBOL='@@iterator';// Before Symbol spec.
// The Symbol used to tag the ReactElement-like types. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.
var REACT_ELEMENT_TYPE;var REACT_CALL_TYPE;var REACT_RETURN_TYPE;var REACT_FRAGMENT_TYPE;if(typeof Symbol==='function'&&Symbol['for']){REACT_ELEMENT_TYPE=Symbol['for']('react.element');REACT_CALL_TYPE=Symbol['for']('react.call');REACT_RETURN_TYPE=Symbol['for']('react.return');REACT_FRAGMENT_TYPE=Symbol['for']('react.fragment');}else{REACT_ELEMENT_TYPE=0xeac7;REACT_CALL_TYPE=0xeac8;REACT_RETURN_TYPE=0xeac9;REACT_FRAGMENT_TYPE=0xeacb;}function getIteratorFn(maybeIterable){if(maybeIterable===null||typeof maybeIterable==='undefined'){return null;}var iteratorFn=ITERATOR_SYMBOL&&maybeIterable[ITERATOR_SYMBOL]||maybeIterable[FAUX_ITERATOR_SYMBOL];if(typeof iteratorFn==='function'){return iteratorFn;}return null;}function coerceRef(current,element){var mixedRef=element.ref;if(mixedRef!==null&&typeof mixedRef!=='function'){if(element._owner){var owner=element._owner;var inst=void 0;if(owner){var ownerFiber=owner;!(ownerFiber.tag===ClassComponent)?invariant(false,'Stateless function components cannot have refs.'):void 0;inst=ownerFiber.stateNode;}!inst?invariant(false,'Missing owner for string ref %s. This error is likely caused by a bug in React. Please file an issue.',mixedRef):void 0;var stringRef=''+mixedRef;// Check if previous string ref matches new string ref
if(current!==null&&current.ref!==null&&current.ref._stringRef===stringRef){return current.ref;}var ref=function ref(value){var refs=inst.refs===emptyObject?inst.refs={}:inst.refs;if(value===null){delete refs[stringRef];}else{refs[stringRef]=value;}};ref._stringRef=stringRef;return ref;}else{!(typeof mixedRef==='string')?invariant(false,'Expected ref to be a function or a string.'):void 0;!element._owner?invariant(false,'Element ref was specified as a string (%s) but no owner was set. You may have multiple copies of React loaded. (details: https://fb.me/react-refs-must-have-owner).',mixedRef):void 0;}}return mixedRef;}function throwOnInvalidObjectType(returnFiber,newChild){if(returnFiber.type!=='textarea'){var addendum='';{addendum=' If you meant to render a collection of children, use an array '+'instead.'+(getCurrentFiberStackAddendum$1()||'');}invariant(false,'Objects are not valid as a React child (found: %s).%s',Object.prototype.toString.call(newChild)==='[object Object]'?'object with keys {'+Object.keys(newChild).join(', ')+'}':newChild,addendum);}}function warnOnFunctionType(){var currentComponentErrorInfo='Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.'+(getCurrentFiberStackAddendum$1()||'');if(ownerHasFunctionTypeWarning[currentComponentErrorInfo]){return;}ownerHasFunctionTypeWarning[currentComponentErrorInfo]=true;warning(false,'Functions are not valid as a React child. This may happen if '+'you return a Component instead of <Component /> from render. '+'Or maybe you meant to call this function rather than return it.%s',getCurrentFiberStackAddendum$1()||'');}// This wrapper function exists because I expect to clone the code in each path
// to be able to optimize each path individually by branching early. This needs
// a compiler or we can do it manually. Helpers that don't need this branching
// live outside of this function.
function ChildReconciler(shouldClone,shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(!shouldTrackSideEffects){// Noop.
return;}if(!shouldClone){// When we're reconciling in place we have a work in progress copy. We
// actually want the current copy. If there is no current copy, then we
// don't need to track deletion side-effects.
if(childToDelete.alternate===null){return;}childToDelete=childToDelete.alternate;}// Deletions are added in reversed order so we add it to the front.
// At this point, the return fiber's effect list is empty except for
// deletions, so we can just append the deletion to the list. The remaining
// effects aren't added until the complete phase. Once we implement
// resuming, this may not be true.
var last=returnFiber.lastEffect;if(last!==null){last.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}childToDelete.nextEffect=null;childToDelete.effectTag=Deletion;}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects){// Noop.
return null;}// TODO: For the shouldClone case, this could be micro-optimized a bit by
// assuming that after the first child we've already added everything.
var childToDelete=currentFirstChild;while(childToDelete!==null){deleteChild(returnFiber,childToDelete);childToDelete=childToDelete.sibling;}return null;}function mapRemainingChildren(returnFiber,currentFirstChild){// Add the remaining children to a temporary map so that we can find them by
// keys quickly. Implicit (null) keys get added to this set with their index
var existingChildren=new Map();var existingChild=currentFirstChild;while(existingChild!==null){if(existingChild.key!==null){existingChildren.set(existingChild.key,existingChild);}else{existingChildren.set(existingChild.index,existingChild);}existingChild=existingChild.sibling;}return existingChildren;}function useFiber(fiber,pendingProps,expirationTime){// We currently set sibling to null and index to 0 here because it is easy
// to forget to do before returning it. E.g. for the single child case.
if(shouldClone){var clone=createWorkInProgress(fiber,pendingProps,expirationTime);clone.index=0;clone.sibling=null;return clone;}else{// We override the expiration time even if it is earlier, because if
// we're reconciling at a later time that means that this was
// down-prioritized.
fiber.expirationTime=expirationTime;fiber.effectTag=NoEffect;fiber.index=0;fiber.sibling=null;fiber.pendingProps=pendingProps;return fiber;}}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects){// Noop.
return lastPlacedIndex;}var current=newFiber.alternate;if(current!==null){var oldIndex=current.index;if(oldIndex<lastPlacedIndex){// This is a move.
newFiber.effectTag=Placement;return lastPlacedIndex;}else{// This item can stay in place.
return oldIndex;}}else{// This is an insertion.
newFiber.effectTag=Placement;return lastPlacedIndex;}}function placeSingleChild(newFiber){// This is simpler for the single child case. We only need to do a
// placement for inserting new children.
if(shouldTrackSideEffects&&newFiber.alternate===null){newFiber.effectTag=Placement;}return newFiber;}function updateTextNode(returnFiber,current,textContent,expirationTime){if(current===null||current.tag!==HostText){// Insert
var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,textContent,expirationTime);existing['return']=returnFiber;return existing;}}function updateElement(returnFiber,current,element,expirationTime){if(current!==null&&current.type===element.type){// Move based on index
var existing=useFiber(current,element.props,expirationTime);existing.ref=coerceRef(current,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{// Insert
var created=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);created.ref=coerceRef(current,element);created['return']=returnFiber;return created;}}function updateCall(returnFiber,current,call,expirationTime){// TODO: Should this also compare handler to determine whether to reuse?
if(current===null||current.tag!==CallComponent){// Insert
var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,call,expirationTime);existing['return']=returnFiber;return existing;}}function updateReturn(returnFiber,current,returnNode,expirationTime){if(current===null||current.tag!==ReturnComponent){// Insert
var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}else{// Move based on index
var existing=useFiber(current,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}}function updatePortal(returnFiber,current,portal,expirationTime){if(current===null||current.tag!==HostPortal||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation){// Insert
var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}}function updateFragment(returnFiber,current,fragment,expirationTime,key){if(current===null||current.tag!==Fragment){// Insert
var created=createFiberFromFragment(fragment,returnFiber.internalContextTag,expirationTime,key);created['return']=returnFiber;return created;}else{// Update
var existing=useFiber(current,fragment,expirationTime);existing['return']=returnFiber;return existing;}}function createChild(returnFiber,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
var created=createFiberFromText(''+newChild,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.type===REACT_FRAGMENT_TYPE){var _created=createFiberFromFragment(newChild.props.children,returnFiber.internalContextTag,expirationTime,newChild.key);_created['return']=returnFiber;return _created;}else{var _created2=createFiberFromElement(newChild,returnFiber.internalContextTag,expirationTime);_created2.ref=coerceRef(null,newChild);_created2['return']=returnFiber;return _created2;}}case REACT_CALL_TYPE:{var _created3=createFiberFromCall(newChild,returnFiber.internalContextTag,expirationTime);_created3['return']=returnFiber;return _created3;}case REACT_RETURN_TYPE:{var _created4=createFiberFromReturn(newChild,returnFiber.internalContextTag,expirationTime);_created4.type=newChild.value;_created4['return']=returnFiber;return _created4;}case REACT_PORTAL_TYPE:{var _created5=createFiberFromPortal(newChild,returnFiber.internalContextTag,expirationTime);_created5['return']=returnFiber;return _created5;}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _created6=createFiberFromFragment(newChild,returnFiber.internalContextTag,expirationTime,null);_created6['return']=returnFiber;return _created6;}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateSlot(returnFiber,oldFiber,newChild,expirationTime){// Update the fiber if the keys match, otherwise return null.
var key=oldFiber!==null?oldFiber.key:null;if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a text
// node.
if(key!==null){return null;}return updateTextNode(returnFiber,oldFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{if(newChild.key===key){if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,oldFiber,newChild.props.children,expirationTime,key);}return updateElement(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_CALL_TYPE:{if(newChild.key===key){return updateCall(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_RETURN_TYPE:{// Returns don't have keys. If the previous node is implicitly keyed
// we can continue to replace it without aborting even if it is not a
// yield.
if(key===null){return updateReturn(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}case REACT_PORTAL_TYPE:{if(newChild.key===key){return updatePortal(returnFiber,oldFiber,newChild,expirationTime);}else{return null;}}}if(isArray$1(newChild)||getIteratorFn(newChild)){if(key!==null){return null;}return updateFragment(returnFiber,oldFiber,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,expirationTime){if(typeof newChild==='string'||typeof newChild==='number'){// Text nodes don't have keys, so we neither have to check the old nor
// new node for the key. If both are text nodes, they match.
var matchedFiber=existingChildren.get(newIdx)||null;return updateTextNode(returnFiber,matchedFiber,''+newChild,expirationTime);}if((typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:{var _matchedFiber=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;if(newChild.type===REACT_FRAGMENT_TYPE){return updateFragment(returnFiber,_matchedFiber,newChild.props.children,expirationTime,newChild.key);}return updateElement(returnFiber,_matchedFiber,newChild,expirationTime);}case REACT_CALL_TYPE:{var _matchedFiber2=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updateCall(returnFiber,_matchedFiber2,newChild,expirationTime);}case REACT_RETURN_TYPE:{// Returns don't have keys, so we neither have to check the old nor
// new node for the key. If both are returns, they match.
var _matchedFiber3=existingChildren.get(newIdx)||null;return updateReturn(returnFiber,_matchedFiber3,newChild,expirationTime);}case REACT_PORTAL_TYPE:{var _matchedFiber4=existingChildren.get(newChild.key===null?newIdx:newChild.key)||null;return updatePortal(returnFiber,_matchedFiber4,newChild,expirationTime);}}if(isArray$1(newChild)||getIteratorFn(newChild)){var _matchedFiber5=existingChildren.get(newIdx)||null;return updateFragment(returnFiber,_matchedFiber5,newChild,expirationTime,null);}throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}return null;}/**
   * Warns if there is a duplicate or missing key
   */function warnOnInvalidKey(child,knownKeys){{if((typeof child==='undefined'?'undefined':_typeof(child))!=='object'||child===null){return knownKeys;}switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_CALL_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child);var key=child.key;if(typeof key!=='string'){break;}if(knownKeys===null){knownKeys=new Set();knownKeys.add(key);break;}if(!knownKeys.has(key)){knownKeys.add(key);break;}warning(false,'Encountered two children with the same key, `%s`. '+'Keys should be unique so that components maintain their identity '+'across updates. Non-unique keys may cause children to be '+'duplicated and/or omitted — the behavior is unsupported and '+'could change in a future version.%s',key,getCurrentFiberStackAddendum$1());break;default:break;}}return knownKeys;}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,expirationTime){// This algorithm can't optimize by searching from boths ends since we
// don't have backpointers on fibers. I'm trying to see how far we can get
// with that model. If it ends up not being worth the tradeoffs, we can
// add it later.
// Even with a two ended optimization, we'd want to optimize for the case
// where there are few changes and brute force the comparison instead of
// going for the Map. It'd like to explore hitting that path first in
// forward-only mode and only go for the Map once we notice that we need
// lots of look ahead. This doesn't handle reversal as well as two ended
// search but that's unusual. Besides, for the two ended optimization to
// work on Iterables, we'd need to copy the whole set.
// In this first iteration, we'll just live with hitting the bad case
// (adding everything to a Map) in for every insert/move.
// If you change this code, also update reconcileChildrenIterator() which
// uses the same algorithm.
{// First, validate keys.
var knownKeys=null;for(var i=0;i<newChildren.length;i++){var child=newChildren[i];knownKeys=warnOnInvalidKey(child,knownKeys);}}var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;for(;oldFiber!==null&&newIdx<newChildren.length;newIdx++){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(oldFiber===null){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(newIdx===newChildren.length){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;newIdx<newChildren.length;newIdx++){var _newFiber=createChild(returnFiber,newChildren[newIdx],expirationTime);if(!_newFiber){continue;}lastPlacedIndex=placeChild(_newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber;}else{previousNewFiber.sibling=_newFiber;}previousNewFiber=_newFiber;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;newIdx<newChildren.length;newIdx++){var _newFiber2=updateFromMap(existingChildren,returnFiber,newIdx,newChildren[newIdx],expirationTime);if(_newFiber2){if(shouldTrackSideEffects){if(_newFiber2.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber2.key===null?newIdx:_newFiber2.key);}}lastPlacedIndex=placeChild(_newFiber2,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber2;}else{previousNewFiber.sibling=_newFiber2;}previousNewFiber=_newFiber2;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileChildrenIterator(returnFiber,currentFirstChild,newChildrenIterable,expirationTime){// This is the same implementation as reconcileChildrenArray(),
// but using the iterator instead.
var iteratorFn=getIteratorFn(newChildrenIterable);!(typeof iteratorFn==='function')?invariant(false,'An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.'):void 0;{// Warn about using Maps as children
if(typeof newChildrenIterable.entries==='function'){var possibleMap=newChildrenIterable;if(possibleMap.entries===iteratorFn){warning(didWarnAboutMaps,'Using Maps as children is unsupported and will likely yield '+'unexpected results. Convert it to a sequence/iterable of keyed '+'ReactElements instead.%s',getCurrentFiberStackAddendum$1());didWarnAboutMaps=true;}}// First, validate keys.
// We'll get a different iterator later for the main pass.
var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren){var knownKeys=null;var _step=_newChildren.next();for(;!_step.done;_step=_newChildren.next()){var child=_step.value;knownKeys=warnOnInvalidKey(child,knownKeys);}}}var newChildren=iteratorFn.call(newChildrenIterable);!(newChildren!=null)?invariant(false,'An iterable object provided no iterator.'):void 0;var resultingFirstChild=null;var previousNewFiber=null;var oldFiber=currentFirstChild;var lastPlacedIndex=0;var newIdx=0;var nextOldFiber=null;var step=newChildren.next();for(;oldFiber!==null&&!step.done;newIdx++,step=newChildren.next()){if(oldFiber.index>newIdx){nextOldFiber=oldFiber;oldFiber=null;}else{nextOldFiber=oldFiber.sibling;}var newFiber=updateSlot(returnFiber,oldFiber,step.value,expirationTime);if(newFiber===null){// TODO: This breaks on empty slots like null children. That's
// unfortunate because it triggers the slow path all the time. We need
// a better way to communicate whether this was a miss or null,
// boolean, undefined, etc.
if(!oldFiber){oldFiber=nextOldFiber;}break;}if(shouldTrackSideEffects){if(oldFiber&&newFiber.alternate===null){// We matched the slot, but we didn't reuse the existing fiber, so we
// need to delete the existing child.
deleteChild(returnFiber,oldFiber);}}lastPlacedIndex=placeChild(newFiber,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=newFiber;}else{// TODO: Defer siblings if we're not at the right index for this slot.
// I.e. if we had null values before, then we want to defer this
// for each null value. However, we also don't want to call updateSlot
// with the previous one.
previousNewFiber.sibling=newFiber;}previousNewFiber=newFiber;oldFiber=nextOldFiber;}if(step.done){// We've reached the end of the new children. We can delete the rest.
deleteRemainingChildren(returnFiber,oldFiber);return resultingFirstChild;}if(oldFiber===null){// If we don't have any more existing children we can choose a fast path
// since the rest will all be insertions.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber3=createChild(returnFiber,step.value,expirationTime);if(_newFiber3===null){continue;}lastPlacedIndex=placeChild(_newFiber3,lastPlacedIndex,newIdx);if(previousNewFiber===null){// TODO: Move out of the loop. This only happens for the first run.
resultingFirstChild=_newFiber3;}else{previousNewFiber.sibling=_newFiber3;}previousNewFiber=_newFiber3;}return resultingFirstChild;}// Add all children to a key map for quick lookups.
var existingChildren=mapRemainingChildren(returnFiber,oldFiber);// Keep scanning and use the map to restore deleted items as moves.
for(;!step.done;newIdx++,step=newChildren.next()){var _newFiber4=updateFromMap(existingChildren,returnFiber,newIdx,step.value,expirationTime);if(_newFiber4!==null){if(shouldTrackSideEffects){if(_newFiber4.alternate!==null){// The new fiber is a work in progress, but if there exists a
// current, that means that we reused the fiber. We need to delete
// it from the child list so that we don't add it to the deletion
// list.
existingChildren['delete'](_newFiber4.key===null?newIdx:_newFiber4.key);}}lastPlacedIndex=placeChild(_newFiber4,lastPlacedIndex,newIdx);if(previousNewFiber===null){resultingFirstChild=_newFiber4;}else{previousNewFiber.sibling=_newFiber4;}previousNewFiber=_newFiber4;}}if(shouldTrackSideEffects){// Any existing children that weren't consumed above were deleted. We need
// to add them to the deletion list.
existingChildren.forEach(function(child){return deleteChild(returnFiber,child);});}return resultingFirstChild;}function reconcileSingleTextNode(returnFiber,currentFirstChild,textContent,expirationTime){// There's no need to check for keys on text nodes since we don't have a
// way to define them.
if(currentFirstChild!==null&&currentFirstChild.tag===HostText){// We already have an existing node so let's just update it and delete
// the rest.
deleteRemainingChildren(returnFiber,currentFirstChild.sibling);var existing=useFiber(currentFirstChild,textContent,expirationTime);existing['return']=returnFiber;return existing;}// The existing first child is not a text node so we need to create one
// and delete the existing ones.
deleteRemainingChildren(returnFiber,currentFirstChild);var created=createFiberFromText(textContent,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleElement(returnFiber,currentFirstChild,element,expirationTime){var key=element.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===Fragment?element.type===REACT_FRAGMENT_TYPE:child.type===element.type){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,element.type===REACT_FRAGMENT_TYPE?element.props.children:element.props,expirationTime);existing.ref=coerceRef(child,element);existing['return']=returnFiber;{existing._debugSource=element._source;existing._debugOwner=element._owner;}return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}if(element.type===REACT_FRAGMENT_TYPE){var created=createFiberFromFragment(element.props.children,returnFiber.internalContextTag,expirationTime,element.key);created['return']=returnFiber;return created;}else{var _created7=createFiberFromElement(element,returnFiber.internalContextTag,expirationTime);_created7.ref=coerceRef(currentFirstChild,element);_created7['return']=returnFiber;return _created7;}}function reconcileSingleCall(returnFiber,currentFirstChild,call,expirationTime){var key=call.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===CallComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,call,expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromCall(call,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}function reconcileSingleReturn(returnFiber,currentFirstChild,returnNode,expirationTime){// There's no need to check for keys on yields since they're stateless.
var child=currentFirstChild;if(child!==null){if(child.tag===ReturnComponent){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,null,expirationTime);existing.type=returnNode.value;existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);}}var created=createFiberFromReturn(returnNode,returnFiber.internalContextTag,expirationTime);created.type=returnNode.value;created['return']=returnFiber;return created;}function reconcileSinglePortal(returnFiber,currentFirstChild,portal,expirationTime){var key=portal.key;var child=currentFirstChild;while(child!==null){// TODO: If key === null and child.key === null, then this only applies to
// the first item in the list.
if(child.key===key){if(child.tag===HostPortal&&child.stateNode.containerInfo===portal.containerInfo&&child.stateNode.implementation===portal.implementation){deleteRemainingChildren(returnFiber,child.sibling);var existing=useFiber(child,portal.children||[],expirationTime);existing['return']=returnFiber;return existing;}else{deleteRemainingChildren(returnFiber,child);break;}}else{deleteChild(returnFiber,child);}child=child.sibling;}var created=createFiberFromPortal(portal,returnFiber.internalContextTag,expirationTime);created['return']=returnFiber;return created;}// This API will tag the children with the side-effect of the reconciliation
// itself. They will be added to the side-effect list as we pass through the
// children and the parent.
function reconcileChildFibers(returnFiber,currentFirstChild,newChild,expirationTime){// This function is not recursive.
// If the top level item is an array, we treat it as a set of children,
// not as a fragment. Nested arrays on the other hand will be treated as
// fragment nodes. Recursion happens at the normal flow.
// Handle top level unkeyed fragments as if they were arrays.
// This leads to an ambiguity between <>{[...]}</> and <>...</>.
// We treat the ambiguous cases above the same.
if(enableReactFragment&&(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null&&newChild.type===REACT_FRAGMENT_TYPE&&newChild.key===null){newChild=newChild.props.children;}// Handle object types
var isObject=(typeof newChild==='undefined'?'undefined':_typeof(newChild))==='object'&&newChild!==null;if(isObject){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return placeSingleChild(reconcileSingleElement(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_CALL_TYPE:return placeSingleChild(reconcileSingleCall(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_RETURN_TYPE:return placeSingleChild(reconcileSingleReturn(returnFiber,currentFirstChild,newChild,expirationTime));case REACT_PORTAL_TYPE:return placeSingleChild(reconcileSinglePortal(returnFiber,currentFirstChild,newChild,expirationTime));}}if(typeof newChild==='string'||typeof newChild==='number'){return placeSingleChild(reconcileSingleTextNode(returnFiber,currentFirstChild,''+newChild,expirationTime));}if(isArray$1(newChild)){return reconcileChildrenArray(returnFiber,currentFirstChild,newChild,expirationTime);}if(getIteratorFn(newChild)){return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,expirationTime);}if(isObject){throwOnInvalidObjectType(returnFiber,newChild);}{if(typeof newChild==='function'){warnOnFunctionType();}}if(typeof newChild==='undefined'){// If the new child is undefined, and the return fiber is a composite
// component, throw an error. If Fiber return types are disabled,
// we already threw above.
switch(returnFiber.tag){case ClassComponent:{{var instance=returnFiber.stateNode;if(instance.render._isMockFunction){// We allow auto-mocks to proceed as if they're returning null.
break;}}}// Intentionally fall through to the next case, which handles both
// functions and classes
// eslint-disable-next-lined no-fallthrough
case FunctionalComponent:{var Component=returnFiber.type;invariant(false,'%s(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.',Component.displayName||Component.name||'Component');}}}// Remaining cases are all treated as empty.
return deleteRemainingChildren(returnFiber,currentFirstChild);}return reconcileChildFibers;}var reconcileChildFibers=ChildReconciler(true,true);var reconcileChildFibersInPlace=ChildReconciler(false,true);var mountChildFibersInPlace=ChildReconciler(false,false);function cloneChildFibers(current,workInProgress){!(current===null||workInProgress.child===current.child)?invariant(false,'Resuming work not yet implemented.'):void 0;if(workInProgress.child===null){return;}var currentChild=workInProgress.child;var newChild=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);workInProgress.child=newChild;newChild['return']=workInProgress;while(currentChild.sibling!==null){currentChild=currentChild.sibling;newChild=newChild.sibling=createWorkInProgress(currentChild,currentChild.pendingProps,currentChild.expirationTime);newChild['return']=workInProgress;}newChild.sibling=null;}{var warnedAboutStatelessRefs={};}var ReactFiberBeginWork=function ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber){var shouldSetTextContent=config.shouldSetTextContent,useSyncScheduling=config.useSyncScheduling,shouldDeprioritizeSubtree=config.shouldDeprioritizeSubtree;var pushHostContext=hostContext.pushHostContext,pushHostContainer=hostContext.pushHostContainer;var enterHydrationState=hydrationContext.enterHydrationState,resetHydrationState=hydrationContext.resetHydrationState,tryToClaimNextHydratableInstance=hydrationContext.tryToClaimNextHydratableInstance;var _ReactFiberClassCompo=ReactFiberClassComponent(scheduleWork,computeExpirationForFiber,memoizeProps,memoizeState),adoptClassInstance=_ReactFiberClassCompo.adoptClassInstance,constructClassInstance=_ReactFiberClassCompo.constructClassInstance,mountClassInstance=_ReactFiberClassCompo.mountClassInstance,updateClassInstance=_ReactFiberClassCompo.updateClassInstance;// TODO: Remove this and use reconcileChildrenAtExpirationTime directly.
function reconcileChildren(current,workInProgress,nextChildren){reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,workInProgress.expirationTime);}function reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime){if(current===null){// If this is a fresh new component that hasn't been rendered yet, we
// won't update its child set by applying minimal side-effects. Instead,
// we will add them all to the child before it gets rendered. That means
// we can optimize this reconciliation pass by not tracking side-effects.
workInProgress.child=mountChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}else if(current.child===workInProgress.child){// If the current child is the same as the work in progress, it means that
// we haven't yet started any work on these children. Therefore, we use
// the clone algorithm to create a copy of all the current children.
// If we had any progressed work already, that is invalid at this point so
// let's throw it out.
workInProgress.child=reconcileChildFibers(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}else{// If, on the other hand, it is already using a clone, that means we've
// already begun some work on this tree and we can continue where we left
// off by reconciling against the existing children.
workInProgress.child=reconcileChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);}}function updateFragment(current,workInProgress){var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=workInProgress.memoizedProps;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);return workInProgress.child;}function markRef(current,workInProgress){var ref=workInProgress.ref;if(ref!==null&&(!current||current.ref!==ref)){// Schedule a Ref effect
workInProgress.effectTag|=Ref;}}function updateFunctionalComponent(current,workInProgress){var fn=workInProgress.type;var nextProps=workInProgress.pendingProps;var memoizedProps=workInProgress.memoizedProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextProps===null){nextProps=memoizedProps;}}else{if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}// TODO: consider bringing fn.shouldComponentUpdate() back.
// It used to be here.
}var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var nextChildren;{ReactCurrentOwner.current=workInProgress;ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=fn(nextProps,context);ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateClassComponent(current,workInProgress,renderExpirationTime){// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);var shouldUpdate=void 0;if(current===null){if(!workInProgress.stateNode){// In the initial pass we might need to construct the instance.
constructClassInstance(workInProgress,workInProgress.pendingProps);mountClassInstance(workInProgress,renderExpirationTime);shouldUpdate=true;}else{invariant(false,'Resuming work not yet implemented.');// In a resume, we'll already have an instance we can reuse.
// shouldUpdate = resumeMountClassInstance(workInProgress, renderExpirationTime);
}}else{shouldUpdate=updateClassInstance(current,workInProgress,renderExpirationTime);}return finishClassComponent(current,workInProgress,shouldUpdate,hasContext);}function finishClassComponent(current,workInProgress,shouldUpdate,hasContext){// Refs should update even if shouldComponentUpdate returns false
markRef(current,workInProgress);if(!shouldUpdate){// Context providers should defer to sCU for rendering
if(hasContext){invalidateContextProvider(workInProgress,false);}return bailoutOnAlreadyFinishedWork(current,workInProgress);}var instance=workInProgress.stateNode;// Rerender
ReactCurrentOwner.current=workInProgress;var nextChildren=void 0;{ReactDebugCurrentFiber.setCurrentPhase('render');nextChildren=instance.render();ReactDebugCurrentFiber.setCurrentPhase(null);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;reconcileChildren(current,workInProgress,nextChildren);// Memoize props and state using the values we just used to render.
// TODO: Restructure so we never read values from the instance.
memoizeState(workInProgress,instance.state);memoizeProps(workInProgress,instance.props);// The context might have changed so we need to recalculate it.
if(hasContext){invalidateContextProvider(workInProgress,true);}return workInProgress.child;}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;if(root.pendingContext){pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context);}else if(root.context){// Should always be set
pushTopLevelContextObject(workInProgress,root.context,false);}pushHostContainer(workInProgress,root.containerInfo);}function updateHostRoot(current,workInProgress,renderExpirationTime){pushHostRootContext(workInProgress);var updateQueue=workInProgress.updateQueue;if(updateQueue!==null){var prevState=workInProgress.memoizedState;var state=processUpdateQueue(current,workInProgress,updateQueue,null,null,renderExpirationTime);if(prevState===state){// If the state is the same as before, that's a bailout because we had
// no work that expires at this time.
resetHydrationState();return bailoutOnAlreadyFinishedWork(current,workInProgress);}var element=state.element;var root=workInProgress.stateNode;if((current===null||current.child===null)&&root.hydrate&&enterHydrationState(workInProgress)){// If we don't have any current children this might be the first pass.
// We always try to hydrate. If this isn't a hydration pass there won't
// be any children to hydrate which is effectively the same thing as
// not hydrating.
// This is a bit of a hack. We track the host root as a placement to
// know that we're currently in a mounting state. That way isMounted
// works as expected. We must reset this before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag|=Placement;// Ensure that children mount into this root without tracking
// side-effects. This ensures that we don't store Placement effects on
// nodes that will be hydrated.
workInProgress.child=mountChildFibersInPlace(workInProgress,workInProgress.child,element,renderExpirationTime);}else{// Otherwise reset hydration state in case we aborted and resumed another
// root.
resetHydrationState();reconcileChildren(current,workInProgress,element);}memoizeState(workInProgress,state);return workInProgress.child;}resetHydrationState();// If there is no update queue, that's a bailout because the root has no props.
return bailoutOnAlreadyFinishedWork(current,workInProgress);}function updateHostComponent(current,workInProgress,renderExpirationTime){pushHostContext(workInProgress);if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var type=workInProgress.type;var memoizedProps=workInProgress.memoizedProps;var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=memoizedProps;!(nextProps!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}var prevProps=current!==null?current.memoizedProps:null;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
}else if(nextProps===null||memoizedProps===nextProps){return bailoutOnAlreadyFinishedWork(current,workInProgress);}var nextChildren=nextProps.children;var isDirectTextChild=shouldSetTextContent(type,nextProps);if(isDirectTextChild){// We special case a direct text child of a host node. This is a common
// case. We won't handle it as a reified child. We will instead handle
// this in the host environment that also have access to this prop. That
// avoids allocating another HostText fiber and traversing it.
nextChildren=null;}else if(prevProps&&shouldSetTextContent(type,prevProps)){// If we're switching from a direct text child to a normal child, or to
// empty, we need to schedule the text content to be reset.
workInProgress.effectTag|=ContentReset;}markRef(current,workInProgress);// Check the host config to see if the children are offscreen/hidden.
if(renderExpirationTime!==Never&&!useSyncScheduling&&shouldDeprioritizeSubtree(type,nextProps)){// Down-prioritize the children.
workInProgress.expirationTime=Never;// Bailout and come back to this fiber later.
return null;}reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextProps);return workInProgress.child;}function updateHostText(current,workInProgress){if(current===null){tryToClaimNextHydratableInstance(workInProgress);}var nextProps=workInProgress.pendingProps;if(nextProps===null){nextProps=workInProgress.memoizedProps;}memoizeProps(workInProgress,nextProps);// Nothing to do here. This is terminal. We'll do the completion step
// immediately after.
return null;}function mountIndeterminateComponent(current,workInProgress,renderExpirationTime){!(current===null)?invariant(false,'An indeterminate component should never have mounted. This error is likely caused by a bug in React. Please file an issue.'):void 0;var fn=workInProgress.type;var props=workInProgress.pendingProps;var unmaskedContext=getUnmaskedContext(workInProgress);var context=getMaskedContext(workInProgress,unmaskedContext);var value;{if(fn.prototype&&typeof fn.prototype.render==='function'){var componentName=getComponentName(workInProgress);warning(false,"The <%s /> component appears to have a render method, but doesn't extend React.Component. "+'This is likely to cause errors. Change %s to extend React.Component instead.',componentName,componentName);}ReactCurrentOwner.current=workInProgress;value=fn(props,context);}// React DevTools reads this flag.
workInProgress.effectTag|=PerformedWork;if((typeof value==='undefined'?'undefined':_typeof(value))==='object'&&value!==null&&typeof value.render==='function'){// Proceed under the assumption that this is a class instance
workInProgress.tag=ClassComponent;// Push context providers early to prevent context stack mismatches.
// During mounting we don't know the child context yet as the instance doesn't exist.
// We will invalidate the child context in finishClassComponent() right after rendering.
var hasContext=pushContextProvider(workInProgress);adoptClassInstance(workInProgress,value);mountClassInstance(workInProgress,renderExpirationTime);return finishClassComponent(current,workInProgress,true,hasContext);}else{// Proceed under the assumption that this is a functional component
workInProgress.tag=FunctionalComponent;{var Component=workInProgress.type;if(Component){warning(!Component.childContextTypes,'%s(...): childContextTypes cannot be defined on a functional component.',Component.displayName||Component.name||'Component');}if(workInProgress.ref!==null){var info='';var ownerName=ReactDebugCurrentFiber.getCurrentFiberOwnerName();if(ownerName){info+='\n\nCheck the render method of `'+ownerName+'`.';}var warningKey=ownerName||workInProgress._debugID||'';var debugSource=workInProgress._debugSource;if(debugSource){warningKey=debugSource.fileName+':'+debugSource.lineNumber;}if(!warnedAboutStatelessRefs[warningKey]){warnedAboutStatelessRefs[warningKey]=true;warning(false,'Stateless function components cannot be given refs. '+'Attempts to access this ref will fail.%s%s',info,ReactDebugCurrentFiber.getCurrentFiberStackAddendum());}}}reconcileChildren(current,workInProgress,value);memoizeProps(workInProgress,props);return workInProgress.child;}}function updateCallComponent(current,workInProgress,renderExpirationTime){var nextCall=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextCall===null){nextCall=current&&current.memoizedProps;!(nextCall!==null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextCall===null||workInProgress.memoizedProps===nextCall){nextCall=workInProgress.memoizedProps;// TODO: When bailing out, we might need to return the stateNode instead
// of the child. To check it for work.
// return bailoutOnAlreadyFinishedWork(current, workInProgress);
}var nextChildren=nextCall.children;// The following is a fork of reconcileChildrenAtExpirationTime but using
// stateNode to store the child.
if(current===null){workInProgress.stateNode=mountChildFibersInPlace(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else if(current.child===workInProgress.child){workInProgress.stateNode=reconcileChildFibers(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}else{workInProgress.stateNode=reconcileChildFibersInPlace(workInProgress,workInProgress.stateNode,nextChildren,renderExpirationTime);}memoizeProps(workInProgress,nextCall);// This doesn't take arbitrary time so we could synchronously just begin
// eagerly do the work of workInProgress.child as an optimization.
return workInProgress.stateNode;}function updatePortalComponent(current,workInProgress,renderExpirationTime){pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);var nextChildren=workInProgress.pendingProps;if(hasContextChanged()){// Normally we can bail out on props equality but if context has changed
// we don't do the bailout and we have to reuse existing props instead.
if(nextChildren===null){nextChildren=current&&current.memoizedProps;!(nextChildren!=null)?invariant(false,'We should always have pending or current props. This error is likely caused by a bug in React. Please file an issue.'):void 0;}}else if(nextChildren===null||workInProgress.memoizedProps===nextChildren){return bailoutOnAlreadyFinishedWork(current,workInProgress);}if(current===null){// Portals are special because we don't append the children during mount
// but at commit. Therefore we need to track insertions which the normal
// flow doesn't do during mount. This doesn't happen at the root because
// the root always starts with a "current" with a null child.
// TODO: Consider unifying this with how the root works.
workInProgress.child=reconcileChildFibersInPlace(workInProgress,workInProgress.child,nextChildren,renderExpirationTime);memoizeProps(workInProgress,nextChildren);}else{reconcileChildren(current,workInProgress,nextChildren);memoizeProps(workInProgress,nextChildren);}return workInProgress.child;}/*
  function reuseChildrenEffects(returnFiber : Fiber, firstChild : Fiber) {
    let child = firstChild;
    do {
      // Ensure that the first and last effect of the parent corresponds
      // to the children's first and last effect.
      if (!returnFiber.firstEffect) {
        returnFiber.firstEffect = child.firstEffect;
      }
      if (child.lastEffect) {
        if (returnFiber.lastEffect) {
          returnFiber.lastEffect.nextEffect = child.firstEffect;
        }
        returnFiber.lastEffect = child.lastEffect;
      }
    } while (child = child.sibling);
  }
  */function bailoutOnAlreadyFinishedWork(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: We should ideally be able to bail out early if the children have no
// more work to do. However, since we don't have a separation of this
// Fiber's priority and its children yet - we don't know without doing lots
// of the same work we do anyway. Once we have that separation we can just
// bail out here if the children has no more work at this priority level.
// if (workInProgress.priorityOfChildren <= priorityLevel) {
//   // If there are side-effects in these children that have not yet been
//   // committed we need to ensure that they get properly transferred up.
//   if (current && current.child !== workInProgress.child) {
//     reuseChildrenEffects(workInProgress, child);
//   }
//   return null;
// }
cloneChildFibers(current,workInProgress);return workInProgress.child;}function bailoutOnLowPriority(current,workInProgress){cancelWorkTimer(workInProgress);// TODO: Handle HostComponent tags here as well and call pushHostContext()?
// See PR 8590 discussion for context
switch(workInProgress.tag){case HostRoot:pushHostRootContext(workInProgress);break;case ClassComponent:pushContextProvider(workInProgress);break;case HostPortal:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;}// TODO: What if this is currently in progress?
// How can that happen? How is this not being cloned?
return null;}// TODO: Delete memoizeProps/State and move to reconcile/bailout instead
function memoizeProps(workInProgress,nextProps){workInProgress.memoizedProps=nextProps;}function memoizeState(workInProgress,nextState){workInProgress.memoizedState=nextState;// Don't reset the updateQueue, in case there are pending updates. Resetting
// is handled by processUpdateQueue.
}function beginWork(current,workInProgress,renderExpirationTime){if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}switch(workInProgress.tag){case IndeterminateComponent:return mountIndeterminateComponent(current,workInProgress,renderExpirationTime);case FunctionalComponent:return updateFunctionalComponent(current,workInProgress);case ClassComponent:return updateClassComponent(current,workInProgress,renderExpirationTime);case HostRoot:return updateHostRoot(current,workInProgress,renderExpirationTime);case HostComponent:return updateHostComponent(current,workInProgress,renderExpirationTime);case HostText:return updateHostText(current,workInProgress);case CallHandlerPhase:// This is a restart. Reset the tag to the initial phase.
workInProgress.tag=CallComponent;// Intentionally fall through since this is now the same.
case CallComponent:return updateCallComponent(current,workInProgress,renderExpirationTime);case ReturnComponent:// A return component is just a placeholder, we can just run through the
// next one immediately.
return null;case HostPortal:return updatePortalComponent(current,workInProgress,renderExpirationTime);case Fragment:return updateFragment(current,workInProgress);default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}function beginFailedWork(current,workInProgress,renderExpirationTime){// Push context providers here to avoid a push/pop context mismatch.
switch(workInProgress.tag){case ClassComponent:pushContextProvider(workInProgress);break;case HostRoot:pushHostRootContext(workInProgress);break;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}// Add an error effect so we can handle the error during the commit phase
workInProgress.effectTag|=Err;// This is a weird case where we do "resume" work — work that failed on
// our first attempt. Because we no longer have a notion of "progressed
// deletions," reset the child to the current child to make sure we delete
// it again. TODO: Find a better way to handle this, perhaps during a more
// general overhaul of error handling.
if(current===null){workInProgress.child=null;}else if(workInProgress.child!==current.child){workInProgress.child=current.child;}if(workInProgress.expirationTime===NoWork||workInProgress.expirationTime>renderExpirationTime){return bailoutOnLowPriority(current,workInProgress);}// If we don't bail out, we're going be recomputing our children so we need
// to drop our effect list.
workInProgress.firstEffect=null;workInProgress.lastEffect=null;// Unmount the current children as if the component rendered null
var nextChildren=null;reconcileChildrenAtExpirationTime(current,workInProgress,nextChildren,renderExpirationTime);if(workInProgress.tag===ClassComponent){var instance=workInProgress.stateNode;workInProgress.memoizedProps=instance.props;workInProgress.memoizedState=instance.state;}return workInProgress.child;}return{beginWork:beginWork,beginFailedWork:beginFailedWork};};var ReactFiberCompleteWork=function ReactFiberCompleteWork(config,hostContext,hydrationContext){var createInstance=config.createInstance,createTextInstance=config.createTextInstance,appendInitialChild=config.appendInitialChild,finalizeInitialChildren=config.finalizeInitialChildren,prepareUpdate=config.prepareUpdate,mutation=config.mutation,persistence=config.persistence;var getRootHostContainer=hostContext.getRootHostContainer,popHostContext=hostContext.popHostContext,getHostContext=hostContext.getHostContext,popHostContainer=hostContext.popHostContainer;var prepareToHydrateHostInstance=hydrationContext.prepareToHydrateHostInstance,prepareToHydrateHostTextInstance=hydrationContext.prepareToHydrateHostTextInstance,popHydrationState=hydrationContext.popHydrationState;function markUpdate(workInProgress){// Tag the fiber with an update effect. This turns a Placement into
// an UpdateAndPlacement.
workInProgress.effectTag|=Update;}function markRef(workInProgress){workInProgress.effectTag|=Ref;}function appendAllReturns(returns,workInProgress){var node=workInProgress.stateNode;if(node){node['return']=workInProgress;}while(node!==null){if(node.tag===HostComponent||node.tag===HostText||node.tag===HostPortal){invariant(false,'A call cannot have host component children.');}else if(node.tag===ReturnComponent){returns.push(node.type);}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function moveCallToHandlerPhase(current,workInProgress,renderExpirationTime){var call=workInProgress.memoizedProps;!call?invariant(false,'Should be resolved by now. This error is likely caused by a bug in React. Please file an issue.'):void 0;// First step of the call has completed. Now we need to do the second.
// TODO: It would be nice to have a multi stage call represented by a
// single component, or at least tail call optimize nested ones. Currently
// that requires additional fields that we don't want to add to the fiber.
// So this requires nested handlers.
// Note: This doesn't mutate the alternate node. I don't think it needs to
// since this stage is reset for every pass.
workInProgress.tag=CallHandlerPhase;// Build up the returns.
// TODO: Compare this to a generator or opaque helpers like Children.
var returns=[];appendAllReturns(returns,workInProgress);var fn=call.handler;var props=call.props;var nextChildren=fn(props,returns);var currentFirstChild=current!==null?current.child:null;workInProgress.child=reconcileChildFibers(workInProgress,currentFirstChild,nextChildren,renderExpirationTime);return workInProgress.child;}function appendAllChildren(parent,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendInitialChild(parent,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}var updateHostContainer=void 0;var updateHostComponent=void 0;var updateHostText=void 0;if(mutation){if(enableMutatingReconciler){// Mutation mode
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// TODO: Type this specific to this type of component.
workInProgress.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update. All the work is done in commitWork.
if(updatePayload){markUpdate(workInProgress);}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// If the text differs, mark it as an update. All the work in done in commitWork.
if(oldText!==newText){markUpdate(workInProgress);}};}else{invariant(false,'Mutating reconciler is disabled.');}}else if(persistence){if(enablePersistentReconciler){// Persistent host tree mode
var cloneInstance=persistence.cloneInstance,createContainerChildSet=persistence.createContainerChildSet,appendChildToContainerChildSet=persistence.appendChildToContainerChildSet,finalizeContainerChildren=persistence.finalizeContainerChildren;// An unfortunate fork of appendAllChildren because we have two different parent types.
var appendAllChildrenToContainer=function appendAllChildrenToContainer(containerChildSet,workInProgress){// We only have the top Fiber that was created but we need recurse down its
// children to find all the terminal nodes.
var node=workInProgress.child;while(node!==null){if(node.tag===HostComponent||node.tag===HostText){appendChildToContainerChildSet(containerChildSet,node.stateNode);}else if(node.tag===HostPortal){// If we have a portal child, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===workInProgress){return;}while(node.sibling===null){if(node['return']===null||node['return']===workInProgress){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}};updateHostContainer=function updateHostContainer(workInProgress){var portalOrRoot=workInProgress.stateNode;var childrenUnchanged=workInProgress.firstEffect===null;if(childrenUnchanged){// No changes, just reuse the existing instance.
}else{var container=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(container);if(finalizeContainerChildren(container,newChildSet)){markUpdate(workInProgress);}portalOrRoot.pendingChildren=newChildSet;// If children might have changed, we have to add them all to the set.
appendAllChildrenToContainer(newChildSet,workInProgress);// Schedule an update on the container to swap out the container.
markUpdate(workInProgress);}};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// If there are no effects associated with this node, then none of our children had any updates.
// This guarantees that we can reuse all of them.
var childrenUnchanged=workInProgress.firstEffect===null;var currentInstance=current.stateNode;if(childrenUnchanged&&updatePayload===null){// No changes, just reuse the existing instance.
// Note that this might release a previous clone.
workInProgress.stateNode=currentInstance;}else{var recyclableInstance=workInProgress.stateNode;var newInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,childrenUnchanged,recyclableInstance);if(finalizeInitialChildren(newInstance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=newInstance;if(childrenUnchanged){// If there are no other effects in this tree, we need to flag this node as having one.
// Even though we're not going to use it for anything.
// Otherwise parents won't know that there are new children to propagate upwards.
markUpdate(workInProgress);}else{// If children might have changed, we have to add them all to the set.
appendAllChildren(newInstance,workInProgress);}}};updateHostText=function updateHostText(current,workInProgress,oldText,newText){if(oldText!==newText){// If the text content differs, we'll create a new text instance for it.
var rootContainerInstance=getRootHostContainer();var currentHostContext=getHostContext();workInProgress.stateNode=createTextInstance(newText,rootContainerInstance,currentHostContext,workInProgress);// We'll have to mark it as having an effect, even though we won't use the effect for anything.
// This lets the parents know that at least one of their children has changed.
markUpdate(workInProgress);}};}else{invariant(false,'Persistent reconciler is disabled.');}}else{if(enableNoopReconciler){// No host operations
updateHostContainer=function updateHostContainer(workInProgress){// Noop
};updateHostComponent=function updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance){// Noop
};updateHostText=function updateHostText(current,workInProgress,oldText,newText){// Noop
};}else{invariant(false,'Noop reconciler is disabled.');}}function completeWork(current,workInProgress,renderExpirationTime){// Get the latest props.
var newProps=workInProgress.pendingProps;if(newProps===null){newProps=workInProgress.memoizedProps;}else if(workInProgress.expirationTime!==Never||renderExpirationTime===Never){// Reset the pending props, unless this was a down-prioritization.
workInProgress.pendingProps=null;}switch(workInProgress.tag){case FunctionalComponent:return null;case ClassComponent:{// We are leaving this subtree, so pop context if any.
popContextProvider(workInProgress);return null;}case HostRoot:{popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);var fiberRoot=workInProgress.stateNode;if(fiberRoot.pendingContext){fiberRoot.context=fiberRoot.pendingContext;fiberRoot.pendingContext=null;}if(current===null||current.child===null){// If we hydrated, pop so that we can delete any remaining children
// that weren't hydrated.
popHydrationState(workInProgress);// This resets the hacky state to fix isMounted before committing.
// TODO: Delete this when we delete isMounted and findDOMNode.
workInProgress.effectTag&=~Placement;}updateHostContainer(workInProgress);return null;}case HostComponent:{popHostContext(workInProgress);var rootContainerInstance=getRootHostContainer();var type=workInProgress.type;if(current!==null&&workInProgress.stateNode!=null){// If we have an alternate, that means this is an update and we need to
// schedule a side-effect to do the updates.
var oldProps=current.memoizedProps;// If we get updated because one of our children updated, we don't
// have newProps so we'll have to reuse them.
// TODO: Split the update API as separate for the props vs. children.
// Even better would be if children weren't special cased at all tho.
var instance=workInProgress.stateNode;var currentHostContext=getHostContext();var updatePayload=prepareUpdate(instance,type,oldProps,newProps,rootContainerInstance,currentHostContext);updateHostComponent(current,workInProgress,updatePayload,type,oldProps,newProps,rootContainerInstance);if(current.ref!==workInProgress.ref){markRef(workInProgress);}}else{if(!newProps){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _currentHostContext=getHostContext();// TODO: Move createInstance to beginWork and keep it on a context
// "stack" as the parent. Then append children as we go in beginWork
// or completeWork depending on we want to add then top->down or
// bottom->up. Top->down is faster in IE11.
var wasHydrated=popHydrationState(workInProgress);if(wasHydrated){// TODO: Move this and createInstance step into the beginPhase
// to consolidate.
if(prepareToHydrateHostInstance(workInProgress,rootContainerInstance,_currentHostContext)){// If changes to the hydrated node needs to be applied at the
// commit-phase we mark this as such.
markUpdate(workInProgress);}}else{var _instance=createInstance(type,newProps,rootContainerInstance,_currentHostContext,workInProgress);appendAllChildren(_instance,workInProgress);// Certain renderers require commit-time effects for initial mount.
// (eg DOM renderer supports auto-focus for certain elements).
// Make sure such renderers get scheduled for later work.
if(finalizeInitialChildren(_instance,type,newProps,rootContainerInstance)){markUpdate(workInProgress);}workInProgress.stateNode=_instance;}if(workInProgress.ref!==null){// If there is a ref on a host node we need to schedule a callback
markRef(workInProgress);}}return null;}case HostText:{var newText=newProps;if(current&&workInProgress.stateNode!=null){var oldText=current.memoizedProps;// If we have an alternate, that means this is an update and we need
// to schedule a side-effect to do the updates.
updateHostText(current,workInProgress,oldText,newText);}else{if(typeof newText!=='string'){!(workInProgress.stateNode!==null)?invariant(false,'We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.'):void 0;// This can happen when we abort work.
return null;}var _rootContainerInstance=getRootHostContainer();var _currentHostContext2=getHostContext();var _wasHydrated=popHydrationState(workInProgress);if(_wasHydrated){if(prepareToHydrateHostTextInstance(workInProgress)){markUpdate(workInProgress);}}else{workInProgress.stateNode=createTextInstance(newText,_rootContainerInstance,_currentHostContext2,workInProgress);}}return null;}case CallComponent:return moveCallToHandlerPhase(current,workInProgress,renderExpirationTime);case CallHandlerPhase:// Reset the tag to now be a first phase call.
workInProgress.tag=CallComponent;return null;case ReturnComponent:// Does nothing.
return null;case Fragment:return null;case HostPortal:popHostContainer(workInProgress);updateHostContainer(workInProgress);return null;// Error cases
case IndeterminateComponent:invariant(false,'An indeterminate component should have become determinate before completing. This error is likely caused by a bug in React. Please file an issue.');// eslint-disable-next-line no-fallthrough
default:invariant(false,'Unknown unit of work tag. This error is likely caused by a bug in React. Please file an issue.');}}return{completeWork:completeWork};};var invokeGuardedCallback$2=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError$1=ReactErrorUtils.hasCaughtError;var clearCaughtError$1=ReactErrorUtils.clearCaughtError;var ReactFiberCommitWork=function ReactFiberCommitWork(config,captureError){var getPublicInstance=config.getPublicInstance,mutation=config.mutation,persistence=config.persistence;var callComponentWillUnmountWithTimer=function callComponentWillUnmountWithTimer(current,instance){startPhaseTimer(current,'componentWillUnmount');instance.props=current.memoizedProps;instance.state=current.memoizedState;instance.componentWillUnmount();stopPhaseTimer();};// Capture errors so they don't interrupt unmounting.
function safelyCallComponentWillUnmount(current,instance){{invokeGuardedCallback$2(null,callComponentWillUnmountWithTimer,null,current,instance);if(hasCaughtError$1()){var unmountError=clearCaughtError$1();captureError(current,unmountError);}}}function safelyDetachRef(current){var ref=current.ref;if(ref!==null){{invokeGuardedCallback$2(null,ref,null,null);if(hasCaughtError$1()){var refError=clearCaughtError$1();captureError(current,refError);}}}}function commitLifeCycles(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{var instance=finishedWork.stateNode;if(finishedWork.effectTag&Update){if(current===null){startPhaseTimer(finishedWork,'componentDidMount');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidMount();stopPhaseTimer();}else{var prevProps=current.memoizedProps;var prevState=current.memoizedState;startPhaseTimer(finishedWork,'componentDidUpdate');instance.props=finishedWork.memoizedProps;instance.state=finishedWork.memoizedState;instance.componentDidUpdate(prevProps,prevState);stopPhaseTimer();}}var updateQueue=finishedWork.updateQueue;if(updateQueue!==null){commitCallbacks(updateQueue,instance);}return;}case HostRoot:{var _updateQueue=finishedWork.updateQueue;if(_updateQueue!==null){var _instance=finishedWork.child!==null?finishedWork.child.stateNode:null;commitCallbacks(_updateQueue,_instance);}return;}case HostComponent:{var _instance2=finishedWork.stateNode;// Renderers may schedule work to be done after host components are mounted
// (eg DOM renderer may schedule auto-focus for inputs and form controls).
// These effects should only be committed when components are first mounted,
// aka when there is no current/alternate.
if(current===null&&finishedWork.effectTag&Update){var type=finishedWork.type;var props=finishedWork.memoizedProps;commitMount(_instance2,type,props,finishedWork);}return;}case HostText:{// We have no life-cycles associated with text.
return;}case HostPortal:{// We have no life-cycles associated with portals.
return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(ref!==null){var instance=finishedWork.stateNode;switch(finishedWork.tag){case HostComponent:ref(getPublicInstance(instance));break;default:ref(instance);}}}function commitDetachRef(current){var currentRef=current.ref;if(currentRef!==null){currentRef(null);}}// User-originating errors (lifecycles and refs) should not interrupt
// deletion, so don't let them throw. Host-originating errors should
// interrupt deletion, so it's okay
function commitUnmount(current){if(typeof onCommitUnmount==='function'){onCommitUnmount(current);}switch(current.tag){case ClassComponent:{safelyDetachRef(current);var instance=current.stateNode;if(typeof instance.componentWillUnmount==='function'){safelyCallComponentWillUnmount(current,instance);}return;}case HostComponent:{safelyDetachRef(current);return;}case CallComponent:{commitNestedUnmounts(current.stateNode);return;}case HostPortal:{// TODO: this is recursive.
// We are also not using this parent because
// the portal will get pushed immediately.
if(enableMutatingReconciler&&mutation){unmountHostComponents(current);}else if(enablePersistentReconciler&&persistence){emptyPortalContainer(current);}return;}}}function commitNestedUnmounts(root){// While we're inside a removed host node we don't want to call
// removeChild on the inner nodes because they're removed by the top
// call anyway. We also want to call componentWillUnmount on all
// composites before this host node is removed from the tree. Therefore
var node=root;while(true){commitUnmount(node);// Visit children because they may contain more composite or host nodes.
// Skip portals because commitUnmount() currently visits them recursively.
if(node.child!==null&&(// If we use mutation we drill down into portals using commitUnmount above.
// If we don't use mutation we drill down into portals here instead.
!mutation||node.tag!==HostPortal)){node.child['return']=node;node=node.child;continue;}if(node===root){return;}while(node.sibling===null){if(node['return']===null||node['return']===root){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function detachFiber(current){// Cut off the return pointers to disconnect it from the tree. Ideally, we
// should clear the child pointer of the parent alternate to let this
// get GC:ed but we don't know which for sure which parent is the current
// one so we'll settle for GC:ing the subtree of this child. This child
// itself will be GC:ed when the parent updates the next time.
current['return']=null;current.child=null;if(current.alternate){current.alternate.child=null;current.alternate['return']=null;}}if(!mutation){var commitContainer=void 0;if(persistence){var replaceContainerChildren=persistence.replaceContainerChildren,createContainerChildSet=persistence.createContainerChildSet;var emptyPortalContainer=function emptyPortalContainer(current){var portal=current.stateNode;var containerInfo=portal.containerInfo;var emptyChildSet=createContainerChildSet(containerInfo);replaceContainerChildren(containerInfo,emptyChildSet);};commitContainer=function commitContainer(finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{return;}case HostText:{return;}case HostRoot:case HostPortal:{var portalOrRoot=finishedWork.stateNode;var containerInfo=portalOrRoot.containerInfo,_pendingChildren=portalOrRoot.pendingChildren;replaceContainerChildren(containerInfo,_pendingChildren);return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}};}else{commitContainer=function commitContainer(finishedWork){// Noop
};}if(enablePersistentReconciler||enableNoopReconciler){return{commitResetTextContent:function commitResetTextContent(finishedWork){},commitPlacement:function commitPlacement(finishedWork){},commitDeletion:function commitDeletion(current){// Detach refs and call componentWillUnmount() on the whole subtree.
commitNestedUnmounts(current);detachFiber(current);},commitWork:function commitWork(current,finishedWork){commitContainer(finishedWork);},commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else if(persistence){invariant(false,'Persistent reconciler is disabled.');}else{invariant(false,'Noop reconciler is disabled.');}}var commitMount=mutation.commitMount,commitUpdate=mutation.commitUpdate,resetTextContent=mutation.resetTextContent,commitTextUpdate=mutation.commitTextUpdate,appendChild=mutation.appendChild,appendChildToContainer=mutation.appendChildToContainer,insertBefore=mutation.insertBefore,insertInContainerBefore=mutation.insertInContainerBefore,removeChild=mutation.removeChild,removeChildFromContainer=mutation.removeChildFromContainer;function getHostParentFiber(fiber){var parent=fiber['return'];while(parent!==null){if(isHostParent(parent)){return parent;}parent=parent['return'];}invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.');}function isHostParent(fiber){return fiber.tag===HostComponent||fiber.tag===HostRoot||fiber.tag===HostPortal;}function getHostSibling(fiber){// We're going to search forward into the tree until we find a sibling host
// node. Unfortunately, if multiple insertions are done in a row we have to
// search past them. This leads to exponential search for the next sibling.
var node=fiber;siblings:while(true){// If we didn't find anything, let's try the next sibling.
while(node.sibling===null){if(node['return']===null||isHostParent(node['return'])){// If we pop out of the root or hit the parent the fiber we are the
// last sibling.
return null;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;while(node.tag!==HostComponent&&node.tag!==HostText){// If it is not host node and, we might have a host node inside it.
// Try to search down until we find one.
if(node.effectTag&Placement){// If we don't have a child, try the siblings instead.
continue siblings;}// If we don't have a child, try the siblings instead.
// We also skip portals because they are not part of this host tree.
if(node.child===null||node.tag===HostPortal){continue siblings;}else{node.child['return']=node;node=node.child;}}// Check if this host node is stable or about to be placed.
if(!(node.effectTag&Placement)){// Found it!
return node.stateNode;}}}function commitPlacement(finishedWork){// Recursively insert all host nodes into the parent.
var parentFiber=getHostParentFiber(finishedWork);var parent=void 0;var isContainer=void 0;switch(parentFiber.tag){case HostComponent:parent=parentFiber.stateNode;isContainer=false;break;case HostRoot:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;case HostPortal:parent=parentFiber.stateNode.containerInfo;isContainer=true;break;default:invariant(false,'Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.');}if(parentFiber.effectTag&ContentReset){// Reset the text content of the parent before doing any insertions
resetTextContent(parent);// Clear ContentReset from the effect tag
parentFiber.effectTag&=~ContentReset;}var before=getHostSibling(finishedWork);// We only have the top Fiber that was inserted but we need recurse down its
// children to find all the terminal nodes.
var node=finishedWork;while(true){if(node.tag===HostComponent||node.tag===HostText){if(before){if(isContainer){insertInContainerBefore(parent,node.stateNode,before);}else{insertBefore(parent,node.stateNode,before);}}else{if(isContainer){appendChildToContainer(parent,node.stateNode);}else{appendChild(parent,node.stateNode);}}}else if(node.tag===HostPortal){// If the insertion itself is a portal, then we don't want to traverse
// down its children. Instead, we'll get insertions from each child in
// the portal directly.
}else if(node.child!==null){node.child['return']=node;node=node.child;continue;}if(node===finishedWork){return;}while(node.sibling===null){if(node['return']===null||node['return']===finishedWork){return;}node=node['return'];}node.sibling['return']=node['return'];node=node.sibling;}}function unmountHostComponents(current){// We only have the top Fiber that was inserted but we need recurse down its
var node=current;// Each iteration, currentParent is populated with node's host parent if not
// currentParentIsValid.
var currentParentIsValid=false;var currentParent=void 0;var currentParentIsContainer=void 0;while(true){if(!currentParentIsValid){var parent=node['return'];findParent:while(true){!(parent!==null)?invariant(false,'Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(parent.tag){case HostComponent:currentParent=parent.stateNode;currentParentIsContainer=false;break findParent;case HostRoot:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;case HostPortal:currentParent=parent.stateNode.containerInfo;currentParentIsContainer=true;break findParent;}parent=parent['return'];}currentParentIsValid=true;}if(node.tag===HostComponent||node.tag===HostText){commitNestedUnmounts(node);// After all the children have unmounted, it is now safe to remove the
// node from the tree.
if(currentParentIsContainer){removeChildFromContainer(currentParent,node.stateNode);}else{removeChild(currentParent,node.stateNode);}// Don't visit children because we already visited them.
}else if(node.tag===HostPortal){// When we go into a portal, it becomes the parent to remove from.
// We will reassign it back when we pop the portal on the way up.
currentParent=node.stateNode.containerInfo;// Visit children because portals might contain host components.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}else{commitUnmount(node);// Visit children because we may find more host components below.
if(node.child!==null){node.child['return']=node;node=node.child;continue;}}if(node===current){return;}while(node.sibling===null){if(node['return']===null||node['return']===current){return;}node=node['return'];if(node.tag===HostPortal){// When we go out of the portal, we need to restore the parent.
// Since we don't keep a stack of them, we will search for it.
currentParentIsValid=false;}}node.sibling['return']=node['return'];node=node.sibling;}}function commitDeletion(current){// Recursively delete all host nodes from the parent.
// Detach refs and call componentWillUnmount() on the whole subtree.
unmountHostComponents(current);detachFiber(current);}function commitWork(current,finishedWork){switch(finishedWork.tag){case ClassComponent:{return;}case HostComponent:{var instance=finishedWork.stateNode;if(instance!=null){// Commit the work prepared earlier.
var newProps=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldProps=current!==null?current.memoizedProps:newProps;var type=finishedWork.type;// TODO: Type the updateQueue to be specific to host components.
var updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=null;if(updatePayload!==null){commitUpdate(instance,updatePayload,type,oldProps,newProps,finishedWork);}}return;}case HostText:{!(finishedWork.stateNode!==null)?invariant(false,'This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.'):void 0;var textInstance=finishedWork.stateNode;var newText=finishedWork.memoizedProps;// For hydration we reuse the update path but we treat the oldProps
// as the newProps. The updatePayload will contain the real change in
// this case.
var oldText=current!==null?current.memoizedProps:newText;commitTextUpdate(textInstance,oldText,newText);return;}case HostRoot:{return;}default:{invariant(false,'This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.');}}}function commitResetTextContent(current){resetTextContent(current.stateNode);}if(enableMutatingReconciler){return{commitResetTextContent:commitResetTextContent,commitPlacement:commitPlacement,commitDeletion:commitDeletion,commitWork:commitWork,commitLifeCycles:commitLifeCycles,commitAttachRef:commitAttachRef,commitDetachRef:commitDetachRef};}else{invariant(false,'Mutating reconciler is disabled.');}};var NO_CONTEXT={};var ReactFiberHostContext=function ReactFiberHostContext(config){var getChildHostContext=config.getChildHostContext,getRootHostContext=config.getRootHostContext;var contextStackCursor=createCursor(NO_CONTEXT);var contextFiberStackCursor=createCursor(NO_CONTEXT);var rootInstanceStackCursor=createCursor(NO_CONTEXT);function requiredContext(c){!(c!==NO_CONTEXT)?invariant(false,'Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.'):void 0;return c;}function getRootHostContainer(){var rootInstance=requiredContext(rootInstanceStackCursor.current);return rootInstance;}function pushHostContainer(fiber,nextRootInstance){// Push current root instance onto the stack;
// This allows us to reset root when portals are popped.
push(rootInstanceStackCursor,nextRootInstance,fiber);var nextRootContext=getRootHostContext(nextRootInstance);// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextRootContext,fiber);}function popHostContainer(fiber){pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber);}function getHostContext(){var context=requiredContext(contextStackCursor.current);return context;}function pushHostContext(fiber){var rootInstance=requiredContext(rootInstanceStackCursor.current);var context=requiredContext(contextStackCursor.current);var nextContext=getChildHostContext(context,fiber.type,rootInstance);// Don't push this Fiber's context unless it's unique.
if(context===nextContext){return;}// Track the context and the Fiber that provided it.
// This enables us to pop only Fibers that provide unique contexts.
push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor,nextContext,fiber);}function popHostContext(fiber){// Do not pop unless this Fiber provided the current context.
// pushHostContext() only pushes Fibers that provide unique contexts.
if(contextFiberStackCursor.current!==fiber){return;}pop(contextStackCursor,fiber);pop(contextFiberStackCursor,fiber);}function resetHostContainer(){contextStackCursor.current=NO_CONTEXT;rootInstanceStackCursor.current=NO_CONTEXT;}return{getHostContext:getHostContext,getRootHostContainer:getRootHostContainer,popHostContainer:popHostContainer,popHostContext:popHostContext,pushHostContainer:pushHostContainer,pushHostContext:pushHostContext,resetHostContainer:resetHostContainer};};var ReactFiberHydrationContext=function ReactFiberHydrationContext(config){var shouldSetTextContent=config.shouldSetTextContent,hydration=config.hydration;// If this doesn't have hydration mode.
if(!hydration){return{enterHydrationState:function enterHydrationState(){return false;},resetHydrationState:function resetHydrationState(){},tryToClaimNextHydratableInstance:function tryToClaimNextHydratableInstance(){},prepareToHydrateHostInstance:function prepareToHydrateHostInstance(){invariant(false,'Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},prepareToHydrateHostTextInstance:function prepareToHydrateHostTextInstance(){invariant(false,'Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.');},popHydrationState:function popHydrationState(fiber){return false;}};}var canHydrateInstance=hydration.canHydrateInstance,canHydrateTextInstance=hydration.canHydrateTextInstance,getNextHydratableSibling=hydration.getNextHydratableSibling,getFirstHydratableChild=hydration.getFirstHydratableChild,hydrateInstance=hydration.hydrateInstance,hydrateTextInstance=hydration.hydrateTextInstance,didNotMatchHydratedContainerTextInstance=hydration.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=hydration.didNotMatchHydratedTextInstance,didNotHydrateContainerInstance=hydration.didNotHydrateContainerInstance,didNotHydrateInstance=hydration.didNotHydrateInstance,didNotFindHydratableContainerInstance=hydration.didNotFindHydratableContainerInstance,didNotFindHydratableContainerTextInstance=hydration.didNotFindHydratableContainerTextInstance,didNotFindHydratableInstance=hydration.didNotFindHydratableInstance,didNotFindHydratableTextInstance=hydration.didNotFindHydratableTextInstance;// The deepest Fiber on the stack involved in a hydration context.
// This may have been an insertion or a hydration.
var hydrationParentFiber=null;var nextHydratableInstance=null;var isHydrating=false;function enterHydrationState(fiber){var parentInstance=fiber.stateNode.containerInfo;nextHydratableInstance=getFirstHydratableChild(parentInstance);hydrationParentFiber=fiber;isHydrating=true;return true;}function deleteHydratableInstance(returnFiber,instance){{switch(returnFiber.tag){case HostRoot:didNotHydrateContainerInstance(returnFiber.stateNode.containerInfo,instance);break;case HostComponent:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;}}var childToDelete=createFiberFromHostInstanceForDeletion();childToDelete.stateNode=instance;childToDelete['return']=returnFiber;childToDelete.effectTag=Deletion;// This might seem like it belongs on progressedFirstDeletion. However,
// these children are not part of the reconciliation list of children.
// Even if we abort and rereconcile the children, that will try to hydrate
// again and the nodes are still in the host tree so these will be
// recreated.
if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=childToDelete;returnFiber.lastEffect=childToDelete;}else{returnFiber.firstEffect=returnFiber.lastEffect=childToDelete;}}function insertNonHydratedInstance(returnFiber,fiber){fiber.effectTag|=Placement;{switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case HostComponent:var type=fiber.type;var props=fiber.pendingProps;didNotFindHydratableContainerInstance(parentContainer,type,props);break;case HostText:var text=fiber.pendingProps;didNotFindHydratableContainerTextInstance(parentContainer,text);break;}break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;switch(fiber.tag){case HostComponent:var _type=fiber.type;var _props=fiber.pendingProps;didNotFindHydratableInstance(parentType,parentProps,parentInstance,_type,_props);break;case HostText:var _text=fiber.pendingProps;didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,_text);break;}break;}default:return;}}}function canHydrate(fiber,nextInstance){switch(fiber.tag){case HostComponent:{var type=fiber.type;var props=fiber.pendingProps;return canHydrateInstance(nextInstance,type,props);}case HostText:{var text=fiber.pendingProps;return canHydrateTextInstance(nextInstance,text);}default:return false;}}function tryToClaimNextHydratableInstance(fiber){if(!isHydrating){return;}var nextInstance=nextHydratableInstance;if(!nextInstance){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}if(!canHydrate(fiber,nextInstance)){// If we can't hydrate this instance let's try the next one.
// We use this as a heuristic. It's based on intuition and not data so it
// might be flawed or unnecessary.
nextInstance=getNextHydratableSibling(nextInstance);if(!nextInstance||!canHydrate(fiber,nextInstance)){// Nothing to hydrate. Make it an insertion.
insertNonHydratedInstance(hydrationParentFiber,fiber);isHydrating=false;hydrationParentFiber=fiber;return;}// We matched the next one, we'll now assume that the first one was
// superfluous and we'll delete it. Since we can't eagerly delete it
// we'll have to schedule a deletion. To do that, this node needs a dummy
// fiber associated with it.
deleteHydratableInstance(hydrationParentFiber,nextHydratableInstance);}fiber.stateNode=nextInstance;hydrationParentFiber=fiber;nextHydratableInstance=getFirstHydratableChild(nextInstance);}function prepareToHydrateHostInstance(fiber,rootContainerInstance,hostContext){var instance=fiber.stateNode;var updatePayload=hydrateInstance(instance,fiber.type,fiber.memoizedProps,rootContainerInstance,hostContext,fiber);// TODO: Type this specific to this type of component.
fiber.updateQueue=updatePayload;// If the update payload indicates that there is a change or if there
// is a new ref we mark this as an update.
if(updatePayload!==null){return true;}return false;}function prepareToHydrateHostTextInstance(fiber){var textInstance=fiber.stateNode;var textContent=fiber.memoizedProps;var shouldUpdate=hydrateTextInstance(textInstance,textContent,fiber);{if(shouldUpdate){// We assume that prepareToHydrateHostTextInstance is called in a context where the
// hydration parent is the parent host component of this host text.
var returnFiber=hydrationParentFiber;if(returnFiber!==null){switch(returnFiber.tag){case HostRoot:{var parentContainer=returnFiber.stateNode.containerInfo;didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,textContent);break;}case HostComponent:{var parentType=returnFiber.type;var parentProps=returnFiber.memoizedProps;var parentInstance=returnFiber.stateNode;didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,textContent);break;}}}}}return shouldUpdate;}function popToNextHostParent(fiber){var parent=fiber['return'];while(parent!==null&&parent.tag!==HostComponent&&parent.tag!==HostRoot){parent=parent['return'];}hydrationParentFiber=parent;}function popHydrationState(fiber){if(fiber!==hydrationParentFiber){// We're deeper than the current hydration context, inside an inserted
// tree.
return false;}if(!isHydrating){// If we're not currently hydrating but we're in a hydration context, then
// we were an insertion and now need to pop up reenter hydration of our
// siblings.
popToNextHostParent(fiber);isHydrating=true;return false;}var type=fiber.type;// If we have any remaining hydratable nodes, we need to delete them now.
// We only do this deeper than head and body since they tend to have random
// other nodes in them. We also ignore components with pure text content in
// side of them.
// TODO: Better heuristic.
if(fiber.tag!==HostComponent||type!=='head'&&type!=='body'&&!shouldSetTextContent(type,fiber.memoizedProps)){var nextInstance=nextHydratableInstance;while(nextInstance){deleteHydratableInstance(fiber,nextInstance);nextInstance=getNextHydratableSibling(nextInstance);}}popToNextHostParent(fiber);nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return true;}function resetHydrationState(){hydrationParentFiber=null;nextHydratableInstance=null;isHydrating=false;}return{enterHydrationState:enterHydrationState,resetHydrationState:resetHydrationState,tryToClaimNextHydratableInstance:tryToClaimNextHydratableInstance,prepareToHydrateHostInstance:prepareToHydrateHostInstance,prepareToHydrateHostTextInstance:prepareToHydrateHostTextInstance,popHydrationState:popHydrationState};};// This lets us hook into Fiber to debug what it's doing.
// See https://github.com/facebook/react/pull/8033.
// This is not part of the public API, not even for React DevTools.
// You may only inject a debugTool if you work on React Fiber itself.
var ReactFiberInstrumentation={debugTool:null};var ReactFiberInstrumentation_1=ReactFiberInstrumentation;var defaultShowDialog=function defaultShowDialog(capturedError){return true;};var showDialog=defaultShowDialog;function logCapturedError(capturedError){var logError=showDialog(capturedError);// Allow injected showDialog() to prevent default console.error logging.
// This enables renderers like ReactNative to better manage redbox behavior.
if(logError===false){return;}{var componentName=capturedError.componentName,componentStack=capturedError.componentStack,errorBoundaryName=capturedError.errorBoundaryName,errorBoundaryFound=capturedError.errorBoundaryFound,willRetry=capturedError.willRetry;var componentNameMessage=componentName?'The above error occurred in the <'+componentName+'> component:':'The above error occurred in one of your React components:';var errorBoundaryMessage=void 0;// errorBoundaryFound check is sufficient; errorBoundaryName check is to satisfy Flow.
if(errorBoundaryFound&&errorBoundaryName){if(willRetry){errorBoundaryMessage='React will try to recreate this component tree from scratch '+('using the error boundary you provided, '+errorBoundaryName+'.');}else{errorBoundaryMessage='This error was initially handled by the error boundary '+errorBoundaryName+'.\n'+'Recreating the tree from scratch failed so React will unmount the tree.';}}else{errorBoundaryMessage='Consider adding an error boundary to your tree to customize error handling behavior.\n'+'Visit https://fb.me/react-error-boundaries to learn more about error boundaries.';}var combinedMessage=''+componentNameMessage+componentStack+'\n\n'+(''+errorBoundaryMessage);// In development, we provide our own message with just the component stack.
// We don't include the original error message and JS stack because the browser
// has already printed it. Even if the application swallows the error, it is still
// displayed by the browser thanks to the DEV-only fake event trick in ReactErrorUtils.
console.error(combinedMessage);}}var invokeGuardedCallback$1=ReactErrorUtils.invokeGuardedCallback;var hasCaughtError=ReactErrorUtils.hasCaughtError;var clearCaughtError=ReactErrorUtils.clearCaughtError;{var didWarnAboutStateTransition=false;var didWarnSetStateChildContext=false;var didWarnStateUpdateForUnmountedComponent={};var warnAboutUpdateOnUnmounted=function warnAboutUpdateOnUnmounted(fiber){var componentName=getComponentName(fiber)||'ReactClass';if(didWarnStateUpdateForUnmountedComponent[componentName]){return;}warning(false,'Can only update a mounted or mounting '+'component. This usually means you called setState, replaceState, '+'or forceUpdate on an unmounted component. This is a no-op.\n\nPlease '+'check the code for the %s component.',componentName);didWarnStateUpdateForUnmountedComponent[componentName]=true;};var warnAboutInvalidUpdates=function warnAboutInvalidUpdates(instance){switch(ReactDebugCurrentFiber.phase){case'getChildContext':if(didWarnSetStateChildContext){return;}warning(false,'setState(...): Cannot call setState() inside getChildContext()');didWarnSetStateChildContext=true;break;case'render':if(didWarnAboutStateTransition){return;}warning(false,'Cannot update during an existing state transition (such as within '+"`render` or another component's constructor). Render methods should "+'be a pure function of props and state; constructor side-effects are '+'an anti-pattern, but can be moved to `componentWillMount`.');didWarnAboutStateTransition=true;break;}};}var ReactFiberScheduler=function ReactFiberScheduler(config){var hostContext=ReactFiberHostContext(config);var hydrationContext=ReactFiberHydrationContext(config);var popHostContainer=hostContext.popHostContainer,popHostContext=hostContext.popHostContext,resetHostContainer=hostContext.resetHostContainer;var _ReactFiberBeginWork=ReactFiberBeginWork(config,hostContext,hydrationContext,scheduleWork,computeExpirationForFiber),beginWork=_ReactFiberBeginWork.beginWork,beginFailedWork=_ReactFiberBeginWork.beginFailedWork;var _ReactFiberCompleteWo=ReactFiberCompleteWork(config,hostContext,hydrationContext),completeWork=_ReactFiberCompleteWo.completeWork;var _ReactFiberCommitWork=ReactFiberCommitWork(config,captureError),commitResetTextContent=_ReactFiberCommitWork.commitResetTextContent,commitPlacement=_ReactFiberCommitWork.commitPlacement,commitDeletion=_ReactFiberCommitWork.commitDeletion,commitWork=_ReactFiberCommitWork.commitWork,commitLifeCycles=_ReactFiberCommitWork.commitLifeCycles,commitAttachRef=_ReactFiberCommitWork.commitAttachRef,commitDetachRef=_ReactFiberCommitWork.commitDetachRef;var now=config.now,scheduleDeferredCallback=config.scheduleDeferredCallback,useSyncScheduling=config.useSyncScheduling,prepareForCommit=config.prepareForCommit,resetAfterCommit=config.resetAfterCommit;// Represents the current time in ms.
var startTime=now();var mostRecentCurrentTime=msToExpirationTime(0);// Represents the expiration time that incoming updates should use. (If this
// is NoWork, use the default strategy: async updates in async mode, sync
// updates in sync mode.)
var expirationContext=NoWork;var isWorking=false;// The next work in progress fiber that we're currently working on.
var nextUnitOfWork=null;var nextRoot=null;// The time at which we're currently rendering work.
var nextRenderExpirationTime=NoWork;// The next fiber with an effect that we're currently committing.
var nextEffect=null;// Keep track of which fibers have captured an error that need to be handled.
// Work is removed from this collection after componentDidCatch is called.
var capturedErrors=null;// Keep track of which fibers have failed during the current batch of work.
// This is a different set than capturedErrors, because it is not reset until
// the end of the batch. This is needed to propagate errors correctly if a
// subtree fails more than once.
var failedBoundaries=null;// Error boundaries that captured an error during the current commit.
var commitPhaseBoundaries=null;var firstUncaughtError=null;var didFatal=false;var isCommitting=false;var isUnmounting=false;// Used for performance tracking.
var interruptedBy=null;function resetContextStack(){// Reset the stack
reset$1();// Reset the cursors
resetContext();resetHostContainer();}function commitAllHostEffects(){while(nextEffect!==null){{ReactDebugCurrentFiber.setCurrentFiber(nextEffect);}recordEffect();var effectTag=nextEffect.effectTag;if(effectTag&ContentReset){commitResetTextContent(nextEffect);}if(effectTag&Ref){var current=nextEffect.alternate;if(current!==null){commitDetachRef(current);}}// The following switch statement is only concerned about placement,
// updates, and deletions. To avoid needing to add a case for every
// possible bitmap value, we remove the secondary effects from the
// effect tag and switch on that value.
var primaryEffectTag=effectTag&~(Callback|Err|ContentReset|Ref|PerformedWork);switch(primaryEffectTag){case Placement:{commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
// TODO: findDOMNode doesn't rely on this any more but isMounted
// does and isMounted is deprecated anyway so we should be able
// to kill this.
nextEffect.effectTag&=~Placement;break;}case PlacementAndUpdate:{// Placement
commitPlacement(nextEffect);// Clear the "placement" from effect tag so that we know that this is inserted, before
// any life-cycles like componentDidMount gets called.
nextEffect.effectTag&=~Placement;// Update
var _current=nextEffect.alternate;commitWork(_current,nextEffect);break;}case Update:{var _current2=nextEffect.alternate;commitWork(_current2,nextEffect);break;}case Deletion:{isUnmounting=true;commitDeletion(nextEffect);isUnmounting=false;break;}}nextEffect=nextEffect.nextEffect;}{ReactDebugCurrentFiber.resetCurrentFiber();}}function commitAllLifeCycles(){while(nextEffect!==null){var effectTag=nextEffect.effectTag;if(effectTag&(Update|Callback)){recordEffect();var current=nextEffect.alternate;commitLifeCycles(current,nextEffect);}if(effectTag&Ref){recordEffect();commitAttachRef(nextEffect);}if(effectTag&Err){recordEffect();commitErrorHandling(nextEffect);}var next=nextEffect.nextEffect;// Ensure that we clean these up so that we don't accidentally keep them.
// I'm not actually sure this matters because we can't reset firstEffect
// and lastEffect since they're on every node, not just the effectful
// ones. So we have to clean everything as we reuse nodes anyway.
nextEffect.nextEffect=null;// Ensure that we reset the effectTag here so that we can rely on effect
// tags to reason about the current life-cycle.
nextEffect=next;}}function commitRoot(finishedWork){// We keep track of this so that captureError can collect any boundaries
// that capture an error during the commit phase. The reason these aren't
// local to this function is because errors that occur during cWU are
// captured elsewhere, to prevent the unmount from being interrupted.
isWorking=true;isCommitting=true;startCommitTimer();var root=finishedWork.stateNode;!(root.current!==finishedWork)?invariant(false,'Cannot commit the same tree as before. This is probably a bug related to the return field. This error is likely caused by a bug in React. Please file an issue.'):void 0;root.isReadyForCommit=false;// Reset this to null before calling lifecycles
ReactCurrentOwner.current=null;var firstEffect=void 0;if(finishedWork.effectTag>PerformedWork){// A fiber's effect list consists only of its children, not itself. So if
// the root has an effect, we need to add it to the end of the list. The
// resulting list is the set that would belong to the root's parent, if
// it had one; that is, all the effects in the tree including the root.
if(finishedWork.lastEffect!==null){finishedWork.lastEffect.nextEffect=finishedWork;firstEffect=finishedWork.firstEffect;}else{firstEffect=finishedWork;}}else{// There is no effect on the root.
firstEffect=finishedWork.firstEffect;}prepareForCommit();// Commit all the side-effects within a tree. We'll do this in two passes.
// The first pass performs all the host insertions, updates, deletions and
// ref unmounts.
nextEffect=firstEffect;startCommitHostEffectsTimer();while(nextEffect!==null){var didError=false;var _error=void 0;{invokeGuardedCallback$1(null,commitAllHostEffects,null);if(hasCaughtError()){didError=true;_error=clearCaughtError();}}if(didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error);// Clean-up
if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}stopCommitHostEffectsTimer();resetAfterCommit();// The work-in-progress tree is now the current tree. This must come after
// the first pass of the commit phase, so that the previous tree is still
// current during componentWillUnmount, but before the second pass, so that
// the finished work is current during componentDidMount/Update.
root.current=finishedWork;// In the second pass we'll perform all life-cycles and ref callbacks.
// Life-cycles happen as a separate pass so that all placements, updates,
// and deletions in the entire tree have already been invoked.
// This pass also triggers any renderer-specific initial effects.
nextEffect=firstEffect;startCommitLifeCyclesTimer();while(nextEffect!==null){var _didError=false;var _error2=void 0;{invokeGuardedCallback$1(null,commitAllLifeCycles,null);if(hasCaughtError()){_didError=true;_error2=clearCaughtError();}}if(_didError){!(nextEffect!==null)?invariant(false,'Should have next effect. This error is likely caused by a bug in React. Please file an issue.'):void 0;captureError(nextEffect,_error2);if(nextEffect!==null){nextEffect=nextEffect.nextEffect;}}}isCommitting=false;isWorking=false;stopCommitLifeCyclesTimer();stopCommitTimer();if(typeof onCommitRoot==='function'){onCommitRoot(finishedWork.stateNode);}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCommitWork(finishedWork);}// If we caught any errors during this commit, schedule their boundaries
// to update.
if(commitPhaseBoundaries){commitPhaseBoundaries.forEach(scheduleErrorRecovery);commitPhaseBoundaries=null;}if(firstUncaughtError!==null){var _error3=firstUncaughtError;firstUncaughtError=null;onUncaughtError(_error3);}var remainingTime=root.current.expirationTime;if(remainingTime===NoWork){capturedErrors=null;failedBoundaries=null;}return remainingTime;}function resetExpirationTime(workInProgress,renderTime){if(renderTime!==Never&&workInProgress.expirationTime===Never){// The children of this component are hidden. Don't bubble their
// expiration times.
return;}// Check for pending updates.
var newExpirationTime=getUpdateExpirationTime(workInProgress);// TODO: Calls need to visit stateNode
// Bubble up the earliest expiration time.
var child=workInProgress.child;while(child!==null){if(child.expirationTime!==NoWork&&(newExpirationTime===NoWork||newExpirationTime>child.expirationTime)){newExpirationTime=child.expirationTime;}child=child.sibling;}workInProgress.expirationTime=newExpirationTime;}function completeUnitOfWork(workInProgress){while(true){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=completeWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}var returnFiber=workInProgress['return'];var siblingFiber=workInProgress.sibling;resetExpirationTime(workInProgress,nextRenderExpirationTime);if(next!==null){stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}// If completing this work spawned new work, do that next. We'll come
// back here again.
return next;}if(returnFiber!==null){// Append all the effects of the subtree and this fiber onto the effect
// list of the parent. The completion order of the children affects the
// side-effect order.
if(returnFiber.firstEffect===null){returnFiber.firstEffect=workInProgress.firstEffect;}if(workInProgress.lastEffect!==null){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress.firstEffect;}returnFiber.lastEffect=workInProgress.lastEffect;}// If this fiber had side-effects, we append it AFTER the children's
// side-effects. We can perform certain side-effects earlier if
// needed, by doing multiple passes over the effect list. We don't want
// to schedule our own side-effect on our own list because if end up
// reusing children we'll schedule this effect onto itself since we're
// at the end.
var effectTag=workInProgress.effectTag;// Skip both NoWork and PerformedWork tags when creating the effect list.
// PerformedWork effect is read by React DevTools but shouldn't be committed.
if(effectTag>PerformedWork){if(returnFiber.lastEffect!==null){returnFiber.lastEffect.nextEffect=workInProgress;}else{returnFiber.firstEffect=workInProgress;}returnFiber.lastEffect=workInProgress;}}stopWorkTimer(workInProgress);if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onCompleteWork(workInProgress);}if(siblingFiber!==null){// If there is more work to do in this returnFiber, do that next.
return siblingFiber;}else if(returnFiber!==null){// If there's no more work in this returnFiber. Complete the returnFiber.
workInProgress=returnFiber;continue;}else{// We've reached the root.
var root=workInProgress.stateNode;root.isReadyForCommit=true;return null;}}// Without this explicit null return Flow complains of invalid return type
// TODO Remove the above while(true) loop
// eslint-disable-next-line no-unreachable
return null;}function performUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function performFailedUnitOfWork(workInProgress){// The current, flushed, state of this fiber is the alternate.
// Ideally nothing should rely on this, but relying on it here
// means that we don't need an additional field on the work in
// progress.
var current=workInProgress.alternate;// See if beginning this work spawns more work.
startWorkTimer(workInProgress);{ReactDebugCurrentFiber.setCurrentFiber(workInProgress);}var next=beginFailedWork(current,workInProgress,nextRenderExpirationTime);{ReactDebugCurrentFiber.resetCurrentFiber();}if(true&&ReactFiberInstrumentation_1.debugTool){ReactFiberInstrumentation_1.debugTool.onBeginWork(workInProgress);}if(next===null){// If this doesn't spawn new work, complete the current work.
next=completeUnitOfWork(workInProgress);}ReactCurrentOwner.current=null;return next;}function workLoop(expirationTime){if(capturedErrors!==null){// If there are unhandled errors, switch to the slow work loop.
// TODO: How to avoid this check in the fast path? Maybe the renderer
// could keep track of which roots have unhandled errors and call a
// forked version of renderRoot.
slowWorkLoopThatChecksForFailedWork(expirationTime);return;}if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}function slowWorkLoopThatChecksForFailedWork(expirationTime){if(nextRenderExpirationTime===NoWork||nextRenderExpirationTime>expirationTime){return;}if(nextRenderExpirationTime<=mostRecentCurrentTime){// Flush all expired work.
while(nextUnitOfWork!==null){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}else{// Flush asynchronous work until the deadline runs out of time.
while(nextUnitOfWork!==null&&!shouldYield()){if(hasCapturedError(nextUnitOfWork)){// Use a forked version of performUnitOfWork
nextUnitOfWork=performFailedUnitOfWork(nextUnitOfWork);}else{nextUnitOfWork=performUnitOfWork(nextUnitOfWork);}}}}function renderRootCatchBlock(root,failedWork,boundary,expirationTime){// We're going to restart the error boundary that captured the error.
// Conceptually, we're unwinding the stack. We need to unwind the
// context stack, too.
unwindContexts(failedWork,boundary);// Restart the error boundary using a forked version of
// performUnitOfWork that deletes the boundary's children. The entire
// failed subree will be unmounted. During the commit phase, a special
// lifecycle method is called on the error boundary, which triggers
// a re-render.
nextUnitOfWork=performFailedUnitOfWork(boundary);// Continue working.
workLoop(expirationTime);}function renderRoot(root,expirationTime){!!isWorking?invariant(false,'renderRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isWorking=true;// We're about to mutate the work-in-progress tree. If the root was pending
// commit, it no longer is: we'll need to complete it again.
root.isReadyForCommit=false;// Check if we're starting from a fresh stack, or if we're resuming from
// previously yielded work.
if(root!==nextRoot||expirationTime!==nextRenderExpirationTime||nextUnitOfWork===null){// Reset the stack and start working from the root.
resetContextStack();nextRoot=root;nextRenderExpirationTime=expirationTime;nextUnitOfWork=createWorkInProgress(nextRoot.current,null,expirationTime);}startWorkLoopTimer(nextUnitOfWork);var didError=false;var error=null;{invokeGuardedCallback$1(null,workLoop,null,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();}}// An error was thrown during the render phase.
while(didError){if(didFatal){// This was a fatal error. Don't attempt to recover from it.
firstUncaughtError=error;break;}var failedWork=nextUnitOfWork;if(failedWork===null){// An error was thrown but there's no current unit of work. This can
// happen during the commit phase if there's a bug in the renderer.
didFatal=true;continue;}// "Capture" the error by finding the nearest boundary. If there is no
// error boundary, we use the root.
var boundary=captureError(failedWork,error);!(boundary!==null)?invariant(false,'Should have found an error boundary. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(didFatal){// The error we just captured was a fatal error. This happens
// when the error propagates to the root more than once.
continue;}didError=false;error=null;{invokeGuardedCallback$1(null,renderRootCatchBlock,null,root,failedWork,boundary,expirationTime);if(hasCaughtError()){didError=true;error=clearCaughtError();continue;}}// We're finished working. Exit the error loop.
break;}var uncaughtError=firstUncaughtError;// We're done performing work. Time to clean up.
stopWorkLoopTimer(interruptedBy);interruptedBy=null;isWorking=false;didFatal=false;firstUncaughtError=null;if(uncaughtError!==null){onUncaughtError(uncaughtError);}return root.isReadyForCommit?root.current.alternate:null;}// Returns the boundary that captured the error, or null if the error is ignored
function captureError(failedWork,error){// It is no longer valid because we exited the user code.
ReactCurrentOwner.current=null;{ReactDebugCurrentFiber.resetCurrentFiber();}// Search for the nearest error boundary.
var boundary=null;// Passed to logCapturedError()
var errorBoundaryFound=false;var willRetry=false;var errorBoundaryName=null;// Host containers are a special case. If the failed work itself is a host
// container, then it acts as its own boundary. In all other cases, we
// ignore the work itself and only search through the parents.
if(failedWork.tag===HostRoot){boundary=failedWork;if(isFailedBoundary(failedWork)){// If this root already failed, there must have been an error when
// attempting to unmount it. This is a worst-case scenario and
// should only be possible if there's a bug in the renderer.
didFatal=true;}}else{var node=failedWork['return'];while(node!==null&&boundary===null){if(node.tag===ClassComponent){var instance=node.stateNode;if(typeof instance.componentDidCatch==='function'){errorBoundaryFound=true;errorBoundaryName=getComponentName(node);// Found an error boundary!
boundary=node;willRetry=true;}}else if(node.tag===HostRoot){// Treat the root like a no-op error boundary
boundary=node;}if(isFailedBoundary(node)){// This boundary is already in a failed state.
// If we're currently unmounting, that means this error was
// thrown while unmounting a failed subtree. We should ignore
// the error.
if(isUnmounting){return null;}// If we're in the commit phase, we should check to see if
// this boundary already captured an error during this commit.
// This case exists because multiple errors can be thrown during
// a single commit without interruption.
if(commitPhaseBoundaries!==null&&(commitPhaseBoundaries.has(node)||node.alternate!==null&&commitPhaseBoundaries.has(node.alternate))){// If so, we should ignore this error.
return null;}// The error should propagate to the next boundary -— we keep looking.
boundary=null;willRetry=false;}node=node['return'];}}if(boundary!==null){// Add to the collection of failed boundaries. This lets us know that
// subsequent errors in this subtree should propagate to the next boundary.
if(failedBoundaries===null){failedBoundaries=new Set();}failedBoundaries.add(boundary);// This method is unsafe outside of the begin and complete phases.
// We might be in the commit phase when an error is captured.
// The risk is that the return path from this Fiber may not be accurate.
// That risk is acceptable given the benefit of providing users more context.
var _componentStack=getStackAddendumByWorkInProgressFiber(failedWork);var _componentName=getComponentName(failedWork);// Add to the collection of captured errors. This is stored as a global
// map of errors and their component stack location keyed by the boundaries
// that capture them. We mostly use this Map as a Set; it's a Map only to
// avoid adding a field to Fiber to store the error.
if(capturedErrors===null){capturedErrors=new Map();}var capturedError={componentName:_componentName,componentStack:_componentStack,error:error,errorBoundary:errorBoundaryFound?boundary.stateNode:null,errorBoundaryFound:errorBoundaryFound,errorBoundaryName:errorBoundaryName,willRetry:willRetry};capturedErrors.set(boundary,capturedError);try{logCapturedError(capturedError);}catch(e){// Prevent cycle if logCapturedError() throws.
// A cycle may still occur if logCapturedError renders a component that throws.
console.error(e);}// If we're in the commit phase, defer scheduling an update on the
// boundary until after the commit is complete
if(isCommitting){if(commitPhaseBoundaries===null){commitPhaseBoundaries=new Set();}commitPhaseBoundaries.add(boundary);}else{// Otherwise, schedule an update now.
// TODO: Is this actually necessary during the render phase? Is it
// possible to unwind and continue rendering at the same priority,
// without corrupting internal state?
scheduleErrorRecovery(boundary);}return boundary;}else if(firstUncaughtError===null){// If no boundary is found, we'll need to throw the error
firstUncaughtError=error;}return null;}function hasCapturedError(fiber){// TODO: capturedErrors should store the boundary instance, to avoid needing
// to check the alternate.
return capturedErrors!==null&&(capturedErrors.has(fiber)||fiber.alternate!==null&&capturedErrors.has(fiber.alternate));}function isFailedBoundary(fiber){// TODO: failedBoundaries should store the boundary instance, to avoid
// needing to check the alternate.
return failedBoundaries!==null&&(failedBoundaries.has(fiber)||fiber.alternate!==null&&failedBoundaries.has(fiber.alternate));}function commitErrorHandling(effectfulFiber){var capturedError=void 0;if(capturedErrors!==null){capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);if(capturedError==null){if(effectfulFiber.alternate!==null){effectfulFiber=effectfulFiber.alternate;capturedError=capturedErrors.get(effectfulFiber);capturedErrors['delete'](effectfulFiber);}}}!(capturedError!=null)?invariant(false,'No error for given unit of work. This error is likely caused by a bug in React. Please file an issue.'):void 0;switch(effectfulFiber.tag){case ClassComponent:var instance=effectfulFiber.stateNode;var info={componentStack:capturedError.componentStack};// Allow the boundary to handle the error, usually by scheduling
// an update to itself
instance.componentDidCatch(capturedError.error,info);return;case HostRoot:if(firstUncaughtError===null){firstUncaughtError=capturedError.error;}return;default:invariant(false,'Invalid type of work. This error is likely caused by a bug in React. Please file an issue.');}}function unwindContexts(from,to){var node=from;while(node!==null){switch(node.tag){case ClassComponent:popContextProvider(node);break;case HostComponent:popHostContext(node);break;case HostRoot:popHostContainer(node);break;case HostPortal:popHostContainer(node);break;}if(node===to||node.alternate===to){stopFailedWorkTimer(node);break;}else{stopWorkTimer(node);}node=node['return'];}}function computeAsyncExpiration(){// Given the current clock time, returns an expiration time. We use rounding
// to batch like updates together.
// Should complete within ~1000ms. 1200ms max.
var currentTime=recalculateCurrentTime();var expirationMs=1000;var bucketSizeMs=200;return computeExpirationBucket(currentTime,expirationMs,bucketSizeMs);}function computeExpirationForFiber(fiber){var expirationTime=void 0;if(expirationContext!==NoWork){// An explicit expiration context was set;
expirationTime=expirationContext;}else if(isWorking){if(isCommitting){// Updates that occur during the commit phase should have sync priority
// by default.
expirationTime=Sync;}else{// Updates during the render phase should expire at the same time as
// the work that is being rendered.
expirationTime=nextRenderExpirationTime;}}else{// No explicit expiration context was set, and we're not currently
// performing work. Calculate a new expiration time.
if(useSyncScheduling&&!(fiber.internalContextTag&AsyncUpdates)){// This is a sync update
expirationTime=Sync;}else{// This is an async update
expirationTime=computeAsyncExpiration();}}return expirationTime;}function scheduleWork(fiber,expirationTime){return scheduleWorkImpl(fiber,expirationTime,false);}function scheduleWorkImpl(fiber,expirationTime,isErrorRecovery){recordScheduleUpdate();{if(!isErrorRecovery&&fiber.tag===ClassComponent){var instance=fiber.stateNode;warnAboutInvalidUpdates(instance);}}var node=fiber;while(node!==null){// Walk the parent path to the root and update each node's
// expiration time.
if(node.expirationTime===NoWork||node.expirationTime>expirationTime){node.expirationTime=expirationTime;}if(node.alternate!==null){if(node.alternate.expirationTime===NoWork||node.alternate.expirationTime>expirationTime){node.alternate.expirationTime=expirationTime;}}if(node['return']===null){if(node.tag===HostRoot){var root=node.stateNode;if(!isWorking&&root===nextRoot&&expirationTime<=nextRenderExpirationTime){// Restart the root from the top.
if(nextUnitOfWork!==null){// This is an interruption. (Used for performance tracking.)
interruptedBy=fiber;}nextRoot=null;nextUnitOfWork=null;nextRenderExpirationTime=NoWork;}requestWork(root,expirationTime);}else{{if(!isErrorRecovery&&fiber.tag===ClassComponent){warnAboutUpdateOnUnmounted(fiber);}}return;}}node=node['return'];}}function scheduleErrorRecovery(fiber){scheduleWorkImpl(fiber,Sync,true);}function recalculateCurrentTime(){// Subtract initial time so it fits inside 32bits
var ms=now()-startTime;mostRecentCurrentTime=msToExpirationTime(ms);return mostRecentCurrentTime;}function deferredUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=computeAsyncExpiration();try{return fn();}finally{expirationContext=previousExpirationContext;}}function syncUpdates(fn){var previousExpirationContext=expirationContext;expirationContext=Sync;try{return fn();}finally{expirationContext=previousExpirationContext;}}// TODO: Everything below this is written as if it has been lifted to the
// renderers. I'll do this in a follow-up.
// Linked-list of roots
var firstScheduledRoot=null;var lastScheduledRoot=null;var isCallbackScheduled=false;var isRendering=false;var nextFlushedRoot=null;var nextFlushedExpirationTime=NoWork;var deadlineDidExpire=false;var hasUnhandledError=false;var unhandledError=null;var deadline=null;var isBatchingUpdates=false;var isUnbatchingUpdates=false;// Use these to prevent an infinite loop of nested updates
var NESTED_UPDATE_LIMIT=1000;var nestedUpdateCount=0;var timeHeuristicForUnitOfWork=1;// requestWork is called by the scheduler whenever a root receives an update.
// It's up to the renderer to call renderRoot at some point in the future.
function requestWork(root,expirationTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT){invariant(false,'Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.');}// Add the root to the schedule.
// Check if this root is already part of the schedule.
if(root.nextScheduledRoot===null){// This root is not already scheduled. Add it.
root.remainingExpirationTime=expirationTime;if(lastScheduledRoot===null){firstScheduledRoot=lastScheduledRoot=root;root.nextScheduledRoot=root;}else{lastScheduledRoot.nextScheduledRoot=root;lastScheduledRoot=root;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;}}else{// This root is already scheduled, but its priority may have increased.
var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork||expirationTime<remainingExpirationTime){// Update the priority.
root.remainingExpirationTime=expirationTime;}}if(isRendering){// Prevent reentrancy. Remaining work will be scheduled at the end of
// the currently rendering batch.
return;}if(isBatchingUpdates){// Flush work at the end of the batch.
if(isUnbatchingUpdates){// ...unless we're inside unbatchedUpdates, in which case we should
// flush it now.
performWorkOnRoot(root,Sync);}return;}// TODO: Get rid of Sync and use current time?
if(expirationTime===Sync){performWork(Sync,null);}else if(!isCallbackScheduled){isCallbackScheduled=true;scheduleDeferredCallback(performAsyncWork);}}function findHighestPriorityRoot(){var highestPriorityWork=NoWork;var highestPriorityRoot=null;if(lastScheduledRoot!==null){var previousScheduledRoot=lastScheduledRoot;var root=firstScheduledRoot;while(root!==null){var remainingExpirationTime=root.remainingExpirationTime;if(remainingExpirationTime===NoWork){// This root no longer has work. Remove it from the scheduler.
// TODO: This check is redudant, but Flow is confused by the branch
// below where we set lastScheduledRoot to null, even though we break
// from the loop right after.
!(previousScheduledRoot!==null&&lastScheduledRoot!==null)?invariant(false,'Should have a previous and last root. This error is likely caused by a bug in React. Please file an issue.'):void 0;if(root===root.nextScheduledRoot){// This is the only root in the list.
root.nextScheduledRoot=null;firstScheduledRoot=lastScheduledRoot=null;break;}else if(root===firstScheduledRoot){// This is the first root in the list.
var next=root.nextScheduledRoot;firstScheduledRoot=next;lastScheduledRoot.nextScheduledRoot=next;root.nextScheduledRoot=null;}else if(root===lastScheduledRoot){// This is the last root in the list.
lastScheduledRoot=previousScheduledRoot;lastScheduledRoot.nextScheduledRoot=firstScheduledRoot;root.nextScheduledRoot=null;break;}else{previousScheduledRoot.nextScheduledRoot=root.nextScheduledRoot;root.nextScheduledRoot=null;}root=previousScheduledRoot.nextScheduledRoot;}else{if(highestPriorityWork===NoWork||remainingExpirationTime<highestPriorityWork){// Update the priority, if it's higher
highestPriorityWork=remainingExpirationTime;highestPriorityRoot=root;}if(root===lastScheduledRoot){break;}previousScheduledRoot=root;root=root.nextScheduledRoot;}}}// If the next root is the same as the previous root, this is a nested
// update. To prevent an infinite loop, increment the nested update count.
var previousFlushedRoot=nextFlushedRoot;if(previousFlushedRoot!==null&&previousFlushedRoot===highestPriorityRoot){nestedUpdateCount++;}else{// Reset whenever we switch roots.
nestedUpdateCount=0;}nextFlushedRoot=highestPriorityRoot;nextFlushedExpirationTime=highestPriorityWork;}function performAsyncWork(dl){performWork(NoWork,dl);}function performWork(minExpirationTime,dl){deadline=dl;// Keep working on roots until there's no more work, or until the we reach
// the deadlne.
findHighestPriorityRoot();while(nextFlushedRoot!==null&&nextFlushedExpirationTime!==NoWork&&(minExpirationTime===NoWork||nextFlushedExpirationTime<=minExpirationTime)&&!deadlineDidExpire){performWorkOnRoot(nextFlushedRoot,nextFlushedExpirationTime);// Find the next highest priority work.
findHighestPriorityRoot();}// We're done flushing work. Either we ran out of time in this callback,
// or there's no more work left with sufficient priority.
// If we're inside a callback, set this to false since we just completed it.
if(deadline!==null){isCallbackScheduled=false;}// If there's work left over, schedule a new callback.
if(nextFlushedRoot!==null&&!isCallbackScheduled){isCallbackScheduled=true;scheduleDeferredCallback(performAsyncWork);}// Clean-up.
deadline=null;deadlineDidExpire=false;nestedUpdateCount=0;if(hasUnhandledError){var _error4=unhandledError;unhandledError=null;hasUnhandledError=false;throw _error4;}}function performWorkOnRoot(root,expirationTime){!!isRendering?invariant(false,'performWorkOnRoot was called recursively. This error is likely caused by a bug in React. Please file an issue.'):void 0;isRendering=true;// Check if this is async work or sync/expired work.
// TODO: Pass current time as argument to renderRoot, commitRoot
if(expirationTime<=recalculateCurrentTime()){// Flush sync work.
var finishedWork=root.finishedWork;if(finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(finishedWork);}else{root.finishedWork=null;finishedWork=renderRoot(root,expirationTime);if(finishedWork!==null){// We've completed the root. Commit it.
root.remainingExpirationTime=commitRoot(finishedWork);}}}else{// Flush async work.
var _finishedWork=root.finishedWork;if(_finishedWork!==null){// This root is already complete. We can commit it.
root.finishedWork=null;root.remainingExpirationTime=commitRoot(_finishedWork);}else{root.finishedWork=null;_finishedWork=renderRoot(root,expirationTime);if(_finishedWork!==null){// We've completed the root. Check the deadline one more time
// before committing.
if(!shouldYield()){// Still time left. Commit the root.
root.remainingExpirationTime=commitRoot(_finishedWork);}else{// There's no time left. Mark this root as complete. We'll come
// back and commit it later.
root.finishedWork=_finishedWork;}}}}isRendering=false;}// When working on async work, the reconciler asks the renderer if it should
// yield execution. For DOM, we implement this with requestIdleCallback.
function shouldYield(){if(deadline===null){return false;}if(deadline.timeRemaining()>timeHeuristicForUnitOfWork){return false;}deadlineDidExpire=true;return true;}// TODO: Not happy about this hook. Conceptually, renderRoot should return a
// tuple of (isReadyForCommit, didError, error)
function onUncaughtError(error){!(nextFlushedRoot!==null)?invariant(false,'Should be working on a root. This error is likely caused by a bug in React. Please file an issue.'):void 0;// Unschedule this root so we don't work on it again until there's
// another update.
nextFlushedRoot.remainingExpirationTime=NoWork;if(!hasUnhandledError){hasUnhandledError=true;unhandledError=error;}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function batchedUpdates(fn,a){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return fn(a);}finally{isBatchingUpdates=previousIsBatchingUpdates;if(!isBatchingUpdates&&!isRendering){performWork(Sync,null);}}}// TODO: Batching should be implemented at the renderer level, not inside
// the reconciler.
function unbatchedUpdates(fn){if(isBatchingUpdates&&!isUnbatchingUpdates){isUnbatchingUpdates=true;try{return fn();}finally{isUnbatchingUpdates=false;}}return fn();}// TODO: Batching should be implemented at the renderer level, not within
// the reconciler.
function flushSync(fn){var previousIsBatchingUpdates=isBatchingUpdates;isBatchingUpdates=true;try{return syncUpdates(fn);}finally{isBatchingUpdates=previousIsBatchingUpdates;!!isRendering?invariant(false,'flushSync was called from inside a lifecycle method. It cannot be called when React is already rendering.'):void 0;performWork(Sync,null);}}return{computeAsyncExpiration:computeAsyncExpiration,computeExpirationForFiber:computeExpirationForFiber,scheduleWork:scheduleWork,batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,flushSync:flushSync,deferredUpdates:deferredUpdates};};{var didWarnAboutNestedUpdates=false;}// 0 is PROD, 1 is DEV.
// Might add PROFILE later.
function getContextForSubtree(parentComponent){if(!parentComponent){return emptyObject;}var fiber=get(parentComponent);var parentContext=findCurrentUnmaskedContext(fiber);return isContextProvider(fiber)?processChildContext(fiber,parentContext):parentContext;}var ReactFiberReconciler$1=function ReactFiberReconciler$1(config){var getPublicInstance=config.getPublicInstance;var _ReactFiberScheduler=ReactFiberScheduler(config),computeAsyncExpiration=_ReactFiberScheduler.computeAsyncExpiration,computeExpirationForFiber=_ReactFiberScheduler.computeExpirationForFiber,scheduleWork=_ReactFiberScheduler.scheduleWork,batchedUpdates=_ReactFiberScheduler.batchedUpdates,unbatchedUpdates=_ReactFiberScheduler.unbatchedUpdates,flushSync=_ReactFiberScheduler.flushSync,deferredUpdates=_ReactFiberScheduler.deferredUpdates;function scheduleTopLevelUpdate(current,element,callback){{if(ReactDebugCurrentFiber.phase==='render'&&ReactDebugCurrentFiber.current!==null&&!didWarnAboutNestedUpdates){didWarnAboutNestedUpdates=true;warning(false,'Render methods should be a pure function of props and state; '+'triggering nested component updates from render is not allowed. '+'If necessary, trigger nested updates in componentDidUpdate.\n\n'+'Check the render method of %s.',getComponentName(ReactDebugCurrentFiber.current)||'Unknown');}}callback=callback===undefined?null:callback;{warning(callback===null||typeof callback==='function','render(...): Expected the last optional `callback` argument to be a '+'function. Instead received: %s.',callback);}var expirationTime=void 0;// Check if the top-level element is an async wrapper component. If so,
// treat updates to the root as async. This is a bit weird but lets us
// avoid a separate `renderAsync` API.
if(enableAsyncSubtreeAPI&&element!=null&&element.type!=null&&element.type.prototype!=null&&element.type.prototype.unstable_isAsyncReactComponent===true){expirationTime=computeAsyncExpiration();}else{expirationTime=computeExpirationForFiber(current);}var update={expirationTime:expirationTime,partialState:{element:element},callback:callback,isReplace:false,isForced:false,nextCallback:null,next:null};insertUpdateIntoFiber(current,update);scheduleWork(current,expirationTime);}function findHostInstance(fiber){var hostFiber=findCurrentHostFiber(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;}return{createContainer:function createContainer(containerInfo,hydrate){return createFiberRoot(containerInfo,hydrate);},updateContainer:function updateContainer(element,container,parentComponent,callback){// TODO: If this is a nested container, this won't be the root.
var current=container.current;{if(ReactFiberInstrumentation_1.debugTool){if(current.alternate===null){ReactFiberInstrumentation_1.debugTool.onMountContainer(container);}else if(element===null){ReactFiberInstrumentation_1.debugTool.onUnmountContainer(container);}else{ReactFiberInstrumentation_1.debugTool.onUpdateContainer(container);}}}var context=getContextForSubtree(parentComponent);if(container.context===null){container.context=context;}else{container.pendingContext=context;}scheduleTopLevelUpdate(current,element,callback);},batchedUpdates:batchedUpdates,unbatchedUpdates:unbatchedUpdates,deferredUpdates:deferredUpdates,flushSync:flushSync,getPublicRootInstance:function getPublicRootInstance(container){var containerFiber=container.current;if(!containerFiber.child){return null;}switch(containerFiber.child.tag){case HostComponent:return getPublicInstance(containerFiber.child.stateNode);default:return containerFiber.child.stateNode;}},findHostInstance:findHostInstance,findHostInstanceWithNoPortals:function findHostInstanceWithNoPortals(fiber){var hostFiber=findCurrentHostFiberWithNoPortals(fiber);if(hostFiber===null){return null;}return hostFiber.stateNode;},injectIntoDevTools:function injectIntoDevTools(devToolsConfig){var _findFiberByHostInstance=devToolsConfig.findFiberByHostInstance;return injectInternals(_assign({},devToolsConfig,{findHostInstanceByFiber:function findHostInstanceByFiber(fiber){return findHostInstance(fiber);},findFiberByHostInstance:function findFiberByHostInstance(instance){if(!_findFiberByHostInstance){// Might not be implemented by the renderer.
return null;}return _findFiberByHostInstance(instance);}}));}};};var ReactFiberReconciler$2=Object.freeze({default:ReactFiberReconciler$1});var ReactFiberReconciler$3=ReactFiberReconciler$2&&ReactFiberReconciler$1||ReactFiberReconciler$2;// TODO: bundle Flow types with the package.
// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactReconciler=ReactFiberReconciler$3['default']?ReactFiberReconciler$3['default']:ReactFiberReconciler$3;// TODO: this is special because it gets imported during build.
var ReactVersion='16.1.0';// a requestAnimationFrame, storing the time for the start of the frame, then
// scheduling a postMessage which gets scheduled after paint. Within the
// postMessage handler do as much work as possible until time + frame rate.
// By separating the idle call into a separate event tick we ensure that
// layout, paint and other browser work is counted against the available time.
// The frame rate is dynamically adjusted.
{if(ExecutionEnvironment.canUseDOM&&typeof requestAnimationFrame!=='function'){warning(false,'React depends on requestAnimationFrame. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}var hasNativePerformanceNow=(typeof performance==='undefined'?'undefined':_typeof(performance))==='object'&&typeof performance.now==='function';var now=void 0;if(hasNativePerformanceNow){now=function now(){return performance.now();};}else{now=function now(){return Date.now();};}// TODO: There's no way to cancel, because Fiber doesn't atm.
var rIC=void 0;if(!ExecutionEnvironment.canUseDOM){rIC=function rIC(frameCallback){setTimeout(function(){frameCallback({timeRemaining:function timeRemaining(){return Infinity;}});});return 0;};}else if(typeof requestIdleCallback!=='function'){// Polyfill requestIdleCallback.
var scheduledRICCallback=null;var isIdleScheduled=false;var isAnimationFrameScheduled=false;var frameDeadline=0;// We start out assuming that we run at 30fps but then the heuristic tracking
// will adjust this value to a faster fps if we get more frequent animation
// frames.
var previousFrameTime=33;var activeFrameTime=33;var frameDeadlineObject;if(hasNativePerformanceNow){frameDeadlineObject={timeRemaining:function timeRemaining(){// We assume that if we have a performance timer that the rAF callback
// gets a performance timer value. Not sure if this is always true.
return frameDeadline-performance.now();}};}else{frameDeadlineObject={timeRemaining:function timeRemaining(){// Fallback to Date.now()
return frameDeadline-Date.now();}};}// We use the postMessage trick to defer idle work until after the repaint.
var messageKey='__reactIdleCallback$'+Math.random().toString(36).slice(2);var idleTick=function idleTick(event){if(event.source!==window||event.data!==messageKey){return;}isIdleScheduled=false;var callback=scheduledRICCallback;scheduledRICCallback=null;if(callback!==null){callback(frameDeadlineObject);}};// Assumes that we have addEventListener in this environment. Might need
// something better for old IE.
window.addEventListener('message',idleTick,false);var animationTick=function animationTick(rafTime){isAnimationFrameScheduled=false;var nextFrameTime=rafTime-frameDeadline+activeFrameTime;if(nextFrameTime<activeFrameTime&&previousFrameTime<activeFrameTime){if(nextFrameTime<8){// Defensive coding. We don't support higher frame rates than 120hz.
// If we get lower than that, it is probably a bug.
nextFrameTime=8;}// If one frame goes long, then the next one can be short to catch up.
// If two frames are short in a row, then that's an indication that we
// actually have a higher frame rate than what we're currently optimizing.
// We adjust our heuristic dynamically accordingly. For example, if we're
// running on 120hz display or 90hz VR display.
// Take the max of the two in case one of them was an anomaly due to
// missed frame deadlines.
activeFrameTime=nextFrameTime<previousFrameTime?previousFrameTime:nextFrameTime;}else{previousFrameTime=nextFrameTime;}frameDeadline=rafTime+activeFrameTime;if(!isIdleScheduled){isIdleScheduled=true;window.postMessage(messageKey,'*');}};rIC=function rIC(callback){// This assumes that we only schedule one callback at a time because that's
// how Fiber uses it.
scheduledRICCallback=callback;if(!isAnimationFrameScheduled){// If rAF didn't already schedule one, we need to schedule a frame.
// TODO: If this rAF doesn't materialize because the browser throttles, we
// might want to still have setTimeout trigger rIC as a backup to ensure
// that we keep performing work.
isAnimationFrameScheduled=true;requestAnimationFrame(animationTick);}return 0;};}else{rIC=requestIdleCallback;}/**
 * Forked from fbjs/warning:
 * https://github.com/facebook/fbjs/blob/e66ba20ad5be433eb54423f2b097d829324d9de6/packages/fbjs/src/__forks__/warning.js
 *
 * Only change is we use console.warn instead of console.error,
 * and do nothing when 'console' is not supported.
 * This really simplifies the code.
 * ---
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */var lowPriorityWarning=function lowPriorityWarning(){};{var printWarning=function printWarning(format){for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}var argIndex=0;var message='Warning: '+format.replace(/%s/g,function(){return args[argIndex++];});if(typeof console!=='undefined'){console.warn(message);}try{// --- Welcome to debugging React ---
// This error was thrown as a convenience so that you can use this stack
// to find the callsite that caused this warning to fire.
throw new Error(message);}catch(x){}};lowPriorityWarning=function lowPriorityWarning(condition,format){if(format===undefined){throw new Error('`warning(condition, format, ...args)` requires a warning '+'message argument');}if(!condition){for(var _len2=arguments.length,args=Array(_len2>2?_len2-2:0),_key2=2;_key2<_len2;_key2++){args[_key2-2]=arguments[_key2];}printWarning.apply(undefined,[format].concat(args));}};}var lowPriorityWarning$1=lowPriorityWarning;// isAttributeNameSafe() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
var VALID_ATTRIBUTE_NAME_REGEX=new RegExp('^['+ATTRIBUTE_NAME_START_CHAR+']['+ATTRIBUTE_NAME_CHAR+']*$');var illegalAttributeNameCache={};var validatedAttributeNameCache={};function isAttributeNameSafe(attributeName){if(validatedAttributeNameCache.hasOwnProperty(attributeName)){return true;}if(illegalAttributeNameCache.hasOwnProperty(attributeName)){return false;}if(VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)){validatedAttributeNameCache[attributeName]=true;return true;}illegalAttributeNameCache[attributeName]=true;{warning(false,'Invalid attribute name: `%s`',attributeName);}return false;}// shouldIgnoreValue() is currently duplicated in DOMMarkupOperations.
// TODO: Find a better place for this.
function shouldIgnoreValue(propertyInfo,value){return value==null||propertyInfo.hasBooleanValue&&!value||propertyInfo.hasNumericValue&&isNaN(value)||propertyInfo.hasPositiveNumericValue&&value<1||propertyInfo.hasOverloadedBooleanValue&&value===false;}/**
 * Operations for dealing with DOM properties.
 *//**
 * Get the value for a property on a node. Only used in DEV for SSR validation.
 * The "expected" argument is used as a hint of what the expected value is.
 * Some properties have multiple equivalent values.
 */function getValueForProperty(node,name,expected){{var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod||propertyInfo.mustUseProperty){return node[propertyInfo.propertyName];}else{var attributeName=propertyInfo.attributeName;var stringValue=null;if(propertyInfo.hasOverloadedBooleanValue){if(node.hasAttribute(attributeName)){var value=node.getAttribute(attributeName);if(value===''){return true;}if(shouldIgnoreValue(propertyInfo,expected)){return value;}if(value===''+expected){return expected;}return value;}}else if(node.hasAttribute(attributeName)){if(shouldIgnoreValue(propertyInfo,expected)){// We had an attribute but shouldn't have had one, so read it
// for the error message.
return node.getAttribute(attributeName);}if(propertyInfo.hasBooleanValue){// If this was a boolean, it doesn't matter what the value is
// the fact that we have it is the same as the expected.
return expected;}// Even if this property uses a namespace we use getAttribute
// because we assume its namespaced name is the same as our config.
// To use getAttributeNS we need the local name which we don't have
// in our config atm.
stringValue=node.getAttribute(attributeName);}if(shouldIgnoreValue(propertyInfo,expected)){return stringValue===null?expected:stringValue;}else if(stringValue===''+expected){return expected;}else{return stringValue;}}}}}/**
 * Get the value for a attribute on a node. Only used in DEV for SSR validation.
 * The third argument is used as a hint of what the expected value is. Some
 * attributes have multiple equivalent values.
 */function getValueForAttribute(node,name,expected){{if(!isAttributeNameSafe(name)){return;}if(!node.hasAttribute(name)){return expected===undefined?undefined:null;}var value=node.getAttribute(name);if(value===''+expected){return expected;}return value;}}/**
 * Sets the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 * @param {*} value
 */function setValueForProperty(node,name,value){var propertyInfo=getPropertyInfo(name);if(propertyInfo&&shouldSetAttribute(name,value)){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,value);}else if(shouldIgnoreValue(propertyInfo,value)){deleteValueForProperty(node,name);return;}else if(propertyInfo.mustUseProperty){// Contrary to `setAttribute`, object properties are properly
// `toString`ed by IE8/9.
node[propertyInfo.propertyName]=value;}else{var attributeName=propertyInfo.attributeName;var namespace=propertyInfo.attributeNamespace;// `setAttribute` with objects becomes only `[object]` in IE8/9,
// ('' + value) makes it output the correct toString()-value.
if(namespace){node.setAttributeNS(namespace,attributeName,''+value);}else if(propertyInfo.hasBooleanValue||propertyInfo.hasOverloadedBooleanValue&&value===true){node.setAttribute(attributeName,'');}else{node.setAttribute(attributeName,''+value);}}}else{setValueForAttribute(node,name,shouldSetAttribute(name,value)?value:null);return;}{}}function setValueForAttribute(node,name,value){if(!isAttributeNameSafe(name)){return;}if(value==null){node.removeAttribute(name);}else{node.setAttribute(name,''+value);}{}}/**
 * Deletes an attributes from a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForAttribute(node,name){node.removeAttribute(name);}/**
 * Deletes the value for a property on a node.
 *
 * @param {DOMElement} node
 * @param {string} name
 */function deleteValueForProperty(node,name){var propertyInfo=getPropertyInfo(name);if(propertyInfo){var mutationMethod=propertyInfo.mutationMethod;if(mutationMethod){mutationMethod(node,undefined);}else if(propertyInfo.mustUseProperty){var propName=propertyInfo.propertyName;if(propertyInfo.hasBooleanValue){node[propName]=false;}else{node[propName]='';}}else{node.removeAttribute(propertyInfo.attributeName);}}else{node.removeAttribute(name);}}var ReactControlledValuePropTypes={checkPropTypes:null};{var hasReadOnlyValue={button:true,checkbox:true,image:true,hidden:true,radio:true,reset:true,submit:true};var propTypes={value:function value(props,propName,componentName){if(!props[propName]||hasReadOnlyValue[props.type]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `value` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultValue`. Otherwise, '+'set either `onChange` or `readOnly`.');},checked:function checked(props,propName,componentName){if(!props[propName]||props.onChange||props.readOnly||props.disabled){return null;}return new Error('You provided a `checked` prop to a form field without an '+'`onChange` handler. This will render a read-only field. If '+'the field should be mutable use `defaultChecked`. Otherwise, '+'set either `onChange` or `readOnly`.');}};/**
   * Provide a linked `value` attribute for controlled forms. You should not use
   * this outside of the ReactDOM controlled form components.
   */ReactControlledValuePropTypes.checkPropTypes=function(tagName,props,getStack){checkPropTypes(propTypes,props,'prop',tagName,getStack);};}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$2=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$3=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValueDefaultValue=false;var didWarnCheckedDefaultChecked=false;var didWarnControlledToUncontrolled=false;var didWarnUncontrolledToControlled=false;function isControlled(props){var usesChecked=props.type==='checkbox'||props.type==='radio';return usesChecked?props.checked!=null:props.value!=null;}/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * See http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */function getHostProps(element,props){var node=element;var value=props.value;var checked=props.checked;var hostProps=_assign({// Make sure we set .type before any other properties (setting .value
// before .type means .value is lost in IE11 and below)
type:undefined,// Make sure we set .step before .value (setting .value before .step
// means .value is rounded on mount, based upon step precision)
step:undefined,// Make sure we set .min & .max before .value (to ensure proper order
// in corner cases such as min or max deriving from value, e.g. Issue #7170)
min:undefined,max:undefined},props,{defaultChecked:undefined,defaultValue:undefined,value:value!=null?value:node._wrapperState.initialValue,checked:checked!=null?checked:node._wrapperState.initialChecked});return hostProps;}function initWrapperState(element,props){{ReactControlledValuePropTypes.checkPropTypes('input',props,getCurrentFiberStackAddendum$3);if(props.checked!==undefined&&props.defaultChecked!==undefined&&!didWarnCheckedDefaultChecked){warning(false,'%s contains an input of type %s with both checked and defaultChecked props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the checked prop, or the defaultChecked prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnCheckedDefaultChecked=true;}if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue){warning(false,'%s contains an input of type %s with both value and defaultValue props. '+'Input elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled input '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components',getCurrentFiberOwnerName$2()||'A component',props.type);didWarnValueDefaultValue=true;}}var defaultValue=props.defaultValue;var node=element;node._wrapperState={initialChecked:props.checked!=null?props.checked:props.defaultChecked,initialValue:props.value!=null?props.value:defaultValue,controlled:isControlled(props)};}function updateWrapper(element,props){var node=element;{var controlled=isControlled(props);if(!node._wrapperState.controlled&&controlled&&!didWarnUncontrolledToControlled){warning(false,'A component is changing an uncontrolled input of type %s to be controlled. '+'Input elements should not switch from uncontrolled to controlled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnUncontrolledToControlled=true;}if(node._wrapperState.controlled&&!controlled&&!didWarnControlledToUncontrolled){warning(false,'A component is changing a controlled input of type %s to be uncontrolled. '+'Input elements should not switch from controlled to uncontrolled (or vice versa). '+'Decide between using a controlled or uncontrolled input '+'element for the lifetime of the component. More info: https://fb.me/react-controlled-components%s',props.type,getCurrentFiberStackAddendum$3());didWarnControlledToUncontrolled=true;}}var checked=props.checked;if(checked!=null){setValueForProperty(node,'checked',checked||false);}var value=props.value;if(value!=null){if(value===0&&node.value===''){node.value='0';// Note: IE9 reports a number inputs as 'text', so check props instead.
}else if(props.type==='number'){// Simulate `input.valueAsNumber`. IE9 does not support it
var valueAsNumber=parseFloat(node.value)||0;if(// eslint-disable-next-line
value!=valueAsNumber||// eslint-disable-next-line
value==valueAsNumber&&node.value!=value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else if(node.value!==''+value){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
node.value=''+value;}}else{if(props.value==null&&props.defaultValue!=null){// In Chrome, assigning defaultValue to certain input types triggers input validation.
// For number inputs, the display value loses trailing decimal points. For email inputs,
// Chrome raises "The specified value <x> is not a valid email address".
//
// Here we check to see if the defaultValue has actually changed, avoiding these problems
// when the user is inputting text
//
// https://github.com/facebook/react/issues/7253
if(node.defaultValue!==''+props.defaultValue){node.defaultValue=''+props.defaultValue;}}if(props.checked==null&&props.defaultChecked!=null){node.defaultChecked=!!props.defaultChecked;}}}function postMountWrapper(element,props){var node=element;// Detach value from defaultValue. We won't do anything if we're working on
// submit or reset inputs as those values & defaultValues are linked. They
// are not resetable nodes so this operation doesn't matter and actually
// removes browser-default values (eg "Submit Query") when no value is
// provided.
switch(props.type){case'submit':case'reset':break;case'color':case'date':case'datetime':case'datetime-local':case'month':case'time':case'week':// This fixes the no-show issue on iOS Safari and Android Chrome:
// https://github.com/facebook/react/issues/7233
node.value='';node.value=node.defaultValue;break;default:node.value=node.value;break;}// Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
// this is needed to work around a chrome bug where setting defaultChecked
// will sometimes influence the value of checked (even after detachment).
// Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
// We need to temporarily unset name to avoid disrupting radio button groups.
var name=node.name;if(name!==''){node.name='';}node.defaultChecked=!node.defaultChecked;node.defaultChecked=!node.defaultChecked;if(name!==''){node.name=name;}}function restoreControlledState$1(element,props){var node=element;updateWrapper(node,props);updateNamedCousins(node,props);}function updateNamedCousins(rootNode,props){var name=props.name;if(props.type==='radio'&&name!=null){var queryRoot=rootNode;while(queryRoot.parentNode){queryRoot=queryRoot.parentNode;}// If `rootNode.form` was non-null, then we could try `form.elements`,
// but that sometimes behaves strangely in IE8. We could also try using
// `form.getElementsByName`, but that will only return direct children
// and won't include inputs that use the HTML5 `form=` attribute. Since
// the input might not even be in a form. It might not even be in the
// document. Let's just use the local `querySelectorAll` to ensure we don't
// miss anything.
var group=queryRoot.querySelectorAll('input[name='+JSON.stringify(''+name)+'][type="radio"]');for(var i=0;i<group.length;i++){var otherNode=group[i];if(otherNode===rootNode||otherNode.form!==rootNode.form){continue;}// This will throw if radio buttons rendered by different copies of React
// and the same name are rendered into the same form (same as #1939).
// That's probably okay; we don't support it just as we don't support
// mixing React radio buttons with non-React ones.
var otherProps=getFiberCurrentPropsFromNode$1(otherNode);!otherProps?invariant(false,'ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.'):void 0;// If this is a controlled radio button group, forcing the input that
// was previously checked to update will cause it to be come re-checked
// as appropriate.
updateWrapper(otherNode,otherProps);}}}function flattenChildren(children){var content='';// Flatten children and warn if they aren't strings or numbers;
// invalid types are ignored.
// We can silently skip them because invalid DOM nesting warning
// catches these cases in Fiber.
React.Children.forEach(children,function(child){if(child==null){return;}if(typeof child==='string'||typeof child==='number'){content+=child;}});return content;}/**
 * Implements an <option> host component that warns when `selected` is set.
 */function validateProps(element,props){// TODO (yungsters): Remove support for `selected` in <option>.
{warning(props.selected==null,'Use the `defaultValue` or `value` props on <select> instead of '+'setting `selected` on <option>.');}}function postMountWrapper$1(element,props){// value="" should make a value attribute (#6219)
if(props.value!=null){element.setAttribute('value',props.value);}}function getHostProps$1(element,props){var hostProps=_assign({children:undefined},props);var content=flattenChildren(props.children);if(content){hostProps.children=content;}return hostProps;}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$3=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$4=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;{var didWarnValueDefaultValue$1=false;}function getDeclarationErrorAddendum(){var ownerName=getCurrentFiberOwnerName$3();if(ownerName){return'\n\nCheck the render method of `'+ownerName+'`.';}return'';}var valuePropNames=['value','defaultValue'];/**
 * Validation function for `value` and `defaultValue`.
 */function checkSelectPropTypes(props){ReactControlledValuePropTypes.checkPropTypes('select',props,getCurrentFiberStackAddendum$4);for(var i=0;i<valuePropNames.length;i++){var propName=valuePropNames[i];if(props[propName]==null){continue;}var isArray=Array.isArray(props[propName]);if(props.multiple&&!isArray){warning(false,'The `%s` prop supplied to <select> must be an array if '+'`multiple` is true.%s',propName,getDeclarationErrorAddendum());}else if(!props.multiple&&isArray){warning(false,'The `%s` prop supplied to <select> must be a scalar '+'value if `multiple` is false.%s',propName,getDeclarationErrorAddendum());}}}function updateOptions(node,multiple,propValue,setDefaultSelected){var options=node.options;if(multiple){var selectedValues=propValue;var selectedValue={};for(var i=0;i<selectedValues.length;i++){// Prefix to avoid chaos with special keys.
selectedValue['$'+selectedValues[i]]=true;}for(var _i=0;_i<options.length;_i++){var selected=selectedValue.hasOwnProperty('$'+options[_i].value);if(options[_i].selected!==selected){options[_i].selected=selected;}if(selected&&setDefaultSelected){options[_i].defaultSelected=true;}}}else{// Do not set `select.value` as exact behavior isn't consistent across all
// browsers for all cases.
var _selectedValue=''+propValue;var defaultSelected=null;for(var _i2=0;_i2<options.length;_i2++){if(options[_i2].value===_selectedValue){options[_i2].selected=true;if(setDefaultSelected){options[_i2].defaultSelected=true;}return;}if(defaultSelected===null&&!options[_i2].disabled){defaultSelected=options[_i2];}}if(defaultSelected!==null){defaultSelected.selected=true;}}}/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */function getHostProps$2(element,props){return _assign({},props,{value:undefined});}function initWrapperState$1(element,props){var node=element;{checkSelectPropTypes(props);}var value=props.value;node._wrapperState={initialValue:value!=null?value:props.defaultValue,wasMultiple:!!props.multiple};{if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValueDefaultValue$1){warning(false,'Select elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled select '+'element and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValueDefaultValue$1=true;}}}function postMountWrapper$2(element,props){var node=element;node.multiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}}function postUpdateWrapper(element,props){var node=element;// After the initial mount, we control selected-ness manually so don't pass
// this value down
node._wrapperState.initialValue=undefined;var wasMultiple=node._wrapperState.wasMultiple;node._wrapperState.wasMultiple=!!props.multiple;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}else if(wasMultiple!==!!props.multiple){// For simplicity, reapply `defaultValue` if `multiple` is toggled.
if(props.defaultValue!=null){updateOptions(node,!!props.multiple,props.defaultValue,true);}else{// Revert the select back to its default unselected state.
updateOptions(node,!!props.multiple,props.multiple?[]:'',false);}}}function restoreControlledState$2(element,props){var node=element;var value=props.value;if(value!=null){updateOptions(node,!!props.multiple,value,false);}}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$5=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnValDefaultVal=false;/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */function getHostProps$3(element,props){var node=element;!(props.dangerouslySetInnerHTML==null)?invariant(false,'`dangerouslySetInnerHTML` does not make sense on <textarea>.'):void 0;// Always set children to the same thing. In IE9, the selection range will
// get reset if `textContent` is mutated.  We could add a check in setTextContent
// to only set the value if/when the value differs from the node value (which would
// completely solve this IE9 bug), but Sebastian+Sophie seemed to like this
// solution. The value can be a boolean or object so that's why it's forced
// to be a string.
var hostProps=_assign({},props,{value:undefined,defaultValue:undefined,children:''+node._wrapperState.initialValue});return hostProps;}function initWrapperState$2(element,props){var node=element;{ReactControlledValuePropTypes.checkPropTypes('textarea',props,getCurrentFiberStackAddendum$5);if(props.value!==undefined&&props.defaultValue!==undefined&&!didWarnValDefaultVal){warning(false,'Textarea elements must be either controlled or uncontrolled '+'(specify either the value prop, or the defaultValue prop, but not '+'both). Decide between using a controlled or uncontrolled textarea '+'and remove one of these props. More info: '+'https://fb.me/react-controlled-components');didWarnValDefaultVal=true;}}var value=props.value;var initialValue=value;// Only bother fetching default value if we're going to use it
if(value==null){var defaultValue=props.defaultValue;// TODO (yungsters): Remove support for children content in <textarea>.
var children=props.children;if(children!=null){{warning(false,'Use the `defaultValue` or `value` props instead of setting '+'children on <textarea>.');}!(defaultValue==null)?invariant(false,'If you supply `defaultValue` on a <textarea>, do not pass children.'):void 0;if(Array.isArray(children)){!(children.length<=1)?invariant(false,'<textarea> can only have at most one child.'):void 0;children=children[0];}defaultValue=''+children;}if(defaultValue==null){defaultValue='';}initialValue=defaultValue;}node._wrapperState={initialValue:''+initialValue};}function updateWrapper$1(element,props){var node=element;var value=props.value;if(value!=null){// Cast `value` to a string to ensure the value is set correctly. While
// browsers typically do this as necessary, jsdom doesn't.
var newValue=''+value;// To avoid side effects (such as losing text selection), only set value if changed
if(newValue!==node.value){node.value=newValue;}if(props.defaultValue==null){node.defaultValue=newValue;}}if(props.defaultValue!=null){node.defaultValue=props.defaultValue;}}function postMountWrapper$3(element,props){var node=element;// This is in postMount because we need access to the DOM node, which is not
// available until after the component has mounted.
var textContent=node.textContent;// Only set node.value if textContent is equal to the expected
// initial value. In IE10/IE11 there is a bug where the placeholder attribute
// will populate textContent as well.
// https://developer.microsoft.com/microsoft-edge/platform/issues/101525/
if(textContent===node._wrapperState.initialValue){node.value=textContent;}}function restoreControlledState$3(element,props){// DOM component is still mounted; update
updateWrapper$1(element,props);}var HTML_NAMESPACE$1='http://www.w3.org/1999/xhtml';var MATH_NAMESPACE='http://www.w3.org/1998/Math/MathML';var SVG_NAMESPACE='http://www.w3.org/2000/svg';var Namespaces={html:HTML_NAMESPACE$1,mathml:MATH_NAMESPACE,svg:SVG_NAMESPACE};// Assumes there is no parent namespace.
function getIntrinsicNamespace(type){switch(type){case'svg':return SVG_NAMESPACE;case'math':return MATH_NAMESPACE;default:return HTML_NAMESPACE$1;}}function getChildNamespace(parentNamespace,type){if(parentNamespace==null||parentNamespace===HTML_NAMESPACE$1){// No (or default) parent namespace: potential entry point.
return getIntrinsicNamespace(type);}if(parentNamespace===SVG_NAMESPACE&&type==='foreignObject'){// We're leaving SVG.
return HTML_NAMESPACE$1;}// By default, pass namespace below.
return parentNamespace;}/* globals MSApp *//**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */var createMicrosoftUnsafeLocalFunction=function createMicrosoftUnsafeLocalFunction(func){if(typeof MSApp!=='undefined'&&MSApp.execUnsafeLocalFunction){return function(arg0,arg1,arg2,arg3){MSApp.execUnsafeLocalFunction(function(){return func(arg0,arg1,arg2,arg3);});};}else{return func;}};// SVG temp container for IE lacking innerHTML
var reusableSVGContainer=void 0;/**
 * Set the innerHTML property of a node
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */var setInnerHTML=createMicrosoftUnsafeLocalFunction(function(node,html){// IE does not have innerHTML for SVG nodes, so instead we inject the
// new markup in a temp node and then move the child nodes across into
// the target node
if(node.namespaceURI===Namespaces.svg&&!('innerHTML'in node)){reusableSVGContainer=reusableSVGContainer||document.createElement('div');reusableSVGContainer.innerHTML='<svg>'+html+'</svg>';var svgNode=reusableSVGContainer.firstChild;while(node.firstChild){node.removeChild(node.firstChild);}while(svgNode.firstChild){node.appendChild(svgNode.firstChild);}}else{node.innerHTML=html;}});// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */var matchHtmlRegExp=/["'&<>]/;/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */function escapeHtml(string){var str=''+string;var match=matchHtmlRegExp.exec(str);if(!match){return str;}var escape;var html='';var index=0;var lastIndex=0;for(index=match.index;index<str.length;index++){switch(str.charCodeAt(index)){case 34:// "
escape='&quot;';break;case 38:// &
escape='&amp;';break;case 39:// '
escape='&#x27;';// modified from escape-html; used to be '&#39'
break;case 60:// <
escape='&lt;';break;case 62:// >
escape='&gt;';break;default:continue;}if(lastIndex!==index){html+=str.substring(lastIndex,index);}lastIndex=index+1;html+=escape;}return lastIndex!==index?html+str.substring(lastIndex,index):html;}// end code copied and modified from escape-html
/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */function escapeTextContentForBrowser(text){if(typeof text==='boolean'||typeof text==='number'){// this shortcircuit helps perf for types that we know will never have
// special characters, especially given that this function is used often
// for numeric dom ids.
return''+text;}return escapeHtml(text);}/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */var setTextContent=function setTextContent(node,text){if(text){var firstChild=node.firstChild;if(firstChild&&firstChild===node.lastChild&&firstChild.nodeType===TEXT_NODE){firstChild.nodeValue=text;return;}}node.textContent=text;};if(ExecutionEnvironment.canUseDOM){if(!('textContent'in document.documentElement)){setTextContent=function setTextContent(node,text){if(node.nodeType===TEXT_NODE){node.nodeValue=text;return;}setInnerHTML(node,escapeTextContentForBrowser(text));};}}var setTextContent$1=setTextContent;/**
 * CSS properties which accept numbers but are not in units of "px".
 */var isUnitlessNumber={animationIterationCount:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,zoom:true,// SVG-related properties
fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true};/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */function prefixKey(prefix,key){return prefix+key.charAt(0).toUpperCase()+key.substring(1);}/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */var prefixes=['Webkit','ms','Moz','O'];// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function(prop){prefixes.forEach(function(prefix){isUnitlessNumber[prefixKey(prefix,prop)]=isUnitlessNumber[prop];});});/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @return {string} Normalized style value with dimensions applied.
 */function dangerousStyleValue(name,value,isCustomProperty){// Note that we've removed escapeTextForBrowser() calls here since the
// whole string will be escaped when the attribute is injected into
// the markup. If you provide unsafe user data here they can inject
// arbitrary CSS which may be problematic (I couldn't repro this):
// https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
// http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
// This is not an XSS hole but instead a potential CSS injection issue
// which has lead to a greater discussion about how we're going to
// trust URLs moving forward. See #2115901
var isEmpty=value==null||typeof value==='boolean'||value==='';if(isEmpty){return'';}if(!isCustomProperty&&typeof value==='number'&&value!==0&&!(isUnitlessNumber.hasOwnProperty(name)&&isUnitlessNumber[name])){return value+'px';// Presumes implicit 'px' suffix for unitless numbers
}return(''+value).trim();}var warnValidStyle=emptyFunction$1;{// 'msTransform' is correct, but the other prefixes should be capitalized
var badVendoredStyleNamePattern=/^(?:webkit|moz|o)[A-Z]/;// style values shouldn't contain a semicolon
var badStyleValueWithSemicolonPattern=/;\s*$/;var warnedStyleNames={};var warnedStyleValues={};var warnedForNaNValue=false;var warnedForInfinityValue=false;var warnHyphenatedStyleName=function warnHyphenatedStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported style property %s. Did you mean %s?%s',name,camelizeStyleName(name),getStack());};var warnBadVendoredStyleName=function warnBadVendoredStyleName(name,getStack){if(warnedStyleNames.hasOwnProperty(name)&&warnedStyleNames[name]){return;}warnedStyleNames[name]=true;warning(false,'Unsupported vendor-prefixed style property %s. Did you mean %s?%s',name,name.charAt(0).toUpperCase()+name.slice(1),getStack());};var warnStyleValueWithSemicolon=function warnStyleValueWithSemicolon(name,value,getStack){if(warnedStyleValues.hasOwnProperty(value)&&warnedStyleValues[value]){return;}warnedStyleValues[value]=true;warning(false,"Style property values shouldn't contain a semicolon. "+'Try "%s: %s" instead.%s',name,value.replace(badStyleValueWithSemicolonPattern,''),getStack());};var warnStyleValueIsNaN=function warnStyleValueIsNaN(name,value,getStack){if(warnedForNaNValue){return;}warnedForNaNValue=true;warning(false,'`NaN` is an invalid value for the `%s` css style property.%s',name,getStack());};var warnStyleValueIsInfinity=function warnStyleValueIsInfinity(name,value,getStack){if(warnedForInfinityValue){return;}warnedForInfinityValue=true;warning(false,'`Infinity` is an invalid value for the `%s` css style property.%s',name,getStack());};warnValidStyle=function warnValidStyle(name,value,getStack){if(name.indexOf('-')>-1){warnHyphenatedStyleName(name,getStack);}else if(badVendoredStyleNamePattern.test(name)){warnBadVendoredStyleName(name,getStack);}else if(badStyleValueWithSemicolonPattern.test(value)){warnStyleValueWithSemicolon(name,value,getStack);}if(typeof value==='number'){if(isNaN(value)){warnStyleValueIsNaN(name,value,getStack);}else if(!isFinite(value)){warnStyleValueIsInfinity(name,value,getStack);}}};}var warnValidStyle$1=warnValidStyle;/**
 * Operations for dealing with CSS properties.
 *//**
 * This creates a string that is expected to be equivalent to the style
 * attribute generated by server-side rendering. It by-passes warnings and
 * security checks so it's not safe to use this value for anything other than
 * comparison. It is only used in DEV for SSR validation.
 */function createDangerousStringForStyles(styles){{var serialized='';var delimiter='';for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var styleValue=styles[styleName];if(styleValue!=null){var isCustomProperty=styleName.indexOf('--')===0;serialized+=delimiter+hyphenateStyleName(styleName)+':';serialized+=dangerousStyleValue(styleName,styleValue,isCustomProperty);delimiter=';';}}return serialized||null;}}/**
 * Sets the value for multiple styles on a node.  If a value is specified as
 * '' (empty string), the corresponding style property will be unset.
 *
 * @param {DOMElement} node
 * @param {object} styles
 */function setValueForStyles(node,styles,getStack){var style=node.style;for(var styleName in styles){if(!styles.hasOwnProperty(styleName)){continue;}var isCustomProperty=styleName.indexOf('--')===0;{if(!isCustomProperty){warnValidStyle$1(styleName,styles[styleName],getStack);}}var styleValue=dangerousStyleValue(styleName,styles[styleName],isCustomProperty);if(styleName==='float'){styleName='cssFloat';}if(isCustomProperty){style.setProperty(styleName,styleValue);}else{style[styleName]=styleValue;}}}// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.
var omittedCloseTags={area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true};// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.
var voidElementTags=_assign({menuitem:true},omittedCloseTags);var HTML$1='__html';function assertValidProps(tag,props,getStack){if(!props){return;}// Note the use of `==` which checks for null or undefined.
if(voidElementTags[tag]){!(props.children==null&&props.dangerouslySetInnerHTML==null)?invariant(false,'%s is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.%s',tag,getStack()):void 0;}if(props.dangerouslySetInnerHTML!=null){!(props.children==null)?invariant(false,'Can only set one of `children` or `props.dangerouslySetInnerHTML`.'):void 0;!(_typeof(props.dangerouslySetInnerHTML)==='object'&&HTML$1 in props.dangerouslySetInnerHTML)?invariant(false,'`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://fb.me/react-invariant-dangerously-set-inner-html for more information.'):void 0;}{warning(props.suppressContentEditableWarning||!props.contentEditable||props.children==null,'A component is `contentEditable` and contains `children` managed by '+'React. It is now your responsibility to guarantee that none of '+'those nodes are unexpectedly modified or duplicated. This is '+'probably not intentional.%s',getStack());}!(props.style==null||_typeof(props.style)==='object')?invariant(false,'The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + \'em\'}} when using JSX.%s',getStack()):void 0;}function isCustomComponent(tagName,props){if(tagName.indexOf('-')===-1){return typeof props.is==='string';}switch(tagName){// These are reserved SVG and MathML elements.
// We don't mind this whitelist too much because we expect it to never grow.
// The alternative is to track the namespace in a few places which is convoluted.
// https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
case'annotation-xml':case'color-profile':case'font-face':case'font-face-src':case'font-face-uri':case'font-face-format':case'font-face-name':case'missing-glyph':return false;default:return true;}}var ariaProperties={'aria-current':0,// state
'aria-details':0,'aria-disabled':0,// state
'aria-hidden':0,// state
'aria-invalid':0,// state
'aria-keyshortcuts':0,'aria-label':0,'aria-roledescription':0,// Widget Attributes
'aria-autocomplete':0,'aria-checked':0,'aria-expanded':0,'aria-haspopup':0,'aria-level':0,'aria-modal':0,'aria-multiline':0,'aria-multiselectable':0,'aria-orientation':0,'aria-placeholder':0,'aria-pressed':0,'aria-readonly':0,'aria-required':0,'aria-selected':0,'aria-sort':0,'aria-valuemax':0,'aria-valuemin':0,'aria-valuenow':0,'aria-valuetext':0,// Live Region Attributes
'aria-atomic':0,'aria-busy':0,'aria-live':0,'aria-relevant':0,// Drag-and-Drop Attributes
'aria-dropeffect':0,'aria-grabbed':0,// Relationship Attributes
'aria-activedescendant':0,'aria-colcount':0,'aria-colindex':0,'aria-colspan':0,'aria-controls':0,'aria-describedby':0,'aria-errormessage':0,'aria-flowto':0,'aria-labelledby':0,'aria-owns':0,'aria-posinset':0,'aria-rowcount':0,'aria-rowindex':0,'aria-rowspan':0,'aria-setsize':0};var warnedProperties={};var rARIA=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var hasOwnProperty=Object.prototype.hasOwnProperty;function getStackAddendum(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperty(tagName,name){if(hasOwnProperty.call(warnedProperties,name)&&warnedProperties[name]){return true;}if(rARIACamel.test(name)){var ariaName='aria-'+name.slice(4).toLowerCase();var correctName=ariaProperties.hasOwnProperty(ariaName)?ariaName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(correctName==null){warning(false,'Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.%s',name,getStackAddendum());warnedProperties[name]=true;return true;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==correctName){warning(false,'Invalid ARIA attribute `%s`. Did you mean `%s`?%s',name,correctName,getStackAddendum());warnedProperties[name]=true;return true;}}if(rARIA.test(name)){var lowerCasedName=name.toLowerCase();var standardName=ariaProperties.hasOwnProperty(lowerCasedName)?lowerCasedName:null;// If this is an aria-* attribute, but is not listed in the known DOM
// DOM properties, then it is an invalid aria-* attribute.
if(standardName==null){warnedProperties[name]=true;return false;}// aria-* attributes should be lowercase; suggest the lowercase version.
if(name!==standardName){warning(false,'Unknown ARIA attribute `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum());warnedProperties[name]=true;return true;}}return true;}function warnInvalidARIAProps(type,props){var invalidProps=[];for(var key in props){var isValid=validateProperty(type,key);if(!isValid){invalidProps.push(key);}}var unknownPropString=invalidProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(invalidProps.length===1){warning(false,'Invalid aria prop %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}else if(invalidProps.length>1){warning(false,'Invalid aria props %s on <%s> tag. '+'For details, see https://fb.me/invalid-aria-prop%s',unknownPropString,type,getStackAddendum());}}function validateProperties(type,props){if(isCustomComponent(type,props)){return;}warnInvalidARIAProps(type,props);}var didWarnValueNull=false;function getStackAddendum$1(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}function validateProperties$1(type,props){if(type!=='input'&&type!=='textarea'&&type!=='select'){return;}if(props!=null&&props.value===null&&!didWarnValueNull){didWarnValueNull=true;if(type==='select'&&props.multiple){warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty array when `multiple` is set to `true` '+'to clear the component or `undefined` for uncontrolled components.%s',type,getStackAddendum$1());}else{warning(false,'`value` prop on `%s` should not be null. '+'Consider using an empty string to clear the component or `undefined` '+'for uncontrolled components.%s',type,getStackAddendum$1());}}}// When adding attributes to the HTML or SVG whitelist, be sure to
// also add them to this module to ensure casing and incorrect name
// warnings.
var possibleStandardNames={// HTML
accept:'accept',acceptcharset:'acceptCharset','accept-charset':'acceptCharset',accesskey:'accessKey',action:'action',allowfullscreen:'allowFullScreen',alt:'alt',as:'as',async:'async',autocapitalize:'autoCapitalize',autocomplete:'autoComplete',autocorrect:'autoCorrect',autofocus:'autoFocus',autoplay:'autoPlay',autosave:'autoSave',capture:'capture',cellpadding:'cellPadding',cellspacing:'cellSpacing',challenge:'challenge',charset:'charSet',checked:'checked',children:'children',cite:'cite','class':'className',classid:'classID',classname:'className',cols:'cols',colspan:'colSpan',content:'content',contenteditable:'contentEditable',contextmenu:'contextMenu',controls:'controls',controlslist:'controlsList',coords:'coords',crossorigin:'crossOrigin',dangerouslysetinnerhtml:'dangerouslySetInnerHTML',data:'data',datetime:'dateTime','default':'default',defaultchecked:'defaultChecked',defaultvalue:'defaultValue',defer:'defer',dir:'dir',disabled:'disabled',download:'download',draggable:'draggable',enctype:'encType','for':'htmlFor',form:'form',formmethod:'formMethod',formaction:'formAction',formenctype:'formEncType',formnovalidate:'formNoValidate',formtarget:'formTarget',frameborder:'frameBorder',headers:'headers',height:'height',hidden:'hidden',high:'high',href:'href',hreflang:'hrefLang',htmlfor:'htmlFor',httpequiv:'httpEquiv','http-equiv':'httpEquiv',icon:'icon',id:'id',innerhtml:'innerHTML',inputmode:'inputMode',integrity:'integrity',is:'is',itemid:'itemID',itemprop:'itemProp',itemref:'itemRef',itemscope:'itemScope',itemtype:'itemType',keyparams:'keyParams',keytype:'keyType',kind:'kind',label:'label',lang:'lang',list:'list',loop:'loop',low:'low',manifest:'manifest',marginwidth:'marginWidth',marginheight:'marginHeight',max:'max',maxlength:'maxLength',media:'media',mediagroup:'mediaGroup',method:'method',min:'min',minlength:'minLength',multiple:'multiple',muted:'muted',name:'name',nonce:'nonce',novalidate:'noValidate',open:'open',optimum:'optimum',pattern:'pattern',placeholder:'placeholder',playsinline:'playsInline',poster:'poster',preload:'preload',profile:'profile',radiogroup:'radioGroup',readonly:'readOnly',referrerpolicy:'referrerPolicy',rel:'rel',required:'required',reversed:'reversed',role:'role',rows:'rows',rowspan:'rowSpan',sandbox:'sandbox',scope:'scope',scoped:'scoped',scrolling:'scrolling',seamless:'seamless',selected:'selected',shape:'shape',size:'size',sizes:'sizes',span:'span',spellcheck:'spellCheck',src:'src',srcdoc:'srcDoc',srclang:'srcLang',srcset:'srcSet',start:'start',step:'step',style:'style',summary:'summary',tabindex:'tabIndex',target:'target',title:'title',type:'type',usemap:'useMap',value:'value',width:'width',wmode:'wmode',wrap:'wrap',// SVG
about:'about',accentheight:'accentHeight','accent-height':'accentHeight',accumulate:'accumulate',additive:'additive',alignmentbaseline:'alignmentBaseline','alignment-baseline':'alignmentBaseline',allowreorder:'allowReorder',alphabetic:'alphabetic',amplitude:'amplitude',arabicform:'arabicForm','arabic-form':'arabicForm',ascent:'ascent',attributename:'attributeName',attributetype:'attributeType',autoreverse:'autoReverse',azimuth:'azimuth',basefrequency:'baseFrequency',baselineshift:'baselineShift','baseline-shift':'baselineShift',baseprofile:'baseProfile',bbox:'bbox',begin:'begin',bias:'bias',by:'by',calcmode:'calcMode',capheight:'capHeight','cap-height':'capHeight',clip:'clip',clippath:'clipPath','clip-path':'clipPath',clippathunits:'clipPathUnits',cliprule:'clipRule','clip-rule':'clipRule',color:'color',colorinterpolation:'colorInterpolation','color-interpolation':'colorInterpolation',colorinterpolationfilters:'colorInterpolationFilters','color-interpolation-filters':'colorInterpolationFilters',colorprofile:'colorProfile','color-profile':'colorProfile',colorrendering:'colorRendering','color-rendering':'colorRendering',contentscripttype:'contentScriptType',contentstyletype:'contentStyleType',cursor:'cursor',cx:'cx',cy:'cy',d:'d',datatype:'datatype',decelerate:'decelerate',descent:'descent',diffuseconstant:'diffuseConstant',direction:'direction',display:'display',divisor:'divisor',dominantbaseline:'dominantBaseline','dominant-baseline':'dominantBaseline',dur:'dur',dx:'dx',dy:'dy',edgemode:'edgeMode',elevation:'elevation',enablebackground:'enableBackground','enable-background':'enableBackground',end:'end',exponent:'exponent',externalresourcesrequired:'externalResourcesRequired',fill:'fill',fillopacity:'fillOpacity','fill-opacity':'fillOpacity',fillrule:'fillRule','fill-rule':'fillRule',filter:'filter',filterres:'filterRes',filterunits:'filterUnits',floodopacity:'floodOpacity','flood-opacity':'floodOpacity',floodcolor:'floodColor','flood-color':'floodColor',focusable:'focusable',fontfamily:'fontFamily','font-family':'fontFamily',fontsize:'fontSize','font-size':'fontSize',fontsizeadjust:'fontSizeAdjust','font-size-adjust':'fontSizeAdjust',fontstretch:'fontStretch','font-stretch':'fontStretch',fontstyle:'fontStyle','font-style':'fontStyle',fontvariant:'fontVariant','font-variant':'fontVariant',fontweight:'fontWeight','font-weight':'fontWeight',format:'format',from:'from',fx:'fx',fy:'fy',g1:'g1',g2:'g2',glyphname:'glyphName','glyph-name':'glyphName',glyphorientationhorizontal:'glyphOrientationHorizontal','glyph-orientation-horizontal':'glyphOrientationHorizontal',glyphorientationvertical:'glyphOrientationVertical','glyph-orientation-vertical':'glyphOrientationVertical',glyphref:'glyphRef',gradienttransform:'gradientTransform',gradientunits:'gradientUnits',hanging:'hanging',horizadvx:'horizAdvX','horiz-adv-x':'horizAdvX',horizoriginx:'horizOriginX','horiz-origin-x':'horizOriginX',ideographic:'ideographic',imagerendering:'imageRendering','image-rendering':'imageRendering',in2:'in2','in':'in',inlist:'inlist',intercept:'intercept',k1:'k1',k2:'k2',k3:'k3',k4:'k4',k:'k',kernelmatrix:'kernelMatrix',kernelunitlength:'kernelUnitLength',kerning:'kerning',keypoints:'keyPoints',keysplines:'keySplines',keytimes:'keyTimes',lengthadjust:'lengthAdjust',letterspacing:'letterSpacing','letter-spacing':'letterSpacing',lightingcolor:'lightingColor','lighting-color':'lightingColor',limitingconeangle:'limitingConeAngle',local:'local',markerend:'markerEnd','marker-end':'markerEnd',markerheight:'markerHeight',markermid:'markerMid','marker-mid':'markerMid',markerstart:'markerStart','marker-start':'markerStart',markerunits:'markerUnits',markerwidth:'markerWidth',mask:'mask',maskcontentunits:'maskContentUnits',maskunits:'maskUnits',mathematical:'mathematical',mode:'mode',numoctaves:'numOctaves',offset:'offset',opacity:'opacity',operator:'operator',order:'order',orient:'orient',orientation:'orientation',origin:'origin',overflow:'overflow',overlineposition:'overlinePosition','overline-position':'overlinePosition',overlinethickness:'overlineThickness','overline-thickness':'overlineThickness',paintorder:'paintOrder','paint-order':'paintOrder',panose1:'panose1','panose-1':'panose1',pathlength:'pathLength',patterncontentunits:'patternContentUnits',patterntransform:'patternTransform',patternunits:'patternUnits',pointerevents:'pointerEvents','pointer-events':'pointerEvents',points:'points',pointsatx:'pointsAtX',pointsaty:'pointsAtY',pointsatz:'pointsAtZ',prefix:'prefix',preservealpha:'preserveAlpha',preserveaspectratio:'preserveAspectRatio',primitiveunits:'primitiveUnits',property:'property',r:'r',radius:'radius',refx:'refX',refy:'refY',renderingintent:'renderingIntent','rendering-intent':'renderingIntent',repeatcount:'repeatCount',repeatdur:'repeatDur',requiredextensions:'requiredExtensions',requiredfeatures:'requiredFeatures',resource:'resource',restart:'restart',result:'result',results:'results',rotate:'rotate',rx:'rx',ry:'ry',scale:'scale',security:'security',seed:'seed',shaperendering:'shapeRendering','shape-rendering':'shapeRendering',slope:'slope',spacing:'spacing',specularconstant:'specularConstant',specularexponent:'specularExponent',speed:'speed',spreadmethod:'spreadMethod',startoffset:'startOffset',stddeviation:'stdDeviation',stemh:'stemh',stemv:'stemv',stitchtiles:'stitchTiles',stopcolor:'stopColor','stop-color':'stopColor',stopopacity:'stopOpacity','stop-opacity':'stopOpacity',strikethroughposition:'strikethroughPosition','strikethrough-position':'strikethroughPosition',strikethroughthickness:'strikethroughThickness','strikethrough-thickness':'strikethroughThickness',string:'string',stroke:'stroke',strokedasharray:'strokeDasharray','stroke-dasharray':'strokeDasharray',strokedashoffset:'strokeDashoffset','stroke-dashoffset':'strokeDashoffset',strokelinecap:'strokeLinecap','stroke-linecap':'strokeLinecap',strokelinejoin:'strokeLinejoin','stroke-linejoin':'strokeLinejoin',strokemiterlimit:'strokeMiterlimit','stroke-miterlimit':'strokeMiterlimit',strokewidth:'strokeWidth','stroke-width':'strokeWidth',strokeopacity:'strokeOpacity','stroke-opacity':'strokeOpacity',suppresscontenteditablewarning:'suppressContentEditableWarning',suppresshydrationwarning:'suppressHydrationWarning',surfacescale:'surfaceScale',systemlanguage:'systemLanguage',tablevalues:'tableValues',targetx:'targetX',targety:'targetY',textanchor:'textAnchor','text-anchor':'textAnchor',textdecoration:'textDecoration','text-decoration':'textDecoration',textlength:'textLength',textrendering:'textRendering','text-rendering':'textRendering',to:'to',transform:'transform','typeof':'typeof',u1:'u1',u2:'u2',underlineposition:'underlinePosition','underline-position':'underlinePosition',underlinethickness:'underlineThickness','underline-thickness':'underlineThickness',unicode:'unicode',unicodebidi:'unicodeBidi','unicode-bidi':'unicodeBidi',unicoderange:'unicodeRange','unicode-range':'unicodeRange',unitsperem:'unitsPerEm','units-per-em':'unitsPerEm',unselectable:'unselectable',valphabetic:'vAlphabetic','v-alphabetic':'vAlphabetic',values:'values',vectoreffect:'vectorEffect','vector-effect':'vectorEffect',version:'version',vertadvy:'vertAdvY','vert-adv-y':'vertAdvY',vertoriginx:'vertOriginX','vert-origin-x':'vertOriginX',vertoriginy:'vertOriginY','vert-origin-y':'vertOriginY',vhanging:'vHanging','v-hanging':'vHanging',videographic:'vIdeographic','v-ideographic':'vIdeographic',viewbox:'viewBox',viewtarget:'viewTarget',visibility:'visibility',vmathematical:'vMathematical','v-mathematical':'vMathematical',vocab:'vocab',widths:'widths',wordspacing:'wordSpacing','word-spacing':'wordSpacing',writingmode:'writingMode','writing-mode':'writingMode',x1:'x1',x2:'x2',x:'x',xchannelselector:'xChannelSelector',xheight:'xHeight','x-height':'xHeight',xlinkactuate:'xlinkActuate','xlink:actuate':'xlinkActuate',xlinkarcrole:'xlinkArcrole','xlink:arcrole':'xlinkArcrole',xlinkhref:'xlinkHref','xlink:href':'xlinkHref',xlinkrole:'xlinkRole','xlink:role':'xlinkRole',xlinkshow:'xlinkShow','xlink:show':'xlinkShow',xlinktitle:'xlinkTitle','xlink:title':'xlinkTitle',xlinktype:'xlinkType','xlink:type':'xlinkType',xmlbase:'xmlBase','xml:base':'xmlBase',xmllang:'xmlLang','xml:lang':'xmlLang',xmlns:'xmlns','xml:space':'xmlSpace',xmlnsxlink:'xmlnsXlink','xmlns:xlink':'xmlnsXlink',xmlspace:'xmlSpace',y1:'y1',y2:'y2',y:'y',ychannelselector:'yChannelSelector',z:'z',zoomandpan:'zoomAndPan'};function getStackAddendum$2(){var stack=ReactDebugCurrentFrame.getStackAddendum();return stack!=null?stack:'';}{var warnedProperties$1={};var hasOwnProperty$1=Object.prototype.hasOwnProperty;var EVENT_NAME_REGEX=/^on[A-Z]/;var rARIA$1=new RegExp('^(aria)-['+ATTRIBUTE_NAME_CHAR+']*$');var rARIACamel$1=new RegExp('^(aria)[A-Z]['+ATTRIBUTE_NAME_CHAR+']*$');var validateProperty$1=function validateProperty$1(tagName,name,value){if(hasOwnProperty$1.call(warnedProperties$1,name)&&warnedProperties$1[name]){return true;}if(registrationNameModules.hasOwnProperty(name)){return true;}if(plugins.length===0&&EVENT_NAME_REGEX.test(name)){// If no event plugins have been injected, we might be in a server environment.
// Don't check events in this case.
return true;}var lowerCasedName=name.toLowerCase();var registrationName=possibleRegistrationNames.hasOwnProperty(lowerCasedName)?possibleRegistrationNames[lowerCasedName]:null;if(registrationName!=null){warning(false,'Invalid event handler property `%s`. Did you mean `%s`?%s',name,registrationName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(lowerCasedName.indexOf('on')===0&&lowerCasedName.length>2){warning(false,'Unknown event handler property `%s`. It will be ignored.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}// Let the ARIA attribute hook validate ARIA attributes
if(rARIA$1.test(name)||rARIACamel$1.test(name)){return true;}if(lowerCasedName==='onfocusin'||lowerCasedName==='onfocusout'){warning(false,'React uses onFocus and onBlur instead of onFocusIn and onFocusOut. '+'All React events are normalized to bubble, so onFocusIn and onFocusOut '+'are not needed/supported by React.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='innerhtml'){warning(false,'Directly setting property `innerHTML` is not permitted. '+'For more information, lookup documentation on `dangerouslySetInnerHTML`.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='aria'){warning(false,'The `aria` attribute is reserved for future use in React. '+'Pass individual `aria-` attributes instead.');warnedProperties$1[name]=true;return true;}if(lowerCasedName==='is'&&value!==null&&value!==undefined&&typeof value!=='string'){warning(false,'Received a `%s` for a string attribute `is`. If this is expected, cast '+'the value to a string.%s',typeof value==='undefined'?'undefined':_typeof(value),getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='number'&&isNaN(value)){warning(false,'Received NaN for the `%s` attribute. If this is expected, cast '+'the value to a string.%s',name,getStackAddendum$2());warnedProperties$1[name]=true;return true;}var isReserved=isReservedProp(name);// Known attributes should match the casing specified in the property config.
if(possibleStandardNames.hasOwnProperty(lowerCasedName)){var standardName=possibleStandardNames[lowerCasedName];if(standardName!==name){warning(false,'Invalid DOM property `%s`. Did you mean `%s`?%s',name,standardName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}}else if(!isReserved&&name!==lowerCasedName){// Unknown attributes should have lowercase casing since that's how they
// will be cased anyway with server rendering.
warning(false,'React does not recognize the `%s` prop on a DOM element. If you '+'intentionally want it to appear in the DOM as a custom '+'attribute, spell it as lowercase `%s` instead. '+'If you accidentally passed it from a parent component, remove '+'it from the DOM element.%s',name,lowerCasedName,getStackAddendum$2());warnedProperties$1[name]=true;return true;}if(typeof value==='boolean'&&!shouldAttributeAcceptBooleanValue(name)){if(value){warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.%s',value,name,name,value,name,getStackAddendum$2());}else{warning(false,'Received `%s` for a non-boolean attribute `%s`.\n\n'+'If you want to write it to the DOM, pass a string instead: '+'%s="%s" or %s={value.toString()}.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',value,name,name,value,name,name,name,getStackAddendum$2());}warnedProperties$1[name]=true;return true;}// Now that we've validated casing, do not validate
// data types for reserved props
if(isReserved){return true;}// Warn when a known attribute is a bad type
if(!shouldSetAttribute(name,value)){warnedProperties$1[name]=true;return false;}return true;};}var warnUnknownProperties=function warnUnknownProperties(type,props){var unknownProps=[];for(var key in props){var isValid=validateProperty$1(type,key,props[key]);if(!isValid){unknownProps.push(key);}}var unknownPropString=unknownProps.map(function(prop){return'`'+prop+'`';}).join(', ');if(unknownProps.length===1){warning(false,'Invalid value for prop %s on <%s> tag. Either remove it from the element, '+'or pass a string or number value to keep it in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}else if(unknownProps.length>1){warning(false,'Invalid values for props %s on <%s> tag. Either remove them from the element, '+'or pass a string or number value to keep them in the DOM. '+'For details, see https://fb.me/react-attribute-behavior%s',unknownPropString,type,getStackAddendum$2());}};function validateProperties$2(type,props){if(isCustomComponent(type,props)){return;}warnUnknownProperties(type,props);}// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberOwnerName$1=ReactDebugCurrentFiber.getCurrentFiberOwnerName;var getCurrentFiberStackAddendum$2=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var didWarnInvalidHydration=false;var didWarnShadyDOM=false;var DANGEROUSLY_SET_INNER_HTML='dangerouslySetInnerHTML';var SUPPRESS_CONTENT_EDITABLE_WARNING='suppressContentEditableWarning';var SUPPRESS_HYDRATION_WARNING$1='suppressHydrationWarning';var AUTOFOCUS='autoFocus';var CHILDREN='children';var STYLE='style';var HTML='__html';var HTML_NAMESPACE=Namespaces.html;var getStack=emptyFunction$1.thatReturns('');{getStack=getCurrentFiberStackAddendum$2;var warnedUnknownTags={// Chrome is the only major browser not shipping <time>. But as of July
// 2017 it intends to ship it due to widespread usage. We intentionally
// *don't* warn for <time> even if it's unrecognized by Chrome because
// it soon will be, and many apps have been using it anyway.
time:true,// There are working polyfills for <dialog>. Let people use it.
dialog:true};var validatePropertiesInDevelopment=function validatePropertiesInDevelopment(type,props){validateProperties(type,props);validateProperties$1(type,props);validateProperties$2(type,props);};// HTML parsing normalizes CR and CRLF to LF.
// It also can turn \u0000 into \uFFFD inside attributes.
// https://www.w3.org/TR/html5/single-page.html#preprocessing-the-input-stream
// If we have a mismatch, it might be caused by that.
// We will still patch up in this case but not fire the warning.
var NORMALIZE_NEWLINES_REGEX=/\r\n?/g;var NORMALIZE_NULL_AND_REPLACEMENT_REGEX=/\u0000|\uFFFD/g;var normalizeMarkupForTextOrAttribute=function normalizeMarkupForTextOrAttribute(markup){var markupString=typeof markup==='string'?markup:''+markup;return markupString.replace(NORMALIZE_NEWLINES_REGEX,'\n').replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX,'');};var warnForTextDifference=function warnForTextDifference(serverText,clientText){if(didWarnInvalidHydration){return;}var normalizedClientText=normalizeMarkupForTextOrAttribute(clientText);var normalizedServerText=normalizeMarkupForTextOrAttribute(serverText);if(normalizedServerText===normalizedClientText){return;}didWarnInvalidHydration=true;warning(false,'Text content did not match. Server: "%s" Client: "%s"',normalizedServerText,normalizedClientText);};var warnForPropDifference=function warnForPropDifference(propName,serverValue,clientValue){if(didWarnInvalidHydration){return;}var normalizedClientValue=normalizeMarkupForTextOrAttribute(clientValue);var normalizedServerValue=normalizeMarkupForTextOrAttribute(serverValue);if(normalizedServerValue===normalizedClientValue){return;}didWarnInvalidHydration=true;warning(false,'Prop `%s` did not match. Server: %s Client: %s',propName,JSON.stringify(normalizedServerValue),JSON.stringify(normalizedClientValue));};var warnForExtraAttributes=function warnForExtraAttributes(attributeNames){if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;var names=[];attributeNames.forEach(function(name){names.push(name);});warning(false,'Extra attributes from the server: %s',names);};var warnForInvalidEventListener=function warnForInvalidEventListener(registrationName,listener){if(listener===false){warning(false,'Expected `%s` listener to be a function, instead got `false`.\n\n'+'If you used to conditionally omit it with %s={condition && value}, '+'pass %s={condition ? value : undefined} instead.%s',registrationName,registrationName,registrationName,getCurrentFiberStackAddendum$2());}else{warning(false,'Expected `%s` listener to be a function, instead got a value of `%s` type.%s',registrationName,typeof listener==='undefined'?'undefined':_typeof(listener),getCurrentFiberStackAddendum$2());}};// Parse the HTML and read it back to normalize the HTML string so that it
// can be used for comparison.
var normalizeHTML=function normalizeHTML(parent,html){// We could have created a separate document here to avoid
// re-initializing custom elements if they exist. But this breaks
// how <noscript> is being handled. So we use the same document.
// See the discussion in https://github.com/facebook/react/pull/11157.
var testElement=parent.namespaceURI===HTML_NAMESPACE?parent.ownerDocument.createElement(parent.tagName):parent.ownerDocument.createElementNS(parent.namespaceURI,parent.tagName);testElement.innerHTML=html;return testElement.innerHTML;};}function ensureListeningTo(rootContainerElement,registrationName){var isDocumentOrFragment=rootContainerElement.nodeType===DOCUMENT_NODE||rootContainerElement.nodeType===DOCUMENT_FRAGMENT_NODE;var doc=isDocumentOrFragment?rootContainerElement:rootContainerElement.ownerDocument;listenTo(registrationName,doc);}function getOwnerDocumentFromRootContainer(rootContainerElement){return rootContainerElement.nodeType===DOCUMENT_NODE?rootContainerElement:rootContainerElement.ownerDocument;}// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents={topAbort:'abort',topCanPlay:'canplay',topCanPlayThrough:'canplaythrough',topDurationChange:'durationchange',topEmptied:'emptied',topEncrypted:'encrypted',topEnded:'ended',topError:'error',topLoadedData:'loadeddata',topLoadedMetadata:'loadedmetadata',topLoadStart:'loadstart',topPause:'pause',topPlay:'play',topPlaying:'playing',topProgress:'progress',topRateChange:'ratechange',topSeeked:'seeked',topSeeking:'seeking',topStalled:'stalled',topSuspend:'suspend',topTimeUpdate:'timeupdate',topVolumeChange:'volumechange',topWaiting:'waiting'};function trapClickOnNonInteractiveElement(node){// Mobile Safari does not fire properly bubble click events on
// non-interactive elements, which means delegated click listeners do not
// fire. The workaround for this bug involves attaching an empty click
// listener on the target node.
// http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
// Just set it using the onclick property so that we don't have to manage any
// bookkeeping for it. Not sure if we need to clear it when the listener is
// removed.
// TODO: Only do this for the relevant Safaris maybe?
node.onclick=emptyFunction$1;}function setInitialDOMProperties(tag,domElement,rootContainerElement,nextProps,isCustomComponentTag){for(var propKey in nextProps){if(!nextProps.hasOwnProperty(propKey)){continue;}var nextProp=nextProps[propKey];if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}// Relies on `updateStylesByID` not mutating `styleUpdates`.
setValueForStyles(domElement,nextProp,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;if(nextHtml!=null){setInnerHTML(domElement,nextHtml);}}else if(propKey===CHILDREN){if(typeof nextProp==='string'){// Avoid setting initial textContent when the text is empty. In IE11 setting
// textContent on a <textarea> will cause the placeholder to not
// show within the <textarea> until it has been focused and blurred again.
// https://github.com/facebook/react/issues/6731#issuecomment-254874553
var canSetTextContent=tag!=='textarea'||nextProp!=='';if(canSetTextContent){setTextContent$1(domElement,nextProp);}}else if(typeof nextProp==='number'){setTextContent$1(domElement,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// We polyfill it separately on the client during commit.
// We blacklist it here rather than in the property list because we emit it in SSR.
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else if(isCustomComponentTag){setValueForAttribute(domElement,propKey,nextProp);}else if(nextProp!=null){// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
setValueForProperty(domElement,propKey,nextProp);}}}function updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag){// TODO: Handle wasCustomComponentTag
for(var i=0;i<updatePayload.length;i+=2){var propKey=updatePayload[i];var propValue=updatePayload[i+1];if(propKey===STYLE){setValueForStyles(domElement,propValue,getStack);}else if(propKey===DANGEROUSLY_SET_INNER_HTML){setInnerHTML(domElement,propValue);}else if(propKey===CHILDREN){setTextContent$1(domElement,propValue);}else if(isCustomComponentTag){if(propValue!=null){setValueForAttribute(domElement,propKey,propValue);}else{deleteValueForAttribute(domElement,propKey);}}else if(propValue!=null){setValueForProperty(domElement,propKey,propValue);}else{// If we're updating to null or undefined, we should remove the property
// from the DOM node instead of inadvertently setting to a string. This
// brings us in line with the same behavior we have on initial render.
deleteValueForProperty(domElement,propKey);}}}function createElement$1(type,props,rootContainerElement,parentNamespace){// We create tags in the namespace of their parent container, except HTML
var ownerDocument=getOwnerDocumentFromRootContainer(rootContainerElement);var domElement;var namespaceURI=parentNamespace;if(namespaceURI===HTML_NAMESPACE){namespaceURI=getIntrinsicNamespace(type);}if(namespaceURI===HTML_NAMESPACE){{var isCustomComponentTag=isCustomComponent(type,props);// Should this check be gated by parent namespace? Not sure we want to
// allow <SVG> or <mATH>.
warning(isCustomComponentTag||type===type.toLowerCase(),'<%s /> is using uppercase HTML. Always use lowercase HTML tags '+'in React.',type);}if(type==='script'){// Create the script via .innerHTML so its "parser-inserted" flag is
// set to true and it does not execute
var div=ownerDocument.createElement('div');div.innerHTML='<script><'+'/script>';// eslint-disable-line
// This is guaranteed to yield a script element.
var firstChild=div.firstChild;domElement=div.removeChild(firstChild);}else if(typeof props.is==='string'){// $FlowIssue `createElement` should be updated for Web Components
domElement=ownerDocument.createElement(type,{is:props.is});}else{// Separate else branch instead of using `props.is || undefined` above because of a Firefox bug.
// See discussion in https://github.com/facebook/react/pull/6896
// and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
domElement=ownerDocument.createElement(type);}}else{domElement=ownerDocument.createElementNS(namespaceURI,type);}{if(namespaceURI===HTML_NAMESPACE){if(!isCustomComponentTag&&Object.prototype.toString.call(domElement)==='[object HTMLUnknownElement]'&&!Object.prototype.hasOwnProperty.call(warnedUnknownTags,type)){warnedUnknownTags[type]=true;warning(false,'The tag <%s> is unrecognized in this browser. '+'If you meant to render a React component, start its name with '+'an uppercase letter.',type);}}}return domElement;}function createTextNode$1(text,rootContainerElement){return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);}function setInitialProperties$1(domElement,tag,rawProps,rootContainerElement){var isCustomComponentTag=isCustomComponent(tag,rawProps);{validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
var props;switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}props=rawProps;break;case'source':trapBubbledEvent('topError','error',domElement);props=rawProps;break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);props=rawProps;break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);props=rawProps;break;case'details':trapBubbledEvent('topToggle','toggle',domElement);props=rawProps;break;case'input':initWrapperState(domElement,rawProps);props=getHostProps(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);props=getHostProps$1(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);props=getHostProps$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);props=getHostProps$3(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;default:props=rawProps;}assertValidProps(tag,props,getStack);setInitialDOMProperties(tag,domElement,rootContainerElement,props,isCustomComponentTag);switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'option':postMountWrapper$1(domElement,rawProps);break;case'select':postMountWrapper$2(domElement,rawProps);break;default:if(typeof props.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}}// Calculate the diff between the two objects.
function diffProperties$1(domElement,tag,lastRawProps,nextRawProps,rootContainerElement){{validatePropertiesInDevelopment(tag,nextRawProps);}var updatePayload=null;var lastProps;var nextProps;switch(tag){case'input':lastProps=getHostProps(domElement,lastRawProps);nextProps=getHostProps(domElement,nextRawProps);updatePayload=[];break;case'option':lastProps=getHostProps$1(domElement,lastRawProps);nextProps=getHostProps$1(domElement,nextRawProps);updatePayload=[];break;case'select':lastProps=getHostProps$2(domElement,lastRawProps);nextProps=getHostProps$2(domElement,nextRawProps);updatePayload=[];break;case'textarea':lastProps=getHostProps$3(domElement,lastRawProps);nextProps=getHostProps$3(domElement,nextRawProps);updatePayload=[];break;default:lastProps=lastRawProps;nextProps=nextRawProps;if(typeof lastProps.onClick!=='function'&&typeof nextProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}assertValidProps(tag,nextProps,getStack);var propKey;var styleName;var styleUpdates=null;for(propKey in lastProps){if(nextProps.hasOwnProperty(propKey)||!lastProps.hasOwnProperty(propKey)||lastProps[propKey]==null){continue;}if(propKey===STYLE){var lastStyle=lastProps[propKey];for(styleName in lastStyle){if(lastStyle.hasOwnProperty(styleName)){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}}else if(propKey===DANGEROUSLY_SET_INNER_HTML||propKey===CHILDREN){// Noop. This is handled by the clear text mechanism.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(propKey===AUTOFOCUS){// Noop. It doesn't work on updates anyway.
}else if(registrationNameModules.hasOwnProperty(propKey)){// This is a special case. If any listener updates we need to ensure
// that the "current" fiber pointer gets updated so we need a commit
// to update this element.
if(!updatePayload){updatePayload=[];}}else{// For all other deleted properties we add it to the queue. We use
// the whitelist in the commit phase instead.
(updatePayload=updatePayload||[]).push(propKey,null);}}for(propKey in nextProps){var nextProp=nextProps[propKey];var lastProp=lastProps!=null?lastProps[propKey]:undefined;if(!nextProps.hasOwnProperty(propKey)||nextProp===lastProp||nextProp==null&&lastProp==null){continue;}if(propKey===STYLE){{if(nextProp){// Freeze the next style object so that we can assume it won't be
// mutated. We have already warned for this in the past.
Object.freeze(nextProp);}}if(lastProp){// Unset styles on `lastProp` but not on `nextProp`.
for(styleName in lastProp){if(lastProp.hasOwnProperty(styleName)&&(!nextProp||!nextProp.hasOwnProperty(styleName))){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]='';}}// Update styles that changed since `lastProp`.
for(styleName in nextProp){if(nextProp.hasOwnProperty(styleName)&&lastProp[styleName]!==nextProp[styleName]){if(!styleUpdates){styleUpdates={};}styleUpdates[styleName]=nextProp[styleName];}}}else{// Relies on `updateStylesByID` not mutating `styleUpdates`.
if(!styleUpdates){if(!updatePayload){updatePayload=[];}updatePayload.push(propKey,styleUpdates);}styleUpdates=nextProp;}}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var nextHtml=nextProp?nextProp[HTML]:undefined;var lastHtml=lastProp?lastProp[HTML]:undefined;if(nextHtml!=null){if(lastHtml!==nextHtml){(updatePayload=updatePayload||[]).push(propKey,''+nextHtml);}}else{// TODO: It might be too late to clear this if we have children
// inserted already.
}}else if(propKey===CHILDREN){if(lastProp!==nextProp&&(typeof nextProp==='string'||typeof nextProp==='number')){(updatePayload=updatePayload||[]).push(propKey,''+nextProp);}}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1){// Noop
}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){// We eagerly listen to this even though we haven't committed yet.
if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}if(!updatePayload&&lastProp!==nextProp){// This is a special case. If any listener updates we need to ensure
// that the "current" props pointer gets updated so we need a commit
// to update this element.
updatePayload=[];}}else{// For any other property we always add it to the queue and then we
// filter it out using the whitelist during the commit.
(updatePayload=updatePayload||[]).push(propKey,nextProp);}}if(styleUpdates){(updatePayload=updatePayload||[]).push(STYLE,styleUpdates);}return updatePayload;}// Apply the diff.
function updateProperties$1(domElement,updatePayload,tag,lastRawProps,nextRawProps){var wasCustomComponentTag=isCustomComponent(tag,lastRawProps);var isCustomComponentTag=isCustomComponent(tag,nextRawProps);// Apply the diff.
updateDOMProperties(domElement,updatePayload,wasCustomComponentTag,isCustomComponentTag);// TODO: Ensure that an update gets scheduled if any of the special props
// changed.
switch(tag){case'input':// Update the wrapper around inputs *after* updating props. This has to
// happen after `updateDOMProperties`. Otherwise HTML5 input validations
// raise warnings and prevent the new value from being assigned.
updateWrapper(domElement,nextRawProps);// We also check that we haven't missed a value update, such as a
// Radio group shifting the checked value to another named radio input.
updateValueIfChanged(domElement);break;case'textarea':updateWrapper$1(domElement,nextRawProps);break;case'select':// <select> value update needs to occur after <option> children
// reconciliation
postUpdateWrapper(domElement,nextRawProps);break;}}function diffHydratedProperties$1(domElement,tag,rawProps,parentNamespace,rootContainerElement){{var suppressHydrationWarning=rawProps[SUPPRESS_HYDRATION_WARNING$1]===true;var isCustomComponentTag=isCustomComponent(tag,rawProps);validatePropertiesInDevelopment(tag,rawProps);if(isCustomComponentTag&&!didWarnShadyDOM&&domElement.shadyRoot){warning(false,'%s is using shady DOM. Using shady DOM with React can '+'cause things to break subtly.',getCurrentFiberOwnerName$1()||'A component');didWarnShadyDOM=true;}}// TODO: Make sure that we check isMounted before firing any of these events.
switch(tag){case'iframe':case'object':trapBubbledEvent('topLoad','load',domElement);break;case'video':case'audio':// Create listener for each media event
for(var event in mediaEvents){if(mediaEvents.hasOwnProperty(event)){trapBubbledEvent(event,mediaEvents[event],domElement);}}break;case'source':trapBubbledEvent('topError','error',domElement);break;case'img':case'image':trapBubbledEvent('topError','error',domElement);trapBubbledEvent('topLoad','load',domElement);break;case'form':trapBubbledEvent('topReset','reset',domElement);trapBubbledEvent('topSubmit','submit',domElement);break;case'details':trapBubbledEvent('topToggle','toggle',domElement);break;case'input':initWrapperState(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'option':validateProps(domElement,rawProps);break;case'select':initWrapperState$1(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;case'textarea':initWrapperState$2(domElement,rawProps);trapBubbledEvent('topInvalid','invalid',domElement);// For controlled components we always need to ensure we're listening
// to onChange. Even if there is no listener.
ensureListeningTo(rootContainerElement,'onChange');break;}assertValidProps(tag,rawProps,getStack);{var extraAttributeNames=new Set();var attributes=domElement.attributes;for(var i=0;i<attributes.length;i++){var name=attributes[i].name.toLowerCase();switch(name){// Built-in SSR attribute is whitelisted
case'data-reactroot':break;// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
case'value':break;case'checked':break;case'selected':break;default:// Intentionally use the original name.
// See discussion in https://github.com/facebook/react/pull/10676.
extraAttributeNames.add(attributes[i].name);}}}var updatePayload=null;for(var propKey in rawProps){if(!rawProps.hasOwnProperty(propKey)){continue;}var nextProp=rawProps[propKey];if(propKey===CHILDREN){// For text content children we compare against textContent. This
// might match additional HTML that is hidden when we read it using
// textContent. E.g. "foo" will match "f<span>oo</span>" but that still
// satisfies our requirement. Our requirement is not to produce perfect
// HTML and attributes. Ideally we should preserve structure but it's
// ok not to if the visible content is still enough to indicate what
// even listeners these nodes might be wired up to.
// TODO: Warn if there is more than a single textNode as a child.
// TODO: Should we use domElement.firstChild.nodeValue to compare?
if(typeof nextProp==='string'){if(domElement.textContent!==nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,nextProp];}}else if(typeof nextProp==='number'){if(domElement.textContent!==''+nextProp){if(true&&!suppressHydrationWarning){warnForTextDifference(domElement.textContent,nextProp);}updatePayload=[CHILDREN,''+nextProp];}}}else if(registrationNameModules.hasOwnProperty(propKey)){if(nextProp!=null){if(true&&typeof nextProp!=='function'){warnForInvalidEventListener(propKey,nextProp);}ensureListeningTo(rootContainerElement,propKey);}}else{// Validate that the properties correspond to their expected values.
var serverValue;var propertyInfo;if(suppressHydrationWarning){// Don't bother comparing. We're ignoring all these warnings.
}else if(propKey===SUPPRESS_CONTENT_EDITABLE_WARNING||propKey===SUPPRESS_HYDRATION_WARNING$1||// Controlled attributes are not validated
// TODO: Only ignore them on controlled tags.
propKey==='value'||propKey==='checked'||propKey==='selected'){// Noop
}else if(propKey===DANGEROUSLY_SET_INNER_HTML){var rawHtml=nextProp?nextProp[HTML]||'':'';var serverHTML=domElement.innerHTML;var expectedHTML=normalizeHTML(domElement,rawHtml);if(expectedHTML!==serverHTML){warnForPropDifference(propKey,serverHTML,expectedHTML);}}else if(propKey===STYLE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);var expectedStyle=createDangerousStringForStyles(nextProp);serverValue=domElement.getAttribute('style');if(expectedStyle!==serverValue){warnForPropDifference(propKey,serverValue,expectedStyle);}}else if(isCustomComponentTag){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());serverValue=getValueForAttribute(domElement,propKey,nextProp);if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}else if(shouldSetAttribute(propKey,nextProp)){if(propertyInfo=getPropertyInfo(propKey)){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propertyInfo.attributeName);serverValue=getValueForProperty(domElement,propKey,nextProp);}else{var ownNamespace=parentNamespace;if(ownNamespace===HTML_NAMESPACE){ownNamespace=getIntrinsicNamespace(tag);}if(ownNamespace===HTML_NAMESPACE){// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey.toLowerCase());}else{// $FlowFixMe - Should be inferred as not undefined.
extraAttributeNames['delete'](propKey);}serverValue=getValueForAttribute(domElement,propKey,nextProp);}if(nextProp!==serverValue){warnForPropDifference(propKey,serverValue,nextProp);}}}}{// $FlowFixMe - Should be inferred as not undefined.
if(extraAttributeNames.size>0&&!suppressHydrationWarning){// $FlowFixMe - Should be inferred as not undefined.
warnForExtraAttributes(extraAttributeNames);}}switch(tag){case'input':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper(domElement,rawProps);break;case'textarea':// TODO: Make sure we check if this is still unmounted or do any clean
// up necessary since we never stop tracking anymore.
track(domElement);postMountWrapper$3(domElement,rawProps);break;case'select':case'option':// For input and textarea we current always set the value property at
// post mount to force it to diverge from attributes. However, for
// option and select we don't quite do the same thing and select
// is not resilient to the DOM state changing so we don't do that here.
// TODO: Consider not doing this for input and textarea.
break;default:if(typeof rawProps.onClick==='function'){// TODO: This cast may not be sound for SVG, MathML or custom elements.
trapClickOnNonInteractiveElement(domElement);}break;}return updatePayload;}function diffHydratedText$1(textNode,text){var isDifferent=textNode.nodeValue!==text;return isDifferent;}function warnForUnmatchedText$1(textNode,text){{warnForTextDifference(textNode.nodeValue,text);}}function warnForDeletedHydratableElement$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain a <%s> in <%s>.',child.nodeName.toLowerCase(),parentNode.nodeName.toLowerCase());}}function warnForDeletedHydratableText$1(parentNode,child){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Did not expect server HTML to contain the text node "%s" in <%s>.',child.nodeValue,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedElement$1(parentNode,tag,props){{if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching <%s> in <%s>.',tag,parentNode.nodeName.toLowerCase());}}function warnForInsertedHydratedText$1(parentNode,text){{if(text===''){// We expect to insert empty text nodes since they're not represented in
// the HTML.
// TODO: Remove this special case if we can just avoid inserting empty
// text nodes.
return;}if(didWarnInvalidHydration){return;}didWarnInvalidHydration=true;warning(false,'Expected server HTML to contain a matching text node for "%s" in <%s>.',text,parentNode.nodeName.toLowerCase());}}function restoreControlledState(domElement,tag,props){switch(tag){case'input':restoreControlledState$1(domElement,props);return;case'textarea':restoreControlledState$3(domElement,props);return;case'select':restoreControlledState$2(domElement,props);return;}}var ReactDOMFiberComponent=Object.freeze({createElement:createElement$1,createTextNode:createTextNode$1,setInitialProperties:setInitialProperties$1,diffProperties:diffProperties$1,updateProperties:updateProperties$1,diffHydratedProperties:diffHydratedProperties$1,diffHydratedText:diffHydratedText$1,warnForUnmatchedText:warnForUnmatchedText$1,warnForDeletedHydratableElement:warnForDeletedHydratableElement$1,warnForDeletedHydratableText:warnForDeletedHydratableText$1,warnForInsertedHydratedElement:warnForInsertedHydratedElement$1,warnForInsertedHydratedText:warnForInsertedHydratedText$1,restoreControlledState:restoreControlledState});// TODO: direct imports like some-package/src/* are bad. Fix me.
var getCurrentFiberStackAddendum$6=ReactDebugCurrentFiber.getCurrentFiberStackAddendum;var validateDOMNesting=emptyFunction$1;{// This validation code was written based on the HTML5 parsing spec:
// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
//
// Note: this does not catch all invalid nesting, nor does it try to (as it's
// not clear what practical benefit doing so provides); instead, we warn only
// for cases where the parser will give a parse tree differing from what React
// intended. For example, <b><div></div></b> is invalid but we don't warn
// because it still parses correctly; we do warn for other cases like nested
// <p> tags where the beginning of the second element implicitly closes the
// first, causing a confusing mess.
// https://html.spec.whatwg.org/multipage/syntax.html#special
var specialTags=['address','applet','area','article','aside','base','basefont','bgsound','blockquote','body','br','button','caption','center','col','colgroup','dd','details','dir','div','dl','dt','embed','fieldset','figcaption','figure','footer','form','frame','frameset','h1','h2','h3','h4','h5','h6','head','header','hgroup','hr','html','iframe','img','input','isindex','li','link','listing','main','marquee','menu','menuitem','meta','nav','noembed','noframes','noscript','object','ol','p','param','plaintext','pre','script','section','select','source','style','summary','table','tbody','td','template','textarea','tfoot','th','thead','title','tr','track','ul','wbr','xmp'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
var inScopeTags=['applet','caption','html','table','td','th','marquee','object','template',// https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
// TODO: Distinguish by namespace here -- for <title>, including it here
// errs on the side of fewer warnings
'foreignObject','desc','title'];// https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
var buttonScopeTags=inScopeTags.concat(['button']);// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
var impliedEndTags=['dd','dt','li','option','optgroup','p','rp','rt'];var emptyAncestorInfo={current:null,formTag:null,aTagInScope:null,buttonTagInScope:null,nobrTagInScope:null,pTagInButtonScope:null,listItemTagAutoclosing:null,dlItemTagAutoclosing:null};var updatedAncestorInfo$1=function updatedAncestorInfo$1(oldInfo,tag,instance){var ancestorInfo=_assign({},oldInfo||emptyAncestorInfo);var info={tag:tag,instance:instance};if(inScopeTags.indexOf(tag)!==-1){ancestorInfo.aTagInScope=null;ancestorInfo.buttonTagInScope=null;ancestorInfo.nobrTagInScope=null;}if(buttonScopeTags.indexOf(tag)!==-1){ancestorInfo.pTagInButtonScope=null;}// See rules for 'li', 'dd', 'dt' start tags in
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
if(specialTags.indexOf(tag)!==-1&&tag!=='address'&&tag!=='div'&&tag!=='p'){ancestorInfo.listItemTagAutoclosing=null;ancestorInfo.dlItemTagAutoclosing=null;}ancestorInfo.current=info;if(tag==='form'){ancestorInfo.formTag=info;}if(tag==='a'){ancestorInfo.aTagInScope=info;}if(tag==='button'){ancestorInfo.buttonTagInScope=info;}if(tag==='nobr'){ancestorInfo.nobrTagInScope=info;}if(tag==='p'){ancestorInfo.pTagInButtonScope=info;}if(tag==='li'){ancestorInfo.listItemTagAutoclosing=info;}if(tag==='dd'||tag==='dt'){ancestorInfo.dlItemTagAutoclosing=info;}return ancestorInfo;};/**
   * Returns whether
   */var isTagValidWithParent=function isTagValidWithParent(tag,parentTag){// First, let's check if we're in an unusual parsing mode...
switch(parentTag){// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
case'select':return tag==='option'||tag==='optgroup'||tag==='#text';case'optgroup':return tag==='option'||tag==='#text';// Strictly speaking, seeing an <option> doesn't mean we're in a <select>
// but
case'option':return tag==='#text';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
// No special behavior since these rules fall back to "in body" mode for
// all except special table nodes which cause bad parsing behavior anyway.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
case'tr':return tag==='th'||tag==='td'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
case'tbody':case'thead':case'tfoot':return tag==='tr'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
case'colgroup':return tag==='col'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
case'table':return tag==='caption'||tag==='colgroup'||tag==='tbody'||tag==='tfoot'||tag==='thead'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
case'head':return tag==='base'||tag==='basefont'||tag==='bgsound'||tag==='link'||tag==='meta'||tag==='title'||tag==='noscript'||tag==='noframes'||tag==='style'||tag==='script'||tag==='template';// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
case'html':return tag==='head'||tag==='body';case'#document':return tag==='html';}// Probably in the "in body" parsing mode, so we outlaw only tag combos
// where the parsing rules cause implicit opens or closes to be added.
// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
switch(tag){case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return parentTag!=='h1'&&parentTag!=='h2'&&parentTag!=='h3'&&parentTag!=='h4'&&parentTag!=='h5'&&parentTag!=='h6';case'rp':case'rt':return impliedEndTags.indexOf(parentTag)===-1;case'body':case'caption':case'col':case'colgroup':case'frame':case'head':case'html':case'tbody':case'td':case'tfoot':case'th':case'thead':case'tr':// These tags are only valid with a few parents that have special child
// parsing rules -- if we're down here, then none of those matched and
// so we allow it only if we don't know what the parent is, as all other
// cases are invalid.
return parentTag==null;}return true;};/**
   * Returns whether
   */var findInvalidAncestorForTag=function findInvalidAncestorForTag(tag,ancestorInfo){switch(tag){case'address':case'article':case'aside':case'blockquote':case'center':case'details':case'dialog':case'dir':case'div':case'dl':case'fieldset':case'figcaption':case'figure':case'footer':case'header':case'hgroup':case'main':case'menu':case'nav':case'ol':case'p':case'section':case'summary':case'ul':case'pre':case'listing':case'table':case'hr':case'xmp':case'h1':case'h2':case'h3':case'h4':case'h5':case'h6':return ancestorInfo.pTagInButtonScope;case'form':return ancestorInfo.formTag||ancestorInfo.pTagInButtonScope;case'li':return ancestorInfo.listItemTagAutoclosing;case'dd':case'dt':return ancestorInfo.dlItemTagAutoclosing;case'button':return ancestorInfo.buttonTagInScope;case'a':// Spec says something about storing a list of markers, but it sounds
// equivalent to this check.
return ancestorInfo.aTagInScope;case'nobr':return ancestorInfo.nobrTagInScope;}return null;};var didWarn={};validateDOMNesting=function validateDOMNesting(childTag,childText,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;if(childText!=null){warning(childTag==null,'validateDOMNesting: when childText is passed, childTag should be null');childTag='#text';}var invalidParent=isTagValidWithParent(childTag,parentTag)?null:parentInfo;var invalidAncestor=invalidParent?null:findInvalidAncestorForTag(childTag,ancestorInfo);var invalidParentOrAncestor=invalidParent||invalidAncestor;if(!invalidParentOrAncestor){return;}var ancestorTag=invalidParentOrAncestor.tag;var addendum=getCurrentFiberStackAddendum$6();var warnKey=!!invalidParent+'|'+childTag+'|'+ancestorTag+'|'+addendum;if(didWarn[warnKey]){return;}didWarn[warnKey]=true;var tagDisplayName=childTag;var whitespaceInfo='';if(childTag==='#text'){if(/\S/.test(childText)){tagDisplayName='Text nodes';}else{tagDisplayName='Whitespace text nodes';whitespaceInfo=" Make sure you don't have any extra whitespace between tags on "+'each line of your source code.';}}else{tagDisplayName='<'+childTag+'>';}if(invalidParent){var info='';if(ancestorTag==='table'&&childTag==='tr'){info+=' Add a <tbody> to your code to match the DOM tree generated by '+'the browser.';}warning(false,'validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s%s',tagDisplayName,ancestorTag,whitespaceInfo,info,addendum);}else{warning(false,'validateDOMNesting(...): %s cannot appear as a descendant of '+'<%s>.%s',tagDisplayName,ancestorTag,addendum);}};// TODO: turn this into a named export
validateDOMNesting.updatedAncestorInfo=updatedAncestorInfo$1;// For testing
validateDOMNesting.isTagValidInContext=function(tag,ancestorInfo){ancestorInfo=ancestorInfo||emptyAncestorInfo;var parentInfo=ancestorInfo.current;var parentTag=parentInfo&&parentInfo.tag;return isTagValidWithParent(tag,parentTag)&&!findInvalidAncestorForTag(tag,ancestorInfo);};}var validateDOMNesting$1=validateDOMNesting;// TODO: direct imports like some-package/src/* are bad. Fix me.
var createElement=createElement$1;var createTextNode=createTextNode$1;var setInitialProperties=setInitialProperties$1;var diffProperties=diffProperties$1;var updateProperties=updateProperties$1;var diffHydratedProperties=diffHydratedProperties$1;var diffHydratedText=diffHydratedText$1;var warnForUnmatchedText=warnForUnmatchedText$1;var warnForDeletedHydratableElement=warnForDeletedHydratableElement$1;var warnForDeletedHydratableText=warnForDeletedHydratableText$1;var warnForInsertedHydratedElement=warnForInsertedHydratedElement$1;var warnForInsertedHydratedText=warnForInsertedHydratedText$1;var updatedAncestorInfo=validateDOMNesting$1.updatedAncestorInfo;var precacheFiberNode=precacheFiberNode$1;var updateFiberProps=updateFiberProps$1;{var SUPPRESS_HYDRATION_WARNING='suppressHydrationWarning';if(typeof Map!=='function'||Map.prototype==null||typeof Map.prototype.forEach!=='function'||typeof Set!=='function'||Set.prototype==null||typeof Set.prototype.clear!=='function'||typeof Set.prototype.forEach!=='function'){warning(false,'React depends on Map and Set built-in types. Make sure that you load a '+'polyfill in older browsers. http://fb.me/react-polyfills');}}injection$3.injectFiberControlledHostComponent(ReactDOMFiberComponent);var eventsEnabled=null;var selectionInformation=null;/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */function isValidContainer(node){return!!(node&&(node.nodeType===ELEMENT_NODE||node.nodeType===DOCUMENT_NODE||node.nodeType===DOCUMENT_FRAGMENT_NODE||node.nodeType===COMMENT_NODE&&node.nodeValue===' react-mount-point-unstable '));}function getReactRootElementInContainer(container){if(!container){return null;}if(container.nodeType===DOCUMENT_NODE){return container.documentElement;}else{return container.firstChild;}}function shouldHydrateDueToLegacyHeuristic(container){var rootElement=getReactRootElementInContainer(container);return!!(rootElement&&rootElement.nodeType===ELEMENT_NODE&&rootElement.hasAttribute(ROOT_ATTRIBUTE_NAME));}function shouldAutoFocusHostComponent(type,props){switch(type){case'button':case'input':case'select':case'textarea':return!!props.autoFocus;}return false;}var DOMRenderer=reactReconciler({getRootHostContext:function getRootHostContext(rootContainerInstance){var type=void 0;var namespace=void 0;var nodeType=rootContainerInstance.nodeType;switch(nodeType){case DOCUMENT_NODE:case DOCUMENT_FRAGMENT_NODE:{type=nodeType===DOCUMENT_NODE?'#document':'#fragment';var root=rootContainerInstance.documentElement;namespace=root?root.namespaceURI:getChildNamespace(null,'');break;}default:{var container=nodeType===COMMENT_NODE?rootContainerInstance.parentNode:rootContainerInstance;var ownNamespace=container.namespaceURI||null;type=container.tagName;namespace=getChildNamespace(ownNamespace,type);break;}}{var validatedTag=type.toLowerCase();var _ancestorInfo=updatedAncestorInfo(null,validatedTag,null);return{namespace:namespace,ancestorInfo:_ancestorInfo};}return namespace;},getChildHostContext:function getChildHostContext(parentHostContext,type){{var parentHostContextDev=parentHostContext;var _namespace=getChildNamespace(parentHostContextDev.namespace,type);var _ancestorInfo2=updatedAncestorInfo(parentHostContextDev.ancestorInfo,type,null);return{namespace:_namespace,ancestorInfo:_ancestorInfo2};}var parentNamespace=parentHostContext;return getChildNamespace(parentNamespace,type);},getPublicInstance:function getPublicInstance(instance){return instance;},prepareForCommit:function prepareForCommit(){eventsEnabled=isEnabled();selectionInformation=getSelectionInformation();setEnabled(false);},resetAfterCommit:function resetAfterCommit(){restoreSelection(selectionInformation);selectionInformation=null;setEnabled(eventsEnabled);eventsEnabled=null;},createInstance:function createInstance(type,props,rootContainerInstance,hostContext,internalInstanceHandle){var parentNamespace=void 0;{// TODO: take namespace into account when validating.
var hostContextDev=hostContext;validateDOMNesting$1(type,null,hostContextDev.ancestorInfo);if(typeof props.children==='string'||typeof props.children==='number'){var string=''+props.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}parentNamespace=hostContextDev.namespace;}var domElement=createElement(type,props,rootContainerInstance,parentNamespace);precacheFiberNode(internalInstanceHandle,domElement);updateFiberProps(domElement,props);return domElement;},appendInitialChild:function appendInitialChild(parentInstance,child){parentInstance.appendChild(child);},finalizeInitialChildren:function finalizeInitialChildren(domElement,type,props,rootContainerInstance){setInitialProperties(domElement,type,props,rootContainerInstance);return shouldAutoFocusHostComponent(type,props);},prepareUpdate:function prepareUpdate(domElement,type,oldProps,newProps,rootContainerInstance,hostContext){{var hostContextDev=hostContext;if(_typeof(newProps.children)!==_typeof(oldProps.children)&&(typeof newProps.children==='string'||typeof newProps.children==='number')){var string=''+newProps.children;var ownAncestorInfo=updatedAncestorInfo(hostContextDev.ancestorInfo,type,null);validateDOMNesting$1(null,string,ownAncestorInfo);}}return diffProperties(domElement,type,oldProps,newProps,rootContainerInstance);},shouldSetTextContent:function shouldSetTextContent(type,props){return type==='textarea'||typeof props.children==='string'||typeof props.children==='number'||_typeof(props.dangerouslySetInnerHTML)==='object'&&props.dangerouslySetInnerHTML!==null&&typeof props.dangerouslySetInnerHTML.__html==='string';},shouldDeprioritizeSubtree:function shouldDeprioritizeSubtree(type,props){return!!props.hidden;},createTextInstance:function createTextInstance(text,rootContainerInstance,hostContext,internalInstanceHandle){{var hostContextDev=hostContext;validateDOMNesting$1(null,text,hostContextDev.ancestorInfo);}var textNode=createTextNode(text,rootContainerInstance);precacheFiberNode(internalInstanceHandle,textNode);return textNode;},now:now,mutation:{commitMount:function commitMount(domElement,type,newProps,internalInstanceHandle){domElement.focus();},commitUpdate:function commitUpdate(domElement,updatePayload,type,oldProps,newProps,internalInstanceHandle){// Update the props handle so that we know which props are the ones with
// with current event handlers.
updateFiberProps(domElement,newProps);// Apply the diff to the DOM node.
updateProperties(domElement,updatePayload,type,oldProps,newProps);},resetTextContent:function resetTextContent(domElement){domElement.textContent='';},commitTextUpdate:function commitTextUpdate(textInstance,oldText,newText){textInstance.nodeValue=newText;},appendChild:function appendChild(parentInstance,child){parentInstance.appendChild(child);},appendChildToContainer:function appendChildToContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,container);}else{container.appendChild(child);}},insertBefore:function insertBefore(parentInstance,child,beforeChild){parentInstance.insertBefore(child,beforeChild);},insertInContainerBefore:function insertInContainerBefore(container,child,beforeChild){if(container.nodeType===COMMENT_NODE){container.parentNode.insertBefore(child,beforeChild);}else{container.insertBefore(child,beforeChild);}},removeChild:function removeChild(parentInstance,child){parentInstance.removeChild(child);},removeChildFromContainer:function removeChildFromContainer(container,child){if(container.nodeType===COMMENT_NODE){container.parentNode.removeChild(child);}else{container.removeChild(child);}}},hydration:{canHydrateInstance:function canHydrateInstance(instance,type,props){return instance.nodeType===ELEMENT_NODE&&type.toLowerCase()===instance.nodeName.toLowerCase();},canHydrateTextInstance:function canHydrateTextInstance(instance,text){if(text===''){// Empty strings are not parsed by HTML so there won't be a correct match here.
return false;}return instance.nodeType===TEXT_NODE;},getNextHydratableSibling:function getNextHydratableSibling(instance){var node=instance.nextSibling;// Skip non-hydratable nodes.
while(node&&node.nodeType!==ELEMENT_NODE&&node.nodeType!==TEXT_NODE){node=node.nextSibling;}return node;},getFirstHydratableChild:function getFirstHydratableChild(parentInstance){var next=parentInstance.firstChild;// Skip non-hydratable nodes.
while(next&&next.nodeType!==ELEMENT_NODE&&next.nodeType!==TEXT_NODE){next=next.nextSibling;}return next;},hydrateInstance:function hydrateInstance(instance,type,props,rootContainerInstance,hostContext,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,instance);// TODO: Possibly defer this until the commit phase where all the events
// get attached.
updateFiberProps(instance,props);var parentNamespace=void 0;{var hostContextDev=hostContext;parentNamespace=hostContextDev.namespace;}return diffHydratedProperties(instance,type,props,parentNamespace,rootContainerInstance);},hydrateTextInstance:function hydrateTextInstance(textInstance,text,internalInstanceHandle){precacheFiberNode(internalInstanceHandle,textInstance);return diffHydratedText(textInstance,text);},didNotMatchHydratedContainerTextInstance:function didNotMatchHydratedContainerTextInstance(parentContainer,textInstance,text){{warnForUnmatchedText(textInstance,text);}},didNotMatchHydratedTextInstance:function didNotMatchHydratedTextInstance(parentType,parentProps,parentInstance,textInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForUnmatchedText(textInstance,text);}},didNotHydrateContainerInstance:function didNotHydrateContainerInstance(parentContainer,instance){{if(instance.nodeType===1){warnForDeletedHydratableElement(parentContainer,instance);}else{warnForDeletedHydratableText(parentContainer,instance);}}},didNotHydrateInstance:function didNotHydrateInstance(parentType,parentProps,parentInstance,instance){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){if(instance.nodeType===1){warnForDeletedHydratableElement(parentInstance,instance);}else{warnForDeletedHydratableText(parentInstance,instance);}}},didNotFindHydratableContainerInstance:function didNotFindHydratableContainerInstance(parentContainer,type,props){{warnForInsertedHydratedElement(parentContainer,type,props);}},didNotFindHydratableContainerTextInstance:function didNotFindHydratableContainerTextInstance(parentContainer,text){{warnForInsertedHydratedText(parentContainer,text);}},didNotFindHydratableInstance:function didNotFindHydratableInstance(parentType,parentProps,parentInstance,type,props){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedElement(parentInstance,type,props);}},didNotFindHydratableTextInstance:function didNotFindHydratableTextInstance(parentType,parentProps,parentInstance,text){if(true&&parentProps[SUPPRESS_HYDRATION_WARNING]!==true){warnForInsertedHydratedText(parentInstance,text);}}},scheduleDeferredCallback:rIC,useSyncScheduling:!enableAsyncSchedulingByDefaultInReactDOM});injection$4.injectFiberBatchedUpdates(DOMRenderer.batchedUpdates);var warnedAboutHydrateAPI=false;function renderSubtreeIntoContainer(parentComponent,children,container,forceHydrate,callback){!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;{if(container._reactRootContainer&&container.nodeType!==COMMENT_NODE){var hostInstance=DOMRenderer.findHostInstanceWithNoPortals(container._reactRootContainer.current);if(hostInstance){warning(hostInstance.parentNode===container,'render(...): It looks like the React-rendered content of this '+'container was removed without using React. This is not '+'supported and will cause errors. Instead, call '+'ReactDOM.unmountComponentAtNode to empty a container.');}}var isRootRenderedBySomeReact=!!container._reactRootContainer;var rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(rootEl&&getInstanceFromNode$1(rootEl));warning(!hasNonRootReactChild||isRootRenderedBySomeReact,'render(...): Replacing React-rendered children with a new root '+'component. If you intended to update the children of this node, '+'you should instead have the existing children update their state '+'and render the new components instead of calling ReactDOM.render.');warning(container.nodeType!==ELEMENT_NODE||!container.tagName||container.tagName.toUpperCase()!=='BODY','render(): Rendering components directly into document.body is '+'discouraged, since its children are often manipulated by third-party '+'scripts and browser extensions. This may lead to subtle '+'reconciliation issues. Try rendering into a container element created '+'for your app.');}var root=container._reactRootContainer;if(!root){var shouldHydrate=forceHydrate||shouldHydrateDueToLegacyHeuristic(container);// First clear any existing content.
if(!shouldHydrate){var warned=false;var rootSibling=void 0;while(rootSibling=container.lastChild){{if(!warned&&rootSibling.nodeType===ELEMENT_NODE&&rootSibling.hasAttribute(ROOT_ATTRIBUTE_NAME)){warned=true;warning(false,'render(): Target node has markup rendered by React, but there '+'are unrelated nodes as well. This is most commonly caused by '+'white-space inserted around server-rendered markup.');}}container.removeChild(rootSibling);}}{if(shouldHydrate&&!forceHydrate&&!warnedAboutHydrateAPI){warnedAboutHydrateAPI=true;lowPriorityWarning$1(false,'render(): Calling ReactDOM.render() to hydrate server-rendered markup '+'will stop working in React v17. Replace the ReactDOM.render() call '+'with ReactDOM.hydrate() if you want React to attach to the server HTML.');}}var newRoot=DOMRenderer.createContainer(container,shouldHydrate);root=container._reactRootContainer=newRoot;// Initial mount should not be batched.
DOMRenderer.unbatchedUpdates(function(){DOMRenderer.updateContainer(children,newRoot,parentComponent,callback);});}else{DOMRenderer.updateContainer(children,root,parentComponent,callback);}return DOMRenderer.getPublicRootInstance(root);}function createPortal(children,container){var key=arguments.length>2&&arguments[2]!==undefined?arguments[2]:null;!isValidContainer(container)?invariant(false,'Target container is not a DOM element.'):void 0;// TODO: pass ReactDOM portal implementation as third argument
return createPortal$1(children,container,null,key);}function ReactRoot(container,hydrate){var root=DOMRenderer.createContainer(container,hydrate);this._reactRootContainer=root;}ReactRoot.prototype.render=function(children,callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(children,root,null,callback);};ReactRoot.prototype.unmount=function(callback){var root=this._reactRootContainer;DOMRenderer.updateContainer(null,root,null,callback);};var ReactDOM={createPortal:createPortal,findDOMNode:function findDOMNode(componentOrElement){{var owner=ReactCurrentOwner.current;if(owner!==null){var warnedAboutRefsInRender=owner.stateNode._warnedAboutRefsInRender;warning(warnedAboutRefsInRender,'%s is accessing findDOMNode inside its render(). '+'render() should be a pure function of props and state. It should '+'never access something that requires stale data from the previous '+'render, such as refs. Move this logic to componentDidMount and '+'componentDidUpdate instead.',getComponentName(owner)||'A component');owner.stateNode._warnedAboutRefsInRender=true;}}if(componentOrElement==null){return null;}if(componentOrElement.nodeType===ELEMENT_NODE){return componentOrElement;}var inst=get(componentOrElement);if(inst){return DOMRenderer.findHostInstance(inst);}if(typeof componentOrElement.render==='function'){invariant(false,'Unable to find node on an unmounted component.');}else{invariant(false,'Element appears to be neither ReactComponent nor DOMNode. Keys: %s',Object.keys(componentOrElement));}},hydrate:function hydrate(element,container,callback){// TODO: throw or warn if we couldn't hydrate?
return renderSubtreeIntoContainer(null,element,container,true,callback);},render:function render(element,container,callback){return renderSubtreeIntoContainer(null,element,container,false,callback);},unstable_renderSubtreeIntoContainer:function unstable_renderSubtreeIntoContainer(parentComponent,element,containerNode,callback){!(parentComponent!=null&&has(parentComponent))?invariant(false,'parentComponent must be a valid React Component'):void 0;return renderSubtreeIntoContainer(parentComponent,element,containerNode,false,callback);},unmountComponentAtNode:function unmountComponentAtNode(container){!isValidContainer(container)?invariant(false,'unmountComponentAtNode(...): Target container is not a DOM element.'):void 0;if(container._reactRootContainer){{var rootEl=getReactRootElementInContainer(container);var renderedByDifferentReact=rootEl&&!getInstanceFromNode$1(rootEl);warning(!renderedByDifferentReact,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by another copy of React.');}// Unmount should not be batched.
DOMRenderer.unbatchedUpdates(function(){renderSubtreeIntoContainer(null,null,container,false,function(){container._reactRootContainer=null;});});// If you call unmountComponentAtNode twice in quick succession, you'll
// get `true` twice. That's probably fine?
return true;}else{{var _rootEl=getReactRootElementInContainer(container);var hasNonRootReactChild=!!(_rootEl&&getInstanceFromNode$1(_rootEl));// Check if the container itself is a React root node.
var isContainerReactRoot=container.nodeType===1&&isValidContainer(container.parentNode)&&!!container.parentNode._reactRootContainer;warning(!hasNonRootReactChild,"unmountComponentAtNode(): The node you're attempting to unmount "+'was rendered by React and is not a top-level container. %s',isContainerReactRoot?'You may have accidentally passed in a React root node instead '+'of its container.':'Instead, have the parent component update its state and '+'rerender in order to remove this component.');}return false;}},// Temporary alias since we already shipped React 16 RC with it.
// TODO: remove in React 17.
unstable_createPortal:createPortal,unstable_batchedUpdates:batchedUpdates,unstable_deferredUpdates:DOMRenderer.deferredUpdates,flushSync:DOMRenderer.flushSync,__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED:{// For TapEventPlugin which is popular in open source
EventPluginHub:EventPluginHub,// Used by test-utils
EventPluginRegistry:EventPluginRegistry,EventPropagators:EventPropagators,ReactControlledComponent:ReactControlledComponent,ReactDOMComponentTree:ReactDOMComponentTree,ReactDOMEventListener:ReactDOMEventListener}};if(enableCreateRoot){ReactDOM.createRoot=function createRoot(container,options){var hydrate=options!=null&&options.hydrate===true;return new ReactRoot(container,hydrate);};}var foundDevTools=DOMRenderer.injectIntoDevTools({findFiberByHostInstance:getClosestInstanceFromNode,bundleType:1,version:ReactVersion,rendererPackageName:'react-dom'});{if(!foundDevTools&&ExecutionEnvironment.canUseDOM&&window.top===window.self){// If we're in Chrome or Firefox, provide a download link if not installed.
if(navigator.userAgent.indexOf('Chrome')>-1&&navigator.userAgent.indexOf('Edge')===-1||navigator.userAgent.indexOf('Firefox')>-1){var protocol=window.location.protocol;// Don't warn in exotic cases like chrome-extension://.
if(/^(https?|file):$/.test(protocol)){console.info('%cDownload the React DevTools '+'for a better development experience: '+'https://fb.me/react-devtools'+(protocol==='file:'?'\nYou might need to use a local HTTP server (instead of file://): '+'https://fb.me/react-devtools-faq':''),'font-weight:bold');}}}}var ReactDOM$2=Object.freeze({default:ReactDOM});var ReactDOM$3=ReactDOM$2&&ReactDOM||ReactDOM$2;// TODO: decide on the top-level export form.
// This is hacky but makes it work with both Rollup and Jest.
var reactDom=ReactDOM$3['default']?ReactDOM$3['default']:ReactDOM$3;module.exports=reactDom;})();}
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var hyphenate = __webpack_require__(32);

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;

/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;

/***/ }),
/* 33 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */



var camelize = __webpack_require__(34);

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;

/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _axios = __webpack_require__(36);

var _axios2 = _interopRequireDefault(_axios);

var _basicinfo = __webpack_require__(55);

var _basicinfo2 = _interopRequireDefault(_basicinfo);

var _bio = __webpack_require__(56);

var _bio2 = _interopRequireDefault(_bio);

var _techskills = __webpack_require__(57);

var _techskills2 = _interopRequireDefault(_techskills);

var _experience = __webpack_require__(59);

var _experience2 = _interopRequireDefault(_experience);

var _projects = __webpack_require__(61);

var _projects2 = _interopRequireDefault(_projects);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var App = function (_Component) {
  _inherits(App, _Component);

  function App(props) {
    _classCallCheck(this, App);

    var _this = _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).call(this, props));

    _this.state = {
      data: {}
    };

    _this.loadCommentsFromServer = _this.loadCommentsFromServer.bind(_this);

    return _this;
  }

  _createClass(App, [{
    key: 'loadCommentsFromServer',
    value: function loadCommentsFromServer() {
      var _this2 = this;

      _axios2.default.get(this.props.url).then(function (res) {
        _this2.setState({ data: res.data[0] });
      });
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.loadCommentsFromServer();
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'wrapper' },
        _react2.default.createElement(_basicinfo2.default, { info: this.state.data.basicinfo }),
        _react2.default.createElement(_bio2.default, { info: this.state.data.bio }),
        _react2.default.createElement(_techskills2.default, { info: this.state.data.skills }),
        _react2.default.createElement(_experience2.default, { info: this.state.data.experience }),
        _react2.default.createElement(_projects2.default, { info: this.state.data.projects })
      );
    }
  }]);

  return App;
}(_react.Component);

exports.default = App;

/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__(37);

/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);
var bind = __webpack_require__(18);
var Axios = __webpack_require__(39);
var defaults = __webpack_require__(11);

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__(22);
axios.CancelToken = __webpack_require__(53);
axios.isCancel = __webpack_require__(21);

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__(54);

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__(11);
var utils = __webpack_require__(2);
var InterceptorManager = __webpack_require__(48);
var dispatchRequest = __webpack_require__(49);

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__(20);

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),
/* 48 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);
var transformData = __webpack_require__(50);
var isCancel = __webpack_require__(21);
var defaults = __webpack_require__(11);
var isAbsoluteURL = __webpack_require__(51);
var combineURLs = __webpack_require__(52);

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(2);

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__(22);

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BasicInfo = function BasicInfo(props) {

  if (!props.info) {
    return _react2.default.createElement(
      "div",
      null,
      "Loading ",
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  $(function () {
    $('[data-toggle="tooltip"]').tooltip({
      html: true
    });
  });

  var tooltipText = "This CV has been build with MongoDB, Express, React and Node";

  return _react2.default.createElement(
    "div",
    { className: "component-container" },
    _react2.default.createElement(
      "a",
      { href: "/docs/Max__Golubev_CV.docx", className: "download-icon", "data-toggle": "tooltip", "data-placement": "left", title: "download cv.docx" },
      _react2.default.createElement("i", { className: "fa fa-download fa-2x", "aria-hidden": "true" })
    ),
    _react2.default.createElement(
      "a",
      { className: "info", href: "https://github.com/MaxGol/CV_HEROKU", "data-toggle": "tooltip", "data-placement": "left", title: tooltipText },
      _react2.default.createElement("span", { className: "fa fa-2x fa-github" })
    ),
    _react2.default.createElement(
      "div",
      { className: "row" },
      _react2.default.createElement(
        "div",
        { className: "col-xs-12" },
        _react2.default.createElement("img", { src: "/images/max.png", className: "img-circle center-block" }),
        _react2.default.createElement(
          "h4",
          { className: "text-center" },
          props.info.name
        ),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.title
          )
        ),
        _react2.default.createElement("hr", { className: "small-divider" }),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.address
          )
        ),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            props.info.email
          )
        ),
        _react2.default.createElement("hr", { className: "small-divider" }),
        _react2.default.createElement(
          "p",
          { className: "text-center" },
          _react2.default.createElement(
            "strong",
            null,
            "07739 365430"
          )
        )
      )
    )
  );
};

exports.default = BasicInfo;

/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Bio = function Bio(props) {

  if (!props.info) {
    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  return _react2.default.createElement(
    "div",
    { className: "component-container" },
    _react2.default.createElement(
      "div",
      { className: "row" },
      _react2.default.createElement(
        "div",
        { className: "col-xs-12" },
        _react2.default.createElement(
          "h4",
          { className: "section-title" },
          props.info.title
        ),
        _react2.default.createElement("hr", { className: "normal-divider" }),
        _react2.default.createElement(
          "p",
          null,
          props.info.about_me
        )
      )
    )
  );
};

exports.default = Bio;

/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _skillslist = __webpack_require__(58);

var _skillslist2 = _interopRequireDefault(_skillslist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TechSkills = function TechSkills(props) {

  if (!props.info) {
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('i', { className: 'fa fa-spinner fa-spin', 'aria-hidden': 'true' })
    );
  }

  var skillList = Object.keys(props.info.skills_stack).map(function (skillname, index) {
    return _react2.default.createElement(_skillslist2.default, { key: index, name: skillname, skills: props.info.skills_stack[skillname] });
  });

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          props.info.title
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' }),
        skillList
      )
    )
  );
};

exports.default = TechSkills;

/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SkillsList = function SkillsList(props) {

  if (!props.skills) {
    return _react2.default.createElement(
      "div",
      null,
      _react2.default.createElement("i", { className: "fa fa-spinner fa-spin", "aria-hidden": "true" })
    );
  }

  var skillsItems = props.skills.map(function (item) {
    if (props.skills.indexOf(item) === props.skills.length - 1) {
      return item;
    } else {
      return item + ', ';
    }
  });

  return _react2.default.createElement(
    "div",
    { className: "row" },
    _react2.default.createElement(
      "div",
      { className: "col-sm-2 text-right hidden-xs" },
      _react2.default.createElement(
        "strong",
        null,
        props.name,
        ":"
      )
    ),
    _react2.default.createElement(
      "div",
      { className: "col-sm-2 visible-xs" },
      _react2.default.createElement(
        "strong",
        null,
        props.name,
        ":"
      )
    ),
    _react2.default.createElement(
      "div",
      { className: "col-sm-10" },
      skillsItems
    )
  );
};

exports.default = SkillsList;

/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _experienselist = __webpack_require__(60);

var _experienselist2 = _interopRequireDefault(_experienselist);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Experience = function Experience(props) {

  if (!props.info) {
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('i', { className: 'fa fa-spinner fa-spin', 'aria-hidden': 'true' })
    );
  }

  var experienceListItem = props.info.work.map(function (item, index) {
    return _react2.default.createElement(_experienselist2.default, { key: index, work: item });
  });

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          props.info.title
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' }),
        experienceListItem
      )
    )
  );
};

exports.default = Experience;

/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ExperienceItem = function ExperienceItem(props) {

  var duty = props.work.duty.map(function (itemduty, index) {
    return _react2.default.createElement(
      "li",
      { key: index },
      itemduty
    );
  });

  return _react2.default.createElement(
    "div",
    { className: "row work-info" },
    _react2.default.createElement(
      "div",
      { className: "col-xs-12 col-sm-3 exp-time" },
      _react2.default.createElement(
        "strong",
        null,
        props.work.time
      )
    ),
    _react2.default.createElement(
      "div",
      { className: "col-xs-12 col-sm-9" },
      _react2.default.createElement(
        "h4",
        null,
        props.work.company
      ),
      _react2.default.createElement(
        "p",
        null,
        props.work.overview
      ),
      _react2.default.createElement(
        "h5",
        null,
        _react2.default.createElement(
          "strong",
          null,
          props.work.jobtitle
        )
      ),
      _react2.default.createElement(
        "ul",
        null,
        duty
      )
    )
  );
};

exports.default = ExperienceItem;

/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = __webpack_require__(0);

var _react2 = _interopRequireDefault(_react);

var _reactOwlCarousel = __webpack_require__(62);

var _reactOwlCarousel2 = _interopRequireDefault(_reactOwlCarousel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Projects = function Projects(props) {

  if (!props.info) {
    return _react2.default.createElement(
      'div',
      null,
      _react2.default.createElement('i', { className: 'fa fa-spinner fa-spin', 'aria-hidden': 'true' })
    );
  }

  var options = {
    items: 4,
    nav: true,
    rewind: true,
    responsive: {
      0: {
        items: 1,
        nav: true
      },
      600: {
        items: 3,
        nav: true
      },
      1000: {
        items: 4,
        nav: true
      }
    }
  };

  return _react2.default.createElement(
    'div',
    { className: 'component-container' },
    _react2.default.createElement(
      'div',
      { className: 'row' },
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          'h4',
          { className: 'section-title' },
          props.info.title
        ),
        _react2.default.createElement('hr', { className: 'normal-divider' })
      ),
      _react2.default.createElement(
        'div',
        { className: 'col-xs-12' },
        _react2.default.createElement(
          _reactOwlCarousel2.default,
          { options: options },
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/home', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Lemonade',
                  _react2.default.createElement('br', null),
                  ' Money'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonadereward.com', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Lemonade',
                  _react2.default.createElement('br', null),
                  ' Reward'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/budget/income', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Budget',
                  _react2.default.createElement('br', null),
                  ' Calculator'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/financial-health-check/income', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Financial',
                  _react2.default.createElement('br', null),
                  ' Health'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://siemens.lemonadereward.com/DIGITAL/PAGES/pension_modeller/', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Pension',
                  _react2.default.createElement('br', null),
                  ' Moduller'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'http://lemonademoney.com/mortgage-app/which-property', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Mortgage',
                  _react2.default.createElement('br', null),
                  ' Calculator'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/react-cards', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'Credit',
                  _react2.default.createElement('br', null),
                  ' (React)'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/CV_HEROKU', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'CV',
                  _react2.default.createElement('br', null),
                  '(React)'
                )
              )
            )
          ),
          _react2.default.createElement(
            'div',
            { className: 'image-cor center-block' },
            _react2.default.createElement(
              'a',
              { href: 'https://github.com/MaxGol/MERN', target: '_blank' },
              _react2.default.createElement(
                'div',
                { className: 'inner-image-cor' },
                _react2.default.createElement(
                  'strong',
                  null,
                  'MERN',
                  _react2.default.createElement('br', null),
                  ' (React)'
                )
              )
            )
          )
        )
      )
    )
  );
};

exports.default = Projects;

/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function webpackUniversalModuleDefinition(root, factory) {
	if (( false ? 'undefined' : _typeof(exports)) === 'object' && ( false ? 'undefined' : _typeof(module)) === 'object') module.exports = factory(__webpack_require__(23), __webpack_require__(0), __webpack_require__(10));else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(23), __webpack_require__(0), __webpack_require__(10)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));else if ((typeof exports === 'undefined' ? 'undefined' : _typeof(exports)) === 'object') exports["react-owl-carousel2"] = factory(require("prop-types"), require("react"), require("react-dom"));else root["react-owl-carousel2"] = factory(root["PropTypes"], root["React"], root["ReactDOM"]);
})(undefined, function (__WEBPACK_EXTERNAL_MODULE_6__, __WEBPACK_EXTERNAL_MODULE_7__, __WEBPACK_EXTERNAL_MODULE_8__) {
	return (/******/function (modules) {
			// webpackBootstrap
			/******/ // The module cache
			/******/var installedModules = {};

			/******/ // The require function
			/******/function __webpack_require__(moduleId) {

				/******/ // Check if module is in cache
				/******/if (installedModules[moduleId])
					/******/return installedModules[moduleId].exports;

				/******/ // Create a new module (and put it into the cache)
				/******/var module = installedModules[moduleId] = {
					/******/exports: {},
					/******/id: moduleId,
					/******/loaded: false
					/******/ };

				/******/ // Execute the module function
				/******/modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

				/******/ // Flag the module as loaded
				/******/module.loaded = true;

				/******/ // Return the exports of the module
				/******/return module.exports;
				/******/
			}

			/******/ // expose the modules object (__webpack_modules__)
			/******/__webpack_require__.m = modules;

			/******/ // expose the module cache
			/******/__webpack_require__.c = installedModules;

			/******/ // __webpack_public_path__
			/******/__webpack_require__.p = "";

			/******/ // Load entry module and return exports
			/******/return __webpack_require__(0);
			/******/
		}(
		/************************************************************************/
		/******/[
		/* 0 */
		/***/function (module, exports, __webpack_require__) {

			eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\nvar _react = __webpack_require__(7);\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _reactDom = __webpack_require__(8);\n\nvar _propTypes = __webpack_require__(6);\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\n__webpack_require__(5);\n\n__webpack_require__(1);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\nvar owlCarouselOptions = {\n\tcore: ['items', 'loop', 'center', 'rewind', 'mouseDrag', 'touchDrag', 'pullDrag', 'freeDrag', 'margin', 'stagePadding', 'merge', 'mergeFit', 'autoWidth', 'startPosition', 'rtl', 'smartSpeed', 'fluidSpeed', 'dragEndSpeed', 'responsive', 'responsiveRefreshRate', 'responsiveBaseElement', 'fallbackEasing', 'info', 'nestedItemSelector', 'itemElement', 'stageElement', 'refreshClass', 'loadedClass', 'loadingClass', 'rtlClass', 'responsiveClass', 'dragClass', 'itemClass', 'stageClass', 'stageOuterClass', 'grabClass'],\n\tautorefresh: ['autoRefresh', 'autoRefreshInterval'],\n\tlazy: ['lazyLoad'],\n\tautoHeight: ['autoHeight', 'autoHeightClass'],\n\tvideo: ['video', 'videoHeight', 'videoWidth'],\n\tanimate: ['animateOut', 'animateIn'],\n\tautoplay: ['autoplay', 'autoplayTimeout', 'autoplayHoverPause', 'autoplaySpeed'],\n\tnavigation: ['nav', 'navText', 'navSpeed', 'navElement', 'navContainer', 'navContainerClass', 'navClass', 'slideBy', 'dotClass', 'dotsClass', 'dots', 'dotsEach', 'dotsData', 'dotsSpeed', 'dotsContainer'],\n\thash: ['URLhashListener']\n};\n\nvar owlCarouselEvents = {\n\tcore: ['onInitialize', 'onInitialized', 'onResize', 'onResized', 'onRefresh', 'onRefreshed', 'onDrag', 'onDragged', 'onTranslate', 'onTranslated', 'onChange', 'onChanged'],\n\tlazy: ['onLoadLazy', 'onLoadedLazy'],\n\tvideo: ['onStopVideo', 'onPlayVideo']\n};\n\nvar OwlCarousel = function (_React$Component) {\n\t_inherits(OwlCarousel, _React$Component);\n\n\tfunction OwlCarousel(props, context) {\n\t\t_classCallCheck(this, OwlCarousel);\n\n\t\tvar _this = _possibleConstructorReturn(this, (OwlCarousel.__proto__ || Object.getPrototypeOf(OwlCarousel)).call(this, props, context));\n\n\t\t_this.onTranslate = function (next) {\n\t\t\treturn function (event) {\n\t\t\t\t_this.currentPosition = event.item.index;\n\t\t\t\tif (next) next(event);\n\t\t\t};\n\t\t};\n\n\t\t_this.next = function () {\n\t\t\treturn _this.$car.next();\n\t\t};\n\t\t_this.prev = function () {\n\t\t\treturn _this.$car.prev();\n\t\t};\n\t\t_this.goTo = function (x) {\n\t\t\treturn _this.$car.to(x);\n\t\t};\n\n\t\t_this.currentPosition = 0;\n\t\t_this.onTranslate = _this.onTranslate.bind(_this);\n\t\treturn _this;\n\t}\n\n\t_createClass(OwlCarousel, [{\n\t\tkey: 'componentDidMount',\n\t\tvalue: function componentDidMount() {\n\t\t\tthis.$node = $((0, _reactDom.findDOMNode)(this));\n\t\t\tvar options = this.getOptions();\n\t\t\tthis.init(options);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillReceiveProps',\n\t\tvalue: function componentWillReceiveProps(nextProps) {\n\t\t\tthis.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'componentDidUpdate',\n\t\tvalue: function componentDidUpdate(prevProps, prevState) {\n\t\t\tvar options = this.getOptions();\n\t\t\toptions.startPosition = this.currentPosition;\n\t\t\tthis.init(options);\n\t\t}\n\t}, {\n\t\tkey: 'componentWillUnmount',\n\t\tvalue: function componentWillUnmount() {\n\t\t\tthis.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'init',\n\t\tvalue: function init(options) {\n\t\t\tvar next = options.onTranslate;\n\t\t\toptions.onTranslate = this.onTranslate(next);\n\t\t\tthis.$node.owlCarousel(options);\n\t\t\tthis.$car = this.$node.data('owl.carousel');\n\t\t}\n\t}, {\n\t\tkey: 'destroy',\n\t\tvalue: function destroy() {\n\t\t\tthis.$car.destroy();\n\t\t}\n\t}, {\n\t\tkey: 'getOptions',\n\t\tvalue: function getOptions() {\n\t\t\tvar _this2 = this;\n\n\t\t\tvar options = {};\n\n\t\t\tvar carOptions = Object.values(owlCarouselOptions).reduce(function (a, v) {\n\t\t\t\treturn a.concat(v);\n\t\t\t}, []);\n\n\t\t\tcarOptions.forEach(function (val) {\n\t\t\t\tif (val in _this2.props.options) options[val] = _this2.props.options[val];\n\t\t\t});\n\n\t\t\tvar carEvents = Object.values(owlCarouselEvents).reduce(function (a, v) {\n\t\t\t\treturn a.concat(v);\n\t\t\t}, []);\n\n\t\t\tcarEvents.forEach(function (val) {\n\t\t\t\tif (val in _this2.props.events) options[val] = _this2.props.events[val];\n\t\t\t});\n\n\t\t\treturn options;\n\t\t}\n\t}, {\n\t\tkey: 'render',\n\t\tvalue: function render() {\n\t\t\tvar _props = this.props,\n\t\t\t    options = _props.options,\n\t\t\t    events = _props.events,\n\t\t\t    children = _props.children,\n\t\t\t    props = _objectWithoutProperties(_props, ['options', 'events', 'children']);\n\n\t\t\treturn _react2.default.createElement(\n\t\t\t\t'div',\n\t\t\t\t_extends({ className: 'owl-carousel owl-theme' }, props),\n\t\t\t\tchildren\n\t\t\t);\n\t\t}\n\t}]);\n\n\treturn OwlCarousel;\n}(_react2.default.Component);\n\nOwlCarousel.propTypes = {\n\tchildren: _propTypes2.default.oneOfType([_propTypes2.default.element, _propTypes2.default.arrayOf(_propTypes2.default.element.isRequired)]).isRequired,\n\n\tstyle: _propTypes2.default.object,\n\tid: _propTypes2.default.string,\n\n\toptions: _propTypes2.default.shape({\n\t\t// core\n\t\titems: _propTypes2.default.number,\n\t\tloop: _propTypes2.default.bool,\n\t\tcenter: _propTypes2.default.bool,\n\t\trewind: _propTypes2.default.bool,\n\n\t\tmouseDrag: _propTypes2.default.bool,\n\t\ttouchDrag: _propTypes2.default.bool,\n\t\tpullDrag: _propTypes2.default.bool,\n\t\tfreeDrag: _propTypes2.default.bool,\n\n\t\tmargin: _propTypes2.default.number,\n\t\tstagePadding: _propTypes2.default.number,\n\n\t\tmerge: _propTypes2.default.bool,\n\t\tmergeFit: _propTypes2.default.bool,\n\t\tautoWidth: _propTypes2.default.bool,\n\n\t\tstartPosition: _propTypes2.default.number,\n\t\trtl: _propTypes2.default.bool,\n\n\t\tsmartSpeed: _propTypes2.default.number,\n\t\tfluidSpeed: _propTypes2.default.bool,\n\t\tdragEndSpeed: _propTypes2.default.bool,\n\n\t\tresponsive: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.object]),\n\t\tresponsiveRefreshRate: _propTypes2.default.number,\n\t\tresponsiveBaseElement: _propTypes2.default.object,\n\n\t\tfallbackEasing: _propTypes2.default.string,\n\n\t\tinfo: _propTypes2.default.bool,\n\n\t\tnestedItemSelector: _propTypes2.default.bool,\n\t\titemElement: _propTypes2.default.string,\n\t\tstageElement: _propTypes2.default.string,\n\n\t\trefreshClass: _propTypes2.default.string,\n\t\tloadedClass: _propTypes2.default.string,\n\t\tloadingClass: _propTypes2.default.string,\n\t\trtlClass: _propTypes2.default.string,\n\t\tresponsiveClass: _propTypes2.default.string,\n\t\tdragClass: _propTypes2.default.string,\n\t\titemClass: _propTypes2.default.string,\n\t\tstageClass: _propTypes2.default.string,\n\t\tstageOuterClass: _propTypes2.default.string,\n\t\tgrabClass: _propTypes2.default.string,\n\n\t\t// autoRefresh\n\t\tautoRefresh: _propTypes2.default.bool,\n\t\tautoRefreshInterval: _propTypes2.default.number,\n\n\t\t// lazy\n\t\tlazyLoad: _propTypes2.default.bool,\n\n\t\t// autoHeight\n\t\tautoHeight: _propTypes2.default.bool,\n\t\tautoHeightClass: _propTypes2.default.string,\n\n\t\t// video\n\t\tvideo: _propTypes2.default.bool,\n\t\tvideoHeight: _propTypes2.default.bool,\n\t\tvideoWidth: _propTypes2.default.bool,\n\n\t\t// animate\n\t\tanimateOut: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),\n\t\tanimateIn: _propTypes2.default.oneOfType([_propTypes2.default.bool, _propTypes2.default.string]),\n\n\t\t// autoplay\n\t\tautoplay: _propTypes2.default.bool,\n\t\tautoplayTimeout: _propTypes2.default.number,\n\t\tautoplayHoverPause: _propTypes2.default.bool,\n\t\tautoplaySpeed: _propTypes2.default.bool,\n\n\t\t// navigation\n\t\tnav: _propTypes2.default.bool,\n\t\tnavText: _propTypes2.default.array,\n\t\tnavSpeed: _propTypes2.default.bool,\n\t\tnavElement: _propTypes2.default.string,\n\t\tnavContainer: _propTypes2.default.bool,\n\t\tnavContainerClass: _propTypes2.default.string,\n\t\tnavClass: _propTypes2.default.array,\n\t\tslideBy: _propTypes2.default.number,\n\t\tdotClass: _propTypes2.default.string,\n\t\tdotsClass: _propTypes2.default.string,\n\t\tdots: _propTypes2.default.bool,\n\t\tdotsEach: _propTypes2.default.bool,\n\t\tdotsData: _propTypes2.default.bool,\n\t\tdotsSpeed: _propTypes2.default.bool,\n\t\tdotsContainer: _propTypes2.default.bool,\n\n\t\t// hash\n\t\tURLhashListener: _propTypes2.default.bool\n\t}),\n\n\tevents: _propTypes2.default.shape({\n\t\t// core\n\t\tonInitialize: _propTypes2.default.func,\n\t\tonInitialized: _propTypes2.default.func,\n\t\tonResize: _propTypes2.default.func,\n\t\tonResized: _propTypes2.default.func,\n\t\tonRefresh: _propTypes2.default.func,\n\t\tonRefreshed: _propTypes2.default.func,\n\t\tonDrag: _propTypes2.default.func,\n\t\tonDragged: _propTypes2.default.func,\n\t\tonTranslate: _propTypes2.default.func,\n\t\tonTranslated: _propTypes2.default.func,\n\t\tonChange: _propTypes2.default.func,\n\t\tonChanged: _propTypes2.default.func,\n\n\t\t// lazy\n\t\tonLoadLazy: _propTypes2.default.func,\n\t\tonLoadedLazy: _propTypes2.default.func,\n\n\t\t// video\n\t\tonStopVideo: _propTypes2.default.func,\n\t\tonPlayVideo: _propTypes2.default.func\n\t})\n};\n\nOwlCarousel.defaultProps = {\n\toptions: {},\n\tevents: {}\n};\n\nexports.default = OwlCarousel;\nmodule.exports = exports['default'];\n\n/*****************\n ** WEBPACK FOOTER\n ** ./components/OwlCarousel.jsx\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./components/OwlCarousel.jsx?");

			/***/
		},
		/* 1 */
		/***/function (module, exports) {

			eval("'use strict';\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * Owl Carousel v2.2.1\n * Copyright 2013-2017 David Deutsch\n * Licensed under  ()\n */\n/**\n * Owl carousel\n * @version 2.1.6\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n * @todo Lazy Load Icon\n * @todo prevent animationend bubling\n * @todo itemsScaleUp\n * @todo Test Zepto\n * @todo stagePadding calculate wrong active classes\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates a carousel.\n  * @class The Owl Carousel.\n  * @public\n  * @param {HTMLElement|jQuery} element - The element to create the carousel for.\n  * @param {Object} [options] - The options\n  */\n\tfunction Owl(element, options) {\n\n\t\t/**\n   * Current settings for the carousel.\n   * @public\n   */\n\t\tthis.settings = null;\n\n\t\t/**\n   * Current options set by the caller including defaults.\n   * @public\n   */\n\t\tthis.options = $.extend({}, Owl.Defaults, options);\n\n\t\t/**\n   * Plugin element.\n   * @public\n   */\n\t\tthis.$element = $(element);\n\n\t\t/**\n   * Proxied event handlers.\n   * @protected\n   */\n\t\tthis._handlers = {};\n\n\t\t/**\n   * References to the running plugins of this carousel.\n   * @protected\n   */\n\t\tthis._plugins = {};\n\n\t\t/**\n   * Currently suppressed events to prevent them from beeing retriggered.\n   * @protected\n   */\n\t\tthis._supress = {};\n\n\t\t/**\n   * Absolute current position.\n   * @protected\n   */\n\t\tthis._current = null;\n\n\t\t/**\n   * Animation speed in milliseconds.\n   * @protected\n   */\n\t\tthis._speed = null;\n\n\t\t/**\n   * Coordinates of all items in pixel.\n   * @todo The name of this member is missleading.\n   * @protected\n   */\n\t\tthis._coordinates = [];\n\n\t\t/**\n   * Current breakpoint.\n   * @todo Real media queries would be nice.\n   * @protected\n   */\n\t\tthis._breakpoint = null;\n\n\t\t/**\n   * Current width of the plugin element.\n   */\n\t\tthis._width = null;\n\n\t\t/**\n   * All real items.\n   * @protected\n   */\n\t\tthis._items = [];\n\n\t\t/**\n   * All cloned items.\n   * @protected\n   */\n\t\tthis._clones = [];\n\n\t\t/**\n   * Merge values of all items.\n   * @todo Maybe this could be part of a plugin.\n   * @protected\n   */\n\t\tthis._mergers = [];\n\n\t\t/**\n   * Widths of all items.\n   */\n\t\tthis._widths = [];\n\n\t\t/**\n   * Invalidated parts within the update process.\n   * @protected\n   */\n\t\tthis._invalidated = {};\n\n\t\t/**\n   * Ordered list of workers for the update process.\n   * @protected\n   */\n\t\tthis._pipe = [];\n\n\t\t/**\n   * Current state information for the drag operation.\n   * @todo #261\n   * @protected\n   */\n\t\tthis._drag = {\n\t\t\ttime: null,\n\t\t\ttarget: null,\n\t\t\tpointer: null,\n\t\t\tstage: {\n\t\t\t\tstart: null,\n\t\t\t\tcurrent: null\n\t\t\t},\n\t\t\tdirection: null\n\t\t};\n\n\t\t/**\n   * Current state information and their tags.\n   * @type {Object}\n   * @protected\n   */\n\t\tthis._states = {\n\t\t\tcurrent: {},\n\t\t\ttags: {\n\t\t\t\t'initializing': ['busy'],\n\t\t\t\t'animating': ['busy'],\n\t\t\t\t'dragging': ['interacting']\n\t\t\t}\n\t\t};\n\n\t\t$.each(['onResize', 'onThrottledResize'], $.proxy(function (i, handler) {\n\t\t\tthis._handlers[handler] = $.proxy(this[handler], this);\n\t\t}, this));\n\n\t\t$.each(Owl.Plugins, $.proxy(function (key, plugin) {\n\t\t\tthis._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);\n\t\t}, this));\n\n\t\t$.each(Owl.Workers, $.proxy(function (priority, worker) {\n\t\t\tthis._pipe.push({\n\t\t\t\t'filter': worker.filter,\n\t\t\t\t'run': $.proxy(worker.run, this)\n\t\t\t});\n\t\t}, this));\n\n\t\tthis.setup();\n\t\tthis.initialize();\n\t}\n\n\t/**\n  * Default options for the carousel.\n  * @public\n  */\n\tOwl.Defaults = {\n\t\titems: 3,\n\t\tloop: false,\n\t\tcenter: false,\n\t\trewind: false,\n\n\t\tmouseDrag: true,\n\t\ttouchDrag: true,\n\t\tpullDrag: true,\n\t\tfreeDrag: false,\n\n\t\tmargin: 0,\n\t\tstagePadding: 0,\n\n\t\tmerge: false,\n\t\tmergeFit: true,\n\t\tautoWidth: false,\n\n\t\tstartPosition: 0,\n\t\trtl: false,\n\n\t\tsmartSpeed: 250,\n\t\tfluidSpeed: false,\n\t\tdragEndSpeed: false,\n\n\t\tresponsive: {},\n\t\tresponsiveRefreshRate: 200,\n\t\tresponsiveBaseElement: window,\n\n\t\tfallbackEasing: 'swing',\n\n\t\tinfo: false,\n\n\t\tnestedItemSelector: false,\n\t\titemElement: 'div',\n\t\tstageElement: 'div',\n\n\t\trefreshClass: 'owl-refresh',\n\t\tloadedClass: 'owl-loaded',\n\t\tloadingClass: 'owl-loading',\n\t\trtlClass: 'owl-rtl',\n\t\tresponsiveClass: 'owl-responsive',\n\t\tdragClass: 'owl-drag',\n\t\titemClass: 'owl-item',\n\t\tstageClass: 'owl-stage',\n\t\tstageOuterClass: 'owl-stage-outer',\n\t\tgrabClass: 'owl-grab'\n\t};\n\n\t/**\n  * Enumeration for width.\n  * @public\n  * @readonly\n  * @enum {String}\n  */\n\tOwl.Width = {\n\t\tDefault: 'default',\n\t\tInner: 'inner',\n\t\tOuter: 'outer'\n\t};\n\n\t/**\n  * Enumeration for types.\n  * @public\n  * @readonly\n  * @enum {String}\n  */\n\tOwl.Type = {\n\t\tEvent: 'event',\n\t\tState: 'state'\n\t};\n\n\t/**\n  * Contains all registered plugins.\n  * @public\n  */\n\tOwl.Plugins = {};\n\n\t/**\n  * List of workers involved in the update process.\n  */\n\tOwl.Workers = [{\n\t\tfilter: ['width', 'settings'],\n\t\trun: function run() {\n\t\t\tthis._width = this.$element.width();\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tcache.current = this._items && this._items[this.relative(this._current)];\n\t\t}\n\t}, {\n\t\tfilter: ['items', 'settings'],\n\t\trun: function run() {\n\t\t\tthis.$stage.children('.cloned').remove();\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar margin = this.settings.margin || '',\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    rtl = this.settings.rtl,\n\t\t\t    css = {\n\t\t\t\t'width': 'auto',\n\t\t\t\t'margin-left': rtl ? margin : '',\n\t\t\t\t'margin-right': rtl ? '' : margin\n\t\t\t};\n\n\t\t\t!grid && this.$stage.children().css(css);\n\n\t\t\tcache.css = css;\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin,\n\t\t\t    merge = null,\n\t\t\t    iterator = this._items.length,\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    widths = [];\n\n\t\t\tcache.items = {\n\t\t\t\tmerge: false,\n\t\t\t\twidth: width\n\t\t\t};\n\n\t\t\twhile (iterator--) {\n\t\t\t\tmerge = this._mergers[iterator];\n\t\t\t\tmerge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;\n\n\t\t\t\tcache.items.merge = merge > 1 || cache.items.merge;\n\n\t\t\t\twidths[iterator] = !grid ? this._items[iterator].width() : width * merge;\n\t\t\t}\n\n\t\t\tthis._widths = widths;\n\t\t}\n\t}, {\n\t\tfilter: ['items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar clones = [],\n\t\t\t    items = this._items,\n\t\t\t    settings = this.settings,\n\n\t\t\t// TODO: Should be computed from number of min width items in stage\n\t\t\tview = Math.max(settings.items * 2, 4),\n\t\t\t    size = Math.ceil(items.length / 2) * 2,\n\t\t\t    repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0,\n\t\t\t    append = '',\n\t\t\t    prepend = '';\n\n\t\t\trepeat /= 2;\n\n\t\t\twhile (repeat--) {\n\t\t\t\t// Switch to only using appended clones\n\t\t\t\tclones.push(this.normalize(clones.length / 2, true));\n\t\t\t\tappend = append + items[clones[clones.length - 1]][0].outerHTML;\n\t\t\t\tclones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));\n\t\t\t\tprepend = items[clones[clones.length - 1]][0].outerHTML + prepend;\n\t\t\t}\n\n\t\t\tthis._clones = clones;\n\n\t\t\t$(append).addClass('cloned').appendTo(this.$stage);\n\t\t\t$(prepend).addClass('cloned').prependTo(this.$stage);\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t    size = this._clones.length + this._items.length,\n\t\t\t    iterator = -1,\n\t\t\t    previous = 0,\n\t\t\t    current = 0,\n\t\t\t    coordinates = [];\n\n\t\t\twhile (++iterator < size) {\n\t\t\t\tprevious = coordinates[iterator - 1] || 0;\n\t\t\t\tcurrent = this._widths[this.relative(iterator)] + this.settings.margin;\n\t\t\t\tcoordinates.push(previous + current * rtl);\n\t\t\t}\n\n\t\t\tthis._coordinates = coordinates;\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar padding = this.settings.stagePadding,\n\t\t\t    coordinates = this._coordinates,\n\t\t\t    css = {\n\t\t\t\t'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,\n\t\t\t\t'padding-left': padding || '',\n\t\t\t\t'padding-right': padding || ''\n\t\t\t};\n\n\t\t\tthis.$stage.css(css);\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tvar iterator = this._coordinates.length,\n\t\t\t    grid = !this.settings.autoWidth,\n\t\t\t    items = this.$stage.children();\n\n\t\t\tif (grid && cache.items.merge) {\n\t\t\t\twhile (iterator--) {\n\t\t\t\t\tcache.css.width = this._widths[this.relative(iterator)];\n\t\t\t\t\titems.eq(iterator).css(cache.css);\n\t\t\t\t}\n\t\t\t} else if (grid) {\n\t\t\t\tcache.css.width = cache.items.width;\n\t\t\t\titems.css(cache.css);\n\t\t\t}\n\t\t}\n\t}, {\n\t\tfilter: ['items'],\n\t\trun: function run() {\n\t\t\tthis._coordinates.length < 1 && this.$stage.removeAttr('style');\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'items', 'settings'],\n\t\trun: function run(cache) {\n\t\t\tcache.current = cache.current ? this.$stage.children().index(cache.current) : 0;\n\t\t\tcache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));\n\t\t\tthis.reset(cache.current);\n\t\t}\n\t}, {\n\t\tfilter: ['position'],\n\t\trun: function run() {\n\t\t\tthis.animate(this.coordinates(this._current));\n\t\t}\n\t}, {\n\t\tfilter: ['width', 'position', 'items', 'settings'],\n\t\trun: function run() {\n\t\t\tvar rtl = this.settings.rtl ? 1 : -1,\n\t\t\t    padding = this.settings.stagePadding * 2,\n\t\t\t    begin = this.coordinates(this.current()) + padding,\n\t\t\t    end = begin + this.width() * rtl,\n\t\t\t    inner,\n\t\t\t    outer,\n\t\t\t    matches = [],\n\t\t\t    i,\n\t\t\t    n;\n\n\t\t\tfor (i = 0, n = this._coordinates.length; i < n; i++) {\n\t\t\t\tinner = this._coordinates[i - 1] || 0;\n\t\t\t\touter = Math.abs(this._coordinates[i]) + padding * rtl;\n\n\t\t\t\tif (this.op(inner, '<=', begin) && this.op(inner, '>', end) || this.op(outer, '<', begin) && this.op(outer, '>', end)) {\n\t\t\t\t\tmatches.push(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.$stage.children('.active').removeClass('active');\n\t\t\tthis.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');\n\n\t\t\tif (this.settings.center) {\n\t\t\t\tthis.$stage.children('.center').removeClass('center');\n\t\t\t\tthis.$stage.children().eq(this.current()).addClass('center');\n\t\t\t}\n\t\t}\n\t}];\n\n\t/**\n  * Initializes the carousel.\n  * @protected\n  */\n\tOwl.prototype.initialize = function () {\n\t\tthis.enter('initializing');\n\t\tthis.trigger('initialize');\n\n\t\tthis.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);\n\n\t\tif (this.settings.autoWidth && !this.is('pre-loading')) {\n\t\t\tvar imgs, nestedSelector, width;\n\t\t\timgs = this.$element.find('img');\n\t\t\tnestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;\n\t\t\twidth = this.$element.children(nestedSelector).width();\n\n\t\t\tif (imgs.length && width <= 0) {\n\t\t\t\tthis.preloadAutoWidthImages(imgs);\n\t\t\t}\n\t\t}\n\n\t\tthis.$element.addClass(this.options.loadingClass);\n\n\t\t// HACK: DISABLE SCROLLBAR\n\t\tvar overflowVal = $('body').css('overflow');\n\t\t$('body').css({ 'overflow': 'hidden' });\n\n\t\t// create stage\n\t\tthis.$stage = $('<' + this.settings.stageElement + ' class=\"' + this.settings.stageClass + '\"/>').wrap('<div class=\"' + this.settings.stageOuterClass + '\"/>');\n\n\t\t// append stage\n\t\tthis.$element.append(this.$stage.parent());\n\n\t\t// append content\n\t\tthis.replace(this.$element.children().not(this.$stage.parent()));\n\n\t\t// check visibility\n\t\tif (this.$element.is(':visible')) {\n\t\t\t// update view\n\t\t\tthis.refresh();\n\t\t} else {\n\t\t\t// invalidate width\n\t\t\tthis.invalidate('width');\n\t\t}\n\n\t\t// HACK: RESTORE SCROLLBAR\n\t\t$('body').css({ 'overflow': overflowVal });\n\n\t\tthis.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);\n\n\t\t// register event handlers\n\t\tthis.registerEventHandlers();\n\n\t\tthis.leave('initializing');\n\t\tthis.trigger('initialized');\n\t};\n\n\t/**\n  * Setups the current settings.\n  * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?\n  * @todo Support for media queries by using `matchMedia` would be nice.\n  * @public\n  */\n\tOwl.prototype.setup = function () {\n\t\tvar viewport = this.viewport(),\n\t\t    overwrites = this.options.responsive,\n\t\t    match = -1,\n\t\t    settings = null;\n\n\t\tif (!overwrites) {\n\t\t\tsettings = $.extend({}, this.options);\n\t\t} else {\n\t\t\t$.each(overwrites, function (breakpoint) {\n\t\t\t\tif (breakpoint <= viewport && breakpoint > match) {\n\t\t\t\t\tmatch = Number(breakpoint);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tsettings = $.extend({}, this.options, overwrites[match]);\n\t\t\tif (typeof settings.stagePadding === 'function') {\n\t\t\t\tsettings.stagePadding = settings.stagePadding();\n\t\t\t}\n\t\t\tdelete settings.responsive;\n\n\t\t\t// responsive class\n\t\t\tif (settings.responsiveClass) {\n\t\t\t\tthis.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\\\S+\\\\s', 'g'), '$1' + match));\n\t\t\t}\n\t\t}\n\n\t\tthis.trigger('change', { property: { name: 'settings', value: settings } });\n\t\tthis._breakpoint = match;\n\t\tthis.settings = settings;\n\t\tthis.invalidate('settings');\n\t\tthis.trigger('changed', { property: { name: 'settings', value: this.settings } });\n\t};\n\n\t/**\n  * Updates option logic if necessery.\n  * @protected\n  */\n\tOwl.prototype.optionsLogic = function () {\n\t\tif (this.settings.autoWidth) {\n\t\t\tthis.settings.stagePadding = false;\n\t\t\tthis.settings.merge = false;\n\t\t}\n\t};\n\n\t/**\n  * Prepares an item before add.\n  * @todo Rename event parameter `content` to `item`.\n  * @protected\n  * @returns {jQuery|HTMLElement} - The item container.\n  */\n\tOwl.prototype.prepare = function (item) {\n\t\tvar event = this.trigger('prepare', { content: item });\n\n\t\tif (!event.data) {\n\t\t\tevent.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item);\n\t\t}\n\n\t\tthis.trigger('prepared', { content: event.data });\n\n\t\treturn event.data;\n\t};\n\n\t/**\n  * Updates the view.\n  * @public\n  */\n\tOwl.prototype.update = function () {\n\t\tvar i = 0,\n\t\t    n = this._pipe.length,\n\t\t    filter = $.proxy(function (p) {\n\t\t\treturn this[p];\n\t\t}, this._invalidated),\n\t\t    cache = {};\n\n\t\twhile (i < n) {\n\t\t\tif (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {\n\t\t\t\tthis._pipe[i].run(cache);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\n\t\tthis._invalidated = {};\n\n\t\t!this.is('valid') && this.enter('valid');\n\t};\n\n\t/**\n  * Gets the width of the view.\n  * @public\n  * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.\n  * @returns {Number} - The width of the view in pixel.\n  */\n\tOwl.prototype.width = function (dimension) {\n\t\tdimension = dimension || Owl.Width.Default;\n\t\tswitch (dimension) {\n\t\t\tcase Owl.Width.Inner:\n\t\t\tcase Owl.Width.Outer:\n\t\t\t\treturn this._width;\n\t\t\tdefault:\n\t\t\t\treturn this._width - this.settings.stagePadding * 2 + this.settings.margin;\n\t\t}\n\t};\n\n\t/**\n  * Refreshes the carousel primarily for adaptive purposes.\n  * @public\n  */\n\tOwl.prototype.refresh = function () {\n\t\tthis.enter('refreshing');\n\t\tthis.trigger('refresh');\n\n\t\tthis.setup();\n\n\t\tthis.optionsLogic();\n\n\t\tthis.$element.addClass(this.options.refreshClass);\n\n\t\tthis.update();\n\n\t\tthis.$element.removeClass(this.options.refreshClass);\n\n\t\tthis.leave('refreshing');\n\t\tthis.trigger('refreshed');\n\t};\n\n\t/**\n  * Checks window `resize` event.\n  * @protected\n  */\n\tOwl.prototype.onThrottledResize = function () {\n\t\twindow.clearTimeout(this.resizeTimer);\n\t\tthis.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);\n\t};\n\n\t/**\n  * Checks window `resize` event.\n  * @protected\n  */\n\tOwl.prototype.onResize = function () {\n\t\tif (!this._items.length) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._width === this.$element.width()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (!this.$element.is(':visible')) {\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.enter('resizing');\n\n\t\tif (this.trigger('resize').isDefaultPrevented()) {\n\t\t\tthis.leave('resizing');\n\t\t\treturn false;\n\t\t}\n\n\t\tthis.invalidate('width');\n\n\t\tthis.refresh();\n\n\t\tthis.leave('resizing');\n\t\tthis.trigger('resized');\n\t};\n\n\t/**\n  * Registers event handlers.\n  * @todo Check `msPointerEnabled`\n  * @todo #261\n  * @protected\n  */\n\tOwl.prototype.registerEventHandlers = function () {\n\t\tif ($.support.transition) {\n\t\t\tthis.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));\n\t\t}\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\tthis.on(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tif (this.settings.mouseDrag) {\n\t\t\tthis.$element.addClass(this.options.dragClass);\n\t\t\tthis.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('dragstart.owl.core selectstart.owl.core', function () {\n\t\t\t\treturn false;\n\t\t\t});\n\t\t}\n\n\t\tif (this.settings.touchDrag) {\n\t\t\tthis.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));\n\t\t\tthis.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));\n\t\t}\n\t};\n\n\t/**\n  * Handles `touchstart` and `mousedown` events.\n  * @todo Horizontal swipe threshold as option\n  * @todo #261\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragStart = function (event) {\n\t\tvar stage = null;\n\n\t\tif (event.which === 3) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ($.support.transform) {\n\t\t\tstage = this.$stage.css('transform').replace(/.*\\(|\\)| /g, '').split(',');\n\t\t\tstage = {\n\t\t\t\tx: stage[stage.length === 16 ? 12 : 4],\n\t\t\t\ty: stage[stage.length === 16 ? 13 : 5]\n\t\t\t};\n\t\t} else {\n\t\t\tstage = this.$stage.position();\n\t\t\tstage = {\n\t\t\t\tx: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,\n\t\t\t\ty: stage.top\n\t\t\t};\n\t\t}\n\n\t\tif (this.is('animating')) {\n\t\t\t$.support.transform ? this.animate(stage.x) : this.$stage.stop();\n\t\t\tthis.invalidate('position');\n\t\t}\n\n\t\tthis.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');\n\n\t\tthis.speed(0);\n\n\t\tthis._drag.time = new Date().getTime();\n\t\tthis._drag.target = $(event.target);\n\t\tthis._drag.stage.start = stage;\n\t\tthis._drag.stage.current = stage;\n\t\tthis._drag.pointer = this.pointer(event);\n\n\t\t$(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));\n\n\t\t$(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function (event) {\n\t\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event));\n\n\t\t\t$(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));\n\n\t\t\tif (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tevent.preventDefault();\n\n\t\t\tthis.enter('dragging');\n\t\t\tthis.trigger('drag');\n\t\t}, this));\n\t};\n\n\t/**\n  * Handles the `touchmove` and `mousemove` events.\n  * @todo #261\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragMove = function (event) {\n\t\tvar minimum = null,\n\t\t    maximum = null,\n\t\t    pull = null,\n\t\t    delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t    stage = this.difference(this._drag.stage.start, delta);\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif (this.settings.loop) {\n\t\t\tminimum = this.coordinates(this.minimum());\n\t\t\tmaximum = this.coordinates(this.maximum() + 1) - minimum;\n\t\t\tstage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum;\n\t\t} else {\n\t\t\tminimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());\n\t\t\tmaximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());\n\t\t\tpull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;\n\t\t\tstage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);\n\t\t}\n\n\t\tthis._drag.stage.current = stage;\n\n\t\tthis.animate(stage.x);\n\t};\n\n\t/**\n  * Handles the `touchend` and `mouseup` events.\n  * @todo #261\n  * @todo Threshold for click event\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onDragEnd = function (event) {\n\t\tvar delta = this.difference(this._drag.pointer, this.pointer(event)),\n\t\t    stage = this._drag.stage.current,\n\t\t    direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';\n\n\t\t$(document).off('.owl.core');\n\n\t\tthis.$element.removeClass(this.options.grabClass);\n\n\t\tif (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {\n\t\t\tthis.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);\n\t\t\tthis.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));\n\t\t\tthis.invalidate('position');\n\t\t\tthis.update();\n\n\t\t\tthis._drag.direction = direction;\n\n\t\t\tif (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {\n\t\t\t\tthis._drag.target.one('click.owl.core', function () {\n\t\t\t\t\treturn false;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (!this.is('dragging')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.leave('dragging');\n\t\tthis.trigger('dragged');\n\t};\n\n\t/**\n  * Gets absolute position of the closest item for a coordinate.\n  * @todo Setting `freeDrag` makes `closest` not reusable. See #165.\n  * @protected\n  * @param {Number} coordinate - The coordinate in pixel.\n  * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.\n  * @return {Number} - The absolute position of the closest item.\n  */\n\tOwl.prototype.closest = function (coordinate, direction) {\n\t\tvar position = -1,\n\t\t    pull = 30,\n\t\t    width = this.width(),\n\t\t    coordinates = this.coordinates();\n\n\t\tif (!this.settings.freeDrag) {\n\t\t\t// check closest item\n\t\t\t$.each(coordinates, $.proxy(function (index, value) {\n\t\t\t\t// on a left pull, check on current index\n\t\t\t\tif (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {\n\t\t\t\t\tposition = index;\n\t\t\t\t\t// on a right pull, check on previous index\n\t\t\t\t\t// to do so, subtract width from value and set position = index + 1\n\t\t\t\t} else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {\n\t\t\t\t\tposition = index + 1;\n\t\t\t\t} else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {\n\t\t\t\t\tposition = direction === 'left' ? index + 1 : index;\n\t\t\t\t}\n\t\t\t\treturn position === -1;\n\t\t\t}, this));\n\t\t}\n\n\t\tif (!this.settings.loop) {\n\t\t\t// non loop boundries\n\t\t\tif (this.op(coordinate, '>', coordinates[this.minimum()])) {\n\t\t\t\tposition = coordinate = this.minimum();\n\t\t\t} else if (this.op(coordinate, '<', coordinates[this.maximum()])) {\n\t\t\t\tposition = coordinate = this.maximum();\n\t\t\t}\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Animates the stage.\n  * @todo #270\n  * @public\n  * @param {Number} coordinate - The coordinate in pixels.\n  */\n\tOwl.prototype.animate = function (coordinate) {\n\t\tvar animate = this.speed() > 0;\n\n\t\tthis.is('animating') && this.onTransitionEnd();\n\n\t\tif (animate) {\n\t\t\tthis.enter('animating');\n\t\t\tthis.trigger('translate');\n\t\t}\n\n\t\tif ($.support.transform3d && $.support.transition) {\n\t\t\tthis.$stage.css({\n\t\t\t\ttransform: 'translate3d(' + coordinate + 'px,0px,0px)',\n\t\t\t\ttransition: this.speed() / 1000 + 's'\n\t\t\t});\n\t\t} else if (animate) {\n\t\t\tthis.$stage.animate({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));\n\t\t} else {\n\t\t\tthis.$stage.css({\n\t\t\t\tleft: coordinate + 'px'\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Checks whether the carousel is in a specific state or not.\n  * @param {String} state - The state to check.\n  * @returns {Boolean} - The flag which indicates if the carousel is busy.\n  */\n\tOwl.prototype.is = function (state) {\n\t\treturn this._states.current[state] && this._states.current[state] > 0;\n\t};\n\n\t/**\n  * Sets the absolute position of the current item.\n  * @public\n  * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.\n  * @returns {Number} - The absolute position of the current item.\n  */\n\tOwl.prototype.current = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._current;\n\t\t}\n\n\t\tif (this._items.length === 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tposition = this.normalize(position);\n\n\t\tif (this._current !== position) {\n\t\t\tvar event = this.trigger('change', { property: { name: 'position', value: position } });\n\n\t\t\tif (event.data !== undefined) {\n\t\t\t\tposition = this.normalize(event.data);\n\t\t\t}\n\n\t\t\tthis._current = position;\n\n\t\t\tthis.invalidate('position');\n\n\t\t\tthis.trigger('changed', { property: { name: 'position', value: this._current } });\n\t\t}\n\n\t\treturn this._current;\n\t};\n\n\t/**\n  * Invalidates the given part of the update routine.\n  * @param {String} [part] - The part to invalidate.\n  * @returns {Array.<String>} - The invalidated parts.\n  */\n\tOwl.prototype.invalidate = function (part) {\n\t\tif ($.type(part) === 'string') {\n\t\t\tthis._invalidated[part] = true;\n\t\t\tthis.is('valid') && this.leave('valid');\n\t\t}\n\t\treturn $.map(this._invalidated, function (v, i) {\n\t\t\treturn i;\n\t\t});\n\t};\n\n\t/**\n  * Resets the absolute position of the current item.\n  * @public\n  * @param {Number} position - The absolute position of the new item.\n  */\n\tOwl.prototype.reset = function (position) {\n\t\tposition = this.normalize(position);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._speed = 0;\n\t\tthis._current = position;\n\n\t\tthis.suppress(['translate', 'translated']);\n\n\t\tthis.animate(this.coordinates(position));\n\n\t\tthis.release(['translate', 'translated']);\n\t};\n\n\t/**\n  * Normalizes an absolute or a relative position of an item.\n  * @public\n  * @param {Number} position - The absolute or relative position to normalize.\n  * @param {Boolean} [relative=false] - Whether the given position is relative or not.\n  * @returns {Number} - The normalized position.\n  */\n\tOwl.prototype.normalize = function (position, relative) {\n\t\tvar n = this._items.length,\n\t\t    m = relative ? 0 : this._clones.length;\n\n\t\tif (!this.isNumeric(position) || n < 1) {\n\t\t\tposition = undefined;\n\t\t} else if (position < 0 || position >= n + m) {\n\t\t\tposition = ((position - m / 2) % n + n) % n + m / 2;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Converts an absolute position of an item into a relative one.\n  * @public\n  * @param {Number} position - The absolute position to convert.\n  * @returns {Number} - The converted position.\n  */\n\tOwl.prototype.relative = function (position) {\n\t\tposition -= this._clones.length / 2;\n\t\treturn this.normalize(position, true);\n\t};\n\n\t/**\n  * Gets the maximum position for the current item.\n  * @public\n  * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n  * @returns {Number}\n  */\n\tOwl.prototype.maximum = function (relative) {\n\t\tvar settings = this.settings,\n\t\t    maximum = this._coordinates.length,\n\t\t    iterator,\n\t\t    reciprocalItemsWidth,\n\t\t    elementWidth;\n\n\t\tif (settings.loop) {\n\t\t\tmaximum = this._clones.length / 2 + this._items.length - 1;\n\t\t} else if (settings.autoWidth || settings.merge) {\n\t\t\titerator = this._items.length;\n\t\t\treciprocalItemsWidth = this._items[--iterator].width();\n\t\t\telementWidth = this.$element.width();\n\t\t\twhile (iterator--) {\n\t\t\t\treciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;\n\t\t\t\tif (reciprocalItemsWidth > elementWidth) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmaximum = iterator + 1;\n\t\t} else if (settings.center) {\n\t\t\tmaximum = this._items.length - 1;\n\t\t} else {\n\t\t\tmaximum = this._items.length - settings.items;\n\t\t}\n\n\t\tif (relative) {\n\t\t\tmaximum -= this._clones.length / 2;\n\t\t}\n\n\t\treturn Math.max(maximum, 0);\n\t};\n\n\t/**\n  * Gets the minimum position for the current item.\n  * @public\n  * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.\n  * @returns {Number}\n  */\n\tOwl.prototype.minimum = function (relative) {\n\t\treturn relative ? 0 : this._clones.length / 2;\n\t};\n\n\t/**\n  * Gets an item at the specified relative position.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n  */\n\tOwl.prototype.items = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._items.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._items[position];\n\t};\n\n\t/**\n  * Gets an item at the specified relative position.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.\n  */\n\tOwl.prototype.mergers = function (position) {\n\t\tif (position === undefined) {\n\t\t\treturn this._mergers.slice();\n\t\t}\n\n\t\tposition = this.normalize(position, true);\n\t\treturn this._mergers[position];\n\t};\n\n\t/**\n  * Gets the absolute positions of clones for an item.\n  * @public\n  * @param {Number} [position] - The relative position of the item.\n  * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.\n  */\n\tOwl.prototype.clones = function (position) {\n\t\tvar odd = this._clones.length / 2,\n\t\t    even = odd + this._items.length,\n\t\t    map = function map(index) {\n\t\t\treturn index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2;\n\t\t};\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._clones, function (v, i) {\n\t\t\t\treturn map(i);\n\t\t\t});\n\t\t}\n\n\t\treturn $.map(this._clones, function (v, i) {\n\t\t\treturn v === position ? map(i) : null;\n\t\t});\n\t};\n\n\t/**\n  * Sets the current animation speed.\n  * @public\n  * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.\n  * @returns {Number} - The current animation speed in milliseconds.\n  */\n\tOwl.prototype.speed = function (speed) {\n\t\tif (speed !== undefined) {\n\t\t\tthis._speed = speed;\n\t\t}\n\n\t\treturn this._speed;\n\t};\n\n\t/**\n  * Gets the coordinate of an item.\n  * @todo The name of this method is missleanding.\n  * @public\n  * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.\n  * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.\n  */\n\tOwl.prototype.coordinates = function (position) {\n\t\tvar multiplier = 1,\n\t\t    newPosition = position - 1,\n\t\t    coordinate;\n\n\t\tif (position === undefined) {\n\t\t\treturn $.map(this._coordinates, $.proxy(function (coordinate, index) {\n\t\t\t\treturn this.coordinates(index);\n\t\t\t}, this));\n\t\t}\n\n\t\tif (this.settings.center) {\n\t\t\tif (this.settings.rtl) {\n\t\t\t\tmultiplier = -1;\n\t\t\t\tnewPosition = position + 1;\n\t\t\t}\n\n\t\t\tcoordinate = this._coordinates[position];\n\t\t\tcoordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;\n\t\t} else {\n\t\t\tcoordinate = this._coordinates[newPosition] || 0;\n\t\t}\n\n\t\tcoordinate = Math.ceil(coordinate);\n\n\t\treturn coordinate;\n\t};\n\n\t/**\n  * Calculates the speed for a translation.\n  * @protected\n  * @param {Number} from - The absolute position of the start item.\n  * @param {Number} to - The absolute position of the target item.\n  * @param {Number} [factor=undefined] - The time factor in milliseconds.\n  * @returns {Number} - The time in milliseconds for the translation.\n  */\n\tOwl.prototype.duration = function (from, to, factor) {\n\t\tif (factor === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed);\n\t};\n\n\t/**\n  * Slides to the specified item.\n  * @public\n  * @param {Number} position - The position of the item.\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.to = function (position, speed) {\n\t\tvar current = this.current(),\n\t\t    revert = null,\n\t\t    distance = position - this.relative(current),\n\t\t    direction = (distance > 0) - (distance < 0),\n\t\t    items = this._items.length,\n\t\t    minimum = this.minimum(),\n\t\t    maximum = this.maximum();\n\n\t\tif (this.settings.loop) {\n\t\t\tif (!this.settings.rewind && Math.abs(distance) > items / 2) {\n\t\t\t\tdistance += direction * -1 * items;\n\t\t\t}\n\n\t\t\tposition = current + distance;\n\t\t\trevert = ((position - minimum) % items + items) % items + minimum;\n\n\t\t\tif (revert !== position && revert - distance <= maximum && revert - distance > 0) {\n\t\t\t\tcurrent = revert - distance;\n\t\t\t\tposition = revert;\n\t\t\t\tthis.reset(current);\n\t\t\t}\n\t\t} else if (this.settings.rewind) {\n\t\t\tmaximum += 1;\n\t\t\tposition = (position % maximum + maximum) % maximum;\n\t\t} else {\n\t\t\tposition = Math.max(minimum, Math.min(maximum, position));\n\t\t}\n\n\t\tthis.speed(this.duration(current, position, speed));\n\t\tthis.current(position);\n\n\t\tif (this.$element.is(':visible')) {\n\t\t\tthis.update();\n\t\t}\n\t};\n\n\t/**\n  * Slides to the next item.\n  * @public\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.next = function (speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) + 1, speed);\n\t};\n\n\t/**\n  * Slides to the previous item.\n  * @public\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  */\n\tOwl.prototype.prev = function (speed) {\n\t\tspeed = speed || false;\n\t\tthis.to(this.relative(this.current()) - 1, speed);\n\t};\n\n\t/**\n  * Handles the end of an animation.\n  * @protected\n  * @param {Event} event - The event arguments.\n  */\n\tOwl.prototype.onTransitionEnd = function (event) {\n\n\t\t// if css2 animation then event object is undefined\n\t\tif (event !== undefined) {\n\t\t\tevent.stopPropagation();\n\n\t\t\t// Catch only owl-stage transitionEnd event\n\t\t\tif ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tthis.leave('animating');\n\t\tthis.trigger('translated');\n\t};\n\n\t/**\n  * Gets viewport width.\n  * @protected\n  * @return {Number} - The width in pixel.\n  */\n\tOwl.prototype.viewport = function () {\n\t\tvar width;\n\t\tif (this.options.responsiveBaseElement !== window) {\n\t\t\twidth = $(this.options.responsiveBaseElement).width();\n\t\t} else if (window.innerWidth) {\n\t\t\twidth = window.innerWidth;\n\t\t} else if (document.documentElement && document.documentElement.clientWidth) {\n\t\t\twidth = document.documentElement.clientWidth;\n\t\t} else {\n\t\t\tconsole.warn('Can not detect viewport width.');\n\t\t}\n\t\treturn width;\n\t};\n\n\t/**\n  * Replaces the current content.\n  * @public\n  * @param {HTMLElement|jQuery|String} content - The new content.\n  */\n\tOwl.prototype.replace = function (content) {\n\t\tthis.$stage.empty();\n\t\tthis._items = [];\n\n\t\tif (content) {\n\t\t\tcontent = content instanceof jQuery ? content : $(content);\n\t\t}\n\n\t\tif (this.settings.nestedItemSelector) {\n\t\t\tcontent = content.find('.' + this.settings.nestedItemSelector);\n\t\t}\n\n\t\tcontent.filter(function () {\n\t\t\treturn this.nodeType === 1;\n\t\t}).each($.proxy(function (index, item) {\n\t\t\titem = this.prepare(item);\n\t\t\tthis.$stage.append(item);\n\t\t\tthis._items.push(item);\n\t\t\tthis._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}, this));\n\n\t\tthis.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);\n\n\t\tthis.invalidate('items');\n\t};\n\n\t/**\n  * Adds an item.\n  * @todo Use `item` instead of `content` for the event arguments.\n  * @public\n  * @param {HTMLElement|jQuery|String} content - The item content to add.\n  * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.\n  */\n\tOwl.prototype.add = function (content, position) {\n\t\tvar current = this.relative(this._current);\n\n\t\tposition = position === undefined ? this._items.length : this.normalize(position, true);\n\t\tcontent = content instanceof jQuery ? content : $(content);\n\n\t\tthis.trigger('add', { content: content, position: position });\n\n\t\tcontent = this.prepare(content);\n\n\t\tif (this._items.length === 0 || position === this._items.length) {\n\t\t\tthis._items.length === 0 && this.$stage.append(content);\n\t\t\tthis._items.length !== 0 && this._items[position - 1].after(content);\n\t\t\tthis._items.push(content);\n\t\t\tthis._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t} else {\n\t\t\tthis._items[position].before(content);\n\t\t\tthis._items.splice(position, 0, content);\n\t\t\tthis._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);\n\t\t}\n\n\t\tthis._items[current] && this.reset(this._items[current].index());\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('added', { content: content, position: position });\n\t};\n\n\t/**\n  * Removes an item by its position.\n  * @todo Use `item` instead of `content` for the event arguments.\n  * @public\n  * @param {Number} position - The relative position of the item to remove.\n  */\n\tOwl.prototype.remove = function (position) {\n\t\tposition = this.normalize(position, true);\n\n\t\tif (position === undefined) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.trigger('remove', { content: this._items[position], position: position });\n\n\t\tthis._items[position].remove();\n\t\tthis._items.splice(position, 1);\n\t\tthis._mergers.splice(position, 1);\n\n\t\tthis.invalidate('items');\n\n\t\tthis.trigger('removed', { content: null, position: position });\n\t};\n\n\t/**\n  * Preloads images with auto width.\n  * @todo Replace by a more generic approach\n  * @protected\n  */\n\tOwl.prototype.preloadAutoWidthImages = function (images) {\n\t\timages.each($.proxy(function (i, element) {\n\t\t\tthis.enter('pre-loading');\n\t\t\telement = $(element);\n\t\t\t$(new Image()).one('load', $.proxy(function (e) {\n\t\t\t\telement.attr('src', e.target.src);\n\t\t\t\telement.css('opacity', 1);\n\t\t\t\tthis.leave('pre-loading');\n\t\t\t\t!this.is('pre-loading') && !this.is('initializing') && this.refresh();\n\t\t\t}, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));\n\t\t}, this));\n\t};\n\n\t/**\n  * Destroys the carousel.\n  * @public\n  */\n\tOwl.prototype.destroy = function () {\n\n\t\tthis.$element.off('.owl.core');\n\t\tthis.$stage.off('.owl.core');\n\t\t$(document).off('.owl.core');\n\n\t\tif (this.settings.responsive !== false) {\n\t\t\twindow.clearTimeout(this.resizeTimer);\n\t\t\tthis.off(window, 'resize', this._handlers.onThrottledResize);\n\t\t}\n\n\t\tfor (var i in this._plugins) {\n\t\t\tthis._plugins[i].destroy();\n\t\t}\n\n\t\tthis.$stage.children('.cloned').remove();\n\n\t\tthis.$stage.unwrap();\n\t\tthis.$stage.children().contents().unwrap();\n\t\tthis.$stage.children().unwrap();\n\n\t\tthis.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\\\S+\\\\s', 'g'), '')).removeData('owl.carousel');\n\t};\n\n\t/**\n  * Operators to calculate right-to-left and left-to-right.\n  * @protected\n  * @param {Number} [a] - The left side operand.\n  * @param {String} [o] - The operator.\n  * @param {Number} [b] - The right side operand.\n  */\n\tOwl.prototype.op = function (a, o, b) {\n\t\tvar rtl = this.settings.rtl;\n\t\tswitch (o) {\n\t\t\tcase '<':\n\t\t\t\treturn rtl ? a > b : a < b;\n\t\t\tcase '>':\n\t\t\t\treturn rtl ? a < b : a > b;\n\t\t\tcase '>=':\n\t\t\t\treturn rtl ? a <= b : a >= b;\n\t\t\tcase '<=':\n\t\t\t\treturn rtl ? a >= b : a <= b;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t}\n\t};\n\n\t/**\n  * Attaches to an internal event.\n  * @protected\n  * @param {HTMLElement} element - The event source.\n  * @param {String} event - The event name.\n  * @param {Function} listener - The event handler to attach.\n  * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.\n  */\n\tOwl.prototype.on = function (element, event, listener, capture) {\n\t\tif (element.addEventListener) {\n\t\t\telement.addEventListener(event, listener, capture);\n\t\t} else if (element.attachEvent) {\n\t\t\telement.attachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n  * Detaches from an internal event.\n  * @protected\n  * @param {HTMLElement} element - The event source.\n  * @param {String} event - The event name.\n  * @param {Function} listener - The attached event handler to detach.\n  * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.\n  */\n\tOwl.prototype.off = function (element, event, listener, capture) {\n\t\tif (element.removeEventListener) {\n\t\t\telement.removeEventListener(event, listener, capture);\n\t\t} else if (element.detachEvent) {\n\t\t\telement.detachEvent('on' + event, listener);\n\t\t}\n\t};\n\n\t/**\n  * Triggers a public event.\n  * @todo Remove `status`, `relatedTarget` should be used instead.\n  * @protected\n  * @param {String} name - The event name.\n  * @param {*} [data=null] - The event data.\n  * @param {String} [namespace=carousel] - The event namespace.\n  * @param {String} [state] - The state which is associated with the event.\n  * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.\n  * @returns {Event} - The event arguments.\n  */\n\tOwl.prototype.trigger = function (name, data, namespace, state, enter) {\n\t\tvar status = {\n\t\t\titem: { count: this._items.length, index: this.current() }\n\t\t},\n\t\t    handler = $.camelCase($.grep(['on', name, namespace], function (v) {\n\t\t\treturn v;\n\t\t}).join('-').toLowerCase()),\n\t\t    event = $.Event([name, 'owl', namespace || 'carousel'].join('.').toLowerCase(), $.extend({ relatedTarget: this }, status, data));\n\n\t\tif (!this._supress[name]) {\n\t\t\t$.each(this._plugins, function (name, plugin) {\n\t\t\t\tif (plugin.onTrigger) {\n\t\t\t\t\tplugin.onTrigger(event);\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tthis.register({ type: Owl.Type.Event, name: name });\n\t\t\tthis.$element.trigger(event);\n\n\t\t\tif (this.settings && typeof this.settings[handler] === 'function') {\n\t\t\t\tthis.settings[handler].call(this, event);\n\t\t\t}\n\t\t}\n\n\t\treturn event;\n\t};\n\n\t/**\n  * Enters a state.\n  * @param name - The state name.\n  */\n\tOwl.prototype.enter = function (name) {\n\t\t$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n\t\t\tif (this._states.current[name] === undefined) {\n\t\t\t\tthis._states.current[name] = 0;\n\t\t\t}\n\n\t\t\tthis._states.current[name]++;\n\t\t}, this));\n\t};\n\n\t/**\n  * Leaves a state.\n  * @param name - The state name.\n  */\n\tOwl.prototype.leave = function (name) {\n\t\t$.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {\n\t\t\tthis._states.current[name]--;\n\t\t}, this));\n\t};\n\n\t/**\n  * Registers an event or state.\n  * @public\n  * @param {Object} object - The event or state to register.\n  */\n\tOwl.prototype.register = function (object) {\n\t\tif (object.type === Owl.Type.Event) {\n\t\t\tif (!$.event.special[object.name]) {\n\t\t\t\t$.event.special[object.name] = {};\n\t\t\t}\n\n\t\t\tif (!$.event.special[object.name].owl) {\n\t\t\t\tvar _default = $.event.special[object.name]._default;\n\t\t\t\t$.event.special[object.name]._default = function (e) {\n\t\t\t\t\tif (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {\n\t\t\t\t\t\treturn _default.apply(this, arguments);\n\t\t\t\t\t}\n\t\t\t\t\treturn e.namespace && e.namespace.indexOf('owl') > -1;\n\t\t\t\t};\n\t\t\t\t$.event.special[object.name].owl = true;\n\t\t\t}\n\t\t} else if (object.type === Owl.Type.State) {\n\t\t\tif (!this._states.tags[object.name]) {\n\t\t\t\tthis._states.tags[object.name] = object.tags;\n\t\t\t} else {\n\t\t\t\tthis._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);\n\t\t\t}\n\n\t\t\tthis._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {\n\t\t\t\treturn $.inArray(tag, this._states.tags[object.name]) === i;\n\t\t\t}, this));\n\t\t}\n\t};\n\n\t/**\n  * Suppresses events.\n  * @protected\n  * @param {Array.<String>} events - The events to suppress.\n  */\n\tOwl.prototype.suppress = function (events) {\n\t\t$.each(events, $.proxy(function (index, event) {\n\t\t\tthis._supress[event] = true;\n\t\t}, this));\n\t};\n\n\t/**\n  * Releases suppressed events.\n  * @protected\n  * @param {Array.<String>} events - The events to release.\n  */\n\tOwl.prototype.release = function (events) {\n\t\t$.each(events, $.proxy(function (index, event) {\n\t\t\tdelete this._supress[event];\n\t\t}, this));\n\t};\n\n\t/**\n  * Gets unified pointer coordinates from event.\n  * @todo #261\n  * @protected\n  * @param {Event} - The `mousedown` or `touchstart` event.\n  * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.\n  */\n\tOwl.prototype.pointer = function (event) {\n\t\tvar result = { x: null, y: null };\n\n\t\tevent = event.originalEvent || event || window.event;\n\n\t\tevent = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;\n\n\t\tif (event.pageX) {\n\t\t\tresult.x = event.pageX;\n\t\t\tresult.y = event.pageY;\n\t\t} else {\n\t\t\tresult.x = event.clientX;\n\t\t\tresult.y = event.clientY;\n\t\t}\n\n\t\treturn result;\n\t};\n\n\t/**\n  * Determines if the input is a Number or something that can be coerced to a Number\n  * @protected\n  * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested\n  * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number\n  */\n\tOwl.prototype.isNumeric = function (number) {\n\t\treturn !isNaN(parseFloat(number));\n\t};\n\n\t/**\n  * Gets the difference of two vectors.\n  * @todo #261\n  * @protected\n  * @param {Object} - The first vector.\n  * @param {Object} - The second vector.\n  * @returns {Object} - The difference.\n  */\n\tOwl.prototype.difference = function (first, second) {\n\t\treturn {\n\t\t\tx: first.x - second.x,\n\t\t\ty: first.y - second.y\n\t\t};\n\t};\n\n\t/**\n  * The jQuery Plugin for the Owl Carousel\n  * @todo Navigation plugin `next` and `prev`\n  * @public\n  */\n\t$.fn.owlCarousel = function (option) {\n\t\tvar args = Array.prototype.slice.call(arguments, 1);\n\n\t\treturn this.each(function () {\n\t\t\tvar $this = $(this),\n\t\t\t    data = $this.data('owl.carousel');\n\n\t\t\tif (!data) {\n\t\t\t\tdata = new Owl(this, (typeof option === 'undefined' ? 'undefined' : _typeof(option)) == 'object' && option);\n\t\t\t\t$this.data('owl.carousel', data);\n\n\t\t\t\t$.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function (i, event) {\n\t\t\t\t\tdata.register({ type: Owl.Type.Event, name: event });\n\t\t\t\t\tdata.$element.on(event + '.owl.carousel.core', $.proxy(function (e) {\n\t\t\t\t\t\tif (e.namespace && e.relatedTarget !== this) {\n\t\t\t\t\t\t\tthis.suppress([event]);\n\t\t\t\t\t\t\tdata[event].apply(this, [].slice.call(arguments, 1));\n\t\t\t\t\t\t\tthis.release([event]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}, data));\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tif (typeof option == 'string' && option.charAt(0) !== '_') {\n\t\t\t\tdata[option].apply(data, args);\n\t\t\t}\n\t\t});\n\t};\n\n\t/**\n  * The constructor for the jQuery Plugin\n  * @public\n  */\n\t$.fn.owlCarousel.Constructor = Owl;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoRefresh Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the auto refresh plugin.\n  * @class The Auto Refresh Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar AutoRefresh = function AutoRefresh(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Refresh interval.\n   * @protected\n   * @type {number}\n   */\n\t\tthis._interval = null;\n\n\t\t/**\n   * Whether the element is currently visible or not.\n   * @protected\n   * @type {Boolean}\n   */\n\t\tthis._visible = null;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoRefresh) {\n\t\t\t\t\tthis.watch();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoRefresh.Defaults = {\n\t\tautoRefresh: true,\n\t\tautoRefreshInterval: 500\n\t};\n\n\t/**\n  * Watches the element.\n  */\n\tAutoRefresh.prototype.watch = function () {\n\t\tif (this._interval) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = this._core.$element.is(':visible');\n\t\tthis._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);\n\t};\n\n\t/**\n  * Refreshes the element.\n  */\n\tAutoRefresh.prototype.refresh = function () {\n\t\tif (this._core.$element.is(':visible') === this._visible) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._visible = !this._visible;\n\n\t\tthis._core.$element.toggleClass('owl-hidden', !this._visible);\n\n\t\tthis._visible && this._core.invalidate('width') && this._core.refresh();\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tAutoRefresh.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\twindow.clearInterval(this._interval);\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Lazy Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the lazy plugin.\n  * @class The Lazy Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar Lazy = function Lazy(carousel) {\n\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Already loaded items.\n   * @protected\n   * @type {Array.<jQuery>}\n   */\n\t\tthis._loaded = [];\n\n\t\t/**\n   * Event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!this._core.settings || !this._core.settings.lazyLoad) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (e.property && e.property.name == 'position' || e.type == 'initialized') {\n\t\t\t\t\tvar settings = this._core.settings,\n\t\t\t\t\t    n = settings.center && Math.ceil(settings.items / 2) || settings.items,\n\t\t\t\t\t    i = settings.center && n * -1 || 0,\n\t\t\t\t\t    position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i,\n\t\t\t\t\t    clones = this._core.clones().length,\n\t\t\t\t\t    load = $.proxy(function (i, v) {\n\t\t\t\t\t\tthis.load(v);\n\t\t\t\t\t}, this);\n\n\t\t\t\t\twhile (i++ < n) {\n\t\t\t\t\t\tthis.load(clones / 2 + this._core.relative(position));\n\t\t\t\t\t\tclones && $.each(this._core.clones(this._core.relative(position)), load);\n\t\t\t\t\t\tposition++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set the default options\n\t\tthis._core.options = $.extend({}, Lazy.Defaults, this._core.options);\n\n\t\t// register event handler\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tLazy.Defaults = {\n\t\tlazyLoad: false\n\t};\n\n\t/**\n  * Loads all resources of an item at the specified position.\n  * @param {Number} position - The absolute position of the item.\n  * @protected\n  */\n\tLazy.prototype.load = function (position) {\n\t\tvar $item = this._core.$stage.children().eq(position),\n\t\t    $elements = $item && $item.find('.owl-lazy');\n\n\t\tif (!$elements || $.inArray($item.get(0), this._loaded) > -1) {\n\t\t\treturn;\n\t\t}\n\n\t\t$elements.each($.proxy(function (index, element) {\n\t\t\tvar $element = $(element),\n\t\t\t    image,\n\t\t\t    url = window.devicePixelRatio > 1 && $element.attr('data-src-retina') || $element.attr('data-src');\n\n\t\t\tthis._core.trigger('load', { element: $element, url: url }, 'lazy');\n\n\t\t\tif ($element.is('img')) {\n\t\t\t\t$element.one('load.owl.lazy', $.proxy(function () {\n\t\t\t\t\t$element.css('opacity', 1);\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this)).attr('src', url);\n\t\t\t} else {\n\t\t\t\timage = new Image();\n\t\t\t\timage.onload = $.proxy(function () {\n\t\t\t\t\t$element.css({\n\t\t\t\t\t\t'background-image': 'url(\"' + url + '\")',\n\t\t\t\t\t\t'opacity': '1'\n\t\t\t\t\t});\n\t\t\t\t\tthis._core.trigger('loaded', { element: $element, url: url }, 'lazy');\n\t\t\t\t}, this);\n\t\t\t\timage.src = url;\n\t\t\t}\n\t\t}, this));\n\n\t\tthis._loaded.push($item.get(0));\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tLazy.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis._core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * AutoHeight Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the auto height plugin.\n  * @class The Auto Height Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar AutoHeight = function AutoHeight(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.property.name == 'position') {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'loaded.owl.lazy': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {\n\t\t\t\t\tthis.update();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoHeight.Defaults = {\n\t\tautoHeight: false,\n\t\tautoHeightClass: 'owl-height'\n\t};\n\n\t/**\n  * Updates the view.\n  */\n\tAutoHeight.prototype.update = function () {\n\t\tvar start = this._core._current,\n\t\t    end = start + this._core.settings.items,\n\t\t    visible = this._core.$stage.children().toArray().slice(start, end),\n\t\t    heights = [],\n\t\t    maxheight = 0;\n\n\t\t$.each(visible, function (index, item) {\n\t\t\theights.push($(item).height());\n\t\t});\n\n\t\tmaxheight = Math.max.apply(null, heights);\n\n\t\tthis._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);\n\t};\n\n\tAutoHeight.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Video Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the video plugin.\n  * @class The Video Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\tvar Video = function Video(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Cache all video URLs.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._videos = {};\n\n\t\t/**\n   * Current playing item.\n   * @protected\n   * @type {jQuery}\n   */\n\t\tthis._playing = null;\n\n\t\t/**\n   * All event handlers.\n   * @todo The cloned content removale is too late\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis._core.register({ type: 'state', name: 'playing', tags: ['interacting'] });\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'resize.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.video && this.isInFullScreen()) {\n\t\t\t\t\te.preventDefault();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.is('resizing')) {\n\t\t\t\t\tthis._core.$stage.find('.cloned .owl-video-frame').remove();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position' && this._playing) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (!e.namespace) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tvar $element = $(e.content).find('.owl-video');\n\n\t\t\t\tif ($element.length) {\n\t\t\t\t\t$element.css('display', 'none');\n\t\t\t\t\tthis.fetch($element, $(e.content));\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Video.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\tthis._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function (e) {\n\t\t\tthis.play(e);\n\t\t}, this));\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tVideo.Defaults = {\n\t\tvideo: false,\n\t\tvideoHeight: false,\n\t\tvideoWidth: false\n\t};\n\n\t/**\n  * Gets the video ID and the type (YouTube/Vimeo/vzaar only).\n  * @protected\n  * @param {jQuery} target - The target containing the video data.\n  * @param {jQuery} item - The item containing the video.\n  */\n\tVideo.prototype.fetch = function (target, item) {\n\t\tvar type = function () {\n\t\t\tif (target.attr('data-vimeo-id')) {\n\t\t\t\treturn 'vimeo';\n\t\t\t} else if (target.attr('data-vzaar-id')) {\n\t\t\t\treturn 'vzaar';\n\t\t\t} else {\n\t\t\t\treturn 'youtube';\n\t\t\t}\n\t\t}(),\n\t\t    id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id'),\n\t\t    width = target.attr('data-width') || this._core.settings.videoWidth,\n\t\t    height = target.attr('data-height') || this._core.settings.videoHeight,\n\t\t    url = target.attr('href');\n\n\t\tif (url) {\n\n\t\t\t/*\n   \t\tParses the id's out of the following urls (and probably more):\n   \t\thttps://www.youtube.com/watch?v=:id\n   \t\thttps://youtu.be/:id\n   \t\thttps://vimeo.com/:id\n   \t\thttps://vimeo.com/channels/:channel/:id\n   \t\thttps://vimeo.com/groups/:group/videos/:id\n   \t\thttps://app.vzaar.com/videos/:id\n   \t\t\tVisual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F\n   */\n\n\t\t\tid = url.match(/(http:|https:|)\\/\\/(player.|www.|app.)?(vimeo\\.com|youtu(be\\.com|\\.be|be\\.googleapis\\.com)|vzaar\\.com)\\/(video\\/|videos\\/|embed\\/|channels\\/.+\\/|groups\\/.+\\/|watch\\?v=|v\\/)?([A-Za-z0-9._%-]*)(\\&\\S+)?/);\n\n\t\t\tif (id[3].indexOf('youtu') > -1) {\n\t\t\t\ttype = 'youtube';\n\t\t\t} else if (id[3].indexOf('vimeo') > -1) {\n\t\t\t\ttype = 'vimeo';\n\t\t\t} else if (id[3].indexOf('vzaar') > -1) {\n\t\t\t\ttype = 'vzaar';\n\t\t\t} else {\n\t\t\t\tthrow new Error('Video URL not supported.');\n\t\t\t}\n\t\t\tid = id[6];\n\t\t} else {\n\t\t\tthrow new Error('Missing video URL.');\n\t\t}\n\n\t\tthis._videos[url] = {\n\t\t\ttype: type,\n\t\t\tid: id,\n\t\t\twidth: width,\n\t\t\theight: height\n\t\t};\n\n\t\titem.attr('data-video', url);\n\n\t\tthis.thumbnail(target, this._videos[url]);\n\t};\n\n\t/**\n  * Creates video thumbnail.\n  * @protected\n  * @param {jQuery} target - The target containing the video data.\n  * @param {Object} info - The video info object.\n  * @see `fetch`\n  */\n\tVideo.prototype.thumbnail = function (target, video) {\n\t\tvar tnLink,\n\t\t    icon,\n\t\t    path,\n\t\t    dimensions = video.width && video.height ? 'style=\"width:' + video.width + 'px;height:' + video.height + 'px;\"' : '',\n\t\t    customTn = target.find('img'),\n\t\t    srcType = 'src',\n\t\t    lazyClass = '',\n\t\t    settings = this._core.settings,\n\t\t    create = function create(path) {\n\t\t\ticon = '<div class=\"owl-video-play-icon\"></div>';\n\n\t\t\tif (settings.lazyLoad) {\n\t\t\t\ttnLink = '<div class=\"owl-video-tn ' + lazyClass + '\" ' + srcType + '=\"' + path + '\"></div>';\n\t\t\t} else {\n\t\t\t\ttnLink = '<div class=\"owl-video-tn\" style=\"opacity:1;background-image:url(' + path + ')\"></div>';\n\t\t\t}\n\t\t\ttarget.after(tnLink);\n\t\t\ttarget.after(icon);\n\t\t};\n\n\t\t// wrap video content into owl-video-wrapper div\n\t\ttarget.wrap('<div class=\"owl-video-wrapper\"' + dimensions + '></div>');\n\n\t\tif (this._core.settings.lazyLoad) {\n\t\t\tsrcType = 'data-src';\n\t\t\tlazyClass = 'owl-lazy';\n\t\t}\n\n\t\t// custom thumbnail\n\t\tif (customTn.length) {\n\t\t\tcreate(customTn.attr(srcType));\n\t\t\tcustomTn.remove();\n\t\t\treturn false;\n\t\t}\n\n\t\tif (video.type === 'youtube') {\n\t\t\tpath = \"//img.youtube.com/vi/\" + video.id + \"/hqdefault.jpg\";\n\t\t\tcreate(path);\n\t\t} else if (video.type === 'vimeo') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vimeo.com/api/v2/video/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\tpath = data[0].thumbnail_large;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t} else if (video.type === 'vzaar') {\n\t\t\t$.ajax({\n\t\t\t\ttype: 'GET',\n\t\t\t\turl: '//vzaar.com/api/videos/' + video.id + '.json',\n\t\t\t\tjsonp: 'callback',\n\t\t\t\tdataType: 'jsonp',\n\t\t\t\tsuccess: function success(data) {\n\t\t\t\t\tpath = data.framegrab_url;\n\t\t\t\t\tcreate(path);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t};\n\n\t/**\n  * Stops the current video.\n  * @public\n  */\n\tVideo.prototype.stop = function () {\n\t\tthis._core.trigger('stop', null, 'video');\n\t\tthis._playing.find('.owl-video-frame').remove();\n\t\tthis._playing.removeClass('owl-video-playing');\n\t\tthis._playing = null;\n\t\tthis._core.leave('playing');\n\t\tthis._core.trigger('stopped', null, 'video');\n\t};\n\n\t/**\n  * Starts the current video.\n  * @public\n  * @param {Event} event - The event arguments.\n  */\n\tVideo.prototype.play = function (event) {\n\t\tvar target = $(event.target),\n\t\t    item = target.closest('.' + this._core.settings.itemClass),\n\t\t    video = this._videos[item.attr('data-video')],\n\t\t    width = video.width || '100%',\n\t\t    height = video.height || this._core.$stage.height(),\n\t\t    html;\n\n\t\tif (this._playing) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('playing');\n\t\tthis._core.trigger('play', null, 'video');\n\n\t\titem = this._core.items(this._core.relative(item.index()));\n\n\t\tthis._core.reset(item.index());\n\n\t\tif (video.type === 'youtube') {\n\t\t\thtml = '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"//www.youtube.com/embed/' + video.id + '?autoplay=1&rel=0&v=' + video.id + '\" frameborder=\"0\" allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vimeo') {\n\t\t\thtml = '<iframe src=\"//player.vimeo.com/video/' + video.id + '?autoplay=1\" width=\"' + width + '\" height=\"' + height + '\" frameborder=\"0\" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';\n\t\t} else if (video.type === 'vzaar') {\n\t\t\thtml = '<iframe frameborder=\"0\"' + 'height=\"' + height + '\"' + 'width=\"' + width + '\" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' + 'src=\"//view.vzaar.com/' + video.id + '/player?autoplay=true\"></iframe>';\n\t\t}\n\n\t\t$('<div class=\"owl-video-frame\">' + html + '</div>').insertAfter(item.find('.owl-video'));\n\n\t\tthis._playing = item.addClass('owl-video-playing');\n\t};\n\n\t/**\n  * Checks whether an video is currently in full screen mode or not.\n  * @todo Bad style because looks like a readonly method but changes members.\n  * @protected\n  * @returns {Boolean}\n  */\n\tVideo.prototype.isInFullScreen = function () {\n\t\tvar element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;\n\n\t\treturn element && $(element).parent().hasClass('owl-video-frame');\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tVideo.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tthis._core.$element.off('click.owl.video');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Video = Video;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Animate Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the animate plugin.\n  * @class The Navigation Plugin\n  * @param {Owl} scope - The Owl Carousel\n  */\n\tvar Animate = function Animate(scope) {\n\t\tthis.core = scope;\n\t\tthis.core.options = $.extend({}, Animate.Defaults, this.core.options);\n\t\tthis.swapping = true;\n\t\tthis.previous = undefined;\n\t\tthis.next = undefined;\n\n\t\tthis.handlers = {\n\t\t\t'change.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.previous = this.core.current();\n\t\t\t\t\tthis.next = e.property.value;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.swapping = e.type == 'translated';\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'translate.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {\n\t\t\t\t\tthis.swap();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\tthis.core.$element.on(this.handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAnimate.Defaults = {\n\t\tanimateOut: false,\n\t\tanimateIn: false\n\t};\n\n\t/**\n  * Toggles the animation classes whenever an translations starts.\n  * @protected\n  * @returns {Boolean|undefined}\n  */\n\tAnimate.prototype.swap = function () {\n\n\t\tif (this.core.settings.items !== 1) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!$.support.animation || !$.support.transition) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.core.speed(0);\n\n\t\tvar left,\n\t\t    clear = $.proxy(this.clear, this),\n\t\t    previous = this.core.$stage.children().eq(this.previous),\n\t\t    next = this.core.$stage.children().eq(this.next),\n\t\t    incoming = this.core.settings.animateIn,\n\t\t    outgoing = this.core.settings.animateOut;\n\n\t\tif (this.core.current() === this.previous) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (outgoing) {\n\t\t\tleft = this.core.coordinates(this.previous) - this.core.coordinates(this.next);\n\t\t\tprevious.one($.support.animation.end, clear).css({ 'left': left + 'px' }).addClass('animated owl-animated-out').addClass(outgoing);\n\t\t}\n\n\t\tif (incoming) {\n\t\t\tnext.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);\n\t\t}\n\t};\n\n\tAnimate.prototype.clear = function (e) {\n\t\t$(e.target).css({ 'left': '' }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);\n\t\tthis.core.onTransitionEnd();\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tAnimate.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tfor (handler in this.handlers) {\n\t\t\tthis.core.$element.off(handler, this.handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Animate = Animate;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Autoplay Plugin\n * @version 2.1.0\n * @author Bartosz Wojciechowski\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\t/**\n  * Creates the autoplay plugin.\n  * @class The Autoplay Plugin\n  * @param {Owl} scope - The Owl Carousel\n  */\n\tvar Autoplay = function Autoplay(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * The autoplay timeout.\n   * @type {Timeout}\n   */\n\t\tthis._timeout = null;\n\n\t\t/**\n   * Indicates whenever the autoplay is paused.\n   * @type {Boolean}\n   */\n\t\tthis._paused = false;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'settings') {\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis.play();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.stop();\n\t\t\t\t\t}\n\t\t\t\t} else if (e.namespace && e.property.name === 'position') {\n\t\t\t\t\t//console.log('play?', e);\n\t\t\t\t\tif (this._core.settings.autoplay) {\n\t\t\t\t\t\tthis._setAutoPlayInterval();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.autoplay) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'play.owl.autoplay': $.proxy(function (e, t, s) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.play(t, s);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'stop.owl.autoplay': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tthis.stop();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseover.owl.autoplay': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'mouseleave.owl.autoplay': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchstart.owl.core': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {\n\t\t\t\t\tthis.pause();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'touchend.owl.core': $.proxy(function () {\n\t\t\t\tif (this._core.settings.autoplayHoverPause) {\n\t\t\t\t\tthis.play();\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// register event handlers\n\t\tthis._core.$element.on(this._handlers);\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Autoplay.Defaults, this._core.options);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tAutoplay.Defaults = {\n\t\tautoplay: false,\n\t\tautoplayTimeout: 5000,\n\t\tautoplayHoverPause: false,\n\t\tautoplaySpeed: false\n\t};\n\n\t/**\n  * Starts the autoplay.\n  * @public\n  * @param {Number} [timeout] - The interval before the next animation starts.\n  * @param {Number} [speed] - The animation speed for the animations.\n  */\n\tAutoplay.prototype.play = function (timeout, speed) {\n\t\tthis._paused = false;\n\n\t\tif (this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._core.enter('rotating');\n\n\t\tthis._setAutoPlayInterval();\n\t};\n\n\t/**\n  * Gets a new timeout\n  * @private\n  * @param {Number} [timeout] - The interval before the next animation starts.\n  * @param {Number} [speed] - The animation speed for the animations.\n  * @return {Timeout}\n  */\n\tAutoplay.prototype._getNextTimeout = function (timeout, speed) {\n\t\tif (this._timeout) {\n\t\t\twindow.clearTimeout(this._timeout);\n\t\t}\n\t\treturn window.setTimeout($.proxy(function () {\n\t\t\tif (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tthis._core.next(speed || this._core.settings.autoplaySpeed);\n\t\t}, this), timeout || this._core.settings.autoplayTimeout);\n\t};\n\n\t/**\n  * Sets autoplay in motion.\n  * @private\n  */\n\tAutoplay.prototype._setAutoPlayInterval = function () {\n\t\tthis._timeout = this._getNextTimeout();\n\t};\n\n\t/**\n  * Stops the autoplay.\n  * @public\n  */\n\tAutoplay.prototype.stop = function () {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\twindow.clearTimeout(this._timeout);\n\t\tthis._core.leave('rotating');\n\t};\n\n\t/**\n  * Stops the autoplay.\n  * @public\n  */\n\tAutoplay.prototype.pause = function () {\n\t\tif (!this._core.is('rotating')) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._paused = true;\n\t};\n\n\t/**\n  * Destroys the plugin.\n  */\n\tAutoplay.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\tthis.stop();\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Navigation Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n  * Creates the navigation plugin.\n  * @class The Navigation Plugin\n  * @param {Owl} carousel - The Owl Carousel.\n  */\n\n\tvar Navigation = function Navigation(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Indicates whether the plugin is initialized or not.\n   * @protected\n   * @type {Boolean}\n   */\n\t\tthis._initialized = false;\n\n\t\t/**\n   * The current paging indexes.\n   * @protected\n   * @type {Array}\n   */\n\t\tthis._pages = [];\n\n\t\t/**\n   * All DOM elements of the user interface.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._controls = {};\n\n\t\t/**\n   * Markup for an indicator.\n   * @protected\n   * @type {Array.<String>}\n   */\n\t\tthis._templates = [];\n\n\t\t/**\n   * The carousel element.\n   * @type {jQuery}\n   */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n   * Overridden methods of the carousel.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._overrides = {\n\t\t\tnext: this._core.next,\n\t\t\tprev: this._core.prev,\n\t\t\tto: this._core.to\n\t\t};\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.push('<div class=\"' + this._core.settings.dotClass + '\">' + $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'added.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 0, this._templates.pop());\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'remove.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.dotsData) {\n\t\t\t\t\tthis._templates.splice(e.position, 1);\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name == 'position') {\n\t\t\t\t\tthis.draw();\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && !this._initialized) {\n\t\t\t\t\tthis._core.trigger('initialize', null, 'navigation');\n\t\t\t\t\tthis.initialize();\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._initialized = true;\n\t\t\t\t\tthis._core.trigger('initialized', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'refreshed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._initialized) {\n\t\t\t\t\tthis._core.trigger('refresh', null, 'navigation');\n\t\t\t\t\tthis.update();\n\t\t\t\t\tthis.draw();\n\t\t\t\t\tthis._core.trigger('refreshed', null, 'navigation');\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Navigation.Defaults, this._core.options);\n\n\t\t// register event handlers\n\t\tthis.$element.on(this._handlers);\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  * @todo Rename `slideBy` to `navBy`\n  */\n\tNavigation.Defaults = {\n\t\tnav: false,\n\t\tnavText: ['prev', 'next'],\n\t\tnavSpeed: false,\n\t\tnavElement: 'div',\n\t\tnavContainer: false,\n\t\tnavContainerClass: 'owl-nav',\n\t\tnavClass: ['owl-prev', 'owl-next'],\n\t\tslideBy: 1,\n\t\tdotClass: 'owl-dot',\n\t\tdotsClass: 'owl-dots',\n\t\tdots: true,\n\t\tdotsEach: false,\n\t\tdotsData: false,\n\t\tdotsSpeed: false,\n\t\tdotsContainer: false\n\t};\n\n\t/**\n  * Initializes the layout of the plugin and extends the carousel.\n  * @protected\n  */\n\tNavigation.prototype.initialize = function () {\n\t\tvar override,\n\t\t    settings = this._core.settings;\n\n\t\t// create DOM structure for relative navigation\n\t\tthis._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function (e) {\n\t\t\tthis.prev(settings.navSpeed);\n\t\t}, this));\n\t\tthis._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function (e) {\n\t\t\tthis.next(settings.navSpeed);\n\t\t}, this));\n\n\t\t// create DOM structure for absolute navigation\n\t\tif (!settings.dotsData) {\n\t\t\tthis._templates = [$('<div>').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];\n\t\t}\n\n\t\tthis._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');\n\n\t\tthis._controls.$absolute.on('click', 'div', $.proxy(function (e) {\n\t\t\tvar index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();\n\n\t\t\te.preventDefault();\n\n\t\t\tthis.to(index, settings.dotsSpeed);\n\t\t}, this));\n\n\t\t// override public methods of the carousel\n\t\tfor (override in this._overrides) {\n\t\t\tthis._core[override] = $.proxy(this[override], this);\n\t\t}\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @protected\n  */\n\tNavigation.prototype.destroy = function () {\n\t\tvar handler, control, property, override;\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (control in this._controls) {\n\t\t\tthis._controls[control].remove();\n\t\t}\n\t\tfor (override in this.overides) {\n\t\t\tthis._core[override] = this._overrides[override];\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t/**\n  * Updates the internal state.\n  * @protected\n  */\n\tNavigation.prototype.update = function () {\n\t\tvar i,\n\t\t    j,\n\t\t    k,\n\t\t    lower = this._core.clones().length / 2,\n\t\t    upper = lower + this._core.items().length,\n\t\t    maximum = this._core.maximum(true),\n\t\t    settings = this._core.settings,\n\t\t    size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;\n\n\t\tif (settings.slideBy !== 'page') {\n\t\t\tsettings.slideBy = Math.min(settings.slideBy, settings.items);\n\t\t}\n\n\t\tif (settings.dots || settings.slideBy == 'page') {\n\t\t\tthis._pages = [];\n\n\t\t\tfor (i = lower, j = 0, k = 0; i < upper; i++) {\n\t\t\t\tif (j >= size || j === 0) {\n\t\t\t\t\tthis._pages.push({\n\t\t\t\t\t\tstart: Math.min(maximum, i - lower),\n\t\t\t\t\t\tend: i - lower + size - 1\n\t\t\t\t\t});\n\t\t\t\t\tif (Math.min(maximum, i - lower) === maximum) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tj = 0, ++k;\n\t\t\t\t}\n\t\t\t\tj += this._core.mergers(this._core.relative(i));\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n  * Draws the user interface.\n  * @todo The option `dotsData` wont work.\n  * @protected\n  */\n\tNavigation.prototype.draw = function () {\n\t\tvar difference,\n\t\t    settings = this._core.settings,\n\t\t    disabled = this._core.items().length <= settings.items,\n\t\t    index = this._core.relative(this._core.current()),\n\t\t    loop = settings.loop || settings.rewind;\n\n\t\tthis._controls.$relative.toggleClass('disabled', !settings.nav || disabled);\n\n\t\tif (settings.nav) {\n\t\t\tthis._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));\n\t\t\tthis._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));\n\t\t}\n\n\t\tthis._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);\n\n\t\tif (settings.dots) {\n\t\t\tdifference = this._pages.length - this._controls.$absolute.children().length;\n\n\t\t\tif (settings.dotsData && difference !== 0) {\n\t\t\t\tthis._controls.$absolute.html(this._templates.join(''));\n\t\t\t} else if (difference > 0) {\n\t\t\t\tthis._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));\n\t\t\t} else if (difference < 0) {\n\t\t\t\tthis._controls.$absolute.children().slice(difference).remove();\n\t\t\t}\n\n\t\t\tthis._controls.$absolute.find('.active').removeClass('active');\n\t\t\tthis._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');\n\t\t}\n\t};\n\n\t/**\n  * Extends event data.\n  * @protected\n  * @param {Event} event - The event object which gets thrown.\n  */\n\tNavigation.prototype.onTrigger = function (event) {\n\t\tvar settings = this._core.settings;\n\n\t\tevent.page = {\n\t\t\tindex: $.inArray(this.current(), this._pages),\n\t\t\tcount: this._pages.length,\n\t\t\tsize: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)\n\t\t};\n\t};\n\n\t/**\n  * Gets the current page position of the carousel.\n  * @protected\n  * @returns {Number}\n  */\n\tNavigation.prototype.current = function () {\n\t\tvar current = this._core.relative(this._core.current());\n\t\treturn $.grep(this._pages, $.proxy(function (page, index) {\n\t\t\treturn page.start <= current && page.end >= current;\n\t\t}, this)).pop();\n\t};\n\n\t/**\n  * Gets the current succesor/predecessor position.\n  * @protected\n  * @returns {Number}\n  */\n\tNavigation.prototype.getPosition = function (successor) {\n\t\tvar position,\n\t\t    length,\n\t\t    settings = this._core.settings;\n\n\t\tif (settings.slideBy == 'page') {\n\t\t\tposition = $.inArray(this.current(), this._pages);\n\t\t\tlength = this._pages.length;\n\t\t\tsuccessor ? ++position : --position;\n\t\t\tposition = this._pages[(position % length + length) % length].start;\n\t\t} else {\n\t\t\tposition = this._core.relative(this._core.current());\n\t\t\tlength = this._core.items().length;\n\t\t\tsuccessor ? position += settings.slideBy : position -= settings.slideBy;\n\t\t}\n\n\t\treturn position;\n\t};\n\n\t/**\n  * Slides to the next item or page.\n  * @public\n  * @param {Number} [speed=false] - The time in milliseconds for the transition.\n  */\n\tNavigation.prototype.next = function (speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);\n\t};\n\n\t/**\n  * Slides to the previous item or page.\n  * @public\n  * @param {Number} [speed=false] - The time in milliseconds for the transition.\n  */\n\tNavigation.prototype.prev = function (speed) {\n\t\t$.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);\n\t};\n\n\t/**\n  * Slides to the specified item or page.\n  * @public\n  * @param {Number} position - The position of the item or page.\n  * @param {Number} [speed] - The time in milliseconds for the transition.\n  * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.\n  */\n\tNavigation.prototype.to = function (position, speed, standard) {\n\t\tvar length;\n\n\t\tif (!standard && this._pages.length) {\n\t\t\tlength = this._pages.length;\n\t\t\t$.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed);\n\t\t} else {\n\t\t\t$.proxy(this._overrides.to, this._core)(position, speed);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Hash Plugin\n * @version 2.1.0\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\t'use strict';\n\n\t/**\n  * Creates the hash plugin.\n  * @class The Hash Plugin\n  * @param {Owl} carousel - The Owl Carousel\n  */\n\n\tvar Hash = function Hash(carousel) {\n\t\t/**\n   * Reference to the core.\n   * @protected\n   * @type {Owl}\n   */\n\t\tthis._core = carousel;\n\n\t\t/**\n   * Hash index for the items.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._hashes = {};\n\n\t\t/**\n   * The carousel element.\n   * @type {jQuery}\n   */\n\t\tthis.$element = this._core.$element;\n\n\t\t/**\n   * All event handlers.\n   * @protected\n   * @type {Object}\n   */\n\t\tthis._handlers = {\n\t\t\t'initialized.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && this._core.settings.startPosition === 'URLHash') {\n\t\t\t\t\t$(window).trigger('hashchange.owl.navigation');\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'prepared.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace) {\n\t\t\t\t\tvar hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');\n\n\t\t\t\t\tif (!hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tthis._hashes[hash] = e.content;\n\t\t\t\t}\n\t\t\t}, this),\n\t\t\t'changed.owl.carousel': $.proxy(function (e) {\n\t\t\t\tif (e.namespace && e.property.name === 'position') {\n\t\t\t\t\tvar current = this._core.items(this._core.relative(this._core.current())),\n\t\t\t\t\t    hash = $.map(this._hashes, function (item, hash) {\n\t\t\t\t\t\treturn item === current ? hash : null;\n\t\t\t\t\t}).join();\n\n\t\t\t\t\tif (!hash || window.location.hash.slice(1) === hash) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\twindow.location.hash = hash;\n\t\t\t\t}\n\t\t\t}, this)\n\t\t};\n\n\t\t// set default options\n\t\tthis._core.options = $.extend({}, Hash.Defaults, this._core.options);\n\n\t\t// register the event handlers\n\t\tthis.$element.on(this._handlers);\n\n\t\t// register event listener for hash navigation\n\t\t$(window).on('hashchange.owl.navigation', $.proxy(function (e) {\n\t\t\tvar hash = window.location.hash.substring(1),\n\t\t\t    items = this._core.$stage.children(),\n\t\t\t    position = this._hashes[hash] && items.index(this._hashes[hash]);\n\n\t\t\tif (position === undefined || position === this._core.current()) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._core.to(this._core.relative(position), false, true);\n\t\t}, this));\n\t};\n\n\t/**\n  * Default options.\n  * @public\n  */\n\tHash.Defaults = {\n\t\tURLhashListener: false\n\t};\n\n\t/**\n  * Destroys the plugin.\n  * @public\n  */\n\tHash.prototype.destroy = function () {\n\t\tvar handler, property;\n\n\t\t$(window).off('hashchange.owl.navigation');\n\n\t\tfor (handler in this._handlers) {\n\t\t\tthis._core.$element.off(handler, this._handlers[handler]);\n\t\t}\n\t\tfor (property in Object.getOwnPropertyNames(this)) {\n\t\t\ttypeof this[property] != 'function' && (this[property] = null);\n\t\t}\n\t};\n\n\t$.fn.owlCarousel.Constructor.Plugins.Hash = Hash;\n})(window.Zepto || window.jQuery, window, document);\n\n/**\n * Support Plugin\n *\n * @version 2.1.0\n * @author Vivid Planet Software GmbH\n * @author Artus Kolanowski\n * @author David Deutsch\n * @license The MIT License (MIT)\n */\n;(function ($, window, document, undefined) {\n\n\tvar style = $('<support>').get(0).style,\n\t    prefixes = 'Webkit Moz O ms'.split(' '),\n\t    events = {\n\t\ttransition: {\n\t\t\tend: {\n\t\t\t\tWebkitTransition: 'webkitTransitionEnd',\n\t\t\t\tMozTransition: 'transitionend',\n\t\t\t\tOTransition: 'oTransitionEnd',\n\t\t\t\ttransition: 'transitionend'\n\t\t\t}\n\t\t},\n\t\tanimation: {\n\t\t\tend: {\n\t\t\t\tWebkitAnimation: 'webkitAnimationEnd',\n\t\t\t\tMozAnimation: 'animationend',\n\t\t\t\tOAnimation: 'oAnimationEnd',\n\t\t\t\tanimation: 'animationend'\n\t\t\t}\n\t\t}\n\t},\n\t    tests = {\n\t\tcsstransforms: function csstransforms() {\n\t\t\treturn !!test('transform');\n\t\t},\n\t\tcsstransforms3d: function csstransforms3d() {\n\t\t\treturn !!test('perspective');\n\t\t},\n\t\tcsstransitions: function csstransitions() {\n\t\t\treturn !!test('transition');\n\t\t},\n\t\tcssanimations: function cssanimations() {\n\t\t\treturn !!test('animation');\n\t\t}\n\t};\n\n\tfunction test(property, prefixed) {\n\t\tvar result = false,\n\t\t    upper = property.charAt(0).toUpperCase() + property.slice(1);\n\n\t\t$.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function (i, property) {\n\t\t\tif (style[property] !== undefined) {\n\t\t\t\tresult = prefixed ? property : true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t});\n\n\t\treturn result;\n\t}\n\n\tfunction prefixed(property) {\n\t\treturn test(property, true);\n\t}\n\n\tif (tests.csstransitions()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transition = new String(prefixed('transition'));\n\t\t$.support.transition.end = events.transition.end[$.support.transition];\n\t}\n\n\tif (tests.cssanimations()) {\n\t\t/* jshint -W053 */\n\t\t$.support.animation = new String(prefixed('animation'));\n\t\t$.support.animation.end = events.animation.end[$.support.animation];\n\t}\n\n\tif (tests.csstransforms()) {\n\t\t/* jshint -W053 */\n\t\t$.support.transform = new String(prefixed('transform'));\n\t\t$.support.transform3d = tests.csstransforms3d();\n\t}\n})(window.Zepto || window.jQuery, window, document);\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/owl.carousel.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.js?");

			/***/
		},
		/* 2 */
		/***/function (module, exports, __webpack_require__) {

			eval("exports = module.exports = __webpack_require__(3)();\n// imports\n\n\n// module\nexports.push([module.id, \"/**\\n * Owl Carousel v2.2.1\\n * Copyright 2013-2017 David Deutsch\\n * Licensed under  ()\\n */\\n/*\\n *  Owl Carousel - Core\\n */\\n.owl-carousel {\\n  display: none;\\n  width: 100%;\\n  -webkit-tap-highlight-color: transparent;\\n  /* position relative and z-index fix webkit rendering fonts issue */\\n  position: relative;\\n  z-index: 1; }\\n  .owl-carousel .owl-stage {\\n    position: relative;\\n    -ms-touch-action: pan-Y;\\n    -moz-backface-visibility: hidden;\\n    /* fix firefox animation glitch */ }\\n  .owl-carousel .owl-stage:after {\\n    content: \\\".\\\";\\n    display: block;\\n    clear: both;\\n    visibility: hidden;\\n    line-height: 0;\\n    height: 0; }\\n  .owl-carousel .owl-stage-outer {\\n    position: relative;\\n    overflow: hidden;\\n    /* fix for flashing background */\\n    -webkit-transform: translate3d(0px, 0px, 0px); }\\n  .owl-carousel .owl-wrapper,\\n  .owl-carousel .owl-item {\\n    -webkit-backface-visibility: hidden;\\n    -moz-backface-visibility: hidden;\\n    -ms-backface-visibility: hidden;\\n    -webkit-transform: translate3d(0, 0, 0);\\n    -moz-transform: translate3d(0, 0, 0);\\n    -ms-transform: translate3d(0, 0, 0); }\\n  .owl-carousel .owl-item {\\n    position: relative;\\n    min-height: 1px;\\n    float: left;\\n    -webkit-backface-visibility: hidden;\\n    -webkit-tap-highlight-color: transparent;\\n    -webkit-touch-callout: none; }\\n  .owl-carousel .owl-item img {\\n    display: block;\\n    width: 100%; }\\n  .owl-carousel .owl-nav.disabled,\\n  .owl-carousel .owl-dots.disabled {\\n    display: none; }\\n  .owl-carousel .owl-nav .owl-prev,\\n  .owl-carousel .owl-nav .owl-next,\\n  .owl-carousel .owl-dot {\\n    cursor: pointer;\\n    cursor: hand;\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel.owl-loaded {\\n    display: block; }\\n  .owl-carousel.owl-loading {\\n    opacity: 0;\\n    display: block; }\\n  .owl-carousel.owl-hidden {\\n    opacity: 0; }\\n  .owl-carousel.owl-refresh .owl-item {\\n    visibility: hidden; }\\n  .owl-carousel.owl-drag .owl-item {\\n    -webkit-user-select: none;\\n    -moz-user-select: none;\\n    -ms-user-select: none;\\n    user-select: none; }\\n  .owl-carousel.owl-grab {\\n    cursor: move;\\n    cursor: -webkit-grab;\\n    cursor: grab; }\\n  .owl-carousel.owl-rtl {\\n    direction: rtl; }\\n  .owl-carousel.owl-rtl .owl-item {\\n    float: right; }\\n\\n/* No Js */\\n.no-js .owl-carousel {\\n  display: block; }\\n\\n/*\\n *  Owl Carousel - Animate Plugin\\n */\\n.owl-carousel .animated {\\n  -webkit-animation-duration: 1000ms;\\n          animation-duration: 1000ms;\\n  -webkit-animation-fill-mode: both;\\n          animation-fill-mode: both; }\\n\\n.owl-carousel .owl-animated-in {\\n  z-index: 0; }\\n\\n.owl-carousel .owl-animated-out {\\n  z-index: 1; }\\n\\n.owl-carousel .fadeOut {\\n  -webkit-animation-name: fadeOut;\\n          animation-name: fadeOut; }\\n\\n@-webkit-keyframes fadeOut {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n@keyframes fadeOut {\\n  0% {\\n    opacity: 1; }\\n  100% {\\n    opacity: 0; } }\\n\\n/*\\n * \\tOwl Carousel - Auto Height Plugin\\n */\\n.owl-height {\\n  transition: height 500ms ease-in-out; }\\n\\n/*\\n * \\tOwl Carousel - Lazy Load Plugin\\n */\\n.owl-carousel .owl-item .owl-lazy {\\n  opacity: 0;\\n  transition: opacity 400ms ease; }\\n\\n.owl-carousel .owl-item img.owl-lazy {\\n  -webkit-transform-style: preserve-3d;\\n          transform-style: preserve-3d; }\\n\\n/*\\n * \\tOwl Carousel - Video Plugin\\n */\\n.owl-carousel .owl-video-wrapper {\\n  position: relative;\\n  height: 100%;\\n  background: #000; }\\n\\n.owl-carousel .owl-video-play-icon {\\n  position: absolute;\\n  height: 80px;\\n  width: 80px;\\n  left: 50%;\\n  top: 50%;\\n  margin-left: -40px;\\n  margin-top: -40px;\\n  /* background: url(\\\"owl.video.play.png\\\") no-repeat; */\\n  cursor: pointer;\\n  z-index: 1;\\n  -webkit-backface-visibility: hidden;\\n  transition: -webkit-transform 100ms ease;\\n  transition: transform 100ms ease;\\n  transition: transform 100ms ease, -webkit-transform 100ms ease; }\\n\\n.owl-carousel .owl-video-play-icon:hover {\\n  -webkit-transform: scale(1.3, 1.3);\\n          transform: scale(1.3, 1.3); }\\n\\n.owl-carousel .owl-video-playing .owl-video-tn,\\n.owl-carousel .owl-video-playing .owl-video-play-icon {\\n  display: none; }\\n\\n.owl-carousel .owl-video-tn {\\n  opacity: 0;\\n  height: 100%;\\n  background-position: center center;\\n  background-repeat: no-repeat;\\n  background-size: contain;\\n  transition: opacity 400ms ease; }\\n\\n.owl-carousel .owl-video-frame {\\n  position: relative;\\n  z-index: 1;\\n  height: 100%;\\n  width: 100%; }\\n\", \"\"]);\n\n// exports\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader!./~/postcss-loader!./src/owl.carousel.css\n ** module id = 2\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.css?./~/css-loader!./~/postcss-loader");

			/***/
		},
		/* 3 */
		/***/function (module, exports) {

			eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/css-loader/lib/css-base.js\n ** module id = 3\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/css-loader/lib/css-base.js?");

			/***/
		},
		/* 4 */
		/***/function (module, exports, __webpack_require__) {

			eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nvar stylesInDom = {},\n\tmemoize = function(fn) {\n\t\tvar memo;\n\t\treturn function () {\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\t\treturn memo;\n\t\t};\n\t},\n\tisOldIE = memoize(function() {\n\t\treturn /msie [6-9]\\b/.test(self.navigator.userAgent.toLowerCase());\n\t}),\n\tgetHeadElement = memoize(function () {\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\n\t}),\n\tsingletonElement = null,\n\tsingletonCounter = 0,\n\tstyleElementsInsertedAtTop = [];\n\nmodule.exports = function(list, options) {\n\tif(false) {\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the bottom of <head>.\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list);\n\taddStylesToDom(styles, options);\n\n\treturn function update(newList) {\n\t\tvar mayRemove = [];\n\t\tfor(var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\n\t\t\t\t\tdomStyle.parts[j]();\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n}\n\nfunction addStylesToDom(styles, options) {\n\tfor(var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles(list) {\n\tvar styles = [];\n\tvar newStyles = {};\n\tfor(var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\t\tif(!newStyles[id])\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse\n\t\t\tnewStyles[id].parts.push(part);\n\t}\n\treturn styles;\n}\n\nfunction insertStyleElement(options, styleElement) {\n\tvar head = getHeadElement();\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\n\tif (options.insertAt === \"top\") {\n\t\tif(!lastStyleElementInsertedAtTop) {\n\t\t\thead.insertBefore(styleElement, head.firstChild);\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\thead.appendChild(styleElement);\n\t\t}\n\t\tstyleElementsInsertedAtTop.push(styleElement);\n\t} else if (options.insertAt === \"bottom\") {\n\t\thead.appendChild(styleElement);\n\t} else {\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\n\t}\n}\n\nfunction removeStyleElement(styleElement) {\n\tstyleElement.parentNode.removeChild(styleElement);\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\n\tif(idx >= 0) {\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement(options) {\n\tvar styleElement = document.createElement(\"style\");\n\tstyleElement.type = \"text/css\";\n\tinsertStyleElement(options, styleElement);\n\treturn styleElement;\n}\n\nfunction createLinkElement(options) {\n\tvar linkElement = document.createElement(\"link\");\n\tlinkElement.rel = \"stylesheet\";\n\tinsertStyleElement(options, linkElement);\n\treturn linkElement;\n}\n\nfunction addStyle(obj, options) {\n\tvar styleElement, update, remove;\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\n\t} else if(obj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\") {\n\t\tstyleElement = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t\tif(styleElement.href)\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\n\t\t};\n\t} else {\n\t\tstyleElement = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, styleElement);\n\t\tremove = function() {\n\t\t\tremoveStyleElement(styleElement);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle(newObj) {\n\t\tif(newObj) {\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\n\t\t\t\treturn;\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = styleElement.childNodes;\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\n\t\tif (childNodes.length) {\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyleElement.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag(styleElement, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyleElement.setAttribute(\"media\", media)\n\t}\n\n\tif(styleElement.styleSheet) {\n\t\tstyleElement.styleSheet.cssText = css;\n\t} else {\n\t\twhile(styleElement.firstChild) {\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\n\t\t}\n\t\tstyleElement.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink(linkElement, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\tif(sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = linkElement.href;\n\n\tlinkElement.href = URL.createObjectURL(blob);\n\n\tif(oldSrc)\n\t\tURL.revokeObjectURL(oldSrc);\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/style-loader/addStyles.js\n ** module id = 4\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./~/style-loader/addStyles.js?");

			/***/
		},
		/* 5 */
		/***/function (module, exports, __webpack_require__) {

			eval("// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = __webpack_require__(2);\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = __webpack_require__(4)(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(false) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!./owl.carousel.css\", function() {\n\t\t\tvar newContent = require(\"!!../node_modules/css-loader/index.js!../node_modules/postcss-loader/index.js!./owl.carousel.css\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n/*****************\n ** WEBPACK FOOTER\n ** ./src/owl.carousel.css\n ** module id = 5\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/owl.carousel.css?");

			/***/
		},
		/* 6 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_6__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"PropTypes\",\"commonjs2\":\"prop-types\",\"commonjs\":\"prop-types\",\"amd\":\"prop-types\"}\n ** module id = 6\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22PropTypes%22,%22commonjs2%22:%22prop-types%22,%22commonjs%22:%22prop-types%22,%22amd%22:%22prop-types%22%7D?");

			/***/
		},
		/* 7 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_7__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}\n ** module id = 7\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22React%22,%22commonjs2%22:%22react%22,%22commonjs%22:%22react%22,%22amd%22:%22react%22%7D?");

			/***/
		},
		/* 8 */
		/***/function (module, exports) {

			eval("module.exports = __WEBPACK_EXTERNAL_MODULE_8__;\n\n/*****************\n ** WEBPACK FOOTER\n ** external {\"root\":\"ReactDOM\",\"commonjs2\":\"react-dom\",\"commonjs\":\"react-dom\",\"amd\":\"react-dom\"}\n ** module id = 8\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///external_%7B%22root%22:%22ReactDOM%22,%22commonjs2%22:%22react-dom%22,%22commonjs%22:%22react-dom%22,%22amd%22:%22react-dom%22%7D?");

			/***/
		}
		/******/])
	);
});
;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(63)(module)))

/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function (module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function () {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function get() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function get() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};

/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyFunction = __webpack_require__(3);
var invariant = __webpack_require__(5);
var warning = __webpack_require__(7);
var assign = __webpack_require__(4);

var ReactPropTypesSecret = __webpack_require__(9);
var checkPropTypes = __webpack_require__(8);

module.exports = function (isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (!manualPropTypeCallCache[cacheKey] &&
          // Avoid spamming the console because they are often not actionable except for lib authors
          manualPropTypeWarningCount < 3) {
            warning(false, 'You are manually calling a React.PropTypes validation ' + 'function for the `%s` prop on `%s`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.', propFullName, componentName);
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(false, 'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received %s at index %s.', getPostfixForTypeWarning(checker), i);
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1)))

/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var emptyFunction = __webpack_require__(3);
var invariant = __webpack_require__(5);
var ReactPropTypesSecret = __webpack_require__(9);

module.exports = function () {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(false, 'Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use PropTypes.checkPropTypes() to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMjE3NDg3NGFiYzFlNzRhZTNmM2IiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaW52YXJpYW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvRXZlbnRMaXN0ZW5lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZ2V0QWN0aXZlRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvc2hhbGxvd0VxdWFsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9jb250YWluc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWRvbS9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9hcHAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J0b2EuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9jb21wb25lbnRzL2Jhc2ljaW5mby5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvY29tcG9uZW50cy9iaW8uanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvdGVjaHNraWxscy5qcyIsIndlYnBhY2s6Ly8vLi9wdWJsaWMvY29tcG9uZW50cy9za2lsbHNsaXN0LmpzIiwid2VicGFjazovLy8uL3B1YmxpYy9jb21wb25lbnRzL2V4cGVyaWVuY2UuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvZXhwZXJpZW5zZWxpc3QuanMiLCJ3ZWJwYWNrOi8vLy4vcHVibGljL2NvbXBvbmVudHMvcHJvamVjdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JlYWN0LW93bC1jYXJvdXNlbDIvbGliL093bENhcm91c2VsLmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJsZW5ndGgiLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsIkFycmF5IiwiYXJndW1lbnRzIiwiaSIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJwcm90b3R5cGUiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9uIiwidmVyc2lvbnMiLCJub29wIiwib24iLCJhZGRMaXN0ZW5lciIsIm9uY2UiLCJvZmYiLCJyZW1vdmVMaXN0ZW5lciIsInJlbW92ZUFsbExpc3RlbmVycyIsImVtaXQiLCJwcmVwZW5kTGlzdGVuZXIiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwibGlzdGVuZXJzIiwibmFtZSIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwiYmluZCIsImlzQnVmZmVyIiwidG9TdHJpbmciLCJPYmplY3QiLCJpc0FycmF5IiwidmFsIiwiaXNBcnJheUJ1ZmZlciIsImlzRm9ybURhdGEiLCJGb3JtRGF0YSIsImlzQXJyYXlCdWZmZXJWaWV3IiwicmVzdWx0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJidWZmZXIiLCJpc1N0cmluZyIsImlzTnVtYmVyIiwiaXNVbmRlZmluZWQiLCJpc09iamVjdCIsImlzRGF0ZSIsImlzRmlsZSIsImlzQmxvYiIsImlzRnVuY3Rpb24iLCJpc1N0cmVhbSIsInBpcGUiLCJpc1VSTFNlYXJjaFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInRyaW0iLCJzdHIiLCJyZXBsYWNlIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0Iiwid2luZG93IiwiZG9jdW1lbnQiLCJmb3JFYWNoIiwib2JqIiwiZm4iLCJsIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJtZXJnZSIsImFzc2lnblZhbHVlIiwiZXh0ZW5kIiwiYSIsImIiLCJ0aGlzQXJnIiwibWFrZUVtcHR5RnVuY3Rpb24iLCJhcmciLCJlbXB0eUZ1bmN0aW9uIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImdldE93blByb3BlcnR5U3ltYm9scyIsInByb3BJc0VudW1lcmFibGUiLCJwcm9wZXJ0eUlzRW51bWVyYWJsZSIsInRvT2JqZWN0IiwidW5kZWZpbmVkIiwiVHlwZUVycm9yIiwic2hvdWxkVXNlTmF0aXZlIiwiYXNzaWduIiwidGVzdDEiLCJTdHJpbmciLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwidGVzdDIiLCJmcm9tQ2hhckNvZGUiLCJvcmRlcjIiLCJtYXAiLCJuIiwiam9pbiIsInRlc3QzIiwic3BsaXQiLCJsZXR0ZXIiLCJrZXlzIiwiZXJyIiwidGFyZ2V0Iiwic291cmNlIiwiZnJvbSIsInRvIiwic3ltYm9scyIsInMiLCJ2YWxpZGF0ZUZvcm1hdCIsImZvcm1hdCIsImludmFyaWFudCIsImNvbmRpdGlvbiIsImMiLCJkIiwiZiIsImVycm9yIiwiYXJnSW5kZXgiLCJmcmFtZXNUb1BvcCIsImVtcHR5T2JqZWN0IiwiZnJlZXplIiwid2FybmluZyIsInByaW50V2FybmluZyIsIl9sZW4iLCJfa2V5IiwibWVzc2FnZSIsImNvbnNvbGUiLCJ4IiwiaW5kZXhPZiIsIl9sZW4yIiwiX2tleTIiLCJSZWFjdFByb3BUeXBlc1NlY3JldCIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZ2V0U3RhY2siLCJ0eXBlU3BlY05hbWUiLCJleCIsInN0YWNrIiwiY2hlY2tEQ0UiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJ1dGlscyIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImhlYWRlcnMiLCJ2YWx1ZSIsImdldERlZmF1bHRBZGFwdGVyIiwiYWRhcHRlciIsIlhNTEh0dHBSZXF1ZXN0IiwiZGVmYXVsdHMiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwiZGF0YSIsIkpTT04iLCJzdHJpbmdpZnkiLCJ0cmFuc2Zvcm1SZXNwb25zZSIsInBhcnNlIiwieHNyZkNvb2tpZU5hbWUiLCJ4c3JmSGVhZGVyTmFtZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ2YWxpZGF0ZVN0YXR1cyIsInN0YXR1cyIsImNvbW1vbiIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJtZXRob2QiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJjYW5Vc2VET00iLCJjcmVhdGVFbGVtZW50IiwiRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJjYW5Vc2VXb3JrZXJzIiwiV29ya2VyIiwiY2FuVXNlRXZlbnRMaXN0ZW5lcnMiLCJhZGRFdmVudExpc3RlbmVyIiwiYXR0YWNoRXZlbnQiLCJjYW5Vc2VWaWV3cG9ydCIsInNjcmVlbiIsImlzSW5Xb3JrZXIiLCJFdmVudExpc3RlbmVyIiwibGlzdGVuIiwiZXZlbnRUeXBlIiwiY2FsbGJhY2siLCJyZW1vdmUiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJjYXB0dXJlIiwicmVnaXN0ZXJEZWZhdWx0IiwiZ2V0QWN0aXZlRWxlbWVudCIsImRvYyIsImFjdGl2ZUVsZW1lbnQiLCJib2R5IiwiaXMiLCJ5Iiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiaXNUZXh0Tm9kZSIsImNvbnRhaW5zTm9kZSIsIm91dGVyTm9kZSIsImlubmVyTm9kZSIsInBhcmVudE5vZGUiLCJjb250YWlucyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiZm9jdXNOb2RlIiwibm9kZSIsImZvY3VzIiwid3JhcCIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJidG9hIiwieGhyQWRhcHRlciIsImNvbmZpZyIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdERhdGEiLCJyZXF1ZXN0SGVhZGVycyIsInJlcXVlc3QiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJ1cmwiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwib3BlbiIsInRvVXBwZXJDYXNlIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVR5cGUiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1c1RleHQiLCJvbmVycm9yIiwiaGFuZGxlRXJyb3IiLCJjb29raWVzIiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwicmVhZCIsInNldFJlcXVlc3RIZWFkZXIiLCJ0b0xvd2VyQ2FzZSIsIm9uRG93bmxvYWRQcm9ncmVzcyIsIm9uVXBsb2FkUHJvZ3Jlc3MiLCJ1cGxvYWQiLCJjYW5jZWxUb2tlbiIsInByb21pc2UiLCJ0aGVuIiwib25DYW5jZWxlZCIsImNhbmNlbCIsImFib3J0Iiwic2VuZCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJpc0NhbmNlbCIsIl9fQ0FOQ0VMX18iLCJDYW5jZWwiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJpc1ZhbGlkRWxlbWVudCIsIm9iamVjdCIsIiQkdHlwZW9mIiwidGhyb3dPbkRpcmVjdEFjY2VzcyIsInJlbmRlciIsInF1ZXJ5U2VsZWN0b3IiLCJtIiwicCIsInEiLCJlbmNvZGVVUklDb21wb25lbnQiLCJyIiwiaXNNb3VudGVkIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiZW5xdWV1ZVJlcGxhY2VTdGF0ZSIsImVucXVldWVTZXRTdGF0ZSIsInQiLCJwcm9wcyIsImNvbnRleHQiLCJyZWZzIiwidXBkYXRlciIsImlzUmVhY3RDb21wb25lbnQiLCJzZXRTdGF0ZSIsImZvcmNlVXBkYXRlIiwidSIsInYiLCJ3IiwiY29uc3RydWN0b3IiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsInVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCIsImNoaWxkcmVuIiwieiIsImN1cnJlbnQiLCJBIiwiQiIsIkMiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsIkQiLCJoIiwiayIsImciLCJkZWZhdWx0UHJvcHMiLCJ0eXBlIiwiX293bmVyIiwiRSIsIkYiLCJpdGVyYXRvciIsIkciLCJIIiwiZXNjYXBlIiwiSSIsIkoiLCJLIiwicG9wIiwia2V5UHJlZml4IiwiZnVuYyIsImNvdW50IiwiTCIsIk0iLCJOIiwibmV4dCIsImRvbmUiLCJPIiwiUCIsIlEiLCJSIiwiQ2hpbGRyZW4iLCJ0b0FycmF5Iiwib25seSIsIkNvbXBvbmVudCIsIlB1cmVDb21wb25lbnQiLCJ1bnN0YWJsZV9Bc3luY0NvbXBvbmVudCIsImNsb25lRWxlbWVudCIsImNyZWF0ZUZhY3RvcnkiLCJfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCIsIlJlYWN0Q3VycmVudE93bmVyIiwiUyIsImRlZmF1bHQiLCJUIiwiX2Fzc2lnbiIsIlJlYWN0VmVyc2lvbiIsImVuYWJsZVJlYWN0RnJhZ21lbnQiLCJsb3dQcmlvcml0eVdhcm5pbmciLCJ3YXJuIiwibG93UHJpb3JpdHlXYXJuaW5nJDEiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQiLCJ3YXJuTm9vcCIsInB1YmxpY0luc3RhbmNlIiwiY2FsbGVyTmFtZSIsImRpc3BsYXlOYW1lIiwid2FybmluZ0tleSIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiY29tcGxldGVTdGF0ZSIsInBhcnRpYWxTdGF0ZSIsImRlcHJlY2F0ZWRBUElzIiwicmVwbGFjZVN0YXRlIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwibWV0aG9kTmFtZSIsImluZm8iLCJkZWZpbmVQcm9wZXJ0eSIsImdldCIsImZuTmFtZSIsIkNvbXBvbmVudER1bW15IiwicHVyZUNvbXBvbmVudFByb3RvdHlwZSIsIkFzeW5jQ29tcG9uZW50IiwiYXN5bmNDb21wb25lbnRQcm90b3R5cGUiLCJSRUFDVF9FTEVNRU5UX1RZUEUkMSIsIlJFU0VSVkVEX1BST1BTIiwic3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24iLCJzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biIsImhhc1ZhbGlkUmVmIiwiZ2V0dGVyIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaXNSZWFjdFdhcm5pbmciLCJoYXNWYWxpZEtleSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiY29uZmlndXJhYmxlIiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJzZWxmIiwib3duZXIiLCJlbGVtZW50IiwiX3N0b3JlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwicHJvcE5hbWUiLCJjaGlsZHJlbkxlbmd0aCIsImNoaWxkQXJyYXkiLCJjbG9uZUFuZFJlcGxhY2VLZXkiLCJvbGRFbGVtZW50IiwibmV3S2V5IiwibmV3RWxlbWVudCIsIl9zZWxmIiwiX3NvdXJjZSIsIlJlYWN0RGVidWdDdXJyZW50RnJhbWUiLCJnZXRDdXJyZW50U3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiaW1wbCIsIklURVJBVE9SX1NZTUJPTCIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiUkVBQ1RfUE9SVEFMX1RZUEUiLCJTRVBBUkFUT1IiLCJTVUJTRVBBUkFUT1IiLCJlc2NhcGVSZWdleCIsImVzY2FwZXJMb29rdXAiLCJlc2NhcGVkU3RyaW5nIiwibWF0Y2giLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgiLCJlc2NhcGVVc2VyUHJvdmlkZWRLZXkiLCJ0ZXh0IiwiUE9PTF9TSVpFIiwidHJhdmVyc2VDb250ZXh0UG9vbCIsImdldFBvb2xlZFRyYXZlcnNlQ29udGV4dCIsIm1hcFJlc3VsdCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInRyYXZlcnNlQ29udGV4dCIsInJlbGVhc2VUcmF2ZXJzZUNvbnRleHQiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsImdldENvbXBvbmVudEtleSIsImNoaWxkIiwibmV4dE5hbWUiLCJzdWJ0cmVlQ291bnQiLCJuZXh0TmFtZVByZWZpeCIsIml0ZXJhdG9yRm4iLCJlbnRyaWVzIiwic3RlcCIsImlpIiwiYWRkZW5kdW0iLCJjaGlsZHJlblN0cmluZyIsInRyYXZlcnNlQWxsQ2hpbGRyZW4iLCJjb21wb25lbnQiLCJpbmRleCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJmb3JFYWNoQ29udGV4dCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsInByZWZpeCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImNvdW50Q2hpbGRyZW4iLCJvbmx5Q2hpbGQiLCJkZXNjcmliZUNvbXBvbmVudEZyYW1lIiwib3duZXJOYW1lIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiZ2V0Q29tcG9uZW50TmFtZSIsImZpYmVyIiwiY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJnZXREaXNwbGF5TmFtZSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUkMSIsIlZBTElEX0ZSQUdNRU5UX1BST1BTIiwiTWFwIiwiSVRFUkFUT1JfU1lNQk9MJDEiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCQxIiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJlbGVtZW50UHJvcHMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsInZhbGlkYXRlUHJvcFR5cGVzIiwiY29tcG9uZW50Q2xhc3MiLCJwcm9wVHlwZXMiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50IiwiX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiIsIl9kaWRJdGVyYXRvckVycm9yIiwiX2l0ZXJhdG9yRXJyb3IiLCJfaXRlcmF0b3IiLCJfc3RlcCIsImhhcyIsImNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24iLCJ2YWxpZGF0ZWRGYWN0b3J5IiwiY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24iLCJSRUFDVF9GUkFHTUVOVF9UWVBFIiwiUmVhY3QiLCJGcmFnbWVudCIsIlJlYWN0Q29tcG9uZW50VHJlZUhvb2siLCJSZWFjdCQyIiwiUmVhY3QkMyIsInJlYWN0IiwiYWEiLCJjYSIsImRhIiwiZWEiLCJoYSIsImlhIiwibGEiLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsImRlZmF1bHRWYWx1ZSIsImRlZmF1bHRDaGVja2VkIiwiaW5uZXJIVE1MIiwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nIiwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nIiwic3R5bGUiLCJxYSIsInJhIiwiTVVTVF9VU0VfUFJPUEVSVFkiLCJIQVNfQk9PTEVBTl9WQUxVRSIsIkhBU19OVU1FUklDX1ZBTFVFIiwiSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUiLCJIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFIiwiSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFIiwiaW5qZWN0RE9NUHJvcGVydHlDb25maWciLCJQcm9wZXJ0aWVzIiwiRE9NQXR0cmlidXRlTmFtZXNwYWNlcyIsIkRPTUF0dHJpYnV0ZU5hbWVzIiwiRE9NTXV0YXRpb25NZXRob2RzIiwic2EiLCJhdHRyaWJ1dGVOYW1lIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwicHJvcGVydHlOYW1lIiwibXV0YXRpb25NZXRob2QiLCJtdXN0VXNlUHJvcGVydHkiLCJoYXNCb29sZWFuVmFsdWUiLCJoYXNOdW1lcmljVmFsdWUiLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJoYXNTdHJpbmdCb29sZWFuVmFsdWUiLCJ0YSIsInVhIiwic2xpY2UiLCJ2YSIsIndhIiwieGEiLCJ5YSIsInphIiwiQWEiLCJhbGxvd0Z1bGxTY3JlZW4iLCJhdXRvRm9jdXMiLCJhc3luYyIsImF1dG9QbGF5IiwiY2hlY2tlZCIsImNvbHMiLCJjb250ZW50RWRpdGFibGUiLCJjb250cm9scyIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImZvcm1Ob1ZhbGlkYXRlIiwiaGlkZGVuIiwibG9vcCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub1ZhbGlkYXRlIiwicGxheXNJbmxpbmUiLCJyZWFkT25seSIsInJlcXVpcmVkIiwicmV2ZXJzZWQiLCJyb3dzIiwicm93U3BhbiIsInNjb3BlZCIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaXplIiwic3RhcnQiLCJzcGFuIiwic3BlbGxDaGVjayIsInRhYkluZGV4IiwiaXRlbVNjb3BlIiwiYWNjZXB0Q2hhcnNldCIsImNsYXNzTmFtZSIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJyZW1vdmVBdHRyaWJ1dGUiLCJoYXNBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGUiLCJ2YWxpZGl0eSIsImJhZElucHV0Iiwib3duZXJEb2N1bWVudCIsIkJhIiwieGxpbmsiLCJ4bWwiLCJDYSIsImF1dG9SZXZlcnNlIiwiZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCIsInByZXNlcnZlQWxwaGEiLCJ4bGlua0FjdHVhdGUiLCJ4bGlua0FyY3JvbGUiLCJ4bGlua0hyZWYiLCJ4bGlua1JvbGUiLCJ4bGlua1Nob3ciLCJ4bGlua1RpdGxlIiwieGxpbmtUeXBlIiwieG1sQmFzZSIsInhtbExhbmciLCJ4bWxTcGFjZSIsIkRhIiwiRWEiLCJfY2F1Z2h0RXJyb3IiLCJfaGFzQ2F1Z2h0RXJyb3IiLCJfcmV0aHJvd0Vycm9yIiwiX2hhc1JldGhyb3dFcnJvciIsImluamVjdGlvbiIsImluamVjdEVycm9yVXRpbHMiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJIYSIsImludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvciIsImhhc0NhdWdodEVycm9yIiwiY2xlYXJDYXVnaHRFcnJvciIsInJldGhyb3dDYXVnaHRFcnJvciIsIklhIiwiSmEiLCJLYSIsIkxhIiwiTWEiLCJleHRyYWN0RXZlbnRzIiwiZXZlbnRUeXBlcyIsIk5hIiwicGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMiLCJPYSIsInJlZ2lzdHJhdGlvbk5hbWUiLCJQYSIsIlFhIiwiZGVwZW5kZW5jaWVzIiwiUmEiLCJTYSIsIlRhIiwicGx1Z2lucyIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyIsInBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMiLCJpbmplY3RFdmVudFBsdWdpbk9yZGVyIiwiaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lIiwiVWEiLCJWYSIsIldhIiwiWGEiLCJjdXJyZW50VGFyZ2V0IiwiWWEiLCJaYSIsIiRhIiwiYWIiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hJbnN0YW5jZXMiLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImlzUGVyc2lzdGVudCIsInJlbGVhc2UiLCJiYiIsImNiIiwiZGIiLCJlYiIsInN0YXRlTm9kZSIsImpiIiwia2IiLCJsYiIsIm1iIiwiZ2V0TGlzdGVuZXIiLCJlbnF1ZXVlRXZlbnRzIiwicHJvY2Vzc0V2ZW50UXVldWUiLCJuYiIsIk1hdGgiLCJyYW5kb20iLCJvYiIsInBiIiwidGFnIiwicWIiLCJyYiIsInNiIiwicHJlY2FjaGVGaWJlck5vZGUiLCJnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSIsImdldEluc3RhbmNlRnJvbU5vZGUiLCJnZXROb2RlRnJvbUluc3RhbmNlIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSIsInVwZGF0ZUZpYmVyUHJvcHMiLCJ0YiIsInViIiwiZGlzcGF0Y2hDb25maWciLCJ2YiIsIl90YXJnZXRJbnN0Iiwid2IiLCJ4YiIsInliIiwiemIiLCJBYiIsImFsdGVybmF0ZSIsIkJiIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwiYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMiLCJDYiIsIkRiIiwiZG9jdW1lbnRFbGVtZW50IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiX2ZhbGxiYWNrVGV4dCIsIkViIiwiRmIiLCJHYiIsIkhiIiwiZXZlbnRQaGFzZSIsImJ1YmJsZXMiLCJjYW5jZWxhYmxlIiwidGltZVN0YW1wIiwiRGF0ZSIsIm5vdyIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJuYXRpdmVFdmVudCIsIkludGVyZmFjZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInJldHVyblZhbHVlIiwicHJldmVudERlZmF1bHQiLCJzdG9wUHJvcGFnYXRpb24iLCJjYW5jZWxCdWJibGUiLCJwZXJzaXN0IiwiZGVzdHJ1Y3RvciIsImF1Z21lbnRDbGFzcyIsIkliIiwiSmIiLCJldmVudFBvb2wiLCJRYiIsImdldFBvb2xlZCIsIlJiIiwiU2IiLCJUYiIsIlViIiwiVmIiLCJkb2N1bWVudE1vZGUiLCJXYiIsIlhiIiwib3BlcmEiLCJwYXJzZUludCIsIlliIiwiWmIiLCIkYiIsImFjIiwiYmVmb3JlSW5wdXQiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJjb21wb3NpdGlvbkVuZCIsImNvbXBvc2l0aW9uU3RhcnQiLCJjb21wb3NpdGlvblVwZGF0ZSIsImJjIiwiY2MiLCJrZXlDb2RlIiwiZGMiLCJkZXRhaWwiLCJlYyIsImZjIiwid2hpY2giLCJnYyIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiY2hhciIsImhjIiwiaWMiLCJqYyIsImtjIiwibGMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlIiwibWMiLCJpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50IiwibmMiLCJvYyIsInBjIiwiZW5xdWV1ZVN0YXRlUmVzdG9yZSIsInJlc3RvcmVTdGF0ZUlmTmVlZGVkIiwicWMiLCJyYyIsInNjIiwidGMiLCJjb2xvciIsImRhdGUiLCJkYXRldGltZSIsImVtYWlsIiwibW9udGgiLCJudW1iZXIiLCJyYW5nZSIsInNlYXJjaCIsInRlbCIsInRpbWUiLCJ3ZWVrIiwidWMiLCJub2RlTmFtZSIsInZjIiwic3JjRWxlbWVudCIsImNvcnJlc3BvbmRpbmdVc2VFbGVtZW50Iiwibm9kZVR5cGUiLCJ3YyIsImltcGxlbWVudGF0aW9uIiwiaGFzRmVhdHVyZSIsInhjIiwieWMiLCJ6YyIsInNldCIsImdldFZhbHVlIiwic2V0VmFsdWUiLCJzdG9wVHJhY2tpbmciLCJfdmFsdWVUcmFja2VyIiwiQWMiLCJCYyIsIkNjIiwiY2hhbmdlIiwiRGMiLCJFYyIsIkZjIiwiR2MiLCJIYyIsIkljIiwiSmMiLCJRYyIsIlJjIiwiU2MiLCJUYyIsIlVjIiwiVmMiLCJXYyIsIl9pc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJfd3JhcHBlclN0YXRlIiwiY29udHJvbGxlZCIsImdldEF0dHJpYnV0ZSIsIlhjIiwidmlldyIsIlljIiwiQWx0IiwiQ29udHJvbCIsIk1ldGEiLCJTaGlmdCIsIlpjIiwiZ2V0TW9kaWZpZXJTdGF0ZSIsIiRjIiwiYWQiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwicGFnZVgiLCJwYWdlWSIsInNoaWZ0S2V5IiwiYnV0dG9uIiwiYnV0dG9ucyIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsInRvRWxlbWVudCIsImJkIiwibW91c2VFbnRlciIsIm1vdXNlTGVhdmUiLCJjZCIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwiZGQiLCJlZCIsImZkIiwiZWZmZWN0VGFnIiwiZ2QiLCJfcmVhY3RJbnRlcm5hbEZpYmVyIiwiaGQiLCJpZCIsInNpYmxpbmciLCJqZCIsImtkIiwibGQiLCJtZCIsInRhcmdldEluc3QiLCJhbmNlc3RvcnMiLCJjb250YWluZXJJbmZvIiwibmQiLCJ0b3BMZXZlbFR5cGUiLCJvZCIsInBkIiwiVSIsInFkIiwicmQiLCJzZCIsIl9lbmFibGVkIiwiX2hhbmRsZVRvcExldmVsIiwic2V0SGFuZGxlVG9wTGV2ZWwiLCJzZXRFbmFibGVkIiwiaXNFbmFibGVkIiwidHJhcEJ1YmJsZWRFdmVudCIsInRyYXBDYXB0dXJlZEV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsInRkIiwidWQiLCJhbmltYXRpb25lbmQiLCJhbmltYXRpb25pdGVyYXRpb24iLCJhbmltYXRpb25zdGFydCIsInRyYW5zaXRpb25lbmQiLCJ2ZCIsIndkIiwiYW5pbWF0aW9uIiwidHJhbnNpdGlvbiIsInhkIiwieWQiLCJ0b3BBYm9ydCIsInRvcEFuaW1hdGlvbkVuZCIsInRvcEFuaW1hdGlvbkl0ZXJhdGlvbiIsInRvcEFuaW1hdGlvblN0YXJ0IiwidG9wQmx1ciIsInRvcENhbmNlbCIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ2xvc2UiLCJ0b3BDb21wb3NpdGlvbkVuZCIsInRvcENvbXBvc2l0aW9uU3RhcnQiLCJ0b3BDb21wb3NpdGlvblVwZGF0ZSIsInRvcENvbnRleHRNZW51IiwidG9wQ29weSIsInRvcEN1dCIsInRvcERvdWJsZUNsaWNrIiwidG9wRHJhZyIsInRvcERyYWdFbmQiLCJ0b3BEcmFnRW50ZXIiLCJ0b3BEcmFnRXhpdCIsInRvcERyYWdMZWF2ZSIsInRvcERyYWdPdmVyIiwidG9wRHJhZ1N0YXJ0IiwidG9wRHJvcCIsInRvcER1cmF0aW9uQ2hhbmdlIiwidG9wRW1wdGllZCIsInRvcEVuY3J5cHRlZCIsInRvcEVuZGVkIiwidG9wRXJyb3IiLCJ0b3BGb2N1cyIsInRvcElucHV0IiwidG9wS2V5RG93biIsInRvcEtleVByZXNzIiwidG9wS2V5VXAiLCJ0b3BMb2FkZWREYXRhIiwidG9wTG9hZCIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvZ2dsZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVHJhbnNpdGlvbkVuZCIsInRvcFZvbHVtZUNoYW5nZSIsInRvcFdhaXRpbmciLCJ0b3BXaGVlbCIsInpkIiwiQWQiLCJCZCIsIkNkIiwiRGQiLCJmaXJzdENoaWxkIiwiRWQiLCJ0ZXh0Q29udGVudCIsIm9mZnNldCIsIm5leHRTaWJsaW5nIiwiRmQiLCJHZCIsIkhkIiwic2VsZWN0IiwiSWQiLCJKZCIsIktkIiwiTGQiLCJNZCIsInNlbGVjdGlvblN0YXJ0IiwiZW5kIiwic2VsZWN0aW9uRW5kIiwiZ2V0U2VsZWN0aW9uIiwiYW5jaG9yTm9kZSIsImFuY2hvck9mZnNldCIsImZvY3VzT2Zmc2V0IiwiTmQiLCJvblNlbGVjdCIsIk9kIiwiYW5pbWF0aW9uTmFtZSIsImVsYXBzZWRUaW1lIiwicHNldWRvRWxlbWVudCIsIlBkIiwiY2xpcGJvYXJkRGF0YSIsIlFkIiwiUmQiLCJjaGFyQ29kZSIsIlNkIiwiRXNjIiwiU3BhY2ViYXIiLCJMZWZ0IiwiVXAiLCJSaWdodCIsIkRvd24iLCJEZWwiLCJXaW4iLCJNZW51IiwiQXBwcyIsIlNjcm9sbCIsIk1velByaW50YWJsZUtleSIsIlRkIiwiVWQiLCJyZXBlYXQiLCJsb2NhbGUiLCJWZCIsImRhdGFUcmFuc2ZlciIsIldkIiwidG91Y2hlcyIsInRhcmdldFRvdWNoZXMiLCJjaGFuZ2VkVG91Y2hlcyIsIlhkIiwiWWQiLCJkZWx0YVgiLCJ3aGVlbERlbHRhWCIsImRlbHRhWSIsIndoZWVsRGVsdGFZIiwid2hlZWxEZWx0YSIsImRlbHRhWiIsImRlbHRhTW9kZSIsIlpkIiwiJGQiLCJhZSIsIlNpbXBsZUV2ZW50UGx1Z2luIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJTZWxlY3RFdmVudFBsdWdpbiIsIkJlZm9yZUlucHV0RXZlbnRQbHVnaW4iLCJiZSIsImNlIiwiViIsIlciLCJTZXQiLCJkZSIsIlgiLCJlZSIsImZlIiwiZ2UiLCJoZSIsImNvbnRleHRUeXBlcyIsIl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dFR5cGVzIiwiaWUiLCJqZSIsImN1cnNvciIsImtlIiwiZ2V0Q2hpbGRDb250ZXh0IiwibGUiLCJfX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCIsIm1lIiwiWSIsIm1lbW9pemVkU3RhdGUiLCJ1cGRhdGVRdWV1ZSIsIm1lbW9pemVkUHJvcHMiLCJwZW5kaW5nUHJvcHMiLCJpbnRlcm5hbENvbnRleHRUYWciLCJsYXN0RWZmZWN0IiwiZmlyc3RFZmZlY3QiLCJuZXh0RWZmZWN0IiwiZXhwaXJhdGlvblRpbWUiLCJuZSIsIm9lIiwicGUiLCJxZSIsInJlIiwiaGFuZGxlciIsInNlIiwidGUiLCJwZW5kaW5nQ2hpbGRyZW4iLCJ1ZSIsInZlIiwid2UiLCJ4ZSIsImlzRGlzYWJsZWQiLCJzdXBwb3J0c0ZpYmVyIiwiaW5qZWN0Iiwib25Db21taXRGaWJlclJvb3QiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInllIiwiemUiLCJBZSIsImJhc2VTdGF0ZSIsImZpcnN0IiwibGFzdCIsImNhbGxiYWNrTGlzdCIsImhhc0ZvcmNlVXBkYXRlIiwiaXNJbml0aWFsaXplZCIsIkJlIiwiQ2UiLCJEZSIsIktlIiwiaXNSZXBsYWNlIiwiaXNGb3JjZWQiLCJMZSIsIk1lIiwibmV4dENhbGxiYWNrIiwiYWRvcHRDbGFzc0luc3RhbmNlIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsIm1vdW50Q2xhc3NJbnN0YW5jZSIsInN0YXRlIiwiY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50RGlkTW91bnQiLCJ1cGRhdGVDbGFzc0luc3RhbmNlIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudERpZFVwZGF0ZSIsInNob3VsZENvbXBvbmVudFVwZGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJOZSIsIk9lIiwiUGUiLCJRZSIsIlJlIiwiU2UiLCJUZSIsIlVlIiwiVmUiLCJXZSIsIl9zdHJpbmdSZWYiLCJYZSIsIlllIiwiWmUiLCIkZSIsImFmIiwiYmYiLCJwZW5kaW5nQ29udGV4dCIsInNob3VsZFNldFRleHRDb250ZW50IiwidXNlU3luY1NjaGVkdWxpbmciLCJzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlIiwicHVzaEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250YWluZXIiLCJlbnRlckh5ZHJhdGlvblN0YXRlIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiS2IiLCJiZWdpbldvcmsiLCJoeWRyYXRlIiwiYmVnaW5GYWlsZWRXb3JrIiwiY2YiLCJjcmVhdGVJbnN0YW5jZSIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImFwcGVuZEluaXRpYWxDaGlsZCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwicHJlcGFyZVVwZGF0ZSIsInBlcnNpc3RlbmNlIiwiZ2V0Um9vdEhvc3RDb250YWluZXIiLCJwb3BIb3N0Q29udGV4dCIsImdldEhvc3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInBvcEh5ZHJhdGlvblN0YXRlIiwibXV0YXRpb24iLCJjb21wbGV0ZVdvcmsiLCJkZiIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsInJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRUZXh0VXBkYXRlIiwiYXBwZW5kQ2hpbGQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiaW5zZXJ0QmVmb3JlIiwiaW5zZXJ0SW5Db250YWluZXJCZWZvcmUiLCJyZW1vdmVDaGlsZCIsInJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciIsImNvbW1pdFJlc2V0VGV4dENvbnRlbnQiLCJjb21taXRQbGFjZW1lbnQiLCJjb21taXREZWxldGlvbiIsImNvbW1pdFdvcmsiLCJjb21taXRMaWZlQ3ljbGVzIiwiY29tbWl0QXR0YWNoUmVmIiwiY29tbWl0RGV0YWNoUmVmIiwiZWYiLCJmZiIsImdldENoaWxkSG9zdENvbnRleHQiLCJnZXRSb290SG9zdENvbnRleHQiLCJyZXNldEhvc3RDb250YWluZXIiLCJnZiIsImh5ZHJhdGlvbiIsImNhbkh5ZHJhdGVJbnN0YW5jZSIsImNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsImh5ZHJhdGVJbnN0YW5jZSIsImh5ZHJhdGVUZXh0SW5zdGFuY2UiLCJoZiIsIkxiIiwibWEiLCJpc1JlYWR5Rm9yQ29tbWl0IiwidWciLCJ2ZyIsIndnIiwiR2UiLCJIZSIsIkxjIiwieGciLCJNYyIsInpnIiwiQWciLCJjb21wb25lbnREaWRDYXRjaCIsImNvbXBvbmVudFN0YWNrIiwiYmEiLCJGYSIsImZhIiwibmEiLCJuZyIsIm1nIiwiTmMiLCJmYiIsImxnIiwiS2MiLCJnYiIsIkVlIiwiYWRkIiwiX2RlYnVnT3duZXIiLCJfZGVidWdTb3VyY2UiLCJlcnJvckJvdW5kYXJ5IiwiZXJyb3JCb3VuZGFyeUZvdW5kIiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJ3aWxsUmV0cnkiLCJCZyIsImphIiwiQ2ciLCJNYiIsIkRnIiwibmV4dFNjaGVkdWxlZFJvb3QiLCJyZW1haW5pbmdFeHBpcmF0aW9uVGltZSIsIm9hIiwia2EiLCJOYiIsImhiIiwiSWUiLCJKZSIsIkVnIiwicGEiLCJPYiIsImliIiwiT2MiLCJQYiIsIlBjIiwiR2EiLCJmaW5pc2hlZFdvcmsiLCJ0aW1lUmVtYWluaW5nIiwiRmciLCJGZSIsInNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjayIsInByZXBhcmVGb3JDb21taXQiLCJ5ZyIsInJlc2V0QWZ0ZXJDb21taXQiLCJjb21wdXRlQXN5bmNFeHBpcmF0aW9uIiwiY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciIsInNjaGVkdWxlV29yayIsImJhdGNoZWRVcGRhdGVzIiwidW5iYXRjaGVkVXBkYXRlcyIsImZsdXNoU3luYyIsImRlZmVycmVkVXBkYXRlcyIsImpmIiwiY3JlYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwiZ2V0UHVibGljUm9vdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZSIsImZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImtmIiwibGYiLCJtZiIsIm5mIiwicGVyZm9ybWFuY2UiLCJvZiIsInBmIiwicmVxdWVzdElkbGVDYWxsYmFjayIsInFmIiwicmYiLCJzZiIsInRmIiwidWYiLCJ2ZiIsIndmIiwieGYiLCJ5ZiIsInBvc3RNZXNzYWdlIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiSW5maW5pdHkiLCJ6ZiIsIkFmIiwiQmYiLCJDZiIsInRlc3QiLCJEZiIsImlzTmFOIiwiRWYiLCJzZXRBdHRyaWJ1dGVOUyIsIkZmIiwiR2YiLCJtaW4iLCJtYXgiLCJpbml0aWFsVmFsdWUiLCJpbml0aWFsQ2hlY2tlZCIsIkhmIiwiSWYiLCJwYXJzZUZsb2F0IiwiSmYiLCJLZiIsIkxmIiwiTWYiLCJvcHRpb25zIiwiZGVmYXVsdFNlbGVjdGVkIiwiTmYiLCJ3YXNNdWx0aXBsZSIsIk9mIiwiUGYiLCJRZiIsIlJmIiwiU2YiLCJodG1sIiwibWF0aG1sIiwic3ZnIiwiVGYiLCJVZiIsIlZmIiwiV2YiLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwibmFtZXNwYWNlVVJJIiwiWGYiLCJZZiIsImxhc3RDaGlsZCIsIm5vZGVWYWx1ZSIsImV4ZWMiLCJjaGFyQ29kZUF0Iiwic3Vic3RyaW5nIiwiWmYiLCIkZiIsImFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50IiwiYm9yZGVySW1hZ2VPdXRzZXQiLCJib3JkZXJJbWFnZVNsaWNlIiwiYm9yZGVySW1hZ2VXaWR0aCIsImJveEZsZXgiLCJib3hGbGV4R3JvdXAiLCJib3hPcmRpbmFsR3JvdXAiLCJjb2x1bW5Db3VudCIsImNvbHVtbnMiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZ3JpZFJvdyIsImdyaWRSb3dFbmQiLCJncmlkUm93U3BhbiIsImdyaWRSb3dTdGFydCIsImdyaWRDb2x1bW4iLCJncmlkQ29sdW1uRW5kIiwiZ3JpZENvbHVtblNwYW4iLCJncmlkQ29sdW1uU3RhcnQiLCJmb250V2VpZ2h0IiwibGluZUNsYW1wIiwibGluZUhlaWdodCIsIm9wYWNpdHkiLCJvcmRlciIsIm9ycGhhbnMiLCJ0YWJTaXplIiwid2lkb3dzIiwiekluZGV4Iiwiem9vbSIsImZpbGxPcGFjaXR5IiwiZmxvb2RPcGFjaXR5Iiwic3RvcE9wYWNpdHkiLCJzdHJva2VEYXNoYXJyYXkiLCJzdHJva2VEYXNob2Zmc2V0Iiwic3Ryb2tlTWl0ZXJsaW1pdCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsImFnIiwiY2hhckF0IiwiYmciLCJzZXRQcm9wZXJ0eSIsImNnIiwibWVudWl0ZW0iLCJhcmVhIiwiYmFzZSIsImJyIiwiY29sIiwiZW1iZWQiLCJociIsImltZyIsImlucHV0Iiwia2V5Z2VuIiwibGluayIsIm1ldGEiLCJwYXJhbSIsInRyYWNrIiwid2JyIiwiZGciLCJlZyIsImZnIiwiZ2ciLCJoZyIsImlnIiwiamciLCJjcmVhdGVFbGVtZW50TlMiLCJrZyIsImNyZWF0ZVRleHROb2RlIiwib2ciLCJfX2h0bWwiLCJvbkNsaWNrIiwib25jbGljayIsInBnIiwicWciLCJyZyIsInNnIiwidGciLCJzZXRJbml0aWFsUHJvcGVydGllcyIsImRpZmZQcm9wZXJ0aWVzIiwidXBkYXRlUHJvcGVydGllcyIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMiLCJkaWZmSHlkcmF0ZWRUZXh0Iiwid2FybkZvclVubWF0Y2hlZFRleHQiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50Iiwid2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJmb3JtIiwiR2ciLCJIZyIsIklnIiwiSmciLCJaIiwidGFnTmFtZSIsInJhbmdlQ291bnQiLCJmb2N1c2VkRWxlbSIsInNlbGVjdGlvblJhbmdlIiwiY3JlYXRlUmFuZ2UiLCJzZXRTdGFydCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwic2V0RW5kIiwibGVmdCIsInNjcm9sbExlZnQiLCJ0b3AiLCJzY3JvbGxUb3AiLCJkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlIiwiZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZSIsImRpZE5vdEh5ZHJhdGVJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZSIsImRpZE5vdEZpbmRIeWRyYXRhYmxlSW5zdGFuY2UiLCJkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsIktnIiwiX3JlYWN0Um9vdENvbnRhaW5lciIsIkxnIiwiTWciLCJ1bm1vdW50IiwiTmciLCJjcmVhdGVQb3J0YWwiLCJmaW5kRE9NTm9kZSIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsInVuc3RhYmxlX2NyZWF0ZVBvcnRhbCIsInVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzIiwidW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiRXZlbnRQcm9wYWdhdG9ycyIsIlJlYWN0Q29udHJvbGxlZENvbXBvbmVudCIsIlJlYWN0RE9NQ29tcG9uZW50VHJlZSIsIlJlYWN0RE9NRXZlbnRMaXN0ZW5lciIsImJ1bmRsZVR5cGUiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwiT2ciLCJQZyIsImlzTm9kZSIsIk5vZGUiLCJlbXB0eUZ1bmN0aW9uJDEiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwicHJvcGVydGllcyIsImxvd2VyQ2FzZWQiLCJwcm9wQ29uZmlnIiwicHJvcGVydHlJbmZvIiwiQVRUUklCVVRFX05BTUVfU1RBUlRfQ0hBUiIsIkFUVFJJQlVURV9OQU1FX0NIQVIiLCJST09UX0FUVFJJQlVURV9OQU1FIiwic2hvdWxkU2V0QXR0cmlidXRlIiwiaXNSZXNlcnZlZFByb3AiLCJzaG91bGRBdHRyaWJ1dGVBY2NlcHRCb29sZWFuVmFsdWUiLCJnZXRQcm9wZXJ0eUluZm8iLCJIVE1MRE9NUHJvcGVydHlDb25maWciLCJIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUkMSIsIk5TIiwiQVRUUlMiLCJTVkdET01Qcm9wZXJ0eUNvbmZpZyIsIkNBTUVMSVpFIiwiY2FwaXRhbGl6ZSIsInRva2VuIiwib3JpZ2luYWwiLCJyZWFjdE5hbWUiLCJSZWFjdEVycm9yVXRpbHMiLCJpbmplY3RlZEVycm9yVXRpbHMiLCJmdW5jQXJncyIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tEZXYiLCJkaWRFcnJvciIsImNhbGxDYWxsYmFjayIsImV2dFR5cGUiLCJkaWRTZXRFcnJvciIsImlzQ3Jvc3NPcmlnaW5FcnJvciIsIm9uRXJyb3IiLCJldmVudCIsImNvbG5vIiwibGluZW5vIiwiZXZ0IiwiaW5pdEV2ZW50IiwiZXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luTW9kdWxlIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudE5hbWUiLCJwdWJsaXNoRXZlbnRGb3JQbHVnaW4iLCJwaGFzZU5hbWUiLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lIiwicHVibGlzaFJlZ2lzdHJhdGlvbk5hbWUiLCJsb3dlckNhc2VkTmFtZSIsIm9uZGJsY2xpY2siLCJpbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RlZE5hbWVzVG9QbHVnaW5zIiwiaXNPcmRlcmluZ0RpcnR5IiwiaW5qZWN0aW9uJDIiLCJpbmplY3RDb21wb25lbnRUcmVlIiwiSW5qZWN0ZWQiLCJ2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcyIsImRpc3BhdGNoTGlzdGVuZXJzIiwiZGlzcGF0Y2hJbnN0YW5jZXMiLCJsaXN0ZW5lcnNJc0FyciIsImxpc3RlbmVyc0xlbiIsImluc3RhbmNlc0lzQXJyIiwiaW5zdGFuY2VzTGVuIiwiZXhlY3V0ZURpc3BhdGNoIiwic2ltdWxhdGVkIiwibGlzdGVuZXIiLCJpbnN0IiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJhcnIiLCJzY29wZSIsImV2ZW50UXVldWUiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VTaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2VUb3BMZXZlbCIsImlzSW50ZXJhY3RpdmUiLCJzaG91bGRQcmV2ZW50TW91c2VFdmVudCIsImluamVjdGlvbiQxIiwibmF0aXZlRXZlbnRUYXJnZXQiLCJldmVudHMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwiSW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkNhbGxDb21wb25lbnQiLCJDYWxsSGFuZGxlclBoYXNlIiwiUmV0dXJuQ29tcG9uZW50IiwicmFuZG9tS2V5IiwiaW50ZXJuYWxJbnN0YW5jZUtleSIsImludGVybmFsRXZlbnRIYW5kbGVyc0tleSIsInByZWNhY2hlRmliZXJOb2RlJDEiLCJob3N0SW5zdCIsInBhcmVudHMiLCJjbG9zZXN0IiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSQxIiwiZ2V0Tm9kZUZyb21JbnN0YW5jZSQxIiwiZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxIiwidXBkYXRlRmliZXJQcm9wcyQxIiwiZ2V0UGFyZW50IiwiZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IiLCJpbnN0QSIsImluc3RCIiwiZGVwdGhBIiwidGVtcEEiLCJkZXB0aEIiLCJ0ZW1wQiIsImRlcHRoIiwiZ2V0UGFyZW50SW5zdGFuY2UiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwicGF0aCIsInRyYXZlcnNlRW50ZXJMZWF2ZSIsImFyZ0Zyb20iLCJhcmdUbyIsInBhdGhGcm9tIiwicGF0aFRvIiwiX2FsdGVybmF0ZSIsIl9pIiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJwaGFzZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGUiLCJhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCIsInBhcmVudEluc3QiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImxlYXZlIiwiZW50ZXIiLCJjb250ZW50S2V5IiwiZ2V0VGV4dENvbnRlbnRBY2Nlc3NvciIsImNvbXBvc2l0aW9uU3RhdGUiLCJpbml0aWFsaXplIiwiZ2V0VGV4dCIsInJlc2V0IiwiZ2V0RGF0YSIsInN0YXJ0VmFsdWUiLCJzdGFydExlbmd0aCIsImVuZFZhbHVlIiwiZW5kTGVuZ3RoIiwibWluRW5kIiwic2xpY2VUYWlsIiwiZGlkV2FybkZvckFkZGVkTmV3UHJvcGVydHkiLCJpc1Byb3h5U3VwcG9ydGVkIiwiUHJveHkiLCJFVkVOVF9QT09MX1NJWkUiLCJzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcyIsIkV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRXZlbnQiLCJub3JtYWxpemUiLCJnZXRQb29sZWRXYXJuaW5nUHJvcGVydHlEZWZpbml0aW9uIiwiQ2xhc3MiLCJTdXBlciIsImFkZEV2ZW50UG9vbGluZ1RvIiwiY29uc3RydWN0IiwiY3JlYXRlIiwidGhhdCIsInByb3AiLCJnZXRWYWwiLCJhY3Rpb24iLCJ3YXJuaW5nQ29uZGl0aW9uIiwiZ2V0UG9vbGVkRXZlbnQiLCJuYXRpdmVJbnN0IiwiRXZlbnRDb25zdHJ1Y3RvciIsImluc3RhbmNlIiwicmVsZWFzZVBvb2xlZEV2ZW50IiwiU3ludGhldGljRXZlbnQkMSIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50IiwiZGlzcGF0Y2hNYXJrZXIiLCJJbnB1dEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljSW5wdXRFdmVudCIsIkVORF9LRVlDT0RFUyIsIlNUQVJUX0tFWUNPREUiLCJjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IiwiY2FuVXNlVGV4dElucHV0RXZlbnQiLCJpc1ByZXN0byIsInVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJoYXNTcGFjZUtleXByZXNzIiwiaXNLZXlwcmVzc0NvbW1hbmQiLCJnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSIsImlzRmFsbGJhY2tDb21wb3NpdGlvblN0YXJ0IiwiaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kIiwiZ2V0RGF0YUZyb21DdXN0b21FdmVudCIsImlzQ29tcG9zaW5nIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJmYWxsYmFja0RhdGEiLCJjdXN0b21EYXRhIiwiZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyIsImNoYXJzIiwiZ2V0RmFsbGJhY2tCZWZvcmVJbnB1dENoYXJzIiwiZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQiLCJmaWJlckhvc3RDb21wb25lbnQiLCJSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24iLCJob3N0Q29tcG9uZW50SW1wbCIsInJlc3RvcmVUYXJnZXQiLCJyZXN0b3JlUXVldWUiLCJyZXN0b3JlU3RhdGVPZlRhcmdldCIsImludGVybmFsSW5zdGFuY2UiLCJpbmplY3Rpb24kMyIsInF1ZXVlZFRhcmdldHMiLCJmaWJlckJhdGNoZWRVcGRhdGVzIiwiYm9va2tlZXBpbmciLCJpc05lc3RpbmdCYXRjaGVkIiwiUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb24iLCJpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzIiwiX2JhdGNoZWRVcGRhdGVzIiwiaW5qZWN0aW9uJDQiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiZWxlbSIsIkVMRU1FTlRfTk9ERSIsIlRFWFRfTk9ERSIsIkNPTU1FTlRfTk9ERSIsIkRPQ1VNRU5UX05PREUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFIiwiZ2V0RXZlbnRUYXJnZXQiLCJ1c2VIYXNGZWF0dXJlIiwiaXNFdmVudFN1cHBvcnRlZCIsImV2ZW50TmFtZVN1ZmZpeCIsImlzU3VwcG9ydGVkIiwiaXNDaGVja2FibGUiLCJnZXRUcmFja2VyIiwiZGV0YWNoVHJhY2tlciIsImdldFZhbHVlRnJvbU5vZGUiLCJ0cmFja1ZhbHVlT25Ob2RlIiwidmFsdWVGaWVsZCIsImRlc2NyaXB0b3IiLCJjdXJyZW50VmFsdWUiLCJ0cmFja2VyIiwidXBkYXRlVmFsdWVJZkNoYW5nZWQiLCJsYXN0VmFsdWUiLCJuZXh0VmFsdWUiLCJldmVudFR5cGVzJDEiLCJjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQiLCJhY3RpdmVFbGVtZW50SW5zdCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwibWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCIsInJ1bkV2ZW50SW5CYXRjaCIsImdldEluc3RJZlZhbHVlQ2hhbmdlZCIsInRhcmdldE5vZGUiLCJnZXRUYXJnZXRJbnN0Rm9yQ2hhbmdlRXZlbnQiLCJpc0lucHV0RXZlbnRTdXBwb3J0ZWQiLCJzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UiLCJoYW5kbGVQcm9wZXJ0eUNoYW5nZSIsInN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsIiwiZ2V0VGFyZ2V0SW5zdEZvcklucHV0RXZlbnRQb2x5ZmlsbCIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJbnN0Rm9yQ2xpY2tFdmVudCIsImdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQiLCJoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyIiwiZ2V0VGFyZ2V0SW5zdEZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJET01FdmVudFBsdWdpbk9yZGVyIiwiVUlFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1VJRXZlbnQiLCJtb2RpZmllcktleVRvUHJvcCIsIm1vZGlmaWVyU3RhdGVHZXR0ZXIiLCJrZXlBcmciLCJzeW50aGV0aWNFdmVudCIsImtleVByb3AiLCJnZXRFdmVudE1vZGlmaWVyU3RhdGUiLCJNb3VzZUV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljTW91c2VFdmVudCIsImV2ZW50VHlwZXMkMiIsIndpbiIsInJlbGF0ZWQiLCJmcm9tTm9kZSIsInRvTm9kZSIsIlJlYWN0SW50ZXJuYWxzIiwiTm9FZmZlY3QiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiVXBkYXRlIiwiUGxhY2VtZW50QW5kVXBkYXRlIiwiRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkVyciIsIlJlZiIsIk1PVU5USU5HIiwiTU9VTlRFRCIsIlVOTU9VTlRFRCIsImlzRmliZXJNb3VudGVkSW1wbCIsImlzRmliZXJNb3VudGVkIiwib3duZXJGaWJlciIsIl93YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImFzc2VydElzTW91bnRlZCIsImZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIiwicGFyZW50QSIsInBhcmVudEIiLCJkaWRGaW5kQ2hpbGQiLCJfY2hpbGQiLCJmaW5kQ3VycmVudEhvc3RGaWJlciIsInBhcmVudCIsImN1cnJlbnRQYXJlbnQiLCJmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMiLCJDQUxMQkFDS19CT09LS0VFUElOR19QT09MX1NJWkUiLCJjYWxsYmFja0Jvb2trZWVwaW5nUG9vbCIsImZpbmRSb290Q29udGFpbmVyTm9kZSIsImdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyIsInJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmciLCJoYW5kbGVUb3BMZXZlbEltcGwiLCJhbmNlc3RvciIsInJvb3QiLCJoYW5kbGVUb3BMZXZlbCIsImVuYWJsZWQiLCJoYW5kbGVyQmFzZU5hbWUiLCJtYWtlUHJlZml4TWFwIiwic3R5bGVQcm9wIiwicHJlZml4ZXMiLCJ2ZW5kb3JQcmVmaXhlcyIsInByZWZpeGVkRXZlbnROYW1lcyIsImdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lIiwicHJlZml4TWFwIiwidG9wTGV2ZWxUeXBlcyQxIiwiQnJvd3NlckV2ZW50Q29uc3RhbnRzIiwidG9wTGV2ZWxUeXBlcyIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwiYWxyZWFkeUxpc3RlbmluZ1RvIiwicmVhY3RUb3BMaXN0ZW5lcnNDb3VudGVyIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJsaXN0ZW5UbyIsImNvbnRlbnREb2N1bWVudEhhbmRsZSIsImlzTGlzdGVuaW5nIiwiZGVwZW5kZW5jeSIsImlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMiLCJnZXRMZWFmTm9kZSIsImdldFNpYmxpbmdOb2RlIiwiZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJnZXRPZmZzZXRzIiwic2VsZWN0aW9uIiwiZm9jdXNOb2RlJCQxIiwiZ2V0TW9kZXJuT2Zmc2V0c0Zyb21Qb2ludHMiLCJpbmRleFdpdGhpbkFuY2hvciIsImluZGV4V2l0aGluRm9jdXMiLCJvdXRlciIsInNldE9mZnNldHMiLCJvZmZzZXRzIiwidGVtcCIsInN0YXJ0TWFya2VyIiwiZW5kTWFya2VyIiwiaXNJbkRvY3VtZW50IiwiaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzIiwiZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24iLCJnZXRTZWxlY3Rpb24kMSIsInJlc3RvcmVTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsInNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCIsImV2ZW50VHlwZXMkMyIsImFjdGl2ZUVsZW1lbnQkMSIsImFjdGl2ZUVsZW1lbnRJbnN0JDEiLCJsYXN0U2VsZWN0aW9uIiwibW91c2VEb3duIiwiY29uc3RydWN0U2VsZWN0RXZlbnQiLCJjdXJyZW50U2VsZWN0aW9uIiwiQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNBbmltYXRpb25FdmVudCIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljQ2xpcGJvYXJkRXZlbnQiLCJGb2N1c0V2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljRm9jdXNFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJub3JtYWxpemVLZXkiLCJ0cmFuc2xhdGVUb0tleSIsImdldEV2ZW50S2V5IiwiS2V5Ym9hcmRFdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJEcmFnRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJUb3VjaEV2ZW50SW50ZXJmYWNlIiwiU3ludGhldGljVG91Y2hFdmVudCIsIlRyYW5zaXRpb25FdmVudEludGVyZmFjZSIsIlN5bnRoZXRpY1RyYW5zaXRpb25FdmVudCIsIldoZWVsRXZlbnRJbnRlcmZhY2UiLCJTeW50aGV0aWNXaGVlbEV2ZW50IiwiZXZlbnRUeXBlcyQ0IiwidG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnIiwiY2FwaXRhbGl6ZWRFdmVudCIsIm9uRXZlbnQiLCJ0b3BFdmVudCIsImtub3duSFRNTFRvcExldmVsVHlwZXMiLCJlbmFibGVBc3luY1N1YnRyZWVBUEkiLCJlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NIiwiZW5hYmxlQ3JlYXRlUm9vdCIsImVuYWJsZVVzZXJUaW1pbmdBUEkiLCJlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIiLCJlbmFibGVOb29wUmVjb25jaWxlciIsImVuYWJsZVBlcnNpc3RlbnRSZWNvbmNpbGVyIiwidmFsdWVTdGFjayIsImZpYmVyU3RhY2siLCJjcmVhdGVDdXJzb3IiLCJyZXNldCQxIiwiZGVzY3JpYmVGaWJlciIsImdldFN0YWNrQWRkZW5kdW1CeVdvcmtJblByb2dyZXNzRmliZXIiLCJ3b3JrSW5Qcm9ncmVzcyIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSIsIlJlYWN0RGVidWdDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtIiwicmVzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50UGhhc2UiLCJyZWFjdEVtb2ppIiwid2FybmluZ0Vtb2ppIiwic3VwcG9ydHNVc2VyVGltaW5nIiwibWFyayIsImNsZWFyTWFya3MiLCJtZWFzdXJlIiwiY2xlYXJNZWFzdXJlcyIsImN1cnJlbnRGaWJlciIsImN1cnJlbnRQaGFzZSIsImN1cnJlbnRQaGFzZUZpYmVyIiwiaXNDb21taXR0aW5nIiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0IiwiaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UiLCJjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wIiwiZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQiLCJsYWJlbHNJbkN1cnJlbnRDb21taXQiLCJmb3JtYXRNYXJrTmFtZSIsIm1hcmtOYW1lIiwiZm9ybWF0TGFiZWwiLCJsYWJlbCIsIndhcm5pbmckJDEiLCJzdWZmaXgiLCJiZWdpbk1hcmsiLCJjbGVhck1hcmsiLCJlbmRNYXJrIiwiZm9ybWF0dGVkTWFya05hbWUiLCJmb3JtYXR0ZWRMYWJlbCIsImdldEZpYmVyTWFya05hbWUiLCJkZWJ1Z0lEIiwiZ2V0RmliZXJMYWJlbCIsImJlZ2luRmliZXJNYXJrIiwiX2RlYnVnSUQiLCJjbGVhckZpYmVyTWFyayIsImVuZEZpYmVyTWFyayIsInNob3VsZElnbm9yZUZpYmVyIiwiY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCIsInBhdXNlVGltZXJzIiwiX2RlYnVnSXNDdXJyZW50bHlUaW1pbmciLCJyZXN1bWVUaW1lcnNSZWN1cnNpdmVseSIsInJlc3VtZVRpbWVycyIsInJlY29yZEVmZmVjdCIsInJlY29yZFNjaGVkdWxlVXBkYXRlIiwic3RhcnRXb3JrVGltZXIiLCJjYW5jZWxXb3JrVGltZXIiLCJzdG9wV29ya1RpbWVyIiwic3RvcEZhaWxlZFdvcmtUaW1lciIsInN0YXJ0UGhhc2VUaW1lciIsInN0b3BQaGFzZVRpbWVyIiwic3RhcnRXb3JrTG9vcFRpbWVyIiwibmV4dFVuaXRPZldvcmsiLCJzdG9wV29ya0xvb3BUaW1lciIsImludGVycnVwdGVkQnkiLCJzdGFydENvbW1pdFRpbWVyIiwiY2xlYXIiLCJzdG9wQ29tbWl0VGltZXIiLCJzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIiLCJzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lciIsInN0YXJ0Q29tbWl0TGlmZUN5Y2xlc1RpbWVyIiwic3RvcENvbW1pdExpZmVDeWNsZXNUaW1lciIsIndhcm5lZEFib3V0TWlzc2luZ0dldENoaWxkQ29udGV4dCIsImNvbnRleHRTdGFja0N1cnNvciIsImRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IiLCJwcmV2aW91c0NvbnRleHQiLCJnZXRVbm1hc2tlZENvbnRleHQiLCJoYXNPd25Db250ZXh0IiwiaXNDb250ZXh0UHJvdmlkZXIiLCJjYWNoZUNvbnRleHQiLCJ1bm1hc2tlZENvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiZ2V0TWFza2VkQ29udGV4dCIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0Q29uc3VtZXIiLCJwb3BDb250ZXh0UHJvdmlkZXIiLCJwb3BUb3BMZXZlbENvbnRleHRPYmplY3QiLCJwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0IiwiZGlkQ2hhbmdlIiwicHJvY2Vzc0NoaWxkQ29udGV4dCIsInBhcmVudENvbnRleHQiLCJjaGlsZENvbnRleHQiLCJjb250ZXh0S2V5IiwicHVzaENvbnRleHRQcm92aWRlciIsIm1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0IiwiaW52YWxpZGF0ZUNvbnRleHRQcm92aWRlciIsIm1lcmdlZENvbnRleHQiLCJyZXNldENvbnRleHQiLCJmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCIsIk5vV29yayIsIlN5bmMiLCJOZXZlciIsIlVOSVRfU0laRSIsIk1BR0lDX05VTUJFUl9PRkZTRVQiLCJtc1RvRXhwaXJhdGlvblRpbWUiLCJtcyIsImNlaWxpbmciLCJudW0iLCJwcmVjaXNpb24iLCJjb21wdXRlRXhwaXJhdGlvbkJ1Y2tldCIsImN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkluTXMiLCJidWNrZXRTaXplTXMiLCJOb0NvbnRleHQiLCJBc3luY1VwZGF0ZXMiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsImRlYnVnQ291bnRlciIsIkZpYmVyTm9kZSIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiY3JlYXRlRmliZXJGcm9tRWxlbWVudCIsImNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50IiwiZWxlbWVudHMiLCJjcmVhdGVGaWJlckZyb21UZXh0IiwiY29udGVudCIsImNyZWF0ZUZpYmVyRnJvbUhvc3RJbnN0YW5jZUZvckRlbGV0aW9uIiwiY3JlYXRlRmliZXJGcm9tQ2FsbCIsImNyZWF0ZUZpYmVyRnJvbVJldHVybiIsInJldHVybk5vZGUiLCJjcmVhdGVGaWJlckZyb21Qb3J0YWwiLCJwb3J0YWwiLCJjcmVhdGVGaWJlclJvb3QiLCJ1bmluaXRpYWxpemVkRmliZXIiLCJoYXNMb2dnZWRFcnJvciIsImNhdGNoRXJyb3JzIiwiaW5qZWN0SW50ZXJuYWxzIiwiaW50ZXJuYWxzIiwiaG9vayIsInJlbmRlcmVySUQiLCJvbkNvbW1pdFJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3JlYXRlVXBkYXRlUXVldWUiLCJpc1Byb2Nlc3NpbmciLCJpbnNlcnRVcGRhdGVJbnRvUXVldWUiLCJ1cGRhdGUiLCJpbnNlcnRVcGRhdGVJbnRvRmliZXIiLCJhbHRlcm5hdGVGaWJlciIsInF1ZXVlMSIsInF1ZXVlMiIsImdldFVwZGF0ZUV4cGlyYXRpb25UaW1lIiwiZ2V0U3RhdGVGcm9tVXBkYXRlIiwicHJldlN0YXRlIiwidXBkYXRlRm4iLCJwcm9jZXNzVXBkYXRlUXVldWUiLCJyZW5kZXJFeHBpcmF0aW9uVGltZSIsImRvbnRNdXRhdGVQcmV2U3RhdGUiLCJkaWRTa2lwIiwidXBkYXRlRXhwaXJhdGlvblRpbWUiLCJfcGFydGlhbFN0YXRlIiwiX2NhbGxiYWNrTGlzdCIsImNvbW1pdENhbGxiYWNrcyIsIl9jYWxsYmFjayIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Iiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwiUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50IiwibWVtb2l6ZVByb3BzIiwibWVtb2l6ZVN0YXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwib2xkU3RhdGUiLCJuZXdTdGF0ZSIsIm5ld0NvbnRleHQiLCJzaG91bGRVcGRhdGUiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50Iiwibm9HZXRJbml0aWFsU3RhdGVPbkVTNiIsImdldEluaXRpYWxTdGF0ZSIsIm5vR2V0RGVmYXVsdFByb3BzT25FUzYiLCJub0luc3RhbmNlUHJvcFR5cGVzIiwibm9JbnN0YW5jZUNvbnRleHRUeXBlcyIsIm5vQ29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwibm9Db21wb25lbnREaWRVbm1vdW50IiwiY29tcG9uZW50RGlkVW5tb3VudCIsIm5vQ29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzIiwibm9Db21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsIm5vSW5zdGFuY2VEZWZhdWx0UHJvcHMiLCJyZXNldElucHV0UG9pbnRlcnMiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiY3RvciIsIm5lZWRzQ29udGV4dCIsImNhbGxDb21wb25lbnRXaWxsTW91bnQiLCJjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIm9sZENvbnRleHQiLCJuZXdVbm1hc2tlZENvbnRleHQiLCJjcmVhdGVQb3J0YWwkMSIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIndhcm5Gb3JNaXNzaW5nS2V5IiwiaXNBcnJheSQxIiwiUkVBQ1RfQ0FMTF9UWVBFIiwiUkVBQ1RfUkVUVVJOX1RZUEUiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsImNvZXJjZVJlZiIsIm1peGVkUmVmIiwic3RyaW5nUmVmIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwicmV0dXJuRmliZXIiLCJuZXdDaGlsZCIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsIkNoaWxkUmVjb25jaWxlciIsInNob3VsZENsb25lIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjbG9uZSIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiZXhpc3RpbmciLCJ1cGRhdGVFbGVtZW50IiwidXBkYXRlQ2FsbCIsInVwZGF0ZVJldHVybiIsInVwZGF0ZVBvcnRhbCIsInVwZGF0ZUZyYWdtZW50IiwiY3JlYXRlQ2hpbGQiLCJfY3JlYXRlZCIsIl9jcmVhdGVkMiIsIl9jcmVhdGVkMyIsIl9jcmVhdGVkNCIsIl9jcmVhdGVkNSIsIl9jcmVhdGVkNiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIl9tYXRjaGVkRmliZXI0IiwiX21hdGNoZWRGaWJlcjUiLCJ3YXJuT25JbnZhbGlkS2V5Iiwia25vd25LZXlzIiwicmVjb25jaWxlQ2hpbGRyZW5BcnJheSIsIm5ld0NoaWxkcmVuIiwicmVzdWx0aW5nRmlyc3RDaGlsZCIsInByZXZpb3VzTmV3RmliZXIiLCJuZXh0T2xkRmliZXIiLCJfbmV3RmliZXIiLCJfbmV3RmliZXIyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJwb3NzaWJsZU1hcCIsIl9uZXdDaGlsZHJlbiIsIl9uZXdGaWJlcjMiLCJfbmV3RmliZXI0IiwicmVjb25jaWxlU2luZ2xlVGV4dE5vZGUiLCJyZWNvbmNpbGVTaW5nbGVFbGVtZW50IiwiX2NyZWF0ZWQ3IiwicmVjb25jaWxlU2luZ2xlQ2FsbCIsInJlY29uY2lsZVNpbmdsZVJldHVybiIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzIiwiX2lzTW9ja0Z1bmN0aW9uIiwicmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlIiwibW91bnRDaGlsZEZpYmVyc0luUGxhY2UiLCJjbG9uZUNoaWxkRmliZXJzIiwiY3VycmVudENoaWxkIiwid2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzIiwiUmVhY3RGaWJlckJlZ2luV29yayIsImhvc3RDb250ZXh0IiwiaHlkcmF0aW9uQ29udGV4dCIsIl9SZWFjdEZpYmVyQ2xhc3NDb21wbyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwicmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lIiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsIm1hcmtSZWYiLCJ1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50IiwibmV4dFByb3BzIiwidXBkYXRlQ2xhc3NDb21wb25lbnQiLCJoYXNDb250ZXh0IiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwicHJldlByb3BzIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJ1cGRhdGVIb3N0VGV4dCIsIm1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudCIsImRlYnVnU291cmNlIiwidXBkYXRlQ2FsbENvbXBvbmVudCIsIm5leHRDYWxsIiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiYmFpbG91dE9uTG93UHJpb3JpdHkiLCJuZXh0U3RhdGUiLCJSZWFjdEZpYmVyQ29tcGxldGVXb3JrIiwibWFya1VwZGF0ZSIsImFwcGVuZEFsbFJldHVybnMiLCJyZXR1cm5zIiwibW92ZUNhbGxUb0hhbmRsZXJQaGFzZSIsImFwcGVuZEFsbENoaWxkcmVuIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInVwZGF0ZVBheWxvYWQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJvbGRUZXh0IiwibmV3VGV4dCIsImNsb25lSW5zdGFuY2UiLCJjcmVhdGVDb250YWluZXJDaGlsZFNldCIsImFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCIsImZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4iLCJhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyIiwiY29udGFpbmVyQ2hpbGRTZXQiLCJwb3J0YWxPclJvb3QiLCJjaGlsZHJlblVuY2hhbmdlZCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwiY3VycmVudEluc3RhbmNlIiwicmVjeWNsYWJsZUluc3RhbmNlIiwibmV3SW5zdGFuY2UiLCJjdXJyZW50SG9zdENvbnRleHQiLCJmaWJlclJvb3QiLCJfY3VycmVudEhvc3RDb250ZXh0Iiwid2FzSHlkcmF0ZWQiLCJfaW5zdGFuY2UiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2skMiIsImhhc0NhdWdodEVycm9yJDEiLCJjbGVhckNhdWdodEVycm9yJDEiLCJSZWFjdEZpYmVyQ29tbWl0V29yayIsImNhcHR1cmVFcnJvciIsImNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsInVubW91bnRFcnJvciIsInNhZmVseURldGFjaFJlZiIsInJlZkVycm9yIiwiX3VwZGF0ZVF1ZXVlIiwiX2luc3RhbmNlMiIsImN1cnJlbnRSZWYiLCJjb21taXRVbm1vdW50IiwiY29tbWl0TmVzdGVkVW5tb3VudHMiLCJ1bm1vdW50SG9zdENvbXBvbmVudHMiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImRldGFjaEZpYmVyIiwiY29tbWl0Q29udGFpbmVyIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiZW1wdHlDaGlsZFNldCIsIl9wZW5kaW5nQ2hpbGRyZW4iLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsInNpYmxpbmdzIiwicGFyZW50RmliZXIiLCJpc0NvbnRhaW5lciIsImJlZm9yZSIsImN1cnJlbnRQYXJlbnRJc1ZhbGlkIiwiY3VycmVudFBhcmVudElzQ29udGFpbmVyIiwiZmluZFBhcmVudCIsInRleHRJbnN0YW5jZSIsIk5PX0NPTlRFWFQiLCJSZWFjdEZpYmVySG9zdENvbnRleHQiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwicmVxdWlyZWRDb250ZXh0Iiwicm9vdEluc3RhbmNlIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsIm5leHRDb250ZXh0IiwiUmVhY3RGaWJlckh5ZHJhdGlvbkNvbnRleHQiLCJoeWRyYXRpb25QYXJlbnRGaWJlciIsIm5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJpc0h5ZHJhdGluZyIsInBhcmVudEluc3RhbmNlIiwiZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlIiwiaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZSIsInBhcmVudENvbnRhaW5lciIsInBhcmVudFByb3BzIiwiX3R5cGUiLCJfcHJvcHMiLCJfdGV4dCIsImNhbkh5ZHJhdGUiLCJuZXh0SW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwiUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiIsImRlYnVnVG9vbCIsIlJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMSIsImRlZmF1bHRTaG93RGlhbG9nIiwiY2FwdHVyZWRFcnJvciIsInNob3dEaWFsb2ciLCJsb2dDYXB0dXJlZEVycm9yIiwibG9nRXJyb3IiLCJjb21wb25lbnROYW1lTWVzc2FnZSIsImVycm9yQm91bmRhcnlNZXNzYWdlIiwiY29tYmluZWRNZXNzYWdlIiwiaW52b2tlR3VhcmRlZENhbGxiYWNrJDEiLCJkaWRXYXJuQWJvdXRTdGF0ZVRyYW5zaXRpb24iLCJkaWRXYXJuU2V0U3RhdGVDaGlsZENvbnRleHQiLCJ3YXJuQWJvdXRVcGRhdGVPblVubW91bnRlZCIsIndhcm5BYm91dEludmFsaWRVcGRhdGVzIiwiUmVhY3RGaWJlclNjaGVkdWxlciIsIl9SZWFjdEZpYmVyQmVnaW5Xb3JrIiwiX1JlYWN0RmliZXJDb21wbGV0ZVdvIiwiX1JlYWN0RmliZXJDb21taXRXb3JrIiwic3RhcnRUaW1lIiwibW9zdFJlY2VudEN1cnJlbnRUaW1lIiwiZXhwaXJhdGlvbkNvbnRleHQiLCJpc1dvcmtpbmciLCJuZXh0Um9vdCIsIm5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSIsImNhcHR1cmVkRXJyb3JzIiwiZmFpbGVkQm91bmRhcmllcyIsImNvbW1pdFBoYXNlQm91bmRhcmllcyIsImZpcnN0VW5jYXVnaHRFcnJvciIsImRpZEZhdGFsIiwiaXNVbm1vdW50aW5nIiwicmVzZXRDb250ZXh0U3RhY2siLCJjb21taXRBbGxIb3N0RWZmZWN0cyIsInByaW1hcnlFZmZlY3RUYWciLCJfY3VycmVudCIsIl9jdXJyZW50MiIsImNvbW1pdEFsbExpZmVDeWNsZXMiLCJjb21taXRFcnJvckhhbmRsaW5nIiwiY29tbWl0Um9vdCIsIl9lcnJvciIsIl9kaWRFcnJvciIsIl9lcnJvcjIiLCJvbkNvbW1pdFdvcmsiLCJzY2hlZHVsZUVycm9yUmVjb3ZlcnkiLCJfZXJyb3IzIiwib25VbmNhdWdodEVycm9yIiwicmVtYWluaW5nVGltZSIsInJlc2V0RXhwaXJhdGlvblRpbWUiLCJyZW5kZXJUaW1lIiwibmV3RXhwaXJhdGlvblRpbWUiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJvbkNvbXBsZXRlV29yayIsInBlcmZvcm1Vbml0T2ZXb3JrIiwib25CZWdpbldvcmsiLCJwZXJmb3JtRmFpbGVkVW5pdE9mV29yayIsIndvcmtMb29wIiwic2xvd1dvcmtMb29wVGhhdENoZWNrc0ZvckZhaWxlZFdvcmsiLCJzaG91bGRZaWVsZCIsImhhc0NhcHR1cmVkRXJyb3IiLCJyZW5kZXJSb290Q2F0Y2hCbG9jayIsImZhaWxlZFdvcmsiLCJib3VuZGFyeSIsInVud2luZENvbnRleHRzIiwicmVuZGVyUm9vdCIsInVuY2F1Z2h0RXJyb3IiLCJpc0ZhaWxlZEJvdW5kYXJ5IiwiX2NvbXBvbmVudFN0YWNrIiwiX2NvbXBvbmVudE5hbWUiLCJlZmZlY3RmdWxGaWJlciIsInJlY2FsY3VsYXRlQ3VycmVudFRpbWUiLCJleHBpcmF0aW9uTXMiLCJzY2hlZHVsZVdvcmtJbXBsIiwiaXNFcnJvclJlY292ZXJ5IiwicmVxdWVzdFdvcmsiLCJwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0Iiwic3luY1VwZGF0ZXMiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImlzQ2FsbGJhY2tTY2hlZHVsZWQiLCJpc1JlbmRlcmluZyIsIm5leHRGbHVzaGVkUm9vdCIsIm5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUiLCJkZWFkbGluZURpZEV4cGlyZSIsImhhc1VuaGFuZGxlZEVycm9yIiwidW5oYW5kbGVkRXJyb3IiLCJkZWFkbGluZSIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiaXNVbmJhdGNoaW5nVXBkYXRlcyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrIiwicGVyZm9ybVdvcmtPblJvb3QiLCJwZXJmb3JtV29yayIsInBlcmZvcm1Bc3luY1dvcmsiLCJmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCIsImhpZ2hlc3RQcmlvcml0eVdvcmsiLCJoaWdoZXN0UHJpb3JpdHlSb290IiwicHJldmlvdXNTY2hlZHVsZWRSb290IiwicHJldmlvdXNGbHVzaGVkUm9vdCIsImRsIiwibWluRXhwaXJhdGlvblRpbWUiLCJfZXJyb3I0IiwiX2ZpbmlzaGVkV29yayIsInByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQxIiwiX1JlYWN0RmliZXJTY2hlZHVsZXIiLCJzY2hlZHVsZVRvcExldmVsVXBkYXRlIiwiaG9zdEZpYmVyIiwib25Nb3VudENvbnRhaW5lciIsIm9uVW5tb3VudENvbnRhaW5lciIsIm9uVXBkYXRlQ29udGFpbmVyIiwiY29udGFpbmVyRmliZXIiLCJkZXZUb29sc0NvbmZpZyIsIlJlYWN0RmliZXJSZWNvbmNpbGVyJDIiLCJSZWFjdEZpYmVyUmVjb25jaWxlciQzIiwicmVhY3RSZWNvbmNpbGVyIiwiaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3ciLCJySUMiLCJmcmFtZUNhbGxiYWNrIiwic2NoZWR1bGVkUklDQ2FsbGJhY2siLCJpc0lkbGVTY2hlZHVsZWQiLCJpc0FuaW1hdGlvbkZyYW1lU2NoZWR1bGVkIiwiZnJhbWVEZWFkbGluZSIsInByZXZpb3VzRnJhbWVUaW1lIiwiYWN0aXZlRnJhbWVUaW1lIiwiZnJhbWVEZWFkbGluZU9iamVjdCIsIm1lc3NhZ2VLZXkiLCJpZGxlVGljayIsImFuaW1hdGlvblRpY2siLCJyYWZUaW1lIiwibmV4dEZyYW1lVGltZSIsIlZBTElEX0FUVFJJQlVURV9OQU1FX1JFR0VYIiwiUmVnRXhwIiwiaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSIsInZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSIsImlzQXR0cmlidXRlTmFtZVNhZmUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsImdldFZhbHVlRm9yUHJvcGVydHkiLCJleHBlY3RlZCIsInN0cmluZ1ZhbHVlIiwiZ2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJzZXRWYWx1ZUZvclByb3BlcnR5IiwiZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eSIsIm5hbWVzcGFjZSIsInNldFZhbHVlRm9yQXR0cmlidXRlIiwiZGVsZXRlVmFsdWVGb3JBdHRyaWJ1dGUiLCJSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyIsImhhc1JlYWRPbmx5VmFsdWUiLCJjaGVja2JveCIsImltYWdlIiwicmFkaW8iLCJzdWJtaXQiLCJvbkNoYW5nZSIsImdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyIiwiZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQzIiwiZGlkV2FyblZhbHVlRGVmYXVsdFZhbHVlIiwiZGlkV2FybkNoZWNrZWREZWZhdWx0Q2hlY2tlZCIsImRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQiLCJkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkIiwiaXNDb250cm9sbGVkIiwidXNlc0NoZWNrZWQiLCJnZXRIb3N0UHJvcHMiLCJob3N0UHJvcHMiLCJpbml0V3JhcHBlclN0YXRlIiwidXBkYXRlV3JhcHBlciIsInZhbHVlQXNOdW1iZXIiLCJwb3N0TW91bnRXcmFwcGVyIiwicmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxIiwidXBkYXRlTmFtZWRDb3VzaW5zIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsIm90aGVyTm9kZSIsIm90aGVyUHJvcHMiLCJmbGF0dGVuQ2hpbGRyZW4iLCJ2YWxpZGF0ZVByb3BzIiwicG9zdE1vdW50V3JhcHBlciQxIiwiZ2V0SG9zdFByb3BzJDEiLCJnZXRDdXJyZW50RmliZXJPd25lck5hbWUkMyIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNCIsImRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxIiwidmFsdWVQcm9wTmFtZXMiLCJjaGVja1NlbGVjdFByb3BUeXBlcyIsInVwZGF0ZU9wdGlvbnMiLCJwcm9wVmFsdWUiLCJzZXREZWZhdWx0U2VsZWN0ZWQiLCJzZWxlY3RlZFZhbHVlcyIsInNlbGVjdGVkVmFsdWUiLCJfc2VsZWN0ZWRWYWx1ZSIsIl9pMiIsImdldEhvc3RQcm9wcyQyIiwiaW5pdFdyYXBwZXJTdGF0ZSQxIiwicG9zdE1vdW50V3JhcHBlciQyIiwicG9zdFVwZGF0ZVdyYXBwZXIiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDIiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUiLCJkaWRXYXJuVmFsRGVmYXVsdFZhbCIsImdldEhvc3RQcm9wcyQzIiwiaW5pdFdyYXBwZXJTdGF0ZSQyIiwidXBkYXRlV3JhcHBlciQxIiwibmV3VmFsdWUiLCJwb3N0TW91bnRXcmFwcGVyJDMiLCJyZXN0b3JlQ29udHJvbGxlZFN0YXRlJDMiLCJIVE1MX05BTUVTUEFDRSQxIiwiTUFUSF9OQU1FU1BBQ0UiLCJTVkdfTkFNRVNQQUNFIiwiTmFtZXNwYWNlcyIsImdldEludHJpbnNpY05hbWVzcGFjZSIsImdldENoaWxkTmFtZXNwYWNlIiwicGFyZW50TmFtZXNwYWNlIiwiY3JlYXRlTWljcm9zb2Z0VW5zYWZlTG9jYWxGdW5jdGlvbiIsImFyZzAiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJyZXVzYWJsZVNWR0NvbnRhaW5lciIsInNldElubmVySFRNTCIsInN2Z05vZGUiLCJtYXRjaEh0bWxSZWdFeHAiLCJlc2NhcGVIdG1sIiwic3RyaW5nIiwibGFzdEluZGV4IiwiZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyIiwic2V0VGV4dENvbnRlbnQiLCJzZXRUZXh0Q29udGVudCQxIiwiaXNVbml0bGVzc051bWJlciIsInByZWZpeEtleSIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJpc0N1c3RvbVByb3BlcnR5IiwiaXNFbXB0eSIsIndhcm5WYWxpZFN0eWxlIiwiYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuIiwiYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuIiwid2FybmVkU3R5bGVOYW1lcyIsIndhcm5lZFN0eWxlVmFsdWVzIiwid2FybmVkRm9yTmFOVmFsdWUiLCJ3YXJuZWRGb3JJbmZpbml0eVZhbHVlIiwid2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUiLCJ3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUiLCJ3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24iLCJ3YXJuU3R5bGVWYWx1ZUlzTmFOIiwid2FyblN0eWxlVmFsdWVJc0luZmluaXR5IiwiaXNGaW5pdGUiLCJ3YXJuVmFsaWRTdHlsZSQxIiwiY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzIiwic3R5bGVzIiwic2VyaWFsaXplZCIsImRlbGltaXRlciIsInN0eWxlTmFtZSIsInN0eWxlVmFsdWUiLCJzZXRWYWx1ZUZvclN0eWxlcyIsIm9taXR0ZWRDbG9zZVRhZ3MiLCJ2b2lkRWxlbWVudFRhZ3MiLCJIVE1MJDEiLCJhc3NlcnRWYWxpZFByb3BzIiwiaXNDdXN0b21Db21wb25lbnQiLCJhcmlhUHJvcGVydGllcyIsIndhcm5lZFByb3BlcnRpZXMiLCJyQVJJQSIsInJBUklBQ2FtZWwiLCJ2YWxpZGF0ZVByb3BlcnR5IiwiYXJpYU5hbWUiLCJjb3JyZWN0TmFtZSIsInN0YW5kYXJkTmFtZSIsIndhcm5JbnZhbGlkQVJJQVByb3BzIiwiaW52YWxpZFByb3BzIiwiaXNWYWxpZCIsInVua25vd25Qcm9wU3RyaW5nIiwidmFsaWRhdGVQcm9wZXJ0aWVzIiwiZGlkV2FyblZhbHVlTnVsbCIsImdldFN0YWNrQWRkZW5kdW0kMSIsInZhbGlkYXRlUHJvcGVydGllcyQxIiwicG9zc2libGVTdGFuZGFyZE5hbWVzIiwiYWNjZXB0IiwiYWNjZXB0Y2hhcnNldCIsImFjY2Vzc2tleSIsImFsbG93ZnVsbHNjcmVlbiIsImFsdCIsImFzIiwiYXV0b2NhcGl0YWxpemUiLCJhdXRvY29tcGxldGUiLCJhdXRvY29ycmVjdCIsImF1dG9mb2N1cyIsImF1dG9wbGF5IiwiYXV0b3NhdmUiLCJjZWxscGFkZGluZyIsImNlbGxzcGFjaW5nIiwiY2hhbGxlbmdlIiwiY2hhcnNldCIsImNpdGUiLCJjbGFzc2lkIiwiY2xhc3NuYW1lIiwiY29sc3BhbiIsImNvbnRlbnRlZGl0YWJsZSIsImNvbnRleHRtZW51IiwiY29udHJvbHNsaXN0IiwiY29vcmRzIiwiY3Jvc3NvcmlnaW4iLCJkYW5nZXJvdXNseXNldGlubmVyaHRtbCIsImRlZmF1bHRjaGVja2VkIiwiZGVmYXVsdHZhbHVlIiwiZW5jdHlwZSIsImZvcm1tZXRob2QiLCJmb3JtYWN0aW9uIiwiZm9ybWVuY3R5cGUiLCJmb3Jtbm92YWxpZGF0ZSIsImZvcm10YXJnZXQiLCJmcmFtZWJvcmRlciIsImhlaWdodCIsImhpZ2giLCJocmVmIiwiaHJlZmxhbmciLCJodG1sZm9yIiwiaHR0cGVxdWl2IiwiaWNvbiIsImlubmVyaHRtbCIsImlucHV0bW9kZSIsImludGVncml0eSIsIml0ZW1pZCIsIml0ZW1wcm9wIiwiaXRlbXJlZiIsIml0ZW1zY29wZSIsIml0ZW10eXBlIiwia2V5cGFyYW1zIiwia2V5dHlwZSIsImtpbmQiLCJsYW5nIiwibGlzdCIsImxvdyIsIm1hbmlmZXN0IiwibWFyZ2lud2lkdGgiLCJtYXJnaW5oZWlnaHQiLCJtYXhsZW5ndGgiLCJtZWRpYSIsIm1lZGlhZ3JvdXAiLCJtaW5sZW5ndGgiLCJub25jZSIsIm5vdmFsaWRhdGUiLCJvcHRpbXVtIiwicGF0dGVybiIsInBsYWNlaG9sZGVyIiwicGxheXNpbmxpbmUiLCJwb3N0ZXIiLCJwcmVsb2FkIiwicHJvZmlsZSIsInJhZGlvZ3JvdXAiLCJyZWFkb25seSIsInJlZmVycmVycG9saWN5IiwicmVsIiwicm9sZSIsInJvd3NwYW4iLCJzYW5kYm94Iiwic2Nyb2xsaW5nIiwic2hhcGUiLCJzaXplcyIsInNwZWxsY2hlY2siLCJzcmMiLCJzcmNkb2MiLCJzcmNsYW5nIiwic3Jjc2V0Iiwic3VtbWFyeSIsInRhYmluZGV4IiwidXNlbWFwIiwid2lkdGgiLCJ3bW9kZSIsImFib3V0IiwiYWNjZW50aGVpZ2h0IiwiYWNjdW11bGF0ZSIsImFkZGl0aXZlIiwiYWxpZ25tZW50YmFzZWxpbmUiLCJhbGxvd3Jlb3JkZXIiLCJhbHBoYWJldGljIiwiYW1wbGl0dWRlIiwiYXJhYmljZm9ybSIsImFzY2VudCIsImF0dHJpYnV0ZW5hbWUiLCJhdHRyaWJ1dGV0eXBlIiwiYXV0b3JldmVyc2UiLCJhemltdXRoIiwiYmFzZWZyZXF1ZW5jeSIsImJhc2VsaW5lc2hpZnQiLCJiYXNlcHJvZmlsZSIsImJib3giLCJiZWdpbiIsImJpYXMiLCJieSIsImNhbGNtb2RlIiwiY2FwaGVpZ2h0IiwiY2xpcCIsImNsaXBwYXRoIiwiY2xpcHBhdGh1bml0cyIsImNsaXBydWxlIiwiY29sb3JpbnRlcnBvbGF0aW9uIiwiY29sb3JpbnRlcnBvbGF0aW9uZmlsdGVycyIsImNvbG9ycHJvZmlsZSIsImNvbG9ycmVuZGVyaW5nIiwiY29udGVudHNjcmlwdHR5cGUiLCJjb250ZW50c3R5bGV0eXBlIiwiY3giLCJjeSIsImRhdGF0eXBlIiwiZGVjZWxlcmF0ZSIsImRlc2NlbnQiLCJkaWZmdXNlY29uc3RhbnQiLCJkaXJlY3Rpb24iLCJkaXNwbGF5IiwiZGl2aXNvciIsImRvbWluYW50YmFzZWxpbmUiLCJkdXIiLCJkeCIsImR5IiwiZWRnZW1vZGUiLCJlbGV2YXRpb24iLCJlbmFibGViYWNrZ3JvdW5kIiwiZXhwb25lbnQiLCJleHRlcm5hbHJlc291cmNlc3JlcXVpcmVkIiwiZmlsbCIsImZpbGxvcGFjaXR5IiwiZmlsbHJ1bGUiLCJmaWx0ZXIiLCJmaWx0ZXJyZXMiLCJmaWx0ZXJ1bml0cyIsImZsb29kb3BhY2l0eSIsImZsb29kY29sb3IiLCJmb2N1c2FibGUiLCJmb250ZmFtaWx5IiwiZm9udHNpemUiLCJmb250c2l6ZWFkanVzdCIsImZvbnRzdHJldGNoIiwiZm9udHN0eWxlIiwiZm9udHZhcmlhbnQiLCJmb250d2VpZ2h0IiwiZngiLCJmeSIsImcxIiwiZzIiLCJnbHlwaG5hbWUiLCJnbHlwaG9yaWVudGF0aW9uaG9yaXpvbnRhbCIsImdseXBob3JpZW50YXRpb252ZXJ0aWNhbCIsImdseXBocmVmIiwiZ3JhZGllbnR0cmFuc2Zvcm0iLCJncmFkaWVudHVuaXRzIiwiaGFuZ2luZyIsImhvcml6YWR2eCIsImhvcml6b3JpZ2lueCIsImlkZW9ncmFwaGljIiwiaW1hZ2VyZW5kZXJpbmciLCJpbjIiLCJpbmxpc3QiLCJpbnRlcmNlcHQiLCJrMSIsImsyIiwiazMiLCJrNCIsImtlcm5lbG1hdHJpeCIsImtlcm5lbHVuaXRsZW5ndGgiLCJrZXJuaW5nIiwia2V5cG9pbnRzIiwia2V5c3BsaW5lcyIsImtleXRpbWVzIiwibGVuZ3RoYWRqdXN0IiwibGV0dGVyc3BhY2luZyIsImxpZ2h0aW5nY29sb3IiLCJsaW1pdGluZ2NvbmVhbmdsZSIsImxvY2FsIiwibWFya2VyZW5kIiwibWFya2VyaGVpZ2h0IiwibWFya2VybWlkIiwibWFya2Vyc3RhcnQiLCJtYXJrZXJ1bml0cyIsIm1hcmtlcndpZHRoIiwibWFzayIsIm1hc2tjb250ZW50dW5pdHMiLCJtYXNrdW5pdHMiLCJtYXRoZW1hdGljYWwiLCJtb2RlIiwibnVtb2N0YXZlcyIsIm9wZXJhdG9yIiwib3JpZW50Iiwib3JpZW50YXRpb24iLCJvcmlnaW4iLCJvdmVyZmxvdyIsIm92ZXJsaW5lcG9zaXRpb24iLCJvdmVybGluZXRoaWNrbmVzcyIsInBhaW50b3JkZXIiLCJwYW5vc2UxIiwicGF0aGxlbmd0aCIsInBhdHRlcm5jb250ZW50dW5pdHMiLCJwYXR0ZXJudHJhbnNmb3JtIiwicGF0dGVybnVuaXRzIiwicG9pbnRlcmV2ZW50cyIsInBvaW50cyIsInBvaW50c2F0eCIsInBvaW50c2F0eSIsInBvaW50c2F0eiIsInByZXNlcnZlYWxwaGEiLCJwcmVzZXJ2ZWFzcGVjdHJhdGlvIiwicHJpbWl0aXZldW5pdHMiLCJwcm9wZXJ0eSIsInJhZGl1cyIsInJlZngiLCJyZWZ5IiwicmVuZGVyaW5naW50ZW50IiwicmVwZWF0Y291bnQiLCJyZXBlYXRkdXIiLCJyZXF1aXJlZGV4dGVuc2lvbnMiLCJyZXF1aXJlZGZlYXR1cmVzIiwicmVzb3VyY2UiLCJyZXN0YXJ0IiwicmVzdWx0cyIsInJvdGF0ZSIsInJ4IiwicnkiLCJzY2FsZSIsInNlY3VyaXR5Iiwic2VlZCIsInNoYXBlcmVuZGVyaW5nIiwic2xvcGUiLCJzcGFjaW5nIiwic3BlY3VsYXJjb25zdGFudCIsInNwZWN1bGFyZXhwb25lbnQiLCJzcGVlZCIsInNwcmVhZG1ldGhvZCIsInN0YXJ0b2Zmc2V0Iiwic3RkZGV2aWF0aW9uIiwic3RlbWgiLCJzdGVtdiIsInN0aXRjaHRpbGVzIiwic3RvcGNvbG9yIiwic3RvcG9wYWNpdHkiLCJzdHJpa2V0aHJvdWdocG9zaXRpb24iLCJzdHJpa2V0aHJvdWdodGhpY2tuZXNzIiwic3Ryb2tlIiwic3Ryb2tlZGFzaGFycmF5Iiwic3Ryb2tlZGFzaG9mZnNldCIsInN0cm9rZWxpbmVjYXAiLCJzdHJva2VsaW5lam9pbiIsInN0cm9rZW1pdGVybGltaXQiLCJzdHJva2V3aWR0aCIsInN0cm9rZW9wYWNpdHkiLCJzdXBwcmVzc2NvbnRlbnRlZGl0YWJsZXdhcm5pbmciLCJzdXBwcmVzc2h5ZHJhdGlvbndhcm5pbmciLCJzdXJmYWNlc2NhbGUiLCJzeXN0ZW1sYW5ndWFnZSIsInRhYmxldmFsdWVzIiwidGFyZ2V0eCIsInRhcmdldHkiLCJ0ZXh0YW5jaG9yIiwidGV4dGRlY29yYXRpb24iLCJ0ZXh0bGVuZ3RoIiwidGV4dHJlbmRlcmluZyIsInRyYW5zZm9ybSIsInUxIiwidTIiLCJ1bmRlcmxpbmVwb3NpdGlvbiIsInVuZGVybGluZXRoaWNrbmVzcyIsInVuaWNvZGUiLCJ1bmljb2RlYmlkaSIsInVuaWNvZGVyYW5nZSIsInVuaXRzcGVyZW0iLCJ1bnNlbGVjdGFibGUiLCJ2YWxwaGFiZXRpYyIsInZlY3RvcmVmZmVjdCIsInZlcnRhZHZ5IiwidmVydG9yaWdpbngiLCJ2ZXJ0b3JpZ2lueSIsInZoYW5naW5nIiwidmlkZW9ncmFwaGljIiwidmlld2JveCIsInZpZXd0YXJnZXQiLCJ2aXNpYmlsaXR5Iiwidm1hdGhlbWF0aWNhbCIsInZvY2FiIiwid2lkdGhzIiwid29yZHNwYWNpbmciLCJ3cml0aW5nbW9kZSIsIngxIiwieDIiLCJ4Y2hhbm5lbHNlbGVjdG9yIiwieGhlaWdodCIsInhsaW5rYWN0dWF0ZSIsInhsaW5rYXJjcm9sZSIsInhsaW5raHJlZiIsInhsaW5rcm9sZSIsInhsaW5rc2hvdyIsInhsaW5rdGl0bGUiLCJ4bGlua3R5cGUiLCJ4bWxiYXNlIiwieG1sbGFuZyIsInhtbG5zIiwieG1sbnN4bGluayIsInhtbHNwYWNlIiwieTEiLCJ5MiIsInljaGFubmVsc2VsZWN0b3IiLCJ6b29tYW5kcGFuIiwiZ2V0U3RhY2tBZGRlbmR1bSQyIiwid2FybmVkUHJvcGVydGllcyQxIiwiaGFzT3duUHJvcGVydHkkMSIsIkVWRU5UX05BTUVfUkVHRVgiLCJyQVJJQSQxIiwickFSSUFDYW1lbCQxIiwidmFsaWRhdGVQcm9wZXJ0eSQxIiwiaXNSZXNlcnZlZCIsIndhcm5Vbmtub3duUHJvcGVydGllcyIsInVua25vd25Qcm9wcyIsInZhbGlkYXRlUHJvcGVydGllcyQyIiwiZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEiLCJnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDIiLCJkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiIsImRpZFdhcm5TaGFkeURPTSIsIkRBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MIiwiU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkckMSIsIkFVVE9GT0NVUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiSFRNTF9OQU1FU1BBQ0UiLCJ3YXJuZWRVbmtub3duVGFncyIsImRpYWxvZyIsInZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQiLCJOT1JNQUxJWkVfTkVXTElORVNfUkVHRVgiLCJOT1JNQUxJWkVfTlVMTF9BTkRfUkVQTEFDRU1FTlRfUkVHRVgiLCJub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUiLCJtYXJrdXAiLCJtYXJrdXBTdHJpbmciLCJ3YXJuRm9yVGV4dERpZmZlcmVuY2UiLCJzZXJ2ZXJUZXh0IiwiY2xpZW50VGV4dCIsIm5vcm1hbGl6ZWRDbGllbnRUZXh0Iiwibm9ybWFsaXplZFNlcnZlclRleHQiLCJ3YXJuRm9yUHJvcERpZmZlcmVuY2UiLCJzZXJ2ZXJWYWx1ZSIsImNsaWVudFZhbHVlIiwibm9ybWFsaXplZENsaWVudFZhbHVlIiwibm9ybWFsaXplZFNlcnZlclZhbHVlIiwid2FybkZvckV4dHJhQXR0cmlidXRlcyIsImF0dHJpYnV0ZU5hbWVzIiwibmFtZXMiLCJ3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIiLCJub3JtYWxpemVIVE1MIiwidGVzdEVsZW1lbnQiLCJlbnN1cmVMaXN0ZW5pbmdUbyIsInJvb3RDb250YWluZXJFbGVtZW50IiwiaXNEb2N1bWVudE9yRnJhZ21lbnQiLCJnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIiLCJtZWRpYUV2ZW50cyIsInRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50Iiwic2V0SW5pdGlhbERPTVByb3BlcnRpZXMiLCJkb21FbGVtZW50IiwiaXNDdXN0b21Db21wb25lbnRUYWciLCJwcm9wS2V5IiwibmV4dFByb3AiLCJuZXh0SHRtbCIsImNhblNldFRleHRDb250ZW50IiwidXBkYXRlRE9NUHJvcGVydGllcyIsIndhc0N1c3RvbUNvbXBvbmVudFRhZyIsImNyZWF0ZUVsZW1lbnQkMSIsImRpdiIsImNyZWF0ZVRleHROb2RlJDEiLCJzZXRJbml0aWFsUHJvcGVydGllcyQxIiwicmF3UHJvcHMiLCJzaGFkeVJvb3QiLCJkaWZmUHJvcGVydGllcyQxIiwibGFzdFJhd1Byb3BzIiwibmV4dFJhd1Byb3BzIiwibGFzdFByb3BzIiwic3R5bGVVcGRhdGVzIiwibGFzdFN0eWxlIiwibGFzdFByb3AiLCJsYXN0SHRtbCIsInVwZGF0ZVByb3BlcnRpZXMkMSIsImRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSIsImV4dHJhQXR0cmlidXRlTmFtZXMiLCJhdHRyaWJ1dGVzIiwicmF3SHRtbCIsInNlcnZlckhUTUwiLCJleHBlY3RlZEhUTUwiLCJleHBlY3RlZFN0eWxlIiwib3duTmFtZXNwYWNlIiwiZGlmZkh5ZHJhdGVkVGV4dCQxIiwidGV4dE5vZGUiLCJpc0RpZmZlcmVudCIsIndhcm5Gb3JVbm1hdGNoZWRUZXh0JDEiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEiLCJ3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEiLCJ3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQkMSIsIndhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxIiwiUmVhY3RET01GaWJlckNvbXBvbmVudCIsImdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNiIsInZhbGlkYXRlRE9NTmVzdGluZyIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJ1cGRhdGVkQW5jZXN0b3JJbmZvJDEiLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZFdpdGhQYXJlbnQiLCJwYXJlbnRUYWciLCJmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRUZXh0IiwicGFyZW50SW5mbyIsImludmFsaWRQYXJlbnQiLCJpbnZhbGlkQW5jZXN0b3IiLCJpbnZhbGlkUGFyZW50T3JBbmNlc3RvciIsImFuY2VzdG9yVGFnIiwid2FybktleSIsInRhZ0Rpc3BsYXlOYW1lIiwid2hpdGVzcGFjZUluZm8iLCJ1cGRhdGVkQW5jZXN0b3JJbmZvIiwiaXNUYWdWYWxpZEluQ29udGV4dCIsInZhbGlkYXRlRE9NTmVzdGluZyQxIiwiU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkciLCJldmVudHNFbmFibGVkIiwic2VsZWN0aW9uSW5mb3JtYXRpb24iLCJpc1ZhbGlkQ29udGFpbmVyIiwiZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyIiwic2hvdWxkSHlkcmF0ZUR1ZVRvTGVnYWN5SGV1cmlzdGljIiwicm9vdEVsZW1lbnQiLCJzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50IiwiRE9NUmVuZGVyZXIiLCJ2YWxpZGF0ZWRUYWciLCJfYW5jZXN0b3JJbmZvIiwicGFyZW50SG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dERldiIsIl9uYW1lc3BhY2UiLCJfYW5jZXN0b3JJbmZvMiIsImludGVybmFsSW5zdGFuY2VIYW5kbGUiLCJob3N0Q29udGV4dERldiIsIm93bkFuY2VzdG9ySW5mbyIsImJlZm9yZUNoaWxkIiwid2FybmVkQWJvdXRIeWRyYXRlQVBJIiwicmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJmb3JjZUh5ZHJhdGUiLCJob3N0SW5zdGFuY2UiLCJpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0Iiwicm9vdEVsIiwiaGFzTm9uUm9vdFJlYWN0Q2hpbGQiLCJzaG91bGRIeWRyYXRlIiwid2FybmVkIiwicm9vdFNpYmxpbmciLCJuZXdSb290IiwiUmVhY3RSb290IiwiUmVhY3RET00iLCJjb21wb25lbnRPckVsZW1lbnQiLCJ3YXJuZWRBYm91dFJlZnNJblJlbmRlciIsImNvbnRhaW5lck5vZGUiLCJyZW5kZXJlZEJ5RGlmZmVyZW50UmVhY3QiLCJfcm9vdEVsIiwiaXNDb250YWluZXJSZWFjdFJvb3QiLCJjcmVhdGVSb290IiwiZm91bmREZXZUb29scyIsInVzZXJBZ2VudCIsInByb3RvY29sIiwiUmVhY3RET00kMiIsIlJlYWN0RE9NJDMiLCJyZWFjdERvbSIsImh5cGhlbmF0ZSIsIm1zUGF0dGVybiIsIl91cHBlcmNhc2VQYXR0ZXJuIiwiY2FtZWxpemUiLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJBcHAiLCJsb2FkQ29tbWVudHNGcm9tU2VydmVyIiwicmVzIiwiYmFzaWNpbmZvIiwiYmlvIiwic2tpbGxzIiwiZXhwZXJpZW5jZSIsInByb2plY3RzIiwiQXhpb3MiLCJkZWZhdWx0Q29uZmlnIiwiYXhpb3MiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbFRva2VuIiwiYWxsIiwicHJvbWlzZXMiLCJzcHJlYWQiLCJpc1Nsb3dCdWZmZXIiLCJfaXNCdWZmZXIiLCJyZWFkRmxvYXRMRSIsIkludGVyY2VwdG9yTWFuYWdlciIsImRpc3BhdGNoUmVxdWVzdCIsImludGVyY2VwdG9ycyIsImNoYWluIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInVuc2hpZnQiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsInNoaWZ0Iiwibm9ybWFsaXplZE5hbWUiLCJwcm9jZXNzSGVhZGVyIiwiZW5jb2RlIiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnRzIiwic2VyaWFsaXplIiwicGFyc2VWYWx1ZSIsInRvSVNPU3RyaW5nIiwiaWdub3JlRHVwbGljYXRlT2YiLCJwYXJzZWQiLCJwYXJzZXIiLCJsaW5lIiwic3Vic3RyIiwic3RhbmRhcmRCcm93c2VyRW52IiwibXNpZSIsInVybFBhcnNpbmdOb2RlIiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsImhvc3QiLCJoYXNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJyZXF1ZXN0VVJMIiwibm9uU3RhbmRhcmRCcm93c2VyRW52Iiwib3V0cHV0IiwiYmxvY2siLCJpZHgiLCJ3cml0ZSIsImV4cGlyZXMiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJ0b0dNVFN0cmluZyIsImRlY29kZVVSSUNvbXBvbmVudCIsImhhbmRsZXJzIiwidXNlIiwiZWplY3QiLCJmb3JFYWNoSGFuZGxlciIsInRyYW5zZm9ybURhdGEiLCJpc0Fic29sdXRlVVJMIiwiY29tYmluZVVSTHMiLCJ0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkIiwidGhyb3dJZlJlcXVlc3RlZCIsImJhc2VVUkwiLCJjbGVhbkhlYWRlckNvbmZpZyIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJyZWFzb24iLCJmbnMiLCJyZWxhdGl2ZVVSTCIsImV4ZWN1dG9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJCYXNpY0luZm8iLCIkIiwidG9vbHRpcCIsInRvb2x0aXBUZXh0IiwiYWRkcmVzcyIsIkJpbyIsImFib3V0X21lIiwiVGVjaFNraWxscyIsInNraWxsTGlzdCIsInNraWxsc19zdGFjayIsInNraWxsbmFtZSIsIlNraWxsc0xpc3QiLCJza2lsbHNJdGVtcyIsIml0ZW0iLCJFeHBlcmllbmNlIiwiZXhwZXJpZW5jZUxpc3RJdGVtIiwid29yayIsIkV4cGVyaWVuY2VJdGVtIiwiZHV0eSIsIml0ZW1kdXR5IiwiY29tcGFueSIsIm92ZXJ2aWV3Iiwiam9idGl0bGUiLCJQcm9qZWN0cyIsIml0ZW1zIiwibmF2IiwicmV3aW5kIiwicmVzcG9uc2l2ZSIsIndlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uIiwiZmFjdG9yeSIsIl9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fIiwiX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV83X18iLCJfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzhfXyIsIm1vZHVsZXMiLCJpbnN0YWxsZWRNb2R1bGVzIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIm1vZHVsZUlkIiwibG9hZGVkIiwiZXZhbCIsIndlYnBhY2tQb2x5ZmlsbCIsImRlcHJlY2F0ZSIsInBhdGhzIiwiQU5PTllNT1VTIiwiUmVhY3RQcm9wVHlwZXMiLCJjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlciIsImJvb2wiLCJzeW1ib2wiLCJhbnkiLCJjcmVhdGVBbnlUeXBlQ2hlY2tlciIsImFycmF5T2YiLCJjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIiLCJjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIiLCJpbnN0YW5jZU9mIiwiY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlciIsImNyZWF0ZU5vZGVDaGVja2VyIiwib2JqZWN0T2YiLCJjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyIiwib25lT2YiLCJjcmVhdGVFbnVtVHlwZUNoZWNrZXIiLCJvbmVPZlR5cGUiLCJjcmVhdGVVbmlvblR5cGVDaGVja2VyIiwiY3JlYXRlU2hhcGVUeXBlQ2hlY2tlciIsImV4YWN0IiwiY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlciIsIlByb3BUeXBlRXJyb3IiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwibWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUiLCJtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCIsImNoZWNrVHlwZSIsImlzUmVxdWlyZWQiLCJwcm9wRnVsbE5hbWUiLCJzZWNyZXQiLCJjYWNoZUtleSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsImdldFBvc3RmaXhGb3JUeXBlV2FybmluZyIsInNoYXBlVHlwZXMiLCJhbGxLZXlzIiwiZXZlcnkiLCJlbnRyeSIsImlzU3ltYm9sIiwiUHJvcFR5cGVzIiwic2hpbSIsImdldFNoaW0iXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7O0FBRUE7QUFDQTs7Ozs7Ozs7K0NDN0RBOztBQUVBLElBQUlBLFFBQVFDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUE3QixFQUEyQztBQUN6Q0MsU0FBT0MsT0FBUCxHQUFpQixtQkFBQUMsQ0FBUSxFQUFSLENBQWpCO0FBQ0QsQ0FGRCxNQUVPO0FBQ0xGLFNBQU9DLE9BQVAsR0FBaUIsbUJBQUFDLENBQVEsRUFBUixDQUFqQjtBQUNELEM7Ozs7Ozs7Ozs7QUNORDtBQUNBLElBQUlMLFVBQVVHLE9BQU9DLE9BQVAsR0FBaUIsRUFBL0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsSUFBSUUsZ0JBQUo7QUFDQSxJQUFJQyxrQkFBSjs7QUFFQSxTQUFTQyxnQkFBVCxHQUE0QjtBQUN4QixVQUFNLElBQUlDLEtBQUosQ0FBVSxpQ0FBVixDQUFOO0FBQ0g7QUFDRCxTQUFTQyxtQkFBVCxHQUFnQztBQUM1QixVQUFNLElBQUlELEtBQUosQ0FBVSxtQ0FBVixDQUFOO0FBQ0g7QUFDQSxhQUFZO0FBQ1QsUUFBSTtBQUNBLFlBQUksT0FBT0UsVUFBUCxLQUFzQixVQUExQixFQUFzQztBQUNsQ0wsK0JBQW1CSyxVQUFuQjtB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NkYsVUFBTWs2RixJQUhhO0FBSW5CcjhFLFlBQVFxOEUsSUFKVztBQUtuQno5RixZQUFReTlGLElBTFc7QUFNbkJodUIsWUFBUWd1QixJQU5XO0FBT25CbEQsWUFBUWtELElBUFc7O0FBU25CakQsU0FBS2lELElBVGM7QUFVbkIvQyxhQUFTZ0QsT0FWVTtBQVduQi8xRixhQUFTODFGLElBWFU7QUFZbkI1QyxnQkFBWTZDLE9BWk87QUFhbkJqaUcsVUFBTWdpRyxJQWJhO0FBY25CekMsY0FBVTBDLE9BZFM7QUFlbkJ4QyxXQUFPd0MsT0FmWTtBQWdCbkJ0QyxlQUFXc0MsT0FoQlE7QUFpQm5CNWxCLFdBQU80bEIsT0FqQlk7QUFrQm5CbkMsV0FBT21DO0FBbEJZLEdBQXJCOztBQXFCQXRELGlCQUFldGpHLGNBQWYsR0FBZ0MzRCxhQUFoQztBQUNBaW5HLGlCQUFlb0QsU0FBZixHQUEyQnBELGNBQTNCOztBQUVBLFNBQU9BLGNBQVA7QUFDRCxDQTVDRCxDIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcbiBcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG4gXHRcdFx0XHRnZXQ6IGdldHRlclxuIFx0XHRcdH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDI0KTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyB3ZWJwYWNrL2Jvb3RzdHJhcCAyMTc0ODc0YWJjMWU3NGFlM2YzYiIsIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC5kZXZlbG9wbWVudC5qcycpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3JlYWN0L2luZGV4LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIFxuICovXG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG52YXIgZW1wdHlGdW5jdGlvbiA9IGZ1bmN0aW9uIGVtcHR5RnVuY3Rpb24oKSB7fTtcblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eU9iamVjdCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBPYmplY3QuZnJlZXplKGVtcHR5T2JqZWN0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eU9iamVjdDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlPYmplY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciB3YXJuaW5nID0gZW1wdHlGdW5jdGlvbjtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIHByaW50V2FybmluZyhmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgLy8gLS0tIFdlbGNvbWUgdG8gZGVidWdnaW5nIFJlYWN0IC0tLVxuICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgICB9IGNhdGNoICh4KSB7fVxuICB9O1xuXG4gIHdhcm5pbmcgPSBmdW5jdGlvbiB3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cblxuICAgIGlmIChmb3JtYXQuaW5kZXhPZignRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJykgPT09IDApIHtcbiAgICAgIHJldHVybjsgLy8gSWdub3JlIENvbXBvc2l0ZUNvbXBvbmVudCBwcm9wdHlwZSBjaGVjay5cbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi93YXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbiAgdmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG4gIHZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG4gIHZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbn1cblxuLyoqXG4gKiBBc3NlcnQgdGhhdCB0aGUgdmFsdWVzIG1hdGNoIHdpdGggdGhlIHR5cGUgc3BlY3MuXG4gKiBFcnJvciBtZXNzYWdlcyBhcmUgbWVtb3JpemVkIGFuZCB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gdHlwZVNwZWNzIE1hcCBvZiBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHZhbHVlcyBSdW50aW1lIHZhbHVlcyB0aGF0IG5lZWQgdG8gYmUgdHlwZS1jaGVja2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHs/RnVuY3Rpb259IGdldFN0YWNrIFJldHVybnMgdGhlIGNvbXBvbmVudCBzdGFjay5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZ2V0U3RhY2spIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBmb3IgKHZhciB0eXBlU3BlY05hbWUgaW4gdHlwZVNwZWNzKSB7XG4gICAgICBpZiAodHlwZVNwZWNzLmhhc093blByb3BlcnR5KHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgYW4gaW52YXJpYW50IHRoYXQgZ2V0cyBjYXVnaHQuIEl0J3MgdGhlIHNhbWVcbiAgICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICAgaW52YXJpYW50KHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSA9PT0gJ2Z1bmN0aW9uJywgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICd0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJXNgLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKTtcbiAgICAgICAgICBlcnJvciA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yID0gZXg7XG4gICAgICAgIH1cbiAgICAgICAgd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yKTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgIShlcnJvci5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvci5tZXNzYWdlXSA9IHRydWU7XG5cbiAgICAgICAgICB2YXIgc3RhY2sgPSBnZXRTdGFjayA/IGdldFN0YWNrKCkgOiAnJztcblxuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgJXMgdHlwZTogJXMlcycsIGxvY2F0aW9uLCBlcnJvci5tZXNzYWdlLCBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjaGVja1Byb3BUeXBlcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9ICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RQcm9wVHlwZXNTZWNyZXQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIGNoZWNrRENFKCkge1xuICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG4gIGlmIChcbiAgICB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJyB8fFxuICAgIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UgIT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gVGhpcyBicmFuY2ggaXMgdW5yZWFjaGFibGUgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgY2FsbGVkXG4gICAgLy8gaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBjb25kaXRpb24gaXMgdHJ1ZSBvbmx5IGluIGRldmVsb3BtZW50LlxuICAgIC8vIFRoZXJlZm9yZSBpZiB0aGUgYnJhbmNoIGlzIHN0aWxsIGhlcmUsIGRlYWQgY29kZSBlbGltaW5hdGlvbiB3YXNuJ3RcbiAgICAvLyBwcm9wZXJseSBhcHBsaWVkLlxuICAgIC8vIERvbid0IGNoYW5nZSB0aGUgbWVzc2FnZS4gUmVhY3QgRGV2VG9vbHMgcmVsaWVzIG9uIGl0LiBBbHNvIG1ha2Ugc3VyZVxuICAgIC8vIHRoaXMgbWVzc2FnZSBkb2Vzbid0IG9jY3VyIGVsc2V3aGVyZSBpbiB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGNhdXNlXG4gICAgLy8gYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ15fXicpO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gVmVyaWZ5IHRoYXQgdGhlIGNvZGUgYWJvdmUgaGFzIGJlZW4gZGVhZCBjb2RlIGVsaW1pbmF0ZWQgKERDRSdkKS5cbiAgICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18uY2hlY2tEQ0UoY2hlY2tEQ0UpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBEZXZUb29scyBzaG91bGRuJ3QgY3Jhc2ggUmVhY3QsIG5vIG1hdHRlciB3aGF0LlxuICAgIC8vIFdlIHNob3VsZCBzdGlsbCByZXBvcnQgaW4gY2FzZSB3ZSBicmVhayB0aGlzIGNvZGUuXG4gICAgY29uc29sZS5lcnJvcihlcnIpO1xuICB9XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIERDRSBjaGVjayBzaG91bGQgaGFwcGVuIGJlZm9yZSBSZWFjdERPTSBidW5kbGUgZXhlY3V0ZXMgc28gdGhhdFxuICAvLyBEZXZUb29scyBjYW4gcmVwb3J0IGJhZCBtaW5pZmljYXRpb24gZHVyaW5nIGluamVjdGlvbi5cbiAgY2hlY2tEQ0UoKTtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtZG9tLmRldmVsb3BtZW50LmpzJyk7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgbm9ybWFsaXplSGVhZGVyTmFtZSA9IHJlcXVpcmUoJy4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxudmFyIGRlZmF1bHRzID0ge1xuICBhZGFwdGVyOiBnZXREZWZhdWx0QWRhcHRlcigpLFxuXG4gIHRyYW5zZm9ybVJlcXVlc3Q6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXF1ZXN0KGRhdGEsIGhlYWRlcnMpIHtcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcbiAgICBpZiAodXRpbHMuaXNGb3JtRGF0YShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNBcnJheUJ1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzU3RyZWFtKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0ZpbGUoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxuICAgICkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc0FycmF5QnVmZmVyVmlldyhkYXRhKSkge1xuICAgICAgcmV0dXJuIGRhdGEuYnVmZmVyO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNVUkxTZWFyY2hQYXJhbXMoZGF0YSkpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc09iamVjdChkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTgnKTtcbiAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkgeyAvKiBJZ25vcmUgKi8gfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG5cbiAgdmFsaWRhdGVTdGF0dXM6IGZ1bmN0aW9uIHZhbGlkYXRlU3RhdHVzKHN0YXR1cykge1xuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcbiAgfVxufTtcblxuZGVmYXVsdHMuaGVhZGVycyA9IHtcbiAgY29tbW9uOiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluLCAqLyonXG4gIH1cbn07XG5cbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0ge307XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcblxuLyoqXG4gKiBTaW1wbGUsIGxpZ2h0d2VpZ2h0IG1vZHVsZSBhc3Npc3Rpbmcgd2l0aCB0aGUgZGV0ZWN0aW9uIGFuZCBjb250ZXh0IG9mXG4gKiBXb3JrZXIuIEhlbHBzIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY2llcyBhbmQgYWxsb3dzIGNvZGUgdG8gcmVhc29uIGFib3V0XG4gKiB3aGV0aGVyIG9yIG5vdCB0aGV5IGFyZSBpbiBhIFdvcmtlciwgZXZlbiBpZiB0aGV5IG5ldmVyIGluY2x1ZGUgdGhlIG1haW5cbiAqIGBSZWFjdFdvcmtlcmAgZGVwZW5kZW5jeS5cbiAqL1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0ge1xuXG4gIGNhblVzZURPTTogY2FuVXNlRE9NLFxuXG4gIGNhblVzZVdvcmtlcnM6IHR5cGVvZiBXb3JrZXIgIT09ICd1bmRlZmluZWQnLFxuXG4gIGNhblVzZUV2ZW50TGlzdGVuZXJzOiBjYW5Vc2VET00gJiYgISEod2luZG93LmFkZEV2ZW50TGlzdGVuZXIgfHwgd2luZG93LmF0dGFjaEV2ZW50KSxcblxuICBjYW5Vc2VWaWV3cG9ydDogY2FuVXNlRE9NICYmICEhd2luZG93LnNjcmVlbixcblxuICBpc0luV29ya2VyOiAhY2FuVXNlRE9NIC8vIEZvciBub3csIHRoaXMgaXMgdHJ1ZSAtIG1pZ2h0IGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV4ZWN1dGlvbkVudmlyb25tZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnLi9lbXB0eUZ1bmN0aW9uJyk7XG5cbi8qKlxuICogVXBzdHJlYW0gdmVyc2lvbiBvZiBldmVudCBsaXN0ZW5lci4gRG9lcyBub3QgdGFrZSBpbnRvIGFjY291bnQgc3BlY2lmaWNcbiAqIG5hdHVyZSBvZiBwbGF0Zm9ybS5cbiAqL1xudmFyIEV2ZW50TGlzdGVuZXIgPSB7XG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGJ1YmJsZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBsaXN0ZW46IGZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHRhcmdldC5hdHRhY2hFdmVudCkge1xuICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgICAgIHRhcmdldC5kZXRhY2hFdmVudCgnb24nICsgZXZlbnRUeXBlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW4gdG8gRE9NIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRhcmdldCBET00gZWxlbWVudCB0byByZWdpc3RlciBsaXN0ZW5lciBvbi5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZSBFdmVudCB0eXBlLCBlLmcuICdjbGljaycgb3IgJ21vdXNlb3ZlcicuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrIGZ1bmN0aW9uLlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IE9iamVjdCB3aXRoIGEgYHJlbW92ZWAgbWV0aG9kLlxuICAgKi9cbiAgY2FwdHVyZTogZnVuY3Rpb24gY2FwdHVyZSh0YXJnZXQsIGV2ZW50VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0F0dGVtcHRlZCB0byBsaXN0ZW4gdG8gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZSBvbiBhICcgKyAnYnJvd3NlciB0aGF0IGRvZXMgbm90IHN1cHBvcnQgdGhlIGNhcHR1cmUgcGhhc2UuIFlvdXIgYXBwbGljYXRpb24gJyArICd3aWxsIG5vdCByZWNlaXZlIHNvbWUgZXZlbnRzLicpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBlbXB0eUZ1bmN0aW9uXG4gICAgICB9O1xuICAgIH1cbiAgfSxcblxuICByZWdpc3RlckRlZmF1bHQ6IGZ1bmN0aW9uIHJlZ2lzdGVyRGVmYXVsdCgpIHt9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50TGlzdGVuZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL0V2ZW50TGlzdGVuZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRG9jdW1lbnR9IGRvYyBEZWZhdWx0cyB0byBjdXJyZW50IGRvY3VtZW50LlxuICogQHJldHVybiB7P0RPTUVsZW1lbnR9XG4gKi9cbmZ1bmN0aW9uIGdldEFjdGl2ZUVsZW1lbnQoZG9jKSAvKj9ET01FbGVtZW50Ki97XG4gIGRvYyA9IGRvYyB8fCAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkKTtcbiAgaWYgKHR5cGVvZiBkb2MgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZG9jLmFjdGl2ZUVsZW1lbnQgfHwgZG9jLmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jLmJvZHk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRBY3RpdmVFbGVtZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBAdHlwZWNoZWNrc1xuICogXG4gKi9cblxuLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIC8vIFNhbWVWYWx1ZSBhbGdvcml0aG1cbiAgaWYgKHggPT09IHkpIHtcbiAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAvLyBTdGVwcyA2LmItNi5lOiArMCAhPSAtMFxuICAgIC8vIEFkZGVkIHRoZSBub256ZXJvIHkgY2hlY2sgdG8gbWFrZSBGbG93IGhhcHB5LCBidXQgaXQgaXMgcmVkdW5kYW50XG4gICAgcmV0dXJuIHggIT09IDAgfHwgeSAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gIH0gZWxzZSB7XG4gICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKGlzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBrZXlzQVtpXSkgfHwgIWlzKG9iakFba2V5c0FbaV1dLCBvYmpCW2tleXNBW2ldXSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKiBcbiAqL1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBjb250YWluc05vZGUob3V0ZXJOb2RlLCBpbm5lck5vZGUpIHtcbiAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChvdXRlck5vZGUgPT09IGlubmVyTm9kZSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGlzVGV4dE5vZGUob3V0ZXJOb2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICByZXR1cm4gY29udGFpbnNOb2RlKG91dGVyTm9kZSwgaW5uZXJOb2RlLnBhcmVudE5vZGUpO1xuICB9IGVsc2UgaWYgKCdjb250YWlucycgaW4gb3V0ZXJOb2RlKSB7XG4gICAgcmV0dXJuIG91dGVyTm9kZS5jb250YWlucyhpbm5lck5vZGUpO1xuICB9IGVsc2UgaWYgKG91dGVyTm9kZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbikge1xuICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250YWluc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NvbnRhaW5zTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgaW5wdXQvdGV4dGFyZWEgdG8gZm9jdXNcbiAqL1xuXG5mdW5jdGlvbiBmb2N1c05vZGUobm9kZSkge1xuICAvLyBJRTggY2FuIHRocm93IFwiQ2FuJ3QgbW92ZSBmb2N1cyB0byB0aGUgY29udHJvbCBiZWNhdXNlIGl0IGlzIGludmlzaWJsZSxcbiAgLy8gbm90IGVuYWJsZWQsIG9yIG9mIGEgdHlwZSB0aGF0IGRvZXMgbm90IGFjY2VwdCB0aGUgZm9jdXMuXCIgZm9yIGFsbCBraW5kcyBvZlxuICAvLyByZWFzb25zIHRoYXQgYXJlIHRvbyBleHBlbnNpdmUgYW5kIGZyYWdpbGUgdG8gdGVzdC5cbiAgdHJ5IHtcbiAgICBub2RlLmZvY3VzKCk7XG4gIH0gY2F0Y2ggKGUpIHt9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZm9jdXNOb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9mb2N1c05vZGUuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHNldHRsZSA9IHJlcXVpcmUoJy4vLi4vY29yZS9zZXR0bGUnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idWlsZFVSTCcpO1xudmFyIHBhcnNlSGVhZGVycyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9wYXJzZUhlYWRlcnMnKTtcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luJyk7XG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuLi9jb3JlL2NyZWF0ZUVycm9yJyk7XG52YXIgYnRvYSA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuYnRvYSAmJiB3aW5kb3cuYnRvYS5iaW5kKHdpbmRvdykpIHx8IHJlcXVpcmUoJy4vLi4vaGVscGVycy9idG9hJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24geGhyQWRhcHRlcihjb25maWcpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIGRpc3BhdGNoWGhyUmVxdWVzdChyZXNvbHZlLCByZWplY3QpIHtcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcbiAgICB2YXIgcmVxdWVzdEhlYWRlcnMgPSBjb25maWcuaGVhZGVycztcblxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xuICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzWydDb250ZW50LVR5cGUnXTsgLy8gTGV0IHRoZSBicm93c2VyIHNldCBpdFxuICAgIH1cblxuICAgIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgdmFyIGxvYWRFdmVudCA9ICdvbnJlYWR5c3RhdGVjaGFuZ2UnO1xuICAgIHZhciB4RG9tYWluID0gZmFsc2U7XG5cbiAgICAvLyBGb3IgSUUgOC85IENPUlMgc3VwcG9ydFxuICAgIC8vIE9ubHkgc3VwcG9ydHMgUE9TVCBhbmQgR0VUIGNhbGxzIGFuZCBkb2Vzbid0IHJldHVybnMgdGhlIHJlc3BvbnNlIGhlYWRlcnMuXG4gICAgLy8gRE9OJ1QgZG8gdGhpcyBmb3IgdGVzdGluZyBiL2MgWE1MSHR0cFJlcXVlc3QgaXMgbW9ja2VkLCBub3QgWERvbWFpblJlcXVlc3QuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAndGVzdCcgJiZcbiAgICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LlhEb21haW5SZXF1ZXN0ICYmICEoJ3dpdGhDcmVkZW50aWFscycgaW4gcmVxdWVzdCkgJiZcbiAgICAgICAgIWlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkge1xuICAgICAgcmVxdWVzdCA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcbiAgICAgIGxvYWRFdmVudCA9ICdvbmxvYWQnO1xuICAgICAgeERvbWFpbiA9IHRydWU7XG4gICAgICByZXF1ZXN0Lm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbiBoYW5kbGVQcm9ncmVzcygpIHt9O1xuICAgICAgcmVxdWVzdC5vbnRpbWVvdXQgPSBmdW5jdGlvbiBoYW5kbGVUaW1lb3V0KCkge307XG4gICAgfVxuXG4gICAgLy8gSFRUUCBiYXNpYyBhdXRoZW50aWNhdGlvblxuICAgIGlmIChjb25maWcuYXV0aCkge1xuICAgICAgdmFyIHVzZXJuYW1lID0gY29uZmlnLmF1dGgudXNlcm5hbWUgfHwgJyc7XG4gICAgICB2YXIgcGFzc3dvcmQgPSBjb25maWcuYXV0aC5wYXNzd29yZCB8fCAnJztcbiAgICAgIHJlcXVlc3RIZWFkZXJzLkF1dGhvcml6YXRpb24gPSAnQmFzaWMgJyArIGJ0b2EodXNlcm5hbWUgKyAnOicgKyBwYXNzd29yZCk7XG4gICAgfVxuXG4gICAgcmVxdWVzdC5vcGVuKGNvbmZpZy5tZXRob2QudG9VcHBlckNhc2UoKSwgYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlXG4gICAgcmVxdWVzdFtsb2FkRXZlbnRdID0gZnVuY3Rpb24gaGFuZGxlTG9hZCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCB8fCAocmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0ICYmICF4RG9tYWluKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZXF1ZXN0IGVycm9yZWQgb3V0IGFuZCB3ZSBkaWRuJ3QgZ2V0IGEgcmVzcG9uc2UsIHRoaXMgd2lsbCBiZVxuICAgICAgLy8gaGFuZGxlZCBieSBvbmVycm9yIGluc3RlYWRcbiAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAvLyB3aWxsIHJldHVybiBzdGF0dXMgYXMgMCBldmVuIHRob3VnaCBpdCdzIGEgc3VjY2Vzc2Z1bCByZXF1ZXN0XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDAgJiYgIShyZXF1ZXN0LnJlc3BvbnNlVVJMICYmIHJlcXVlc3QucmVzcG9uc2VVUkwuaW5kZXhPZignZmlsZTonKSA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBQcmVwYXJlIHRoZSByZXNwb25zZVxuICAgICAgdmFyIHJlc3BvbnNlSGVhZGVycyA9ICdnZXRBbGxSZXNwb25zZUhlYWRlcnMnIGluIHJlcXVlc3QgPyBwYXJzZUhlYWRlcnMocmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkgOiBudWxsO1xuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFjb25maWcucmVzcG9uc2VUeXBlIHx8IGNvbmZpZy5yZXNwb25zZVR5cGUgPT09ICd0ZXh0JyA/IHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICAvLyBJRSBzZW5kcyAxMjIzIGluc3RlYWQgb2YgMjA0IChodHRwczovL2dpdGh1Yi5jb20vYXhpb3MvYXhpb3MvaXNzdWVzLzIwMSlcbiAgICAgICAgc3RhdHVzOiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/IDIwNCA6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1cyA9PT0gMTIyMyA/ICdObyBDb250ZW50JyA6IHJlcXVlc3Quc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdFxuICAgICAgfTtcblxuICAgICAgc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgdmFyIGNvb2tpZXMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29va2llcycpO1xuXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAgIHZhciB4c3JmVmFsdWUgPSAoY29uZmlnLndpdGhDcmVkZW50aWFscyB8fCBpc1VSTFNhbWVPcmlnaW4oY29uZmlnLnVybCkpICYmIGNvbmZpZy54c3JmQ29va2llTmFtZSA/XG4gICAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICAgIHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHhzcmZWYWx1ZSkge1xuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEFkZCBoZWFkZXJzIHRvIHRoZSByZXF1ZXN0XG4gICAgaWYgKCdzZXRSZXF1ZXN0SGVhZGVyJyBpbiByZXF1ZXN0KSB7XG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdERhdGEgPT09ICd1bmRlZmluZWQnICYmIGtleS50b0xvd2VyQ2FzZSgpID09PSAnY29udGVudC10eXBlJykge1xuICAgICAgICAgIC8vIFJlbW92ZSBDb250ZW50LVR5cGUgaWYgZGF0YSBpcyB1bmRlZmluZWRcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBPdGhlcndpc2UgYWRkIGhlYWRlciB0byB0aGUgcmVxdWVzdFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRoQ3JlZGVudGlhbHMgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLndpdGhDcmVkZW50aWFscykge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIEFkZCByZXNwb25zZVR5cGUgdG8gcmVxdWVzdCBpZiBuZWVkZWRcbiAgICBpZiAoY29uZmlnLnJlc3BvbnNlVHlwZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBFeHBlY3RlZCBET01FeGNlcHRpb24gdGhyb3duIGJ5IGJyb3dzZXJzIG5vdCBjb21wYXRpYmxlIFhNTEh0dHBSZXF1ZXN0IExldmVsIDIuXG4gICAgICAgIC8vIEJ1dCwgdGhpcyBjYW4gYmUgc3VwcHJlc3NlZCBmb3IgJ2pzb24nIHR5cGUgYXMgaXQgY2FuIGJlIHBhcnNlZCBieSBkZWZhdWx0ICd0cmFuc2Zvcm1SZXNwb25zZScgZnVuY3Rpb24uXG4gICAgICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHByb2dyZXNzIGlmIG5lZWRlZFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25VcGxvYWRQcm9ncmVzcyA9PT0gJ2Z1bmN0aW9uJyAmJiByZXF1ZXN0LnVwbG9hZCkge1xuICAgICAgcmVxdWVzdC51cGxvYWQuYWRkRXZlbnRMaXN0ZW5lcigncHJvZ3Jlc3MnLCBjb25maWcub25VcGxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgICAgLy8gSGFuZGxlIGNhbmNlbGxhdGlvblxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuLnByb21pc2UudGhlbihmdW5jdGlvbiBvbkNhbmNlbGVkKGNhbmNlbCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICByZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgIHJlamVjdChjYW5jZWwpO1xuICAgICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKHJlcXVlc3REYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcbiAgICB9XG5cbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XG4gICAgcmVxdWVzdC5zZW5kKHJlcXVlc3REYXRhKTtcbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGBDYW5jZWxgIGlzIGFuIG9iamVjdCB0aGF0IGlzIHRocm93biB3aGVuIGFuIG9wZXJhdGlvbiBpcyBjYW5jZWxlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBwYXJhbSB7c3RyaW5nPX0gbWVzc2FnZSBUaGUgbWVzc2FnZS5cbiAqL1xuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbn1cblxuQ2FuY2VsLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICByZXR1cm4gJ0NhbmNlbCcgKyAodGhpcy5tZXNzYWdlID8gJzogJyArIHRoaXMubWVzc2FnZSA6ICcnKTtcbn07XG5cbkNhbmNlbC5wcm90b3R5cGUuX19DQU5DRUxfXyA9IHRydWU7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FuY2VsO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiZcbiAgICBTeW1ib2wuZm9yICYmXG4gICAgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpKSB8fFxuICAgIDB4ZWFjNztcblxuICB2YXIgaXNWYWxpZEVsZW1lbnQgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiZcbiAgICAgIG9iamVjdCAhPT0gbnVsbCAmJlxuICAgICAgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEU7XG4gIH07XG5cbiAgLy8gQnkgZXhwbGljaXRseSB1c2luZyBgcHJvcC10eXBlc2AgeW91IGFyZSBvcHRpbmcgaW50byBuZXcgZGV2ZWxvcG1lbnQgYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgdmFyIHRocm93T25EaXJlY3RBY2Nlc3MgPSB0cnVlO1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMnKShpc1ZhbGlkRWxlbWVudCwgdGhyb3dPbkRpcmVjdEFjY2Vzcyk7XG59IGVsc2Uge1xuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBwcm9kdWN0aW9uIGJlaGF2aW9yLlxuICAvLyBodHRwOi8vZmIubWUvcHJvcC10eXBlcy1pbi1wcm9kXG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFRocm93aW5nU2hpbXMnKSgpO1xufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG5pbXBvcnQgQXBwIGZyb20gJy4vYXBwJztcblxuLy8gUmVhY3RET00ucmVuZGVyKDxBcHAgdXJsPVwiaHR0cDovL2xvY2FsaG9zdDo4MDAwL2FwaS9kYXRhXCIgLz4sIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250YWluZXInKSk7XG5SZWFjdERPTS5yZW5kZXIoPEFwcCB1cmw9XCJodHRwczovL21heGdvbHViZXYtY3YuaGVyb2t1YXBwLmNvbS9hcGkvZGF0YVwiIC8+LCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY29udGFpbmVyJykpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2luZGV4LmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xLjBcbiAqIHJlYWN0LnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbid1c2Ugc3RyaWN0Jzt2YXIgbT1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxuPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eU9iamVjdFwiKSxwPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpO1xuZnVuY3Rpb24gcShhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGU9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsZD0wO2Q8YjtkKyspZSs9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtiPUVycm9yKGUrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fVxudmFyIHI9e2lzTW91bnRlZDpmdW5jdGlvbigpe3JldHVybiExfSxlbnF1ZXVlRm9yY2VVcGRhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVSZXBsYWNlU3RhdGU6ZnVuY3Rpb24oKXt9LGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbigpe319O2Z1bmN0aW9uIHQoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8cn10LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50PXt9O3QucHJvdG90eXBlLnNldFN0YXRlPWZ1bmN0aW9uKGEsYil7XCJvYmplY3RcIiE9PXR5cGVvZiBhJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYSYmbnVsbCE9YT9xKFwiODVcIik6dm9pZCAwO3RoaXMudXBkYXRlci5lbnF1ZXVlU2V0U3RhdGUodGhpcyxhLGIsXCJzZXRTdGF0ZVwiKX07dC5wcm90b3R5cGUuZm9yY2VVcGRhdGU9ZnVuY3Rpb24oYSl7dGhpcy51cGRhdGVyLmVucXVldWVGb3JjZVVwZGF0ZSh0aGlzLGEsXCJmb3JjZVVwZGF0ZVwiKX07XG5mdW5jdGlvbiB1KGEsYixlKXt0aGlzLnByb3BzPWE7dGhpcy5jb250ZXh0PWI7dGhpcy5yZWZzPW47dGhpcy51cGRhdGVyPWV8fHJ9ZnVuY3Rpb24gdigpe312LnByb3RvdHlwZT10LnByb3RvdHlwZTt2YXIgdz11LnByb3RvdHlwZT1uZXcgdjt3LmNvbnN0cnVjdG9yPXU7bSh3LHQucHJvdG90eXBlKTt3LmlzUHVyZVJlYWN0Q29tcG9uZW50PSEwO2Z1bmN0aW9uIHgoYSxiLGUpe3RoaXMucHJvcHM9YTt0aGlzLmNvbnRleHQ9Yjt0aGlzLnJlZnM9bjt0aGlzLnVwZGF0ZXI9ZXx8cn12YXIgeT14LnByb3RvdHlwZT1uZXcgdjt5LmNvbnN0cnVjdG9yPXg7bSh5LHQucHJvdG90eXBlKTt5LnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD0hMDt5LnJlbmRlcj1mdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BzLmNoaWxkcmVufTtcbnZhciB6PXtjdXJyZW50Om51bGx9LEE9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxCPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSYmU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKXx8NjAxMDMsQz17a2V5OiEwLHJlZjohMCxfX3NlbGY6ITAsX19zb3VyY2U6ITB9O1xuZnVuY3Rpb24gRChhLGIsZSl7dmFyIGQsYz17fSxoPW51bGwsaz1udWxsO2lmKG51bGwhPWIpZm9yKGQgaW4gdm9pZCAwIT09Yi5yZWYmJihrPWIucmVmKSx2b2lkIDAhPT1iLmtleSYmKGg9XCJcIitiLmtleSksYilBLmNhbGwoYixkKSYmIUMuaGFzT3duUHJvcGVydHkoZCkmJihjW2RdPWJbZF0pO3ZhciBmPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZiljLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGYpe2Zvcih2YXIgZz1BcnJheShmKSxsPTA7bDxmO2wrKylnW2xdPWFyZ3VtZW50c1tsKzJdO2MuY2hpbGRyZW49Z31pZihhJiZhLmRlZmF1bHRQcm9wcylmb3IoZCBpbiBmPWEuZGVmYXVsdFByb3BzLGYpdm9pZCAwPT09Y1tkXSYmKGNbZF09ZltkXSk7cmV0dXJueyQkdHlwZW9mOkIsdHlwZTphLGtleTpoLHJlZjprLHByb3BzOmMsX293bmVyOnouY3VycmVudH19ZnVuY3Rpb24gRShhKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZhLiQkdHlwZW9mPT09Qn1cbnZhciBGPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcixHPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSYmU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKXx8NjAxMDMsSD1cImZ1bmN0aW9uXCI9PT10eXBlb2YgU3ltYm9sJiZTeW1ib2xbXCJmb3JcIl0mJlN5bWJvbFtcImZvclwiXShcInJlYWN0LnBvcnRhbFwiKXx8NjAxMDY7ZnVuY3Rpb24gZXNjYXBlKGEpe3ZhciBiPXtcIlxceDNkXCI6XCJcXHgzZDBcIixcIjpcIjpcIlxceDNkMlwifTtyZXR1cm5cIiRcIisoXCJcIithKS5yZXBsYWNlKC9bPTpdL2csZnVuY3Rpb24oYSl7cmV0dXJuIGJbYV19KX12YXIgST0vXFwvKy9nLEo9W107XG5mdW5jdGlvbiBLKGEsYixlLGQpe2lmKEoubGVuZ3RoKXt2YXIgYz1KLnBvcCgpO2MucmVzdWx0PWE7Yy5rZXlQcmVmaXg9YjtjLmZ1bmM9ZTtjLmNvbnRleHQ9ZDtjLmNvdW50PTA7cmV0dXJuIGN9cmV0dXJue3Jlc3VsdDphLGtleVByZWZpeDpiLGZ1bmM6ZSxjb250ZXh0OmQsY291bnQ6MH19ZnVuY3Rpb24gTChhKXthLnJlc3VsdD1udWxsO2Eua2V5UHJlZml4PW51bGw7YS5mdW5jPW51bGw7YS5jb250ZXh0PW51bGw7YS5jb3VudD0wOzEwPkoubGVuZ3RoJiZKLnB1c2goYSl9XG5mdW5jdGlvbiBNKGEsYixlLGQpe3ZhciBjPXR5cGVvZiBhO2lmKFwidW5kZWZpbmVkXCI9PT1jfHxcImJvb2xlYW5cIj09PWMpYT1udWxsO2lmKG51bGw9PT1hfHxcInN0cmluZ1wiPT09Y3x8XCJudW1iZXJcIj09PWN8fFwib2JqZWN0XCI9PT1jJiZhLiQkdHlwZW9mPT09R3x8XCJvYmplY3RcIj09PWMmJmEuJCR0eXBlb2Y9PT1IKXJldHVybiBlKGQsYSxcIlwiPT09Yj9cIi5cIitOKGEsMCk6YiksMTt2YXIgaD0wO2I9XCJcIj09PWI/XCIuXCI6YitcIjpcIjtpZihBcnJheS5pc0FycmF5KGEpKWZvcih2YXIgaz0wO2s8YS5sZW5ndGg7aysrKXtjPWFba107dmFyIGY9YitOKGMsayk7aCs9TShjLGYsZSxkKX1lbHNlIGlmKGY9RiYmYVtGXXx8YVtcIkBAaXRlcmF0b3JcIl0sXCJmdW5jdGlvblwiPT09dHlwZW9mIGYpZm9yKGE9Zi5jYWxsKGEpLGs9MDshKGM9YS5uZXh0KCkpLmRvbmU7KWM9Yy52YWx1ZSxmPWIrTihjLGsrKyksaCs9TShjLGYsZSxkKTtlbHNlXCJvYmplY3RcIj09PWMmJihlPVwiXCIrYSxxKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09XG5lP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYSkuam9pbihcIiwgXCIpK1wifVwiOmUsXCJcIikpO3JldHVybiBofWZ1bmN0aW9uIE4oYSxiKXtyZXR1cm5cIm9iamVjdFwiPT09dHlwZW9mIGEmJm51bGwhPT1hJiZudWxsIT1hLmtleT9lc2NhcGUoYS5rZXkpOmIudG9TdHJpbmcoMzYpfWZ1bmN0aW9uIE8oYSxiKXthLmZ1bmMuY2FsbChhLmNvbnRleHQsYixhLmNvdW50KyspfVxuZnVuY3Rpb24gUChhLGIsZSl7dmFyIGQ9YS5yZXN1bHQsYz1hLmtleVByZWZpeDthPWEuZnVuYy5jYWxsKGEuY29udGV4dCxiLGEuY291bnQrKyk7QXJyYXkuaXNBcnJheShhKT9RKGEsZCxlLHAudGhhdFJldHVybnNBcmd1bWVudCk6bnVsbCE9YSYmKEUoYSkmJihiPWMrKCFhLmtleXx8YiYmYi5rZXk9PT1hLmtleT9cIlwiOihcIlwiK2Eua2V5KS5yZXBsYWNlKEksXCIkXFx4MjYvXCIpK1wiL1wiKStlLGE9eyQkdHlwZW9mOkIsdHlwZTphLnR5cGUsa2V5OmIscmVmOmEucmVmLHByb3BzOmEucHJvcHMsX293bmVyOmEuX293bmVyfSksZC5wdXNoKGEpKX1mdW5jdGlvbiBRKGEsYixlLGQsYyl7dmFyIGg9XCJcIjtudWxsIT1lJiYoaD0oXCJcIitlKS5yZXBsYWNlKEksXCIkXFx4MjYvXCIpK1wiL1wiKTtiPUsoYixoLGQsYyk7bnVsbD09YXx8TShhLFwiXCIsUCxiKTtMKGIpfVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSYmU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZnJhZ21lbnRcIik7XG52YXIgUj17Q2hpbGRyZW46e21hcDpmdW5jdGlvbihhLGIsZSl7aWYobnVsbD09YSlyZXR1cm4gYTt2YXIgZD1bXTtRKGEsZCxudWxsLGIsZSk7cmV0dXJuIGR9LGZvckVhY2g6ZnVuY3Rpb24oYSxiLGUpe2lmKG51bGw9PWEpcmV0dXJuIGE7Yj1LKG51bGwsbnVsbCxiLGUpO251bGw9PWF8fE0oYSxcIlwiLE8sYik7TChiKX0sY291bnQ6ZnVuY3Rpb24oYSl7cmV0dXJuIG51bGw9PWE/MDpNKGEsXCJcIixwLnRoYXRSZXR1cm5zTnVsbCxudWxsKX0sdG9BcnJheTpmdW5jdGlvbihhKXt2YXIgYj1bXTtRKGEsYixudWxsLHAudGhhdFJldHVybnNBcmd1bWVudCk7cmV0dXJuIGJ9LG9ubHk6ZnVuY3Rpb24oYSl7RShhKT92b2lkIDA6cShcIjE0M1wiKTtyZXR1cm4gYX19LENvbXBvbmVudDp0LFB1cmVDb21wb25lbnQ6dSx1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDp4LGNyZWF0ZUVsZW1lbnQ6RCxjbG9uZUVsZW1lbnQ6ZnVuY3Rpb24oYSxiLGUpe3ZhciBkPW0oe30sYS5wcm9wcyksYz1hLmtleSxoPWEucmVmLFxuaz1hLl9vd25lcjtpZihudWxsIT1iKXt2b2lkIDAhPT1iLnJlZiYmKGg9Yi5yZWYsaz16LmN1cnJlbnQpO3ZvaWQgMCE9PWIua2V5JiYoYz1cIlwiK2Iua2V5KTtpZihhLnR5cGUmJmEudHlwZS5kZWZhdWx0UHJvcHMpdmFyIGY9YS50eXBlLmRlZmF1bHRQcm9wcztmb3IoZyBpbiBiKUEuY2FsbChiLGcpJiYhQy5oYXNPd25Qcm9wZXJ0eShnKSYmKGRbZ109dm9pZCAwPT09YltnXSYmdm9pZCAwIT09Zj9mW2ddOmJbZ10pfXZhciBnPWFyZ3VtZW50cy5sZW5ndGgtMjtpZigxPT09ZylkLmNoaWxkcmVuPWU7ZWxzZSBpZigxPGcpe2Y9QXJyYXkoZyk7Zm9yKHZhciBsPTA7bDxnO2wrKylmW2xdPWFyZ3VtZW50c1tsKzJdO2QuY2hpbGRyZW49Zn1yZXR1cm57JCR0eXBlb2Y6Qix0eXBlOmEudHlwZSxrZXk6YyxyZWY6aCxwcm9wczpkLF9vd25lcjprfX0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbihhKXt2YXIgYj1ELmJpbmQobnVsbCxhKTtiLnR5cGU9YTtyZXR1cm4gYn0saXNWYWxpZEVsZW1lbnQ6RSxcbnZlcnNpb246XCIxNi4xLjBcIixfX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDp7UmVhY3RDdXJyZW50T3duZXI6eixhc3NpZ246bX19LFM9T2JqZWN0LmZyZWV6ZSh7ZGVmYXVsdDpSfSksVD1TJiZSfHxTO21vZHVsZS5leHBvcnRzPVRbXCJkZWZhdWx0XCJdP1RbXCJkZWZhdWx0XCJdOlQ7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LnByb2R1Y3Rpb24ubWluLmpzIiwiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNi4xLjBcbiAqIHJlYWN0LmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBjaGVja1Byb3BUeXBlcyA9IHJlcXVpcmUoJ3Byb3AtdHlwZXMvY2hlY2tQcm9wVHlwZXMnKTtcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMS4wJztcblxuLyoqXG4gKiBXQVJOSU5HOiBETyBOT1QgbWFudWFsbHkgcmVxdWlyZSB0aGlzIG1vZHVsZS5cbiAqIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgYGludmFyaWFudCguLi4pYCB1c2VkIGJ5IHRoZSBlcnJvciBjb2RlIHN5c3RlbVxuICogYW5kIHdpbGwgX29ubHlfIGJlIHJlcXVpcmVkIGJ5IHRoZSBjb3JyZXNwb25kaW5nIGJhYmVsIHBhc3MuXG4gKiBJdCBhbHdheXMgdGhyb3dzLlxuICovXG5cbi8vIEV4cG9ydHMgUmVhY3QuRnJhZ21lbnRcbnZhciBlbmFibGVSZWFjdEZyYWdtZW50ID0gZmFsc2U7XG4vLyBFeHBvcnRzIFJlYWN0RE9NLmNyZWF0ZVJvb3RcblxuXG5cbi8vIE11dGF0aW5nIG1vZGUgKFJlYWN0IERPTSwgUmVhY3QgQVJULCBSZWFjdCBOYXRpdmUpOlxuXG4vLyBFeHBlcmltZW50YWwgbm9vcCBtb2RlIChjdXJyZW50bHkgdW51c2VkKTpcblxuLy8gRXhwZXJpbWVudGFsIHBlcnNpc3RlbnQgbW9kZSAoQ1MpOlxuXG5cbi8vIE9ubHkgdXNlZCBpbiB3d3cgYnVpbGRzLlxuXG4vKipcbiAqIEZvcmtlZCBmcm9tIGZianMvd2FybmluZzpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mYmpzL2Jsb2IvZTY2YmEyMGFkNWJlNDMzZWI1NDQyM2YyYjA5N2Q4MjkzMjRkOWRlNi9wYWNrYWdlcy9mYmpzL3NyYy9fX2ZvcmtzX18vd2FybmluZy5qc1xuICpcbiAqIE9ubHkgY2hhbmdlIGlzIHdlIHVzZSBjb25zb2xlLndhcm4gaW5zdGVhZCBvZiBjb25zb2xlLmVycm9yLFxuICogYW5kIGRvIG5vdGhpbmcgd2hlbiAnY29uc29sZScgaXMgbm90IHN1cHBvcnRlZC5cbiAqIFRoaXMgcmVhbGx5IHNpbXBsaWZpZXMgdGhlIGNvZGUuXG4gKiAtLS1cbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKCkge307XG5cbntcbiAgdmFyIHByaW50V2FybmluZyA9IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgbG93UHJpb3JpdHlXYXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgKyAnbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbjIgPiAyID8gX2xlbjIgLSAyIDogMCksIF9rZXkyID0gMjsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMl0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcuYXBwbHkodW5kZWZpbmVkLCBbZm9ybWF0XS5jb25jYXQoYXJncykpO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIGxvd1ByaW9yaXR5V2FybmluZyQxID0gbG93UHJpb3JpdHlXYXJuaW5nO1xuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50ID0ge307XG5cbmZ1bmN0aW9uIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIHtcbiAgICB2YXIgY29uc3RydWN0b3IgPSBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGNvbnN0cnVjdG9yICYmIChjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3Rvci5uYW1lKSB8fCAnUmVhY3RDbGFzcyc7XG4gICAgdmFyIHdhcm5pbmdLZXkgPSBjb21wb25lbnROYW1lICsgJy4nICsgY2FsbGVyTmFtZTtcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W3dhcm5pbmdLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLlxcblxcblBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbd2FybmluZ0tleV0gPSB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQgaXMgbW91bnRlZC5cbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2Ugd2Ugd2FudCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIG1vdW50ZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICogQHByb3RlY3RlZFxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzTW91bnRlZDogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gICAqIGNlcnRhaW50eSB0aGF0IHdlIGFyZSAqKm5vdCoqIGluIGEgRE9NIHRyYW5zYWN0aW9uLlxuICAgKlxuICAgKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gICAqIGNvbXBvbmVudCdzIHN0YXRlIGhhcyBjaGFuZ2VkIGJ1dCBgc2V0U3RhdGVgIHdhcyBub3QgY2FsbGVkLlxuICAgKlxuICAgKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gICAqIGBjb21wb25lbnRXaWxsVXBkYXRlYCBhbmQgYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIGNvbXBvbmVudCBpcyB1cGRhdGVkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGNhbGxlck5hbWUgbmFtZSBvZiB0aGUgY2FsbGluZyBmdW5jdGlvbiBpbiB0aGUgcHVibGljIEFQSS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuTm9vcChwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyBvciBgc2V0U3RhdGVgIHRvIG11dGF0ZSBzdGF0ZS5cbiAgICogWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICAgKlxuICAgKiBUaGVyZSBpcyBubyBndWFyYW50ZWUgdGhhdCBgdGhpcy5zdGF0ZWAgd2lsbCBiZSBpbW1lZGlhdGVseSB1cGRhdGVkLCBzb1xuICAgKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbXBsZXRlU3RhdGUgTmV4dCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBjYWxsZXJOYW1lIG5hbWUgb2YgdGhlIGNhbGxpbmcgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjb21wbGV0ZVN0YXRlLCBjYWxsYmFjaywgY2FsbGVyTmFtZSkge1xuICAgIHdhcm5Ob29wKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBjb21wb25lbnQgaXMgdXBkYXRlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBOYW1lIG9mIHRoZSBjYWxsaW5nIGZ1bmN0aW9uIGluIHRoZSBwdWJsaWMgQVBJLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCBjYWxsZXJOYW1lKSB7XG4gICAgd2Fybk5vb3AocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuICB9XG59O1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbkNvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCA9IHt9O1xuXG4vKipcbiAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBBbHdheXMgdXNlIHRoaXMgdG8gbXV0YXRlXG4gKiBzdGF0ZS4gWW91IHNob3VsZCB0cmVhdCBgdGhpcy5zdGF0ZWAgYXMgaW1tdXRhYmxlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gKiBhY2Nlc3NpbmcgYHRoaXMuc3RhdGVgIGFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QgbWF5IHJldHVybiB0aGUgb2xkIHZhbHVlLlxuICpcbiAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGNhbGxzIHRvIGBzZXRTdGF0ZWAgd2lsbCBydW4gc3luY2hyb25vdXNseSxcbiAqIGFzIHRoZXkgbWF5IGV2ZW50dWFsbHkgYmUgYmF0Y2hlZCB0b2dldGhlci4gIFlvdSBjYW4gcHJvdmlkZSBhbiBvcHRpb25hbFxuICogY2FsbGJhY2sgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gdGhlIGNhbGwgdG8gc2V0U3RhdGUgaXMgYWN0dWFsbHlcbiAqIGNvbXBsZXRlZC5cbiAqXG4gKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQgdG8gc2V0U3RhdGUsIGl0IHdpbGwgYmUgY2FsbGVkIGF0IHNvbWUgcG9pbnQgaW5cbiAqIHRoZSBmdXR1cmUgKG5vdCBzeW5jaHJvbm91c2x5KS4gSXQgd2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgdXAgdG8gZGF0ZVxuICogY29tcG9uZW50IGFyZ3VtZW50cyAoc3RhdGUsIHByb3BzLCBjb250ZXh0KS4gVGhlc2UgdmFsdWVzIGNhbiBiZSBkaWZmZXJlbnRcbiAqIGZyb20gdGhpcy4qIGJlY2F1c2UgeW91ciBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGFmdGVyIHJlY2VpdmVQcm9wcyBidXQgYmVmb3JlXG4gKiBzaG91bGRDb21wb25lbnRVcGRhdGUsIGFuZCB0aGlzIG5ldyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHdpbGwgbm90IHlldCBiZVxuICogYXNzaWduZWQgdG8gdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdHxmdW5jdGlvbn0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSBvciBmdW5jdGlvbiB0b1xuICogICAgICAgIHByb2R1Y2UgbmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIGN1cnJlbnQgc3RhdGUuXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gKiBAZmluYWxcbiAqIEBwcm90ZWN0ZWRcbiAqL1xuQ29tcG9uZW50LnByb3RvdHlwZS5zZXRTdGF0ZSA9IGZ1bmN0aW9uIChwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICEodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCBwYXJ0aWFsU3RhdGUgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdzZXRTdGF0ZSguLi4pOiB0YWtlcyBhbiBvYmplY3Qgb2Ygc3RhdGUgdmFyaWFibGVzIHRvIHVwZGF0ZSBvciBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYW4gb2JqZWN0IG9mIHN0YXRlIHZhcmlhYmxlcy4nKSA6IHZvaWQgMDtcbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrLCAnc2V0U3RhdGUnKTtcbn07XG5cbi8qKlxuICogRm9yY2VzIGFuIHVwZGF0ZS4gVGhpcyBzaG91bGQgb25seSBiZSBpbnZva2VkIHdoZW4gaXQgaXMga25vd24gd2l0aFxuICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gKlxuICogWW91IG1heSB3YW50IHRvIGNhbGwgdGhpcyB3aGVuIHlvdSBrbm93IHRoYXQgc29tZSBkZWVwZXIgYXNwZWN0IG9mIHRoZVxuICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gKlxuICogVGhpcyB3aWxsIG5vdCBpbnZva2UgYHNob3VsZENvbXBvbmVudFVwZGF0ZWAsIGJ1dCBpdCB3aWxsIGludm9rZVxuICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAqXG4gKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGVkIGFmdGVyIHVwZGF0ZSBpcyBjb21wbGV0ZS5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5Db21wb25lbnQucHJvdG90eXBlLmZvcmNlVXBkYXRlID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHRoaXMudXBkYXRlci5lbnF1ZXVlRm9yY2VVcGRhdGUodGhpcywgY2FsbGJhY2ssICdmb3JjZVVwZGF0ZScpO1xufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbntcbiAgdmFyIGRlcHJlY2F0ZWRBUElzID0ge1xuICAgIGlzTW91bnRlZDogWydpc01vdW50ZWQnLCAnSW5zdGVhZCwgbWFrZSBzdXJlIHRvIGNsZWFuIHVwIHN1YnNjcmlwdGlvbnMgYW5kIHBlbmRpbmcgcmVxdWVzdHMgaW4gJyArICdjb21wb25lbnRXaWxsVW5tb3VudCB0byBwcmV2ZW50IG1lbW9yeSBsZWFrcy4nXSxcbiAgICByZXBsYWNlU3RhdGU6IFsncmVwbGFjZVN0YXRlJywgJ1JlZmFjdG9yIHlvdXIgY29kZSB0byB1c2Ugc2V0U3RhdGUgaW5zdGVhZCAoc2VlICcgKyAnaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zMjM2KS4nXVxuICB9O1xuICB2YXIgZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUsIGluZm8pIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ29tcG9uZW50LnByb3RvdHlwZSwgbWV0aG9kTmFtZSwge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvd1ByaW9yaXR5V2FybmluZyQxKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbiAgZm9yICh2YXIgZm5OYW1lIGluIGRlcHJlY2F0ZWRBUElzKSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRBUElzLmhhc093blByb3BlcnR5KGZuTmFtZSkpIHtcbiAgICAgIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyhmbk5hbWUsIGRlcHJlY2F0ZWRBUElzW2ZuTmFtZV0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgaGVscGVycyBmb3IgdGhlIHVwZGF0aW5nIHN0YXRlIG9mIGEgY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBQdXJlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0LCB1cGRhdGVyKSB7XG4gIC8vIER1cGxpY2F0ZWQgZnJvbSBDb21wb25lbnQuXG4gIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gIC8vIFdlIGluaXRpYWxpemUgdGhlIGRlZmF1bHQgdXBkYXRlciBidXQgdGhlIHJlYWwgb25lIGdldHMgaW5qZWN0ZWQgYnkgdGhlXG4gIC8vIHJlbmRlcmVyLlxuICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xufVxuXG5mdW5jdGlvbiBDb21wb25lbnREdW1teSgpIHt9XG5Db21wb25lbnREdW1teS5wcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xudmFyIHB1cmVDb21wb25lbnRQcm90b3R5cGUgPSBQdXJlQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xucHVyZUNvbXBvbmVudFByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFB1cmVDb21wb25lbnQ7XG4vLyBBdm9pZCBhbiBleHRyYSBwcm90b3R5cGUganVtcCBmb3IgdGhlc2UgbWV0aG9kcy5cbl9hc3NpZ24ocHVyZUNvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5wdXJlQ29tcG9uZW50UHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ID0gdHJ1ZTtcblxuZnVuY3Rpb24gQXN5bmNDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgLy8gRHVwbGljYXRlZCBmcm9tIENvbXBvbmVudC5cbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cbnZhciBhc3luY0NvbXBvbmVudFByb3RvdHlwZSA9IEFzeW5jQ29tcG9uZW50LnByb3RvdHlwZSA9IG5ldyBDb21wb25lbnREdW1teSgpO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUuY29uc3RydWN0b3IgPSBBc3luY0NvbXBvbmVudDtcbi8vIEF2b2lkIGFuIGV4dHJhIHByb3RvdHlwZSBqdW1wIGZvciB0aGVzZSBtZXRob2RzLlxuX2Fzc2lnbihhc3luY0NvbXBvbmVudFByb3RvdHlwZSwgQ29tcG9uZW50LnByb3RvdHlwZSk7XG5hc3luY0NvbXBvbmVudFByb3RvdHlwZS51bnN0YWJsZV9pc0FzeW5jUmVhY3RDb21wb25lbnQgPSB0cnVlO1xuYXN5bmNDb21wb25lbnRQcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogS2VlcHMgdHJhY2sgb2YgdGhlIGN1cnJlbnQgb3duZXIuXG4gKlxuICogVGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIGNvbXBvbmVudCB3aG8gc2hvdWxkIG93biBhbnkgY29tcG9uZW50cyB0aGF0IGFyZVxuICogY3VycmVudGx5IGJlaW5nIGNvbnN0cnVjdGVkLlxuICovXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxufTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50IHR5cGUuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUkMSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaGFzVmFsaWRLZXkoY29uZmlnKSB7XG4gIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsICdrZXknKSkge1xuICAgICAgdmFyIGdldHRlciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoY29uZmlnLCAna2V5JykuZ2V0O1xuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL2ZiLm1lL3JlYWN0LXNwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgIH1cbiAgfTtcbiAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9mYi5tZS9yZWFjdC1zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICB9XG4gIH07XG4gIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICBjb25maWd1cmFibGU6IHRydWVcbiAgfSk7XG59XG5cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBubyBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdEVsZW1lbnQgPSBmdW5jdGlvbiAodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKSB7XG4gIHZhciBlbGVtZW50ID0ge1xuICAgIC8vIFRoaXMgdGFnIGFsbG93IHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSQxLFxuXG4gICAgLy8gQnVpbHQtaW4gcHJvcGVydGllcyB0aGF0IGJlbG9uZyBvbiB0aGUgZWxlbWVudFxuICAgIHR5cGU6IHR5cGUsXG4gICAga2V5OiBrZXksXG4gICAgcmVmOiByZWYsXG4gICAgcHJvcHM6IHByb3BzLFxuXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7XG4gICAgLy8gc2VsZiBhbmQgc291cmNlIGFyZSBERVYgb25seSBwcm9wZXJ0aWVzLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pO1xuICAgIC8vIFR3byBlbGVtZW50cyBjcmVhdGVkIGluIHR3byBkaWZmZXJlbnQgcGxhY2VzIHNob3VsZCBiZSBjb25zaWRlcmVkXG4gICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuZCByZXR1cm4gYSBuZXcgUmVhY3RFbGVtZW50IG9mIHRoZSBnaXZlbiB0eXBlLlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNjcmVhdGVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodHlwZSwgY29uZmlnLCBjaGlsZHJlbikge1xuICB2YXIgcHJvcE5hbWU7XG5cbiAgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuICB2YXIgcHJvcHMgPSB7fTtcblxuICB2YXIga2V5ID0gbnVsbDtcbiAgdmFyIHJlZiA9IG51bGw7XG4gIHZhciBzZWxmID0gbnVsbDtcbiAgdmFyIHNvdXJjZSA9IG51bGw7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgfVxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICB7XG4gICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkQXJyYXkpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmIChwcm9wc1twcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB7XG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHMuJCR0eXBlb2YgPT09ICd1bmRlZmluZWQnIHx8IHByb3BzLiQkdHlwZW9mICE9PSBSRUFDVF9FTEVNRU5UX1RZUEUkMSkge1xuICAgICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG4gICAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufVxuXG4vKipcbiAqIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgUmVhY3RFbGVtZW50cyBvZiBhIGdpdmVuIHR5cGUuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2NyZWF0ZWZhY3RvcnlcbiAqL1xuXG5cbmZ1bmN0aW9uIGNsb25lQW5kUmVwbGFjZUtleShvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxuLyoqXG4gKiBDbG9uZSBhbmQgcmV0dXJuIGEgbmV3IFJlYWN0RWxlbWVudCB1c2luZyBlbGVtZW50IGFzIHRoZSBzdGFydGluZyBwb2ludC5cbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjY2xvbmVlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGNsb25lRWxlbWVudChlbGVtZW50LCBjb25maWcsIGNoaWxkcmVuKSB7XG4gIHZhciBwcm9wTmFtZTtcblxuICAvLyBPcmlnaW5hbCBwcm9wcyBhcmUgY29waWVkXG4gIHZhciBwcm9wcyA9IF9hc3NpZ24oe30sIGVsZW1lbnQucHJvcHMpO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIC8vIFNlbGYgaXMgcHJlc2VydmVkIHNpbmNlIHRoZSBvd25lciBpcyBwcmVzZXJ2ZWQuXG4gIHZhciBzZWxmID0gZWxlbWVudC5fc2VsZjtcbiAgLy8gU291cmNlIGlzIHByZXNlcnZlZCBzaW5jZSBjbG9uZUVsZW1lbnQgaXMgdW5saWtlbHkgdG8gYmUgdGFyZ2V0ZWQgYnkgYVxuICAvLyB0cmFuc3BpbGVyLCBhbmQgdGhlIG9yaWdpbmFsIHNvdXJjZSBpcyBwcm9iYWJseSBhIGJldHRlciBpbmRpY2F0b3Igb2YgdGhlXG4gIC8vIHRydWUgb3duZXIuXG4gIHZhciBzb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG5cbiAgLy8gT3duZXIgd2lsbCBiZSBwcmVzZXJ2ZWQsIHVubGVzcyByZWYgaXMgb3ZlcnJpZGRlblxuICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcblxuICBpZiAoY29uZmlnICE9IG51bGwpIHtcbiAgICBpZiAoaGFzVmFsaWRSZWYoY29uZmlnKSkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgdmFyIGRlZmF1bHRQcm9wcztcbiAgICBpZiAoZWxlbWVudC50eXBlICYmIGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGRlZmF1bHRQcm9wcyA9IGVsZW1lbnQudHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgfVxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIGlmIChjb25maWdbcHJvcE5hbWVdID09PSB1bmRlZmluZWQgJiYgZGVmYXVsdFByb3BzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn1cblxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiBvYmplY3QgIT09IG51bGwgJiYgb2JqZWN0LiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUkMTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSB7fTtcblxue1xuICAvLyBDb21wb25lbnQgdGhhdCBpcyBiZWluZyB3b3JrZWQgb25cbiAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuXG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW1wbCA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrO1xuICAgIGlmIChpbXBsKSB7XG4gICAgICByZXR1cm4gaW1wbCgpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbn1cblxudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddICYmIFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnBvcnRhbCcpIHx8IDB4ZWFjYTtcbnZhciBTRVBBUkFUT1IgPSAnLic7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIEVzY2FwZSBhbmQgd3JhcCBrZXkgc28gaXQgaXMgc2FmZSB0byB1c2UgYXMgYSByZWFjdGlkXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGtleSB0byBiZSBlc2NhcGVkLlxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZXNjYXBlZCBrZXkuXG4gKi9cbmZ1bmN0aW9uIGVzY2FwZShrZXkpIHtcbiAgdmFyIGVzY2FwZVJlZ2V4ID0gL1s9Ol0vZztcbiAgdmFyIGVzY2FwZXJMb29rdXAgPSB7XG4gICAgJz0nOiAnPTAnLFxuICAgICc6JzogJz0yJ1xuICB9O1xuICB2YXIgZXNjYXBlZFN0cmluZyA9ICgnJyArIGtleSkucmVwbGFjZShlc2NhcGVSZWdleCwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgcmV0dXJuIGVzY2FwZXJMb29rdXBbbWF0Y2hdO1xuICB9KTtcblxuICByZXR1cm4gJyQnICsgZXNjYXBlZFN0cmluZztcbn1cblxuLyoqXG4gKiBUT0RPOiBUZXN0IHRoYXQgYSBzaW5nbGUgY2hpbGQgYW5kIGFuIGFycmF5IHdpdGggb25lIGl0ZW0gaGF2ZSB0aGUgc2FtZSBrZXlcbiAqIHBhdHRlcm4uXG4gKi9cblxudmFyIGRpZFdhcm5BYm91dE1hcHMgPSBmYWxzZTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1xcLysvZztcbmZ1bmN0aW9uIGVzY2FwZVVzZXJQcm92aWRlZEtleSh0ZXh0KSB7XG4gIHJldHVybiAoJycgKyB0ZXh0KS5yZXBsYWNlKHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4LCAnJCYvJyk7XG59XG5cbnZhciBQT09MX1NJWkUgPSAxMDtcbnZhciB0cmF2ZXJzZUNvbnRleHRQb29sID0gW107XG5mdW5jdGlvbiBnZXRQb29sZWRUcmF2ZXJzZUNvbnRleHQobWFwUmVzdWx0LCBrZXlQcmVmaXgsIG1hcEZ1bmN0aW9uLCBtYXBDb250ZXh0KSB7XG4gIGlmICh0cmF2ZXJzZUNvbnRleHRQb29sLmxlbmd0aCkge1xuICAgIHZhciB0cmF2ZXJzZUNvbnRleHQgPSB0cmF2ZXJzZUNvbnRleHRQb29sLnBvcCgpO1xuICAgIHRyYXZlcnNlQ29udGV4dC5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gICAgdHJhdmVyc2VDb250ZXh0LmtleVByZWZpeCA9IGtleVByZWZpeDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG1hcEZ1bmN0aW9uO1xuICAgIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgICB0cmF2ZXJzZUNvbnRleHQuY291bnQgPSAwO1xuICAgIHJldHVybiB0cmF2ZXJzZUNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3VsdDogbWFwUmVzdWx0LFxuICAgICAga2V5UHJlZml4OiBrZXlQcmVmaXgsXG4gICAgICBmdW5jOiBtYXBGdW5jdGlvbixcbiAgICAgIGNvbnRleHQ6IG1hcENvbnRleHQsXG4gICAgICBjb3VudDogMFxuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdHJhdmVyc2VDb250ZXh0LnJlc3VsdCA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5rZXlQcmVmaXggPSBudWxsO1xuICB0cmF2ZXJzZUNvbnRleHQuZnVuYyA9IG51bGw7XG4gIHRyYXZlcnNlQ29udGV4dC5jb250ZXh0ID0gbnVsbDtcbiAgdHJhdmVyc2VDb250ZXh0LmNvdW50ID0gMDtcbiAgaWYgKHRyYXZlcnNlQ29udGV4dFBvb2wubGVuZ3RoIDwgUE9PTF9TSVpFKSB7XG4gICAgdHJhdmVyc2VDb250ZXh0UG9vbC5wdXNoKHRyYXZlcnNlQ29udGV4dCk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZVNvRmFyIE5hbWUgb2YgdGhlIGtleSBwYXRoIHNvIGZhci5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayB0byBpbnZva2Ugd2l0aCBlYWNoIGNoaWxkIGZvdW5kLlxuICogQHBhcmFtIHs/Kn0gdHJhdmVyc2VDb250ZXh0IFVzZWQgdG8gcGFzcyBpbmZvcm1hdGlvbiB0aHJvdWdob3V0IHRoZSB0cmF2ZXJzYWxcbiAqIHByb2Nlc3MuXG4gKiBAcmV0dXJuIHshbnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNoaWxkcmVuIGluIHRoaXMgc3VidHJlZS5cbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGRyZW4sIG5hbWVTb0ZhciwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHR5cGVvZiBjaGlsZHJlbjtcblxuICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgLy8gQWxsIG9mIHRoZSBhYm92ZSBhcmUgcGVyY2VpdmVkIGFzIG51bGwuXG4gICAgY2hpbGRyZW4gPSBudWxsO1xuICB9XG5cbiAgaWYgKGNoaWxkcmVuID09PSBudWxsIHx8IHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGUgPT09ICdudW1iZXInIHx8XG4gIC8vIFRoZSBmb2xsb3dpbmcgaXMgaW5saW5lZCBmcm9tIFJlYWN0RWxlbWVudC4gVGhpcyBtZWFucyB3ZSBjYW4gb3B0aW1pemVcbiAgLy8gc29tZSBjaGVja3MuIFJlYWN0IEZpYmVyIGFsc28gaW5saW5lcyB0aGlzIGxvZ2ljIGZvciBzaW1pbGFyIHB1cnBvc2VzLlxuICB0eXBlID09PSAnb2JqZWN0JyAmJiBjaGlsZHJlbi4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFIHx8IHR5cGUgPT09ICdvYmplY3QnICYmIGNoaWxkcmVuLiQkdHlwZW9mID09PSBSRUFDVF9QT1JUQUxfVFlQRSkge1xuICAgIGNhbGxiYWNrKHRyYXZlcnNlQ29udGV4dCwgY2hpbGRyZW4sXG4gICAgLy8gSWYgaXQncyB0aGUgb25seSBjaGlsZCwgdHJlYXQgdGhlIG5hbWUgYXMgaWYgaXQgd2FzIHdyYXBwZWQgaW4gYW4gYXJyYXlcbiAgICAvLyBzbyB0aGF0IGl0J3MgY29uc2lzdGVudCBpZiB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIGdyb3dzLlxuICAgIG5hbWVTb0ZhciA9PT0gJycgPyBTRVBBUkFUT1IgKyBnZXRDb21wb25lbnRLZXkoY2hpbGRyZW4sIDApIDogbmFtZVNvRmFyKTtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBjaGlsZDtcbiAgdmFyIG5leHROYW1lO1xuICB2YXIgc3VidHJlZUNvdW50ID0gMDsgLy8gQ291bnQgb2YgY2hpbGRyZW4gZm91bmQgaW4gdGhlIGN1cnJlbnQgc3VidHJlZS5cbiAgdmFyIG5leHROYW1lUHJlZml4ID0gbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiA6IG5hbWVTb0ZhciArIFNVQlNFUEFSQVRPUjtcblxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgbmV4dE5hbWUgPSBuZXh0TmFtZVByZWZpeCArIGdldENvbXBvbmVudEtleShjaGlsZCwgaSk7XG4gICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBJVEVSQVRPUl9TWU1CT0wgJiYgY2hpbGRyZW5bSVRFUkFUT1JfU1lNQk9MXSB8fCBjaGlsZHJlbltGQVVYX0lURVJBVE9SX1NZTUJPTF07XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoaXRlcmF0b3JGbiA9PT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICAgIHdhcm5pbmcoZGlkV2FybkFib3V0TWFwcywgJ1VzaW5nIE1hcHMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzLiBDb252ZXJ0IGl0IHRvIGEgc2VxdWVuY2UvaXRlcmFibGUgb2Yga2V5ZWQgJyArICdSZWFjdEVsZW1lbnRzIGluc3RlYWQuJXMnLCBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcbiAgICAgIHZhciBzdGVwO1xuICAgICAgdmFyIGlpID0gMDtcbiAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpaSsrKTtcbiAgICAgICAgc3VidHJlZUNvdW50ICs9IHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkLCBuZXh0TmFtZSwgY2FsbGJhY2ssIHRyYXZlcnNlQ29udGV4dCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG4gICAgICB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW5TdHJpbmcgPSAnJyArIGNoaWxkcmVuO1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBjaGlsZHJlblN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNoaWxkcmVuKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRyZW5TdHJpbmcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIC8vIERvIHNvbWUgdHlwZWNoZWNraW5nIGhlcmUgc2luY2Ugd2UgY2FsbCB0aGlzIGJsaW5kbHkuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgZG9uJ3QgYmxvY2sgcG90ZW50aWFsIGZ1dHVyZSBFUyBBUElzLlxuICBpZiAodHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgY29tcG9uZW50ICE9PSBudWxsICYmIGNvbXBvbmVudC5rZXkgIT0gbnVsbCkge1xuICAgIC8vIEV4cGxpY2l0IGtleVxuICAgIHJldHVybiBlc2NhcGUoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmMsXG4gICAgICBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4uZm9yZWFjaFxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IGdldFBvb2xlZFRyYXZlcnNlQ29udGV4dChudWxsLCBudWxsLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpO1xuICB0cmF2ZXJzZUFsbENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoU2luZ2xlQ2hpbGQsIHRyYXZlcnNlQ29udGV4dCk7XG4gIHJlbGVhc2VUcmF2ZXJzZUNvbnRleHQodHJhdmVyc2VDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQsXG4gICAgICBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXgsXG4gICAgICBmdW5jID0gYm9va0tlZXBpbmcuZnVuYyxcbiAgICAgIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG5cbiAgdmFyIG1hcHBlZENoaWxkID0gZnVuYy5jYWxsKGNvbnRleHQsIGNoaWxkLCBib29rS2VlcGluZy5jb3VudCsrKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkobWFwcGVkQ2hpbGQpKSB7XG4gICAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChtYXBwZWRDaGlsZCwgcmVzdWx0LCBjaGlsZEtleSwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgfSBlbHNlIGlmIChtYXBwZWRDaGlsZCAhPSBudWxsKSB7XG4gICAgaWYgKGlzVmFsaWRFbGVtZW50KG1hcHBlZENoaWxkKSkge1xuICAgICAgbWFwcGVkQ2hpbGQgPSBjbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQua2V5ICYmICghY2hpbGQgfHwgY2hpbGQua2V5ICE9PSBtYXBwZWRDaGlsZC5rZXkpID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSkgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gZ2V0UG9vbGVkVHJhdmVyc2VDb250ZXh0KGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgcmVsZWFzZVRyYXZlcnNlQ29udGV4dCh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ubWFwXG4gKlxuICogVGhlIHByb3ZpZGVkIG1hcEZ1bmN0aW9uKGNoaWxkLCBrZXksIGluZGV4KSB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaFxuICogbGVhZiBjaGlsZC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIGNvbnRhaW5lci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwgaW50KX0gZnVuYyBUaGUgbWFwIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IENvbnRleHQgZm9yIG1hcEZ1bmN0aW9uLlxuICogQHJldHVybiB7b2JqZWN0fSBPYmplY3QgY29udGFpbmluZyB0aGUgb3JkZXJlZCBtYXAgb2YgcmVzdWx0cy5cbiAqL1xuZnVuY3Rpb24gbWFwQ2hpbGRyZW4oY2hpbGRyZW4sIGZ1bmMsIGNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdO1xuICBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCByZXN1bHQsIG51bGwsIGZ1bmMsIGNvbnRleHQpO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIENvdW50IHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhc1xuICogYHByb3BzLmNoaWxkcmVuYC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLmNvdW50XG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsLCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI3JlYWN0LmNoaWxkcmVuLnRvYXJyYXlcbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBmaXJzdCBjaGlsZCBpbiBhIGNvbGxlY3Rpb24gb2YgY2hpbGRyZW4gYW5kIHZlcmlmaWVzIHRoYXQgdGhlcmVcbiAqIGlzIG9ubHkgb25lIGNoaWxkIGluIHRoZSBjb2xsZWN0aW9uLlxuICpcbiAqIFNlZSBodHRwczovL3JlYWN0anMub3JnL2RvY3MvcmVhY3QtYXBpLmh0bWwjcmVhY3QuY2hpbGRyZW4ub25seVxuICpcbiAqIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXMgZnVuY3Rpb24gYXNzdW1lcyB0aGF0IGEgc2luZ2xlIGNoaWxkIGdldHNcbiAqIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZSBwdXJwb3NlIG9mIHRoaXMgaGVscGVyIGZ1bmN0aW9uIGlzIHRvXG4gKiBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZSBvZiBjaGlsZHJlbi5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGNoaWxkcmVuIENoaWxkIGNvbGxlY3Rpb24gc3RydWN0dXJlLlxuICogQHJldHVybiB7UmVhY3RFbGVtZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0RWxlbWVudGAgY29udGFpbmVkIGluIHRoZVxuICogc3RydWN0dXJlLlxuICovXG5mdW5jdGlvbiBvbmx5Q2hpbGQoY2hpbGRyZW4pIHtcbiAgIWlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0LkNoaWxkcmVuLm9ubHkgZXhwZWN0ZWQgdG8gcmVjZWl2ZSBhIHNpbmdsZSBSZWFjdCBlbGVtZW50IGNoaWxkLicpIDogdm9pZCAwO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbnZhciBkZXNjcmliZUNvbXBvbmVudEZyYW1lID0gZnVuY3Rpb24gKG5hbWUsIHNvdXJjZSwgb3duZXJOYW1lKSB7XG4gIHJldHVybiAnXFxuICAgIGluICcgKyAobmFtZSB8fCAnVW5rbm93bicpICsgKHNvdXJjZSA/ICcgKGF0ICcgKyBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpICsgJzonICsgc291cmNlLmxpbmVOdW1iZXIgKyAnKScgOiBvd25lck5hbWUgPyAnIChjcmVhdGVkIGJ5ICcgKyBvd25lck5hbWUgKyAnKScgOiAnJyk7XG59O1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFJlYWN0RWxlbWVudFZhbGlkYXRvciBwcm92aWRlcyBhIHdyYXBwZXIgYXJvdW5kIGEgZWxlbWVudCBmYWN0b3J5XG4gKiB3aGljaCB2YWxpZGF0ZXMgdGhlIHByb3BzIHBhc3NlZCB0byB0aGUgZWxlbWVudC4gVGhpcyBpcyBpbnRlbmRlZCB0byBiZVxuICogdXNlZCBvbmx5IGluIERFViBhbmQgY291bGQgYmUgcmVwbGFjZWQgYnkgYSBzdGF0aWMgdHlwZSBjaGVja2VyIGZvciBsYW5ndWFnZXNcbiAqIHRoYXQgc3VwcG9ydCBpdC5cbiAqL1xuXG57XG4gIHZhciBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG5cbiAgdmFyIGdldERpc3BsYXlOYW1lID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyNlbXB0eSc7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGVsZW1lbnQgPT09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gJyN0ZXh0JztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbGVtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlO1xuICAgIH0gZWxzZSBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFJDEpIHtcbiAgICAgIHJldHVybiAnUmVhY3QuRnJhZ21lbnQnO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZWxlbWVudC50eXBlLmRpc3BsYXlOYW1lIHx8IGVsZW1lbnQudHlwZS5uYW1lIHx8ICdVbmtub3duJztcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldFN0YWNrQWRkZW5kdW0gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YWNrID0gJyc7XG4gICAgaWYgKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldERpc3BsYXlOYW1lKGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KTtcbiAgICAgIHZhciBvd25lciA9IGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50Ll9vd25lcjtcbiAgICAgIHN0YWNrICs9IGRlc2NyaWJlQ29tcG9uZW50RnJhbWUobmFtZSwgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQuX3NvdXJjZSwgb3duZXIgJiYgZ2V0Q29tcG9uZW50TmFtZShvd25lcikpO1xuICAgIH1cbiAgICBzdGFjayArPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcbiAgICByZXR1cm4gc3RhY2s7XG4gIH07XG5cbiAgdmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUkMSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5mcmFnbWVudCcpIHx8IDB4ZWFjYjtcblxuICB2YXIgVkFMSURfRlJBR01FTlRfUFJPUFMgPSBuZXcgTWFwKFtbJ2NoaWxkcmVuJywgdHJ1ZV0sIFsna2V5JywgdHJ1ZV1dKTtcbn1cblxudmFyIElURVJBVE9SX1NZTUJPTCQxID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wkMSA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oZWxlbWVudFByb3BzKSB7XG4gIGlmIChlbGVtZW50UHJvcHMgIT09IG51bGwgJiYgZWxlbWVudFByb3BzICE9PSB1bmRlZmluZWQgJiYgZWxlbWVudFByb3BzLl9fc291cmNlICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgc291cmNlID0gZWxlbWVudFByb3BzLl9fc291cmNlO1xuICAgIHZhciBmaWxlTmFtZSA9IHNvdXJjZS5maWxlTmFtZS5yZXBsYWNlKC9eLipbXFxcXFxcL10vLCAnJyk7XG4gICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHZhciBpbmZvID0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG5cbiAgaWYgKCFpbmZvKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8JyArIHBhcmVudE5hbWUgKyAnPi4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gaW5mbztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG4gIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgdmFyIGNoaWxkT3duZXIgPSAnJztcbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBjaGlsZE93bmVyID0gJyBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSAnICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lcikgKyAnLic7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IGVsZW1lbnQ7XG4gIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4lcycsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGV2ZXJ5IGVsZW1lbnQgZWl0aGVyIGlzIHBhc3NlZCBpbiBhIHN0YXRpYyBsb2NhdGlvbiwgaW4gYW5cbiAqIGFycmF5IHdpdGggYW4gZXhwbGljaXQga2V5cyBwcm9wZXJ0eSBkZWZpbmVkLCBvciBpbiBhbiBvYmplY3QgbGl0ZXJhbFxuICogd2l0aCB2YWxpZCBrZXkgcHJvcGVydHkuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge1JlYWN0Tm9kZX0gbm9kZSBTdGF0aWNhbGx5IHBhc3NlZCBjaGlsZCBvZiBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBub2RlJ3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICBpZiAodHlwZW9mIG5vZGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KGNoaWxkKSkge1xuICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gSVRFUkFUT1JfU1lNQk9MJDEgJiYgbm9kZVtJVEVSQVRPUl9TWU1CT0wkMV0gfHwgbm9kZVtGQVVYX0lURVJBVE9SX1NZTUJPTCQxXTtcbiAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEVudHJ5IGl0ZXJhdG9ycyB1c2VkIHRvIHByb3ZpZGUgaW1wbGljaXQga2V5cyxcbiAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwobm9kZSk7XG4gICAgICAgIHZhciBzdGVwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KSB7XG4gIHZhciBjb21wb25lbnRDbGFzcyA9IGVsZW1lbnQudHlwZTtcbiAgaWYgKHR5cGVvZiBjb21wb25lbnRDbGFzcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbmFtZSA9IGNvbXBvbmVudENsYXNzLmRpc3BsYXlOYW1lIHx8IGNvbXBvbmVudENsYXNzLm5hbWU7XG4gIHZhciBwcm9wVHlwZXMgPSBjb21wb25lbnRDbGFzcy5wcm9wVHlwZXM7XG5cbiAgaWYgKHByb3BUeXBlcykge1xuICAgIGN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50ID0gZWxlbWVudDtcbiAgICBjaGVja1Byb3BUeXBlcyhwcm9wVHlwZXMsIGVsZW1lbnQucHJvcHMsICdwcm9wJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSk7XG4gICAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhjb21wb25lbnRDbGFzcy5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQsICdnZXREZWZhdWx0UHJvcHMgaXMgb25seSB1c2VkIG9uIGNsYXNzaWMgUmVhY3QuY3JlYXRlQ2xhc3MgJyArICdkZWZpbml0aW9ucy4gVXNlIGEgc3RhdGljIHByb3BlcnR5IG5hbWVkIGBkZWZhdWx0UHJvcHNgIGluc3RlYWQuJyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZnJhZ21lbnQpIHtcbiAgY3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQgPSBmcmFnbWVudDtcblxuICB2YXIgX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiA9IHRydWU7XG4gIHZhciBfZGlkSXRlcmF0b3JFcnJvciA9IGZhbHNlO1xuICB2YXIgX2l0ZXJhdG9yRXJyb3IgPSB1bmRlZmluZWQ7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKHZhciBfaXRlcmF0b3IgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcylbU3ltYm9sLml0ZXJhdG9yXSgpLCBfc3RlcDsgIShfaXRlcmF0b3JOb3JtYWxDb21wbGV0aW9uID0gKF9zdGVwID0gX2l0ZXJhdG9yLm5leHQoKSkuZG9uZSk7IF9pdGVyYXRvck5vcm1hbENvbXBsZXRpb24gPSB0cnVlKSB7XG4gICAgICB2YXIga2V5ID0gX3N0ZXAudmFsdWU7XG5cbiAgICAgIGlmICghVkFMSURfRlJBR01FTlRfUFJPUFMuaGFzKGtleSkpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4lcycsIGtleSwgZ2V0U3RhY2tBZGRlbmR1bSgpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZGlkSXRlcmF0b3JFcnJvciA9IHRydWU7XG4gICAgX2l0ZXJhdG9yRXJyb3IgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX2l0ZXJhdG9yTm9ybWFsQ29tcGxldGlvbiAmJiBfaXRlcmF0b3JbJ3JldHVybiddKSB7XG4gICAgICAgIF9pdGVyYXRvclsncmV0dXJuJ10oKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kaWRJdGVyYXRvckVycm9yKSB7XG4gICAgICAgIHRocm93IF9pdGVyYXRvckVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4lcycsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gIH1cblxuICBjdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgdmFyIHZhbGlkVHlwZSA9IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgdHlwZSA9PT0gJ3N5bWJvbCcgfHwgdHlwZW9mIHR5cGUgPT09ICdudW1iZXInO1xuICAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICBpZiAoIXZhbGlkVHlwZSkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4uXCI7XG4gICAgfVxuXG4gICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShwcm9wcyk7XG4gICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICB9IGVsc2Uge1xuICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICB9XG5cbiAgICBpbmZvICs9IGdldFN0YWNrQWRkZW5kdW0oKSB8fCAnJztcblxuICAgIHdhcm5pbmcoZmFsc2UsICdSZWFjdC5jcmVhdGVFbGVtZW50OiB0eXBlIGlzIGludmFsaWQgLS0gZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciAnICsgJ2J1aWx0LWluIGNvbXBvbmVudHMpIG9yIGEgY2xhc3MvZnVuY3Rpb24gKGZvciBjb21wb3NpdGUgJyArICdjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIHR5cGUgPT0gbnVsbCA/IHR5cGUgOiB0eXBlb2YgdHlwZSwgaW5mbyk7XG4gIH1cblxuICB2YXIgZWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuXG4gIC8vIFNraXAga2V5IHdhcm5pbmcgaWYgdGhlIHR5cGUgaXNuJ3QgdmFsaWQgc2luY2Ugb3VyIGtleSB2YWxpZGF0aW9uIGxvZ2ljXG4gIC8vIGRvZXNuJ3QgZXhwZWN0IGEgbm9uLXN0cmluZy9mdW5jdGlvbiB0eXBlIGFuZCBjYW4gdGhyb3cgY29uZnVzaW5nIGVycm9ycy5cbiAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAvLyAoUmVuZGVyaW5nIHdpbGwgdGhyb3cgd2l0aCBhIGhlbHBmdWwgbWVzc2FnZSBhbmQgYXMgc29vbiBhcyB0aGUgdHlwZSBpc1xuICAvLyBmaXhlZCwgdGhlIGtleSB3YXJuaW5ncyB3aWxsIGFwcGVhci4pXG4gIGlmICh2YWxpZFR5cGUpIHtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCB0eXBlKTtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzeW1ib2wnICYmIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUkMSkge1xuICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhlbGVtZW50KTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24odHlwZSkge1xuICB2YXIgdmFsaWRhdGVkRmFjdG9yeSA9IGNyZWF0ZUVsZW1lbnRXaXRoVmFsaWRhdGlvbi5iaW5kKG51bGwsIHR5cGUpO1xuICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgdmFsaWRhdGVkRmFjdG9yeS50eXBlID0gdHlwZTtcblxuICB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHZhbGlkYXRlZEZhY3RvcnksICd0eXBlJywge1xuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdGYWN0b3J5LnR5cGUgaXMgZGVwcmVjYXRlZC4gQWNjZXNzIHRoZSBjbGFzcyBkaXJlY3RseSAnICsgJ2JlZm9yZSBwYXNzaW5nIGl0IHRvIGNyZWF0ZUZhY3RvcnkuJyk7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICB2YWx1ZTogdHlwZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbn1cblxuZnVuY3Rpb24gY2xvbmVFbGVtZW50V2l0aFZhbGlkYXRpb24oZWxlbWVudCwgcHJvcHMsIGNoaWxkcmVuKSB7XG4gIHZhciBuZXdFbGVtZW50ID0gY2xvbmVFbGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICB9XG4gIHZhbGlkYXRlUHJvcFR5cGVzKG5ld0VsZW1lbnQpO1xuICByZXR1cm4gbmV3RWxlbWVudDtcbn1cblxudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbFsnZm9yJ10gJiYgU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKSB8fCAweGVhY2I7XG5cbnZhciBSZWFjdCA9IHtcbiAgQ2hpbGRyZW46IHtcbiAgICBtYXA6IG1hcENoaWxkcmVuLFxuICAgIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgICBjb3VudDogY291bnRDaGlsZHJlbixcbiAgICB0b0FycmF5OiB0b0FycmF5LFxuICAgIG9ubHk6IG9ubHlDaGlsZFxuICB9LFxuXG4gIENvbXBvbmVudDogQ29tcG9uZW50LFxuICBQdXJlQ29tcG9uZW50OiBQdXJlQ29tcG9uZW50LFxuICB1bnN0YWJsZV9Bc3luY0NvbXBvbmVudDogQXN5bmNDb21wb25lbnQsXG5cbiAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjbG9uZUVsZW1lbnQ6IGNsb25lRWxlbWVudFdpdGhWYWxpZGF0aW9uLFxuICBjcmVhdGVGYWN0b3J5OiBjcmVhdGVGYWN0b3J5V2l0aFZhbGlkYXRpb24sXG4gIGlzVmFsaWRFbGVtZW50OiBpc1ZhbGlkRWxlbWVudCxcblxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICBSZWFjdEN1cnJlbnRPd25lcjogUmVhY3RDdXJyZW50T3duZXIsXG4gICAgLy8gVXNlZCBieSByZW5kZXJlcnMgdG8gYXZvaWQgYnVuZGxpbmcgb2JqZWN0LWFzc2lnbiB0d2ljZSBpbiBVTUQgYnVuZGxlczpcbiAgICBhc3NpZ246IF9hc3NpZ25cbiAgfVxufTtcblxuaWYgKGVuYWJsZVJlYWN0RnJhZ21lbnQpIHtcbiAgUmVhY3QuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xufVxuXG57XG4gIF9hc3NpZ24oUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQsIHtcbiAgICAvLyBUaGVzZSBzaG91bGQgbm90IGJlIGluY2x1ZGVkIGluIHByb2R1Y3Rpb24uXG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTogUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSxcbiAgICAvLyBTaGltIGZvciBSZWFjdCBET00gMTYuMC4wIHdoaWNoIHN0aWxsIGRlc3RydWN0dXJlZCAoYnV0IG5vdCB1c2VkKSB0aGlzLlxuICAgIC8vIFRPRE86IHJlbW92ZSBpbiBSZWFjdCAxNy4wLlxuICAgIFJlYWN0Q29tcG9uZW50VHJlZUhvb2s6IHt9XG4gIH0pO1xufVxuXG5cblxudmFyIFJlYWN0JDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3Rcbn0pO1xuXG52YXIgUmVhY3QkMyA9ICggUmVhY3QkMiAmJiBSZWFjdCApIHx8IFJlYWN0JDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0ID0gUmVhY3QkM1snZGVmYXVsdCddID8gUmVhY3QkM1snZGVmYXVsdCddIDogUmVhY3QkMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdDtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QuZGV2ZWxvcG1lbnQuanMiLCIvKiogQGxpY2Vuc2UgUmVhY3QgdjE2LjEuMFxuICogcmVhY3QtZG9tLnByb2R1Y3Rpb24ubWluLmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cbi8qXG4gTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4qL1xuJ3VzZSBzdHJpY3QnO3ZhciBhYT1yZXF1aXJlKFwicmVhY3RcIiksbT1yZXF1aXJlKFwiZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnRcIiksQT1yZXF1aXJlKFwib2JqZWN0LWFzc2lnblwiKSxCPXJlcXVpcmUoXCJmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uXCIpLGNhPXJlcXVpcmUoXCJmYmpzL2xpYi9FdmVudExpc3RlbmVyXCIpLGRhPXJlcXVpcmUoXCJmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50XCIpLGVhPXJlcXVpcmUoXCJmYmpzL2xpYi9zaGFsbG93RXF1YWxcIiksaGE9cmVxdWlyZShcImZianMvbGliL2NvbnRhaW5zTm9kZVwiKSxpYT1yZXF1aXJlKFwiZmJqcy9saWIvZm9jdXNOb2RlXCIpLEM9cmVxdWlyZShcImZianMvbGliL2VtcHR5T2JqZWN0XCIpO1xuZnVuY3Rpb24gRChhKXtmb3IodmFyIGI9YXJndW1lbnRzLmxlbmd0aC0xLGM9XCJNaW5pZmllZCBSZWFjdCBlcnJvciAjXCIrYStcIjsgdmlzaXQgaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Vycm9yLWRlY29kZXIuaHRtbD9pbnZhcmlhbnRcXHgzZFwiK2EsZD0wO2Q8YjtkKyspYys9XCJcXHgyNmFyZ3NbXVxceDNkXCIrZW5jb2RlVVJJQ29tcG9uZW50KGFyZ3VtZW50c1tkKzFdKTtiPUVycm9yKGMrXCIgZm9yIHRoZSBmdWxsIG1lc3NhZ2Ugb3IgdXNlIHRoZSBub24tbWluaWZpZWQgZGV2IGVudmlyb25tZW50IGZvciBmdWxsIGVycm9ycyBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLlwiKTtiLm5hbWU9XCJJbnZhcmlhbnQgVmlvbGF0aW9uXCI7Yi5mcmFtZXNUb1BvcD0xO3Rocm93IGI7fWFhP3ZvaWQgMDpEKFwiMjI3XCIpO1xudmFyIGxhPXtjaGlsZHJlbjohMCxkYW5nZXJvdXNseVNldElubmVySFRNTDohMCxkZWZhdWx0VmFsdWU6ITAsZGVmYXVsdENoZWNrZWQ6ITAsaW5uZXJIVE1MOiEwLHN1cHByZXNzQ29udGVudEVkaXRhYmxlV2FybmluZzohMCxzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmc6ITAsc3R5bGU6ITB9O2Z1bmN0aW9uIHFhKGEsYil7cmV0dXJuKGEmYik9PT1ifVxudmFyIHJhPXtNVVNUX1VTRV9QUk9QRVJUWToxLEhBU19CT09MRUFOX1ZBTFVFOjQsSEFTX05VTUVSSUNfVkFMVUU6OCxIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRToyNCxIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOjMyLEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTo2NCxpbmplY3RET01Qcm9wZXJ0eUNvbmZpZzpmdW5jdGlvbihhKXt2YXIgYj1yYSxjPWEuUHJvcGVydGllc3x8e30sZD1hLkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXN8fHt9LGU9YS5ET01BdHRyaWJ1dGVOYW1lc3x8e307YT1hLkRPTU11dGF0aW9uTWV0aG9kc3x8e307Zm9yKHZhciBmIGluIGMpe3NhLmhhc093blByb3BlcnR5KGYpP0QoXCI0OFwiLGYpOnZvaWQgMDt2YXIgZz1mLnRvTG93ZXJDYXNlKCksaz1jW2ZdO2c9e2F0dHJpYnV0ZU5hbWU6ZyxhdHRyaWJ1dGVOYW1lc3BhY2U6bnVsbCxwcm9wZXJ0eU5hbWU6ZixtdXRhdGlvbk1ldGhvZDpudWxsLG11c3RVc2VQcm9wZXJ0eTpxYShrLGIuTVVTVF9VU0VfUFJPUEVSVFkpLFxuaGFzQm9vbGVhblZhbHVlOnFhKGssYi5IQVNfQk9PTEVBTl9WQUxVRSksaGFzTnVtZXJpY1ZhbHVlOnFhKGssYi5IQVNfTlVNRVJJQ19WQUxVRSksaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6cWEoayxiLkhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFKSxoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOnFhKGssYi5IQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFKSxoYXNTdHJpbmdCb29sZWFuVmFsdWU6cWEoayxiLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSl9OzE+PWcuaGFzQm9vbGVhblZhbHVlK2cuaGFzTnVtZXJpY1ZhbHVlK2cuaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZT92b2lkIDA6RChcIjUwXCIsZik7ZS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcuYXR0cmlidXRlTmFtZT1lW2ZdKTtkLmhhc093blByb3BlcnR5KGYpJiYoZy5hdHRyaWJ1dGVOYW1lc3BhY2U9ZFtmXSk7YS5oYXNPd25Qcm9wZXJ0eShmKSYmKGcubXV0YXRpb25NZXRob2Q9YVtmXSk7c2FbZl09Z319fSxzYT17fTtcbmZ1bmN0aW9uIHRhKGEsYil7aWYobGEuaGFzT3duUHJvcGVydHkoYSl8fDI8YS5sZW5ndGgmJihcIm9cIj09PWFbMF18fFwiT1wiPT09YVswXSkmJihcIm5cIj09PWFbMV18fFwiTlwiPT09YVsxXSkpcmV0dXJuITE7aWYobnVsbD09PWIpcmV0dXJuITA7c3dpdGNoKHR5cGVvZiBiKXtjYXNlIFwiYm9vbGVhblwiOnJldHVybiBsYS5oYXNPd25Qcm9wZXJ0eShhKT9hPSEwOihiPXVhKGEpKT9hPWIuaGFzQm9vbGVhblZhbHVlfHxiLmhhc1N0cmluZ0Jvb2xlYW5WYWx1ZXx8Yi5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOihhPWEudG9Mb3dlckNhc2UoKS5zbGljZSgwLDUpLGE9XCJkYXRhLVwiPT09YXx8XCJhcmlhLVwiPT09YSksYTtjYXNlIFwidW5kZWZpbmVkXCI6Y2FzZSBcIm51bWJlclwiOmNhc2UgXCJzdHJpbmdcIjpjYXNlIFwib2JqZWN0XCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdWEoYSl7cmV0dXJuIHNhLmhhc093blByb3BlcnR5KGEpP3NhW2FdOm51bGx9XG52YXIgdmE9cmEsd2E9dmEuTVVTVF9VU0VfUFJPUEVSVFksSD12YS5IQVNfQk9PTEVBTl9WQUxVRSx4YT12YS5IQVNfTlVNRVJJQ19WQUxVRSx5YT12YS5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSx6YT12YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsQWE9e1Byb3BlcnRpZXM6e2FsbG93RnVsbFNjcmVlbjpILGF1dG9Gb2N1czp6YSxhc3luYzpILGF1dG9QbGF5OkgsY2FwdHVyZTpILGNoZWNrZWQ6d2F8SCxjb2xzOnlhLGNvbnRlbnRFZGl0YWJsZTp6YSxjb250cm9sczpILFwiZGVmYXVsdFwiOkgsZGVmZXI6SCxkaXNhYmxlZDpILGRvd25sb2FkOnZhLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUsZHJhZ2dhYmxlOnphLGZvcm1Ob1ZhbGlkYXRlOkgsaGlkZGVuOkgsbG9vcDpILG11bHRpcGxlOndhfEgsbXV0ZWQ6d2F8SCxub1ZhbGlkYXRlOkgsb3BlbjpILHBsYXlzSW5saW5lOkgscmVhZE9ubHk6SCxyZXF1aXJlZDpILHJldmVyc2VkOkgscm93czp5YSxyb3dTcGFuOnhhLFxuc2NvcGVkOkgsc2VhbWxlc3M6SCxzZWxlY3RlZDp3YXxILHNpemU6eWEsc3RhcnQ6eGEsc3Bhbjp5YSxzcGVsbENoZWNrOnphLHN0eWxlOjAsdGFiSW5kZXg6MCxpdGVtU2NvcGU6SCxhY2NlcHRDaGFyc2V0OjAsY2xhc3NOYW1lOjAsaHRtbEZvcjowLGh0dHBFcXVpdjowLHZhbHVlOnphfSxET01BdHRyaWJ1dGVOYW1lczp7YWNjZXB0Q2hhcnNldDpcImFjY2VwdC1jaGFyc2V0XCIsY2xhc3NOYW1lOlwiY2xhc3NcIixodG1sRm9yOlwiZm9yXCIsaHR0cEVxdWl2OlwiaHR0cC1lcXVpdlwifSxET01NdXRhdGlvbk1ldGhvZHM6e3ZhbHVlOmZ1bmN0aW9uKGEsYil7aWYobnVsbD09YilyZXR1cm4gYS5yZW1vdmVBdHRyaWJ1dGUoXCJ2YWx1ZVwiKTtcIm51bWJlclwiIT09YS50eXBlfHwhMT09PWEuaGFzQXR0cmlidXRlKFwidmFsdWVcIik/YS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFwiXCIrYik6YS52YWxpZGl0eSYmIWEudmFsaWRpdHkuYmFkSW5wdXQmJmEub3duZXJEb2N1bWVudC5hY3RpdmVFbGVtZW50IT09YSYmXG5hLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsXCJcIitiKX19fSxCYT12YS5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsSz17eGxpbms6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rXCIseG1sOlwiaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlXCJ9LENhPXtQcm9wZXJ0aWVzOnthdXRvUmV2ZXJzZTpCYSxleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOkJhLHByZXNlcnZlQWxwaGE6QmF9LERPTUF0dHJpYnV0ZU5hbWVzOnthdXRvUmV2ZXJzZTpcImF1dG9SZXZlcnNlXCIsZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDpcImV4dGVybmFsUmVzb3VyY2VzUmVxdWlyZWRcIixwcmVzZXJ2ZUFscGhhOlwicHJlc2VydmVBbHBoYVwifSxET01BdHRyaWJ1dGVOYW1lc3BhY2VzOnt4bGlua0FjdHVhdGU6Sy54bGluayx4bGlua0FyY3JvbGU6Sy54bGluayx4bGlua0hyZWY6Sy54bGluayx4bGlua1JvbGU6Sy54bGluayx4bGlua1Nob3c6Sy54bGluayx4bGlua1RpdGxlOksueGxpbmsseGxpbmtUeXBlOksueGxpbmssXG54bWxCYXNlOksueG1sLHhtbExhbmc6Sy54bWwseG1sU3BhY2U6Sy54bWx9fSxEYT0vW1xcLVxcOl0oW2Etel0pL2c7ZnVuY3Rpb24gRWEoYSl7cmV0dXJuIGFbMV0udG9VcHBlckNhc2UoKX1cblwiYWNjZW50LWhlaWdodCBhbGlnbm1lbnQtYmFzZWxpbmUgYXJhYmljLWZvcm0gYmFzZWxpbmUtc2hpZnQgY2FwLWhlaWdodCBjbGlwLXBhdGggY2xpcC1ydWxlIGNvbG9yLWludGVycG9sYXRpb24gY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzIGNvbG9yLXByb2ZpbGUgY29sb3ItcmVuZGVyaW5nIGRvbWluYW50LWJhc2VsaW5lIGVuYWJsZS1iYWNrZ3JvdW5kIGZpbGwtb3BhY2l0eSBmaWxsLXJ1bGUgZmxvb2QtY29sb3IgZmxvb2Qtb3BhY2l0eSBmb250LWZhbWlseSBmb250LXNpemUgZm9udC1zaXplLWFkanVzdCBmb250LXN0cmV0Y2ggZm9udC1zdHlsZSBmb250LXZhcmlhbnQgZm9udC13ZWlnaHQgZ2x5cGgtbmFtZSBnbHlwaC1vcmllbnRhdGlvbi1ob3Jpem9udGFsIGdseXBoLW9yaWVudGF0aW9uLXZlcnRpY2FsIGhvcml6LWFkdi14IGhvcml6LW9yaWdpbi14IGltYWdlLXJlbmRlcmluZyBsZXR0ZXItc3BhY2luZyBsaWdodGluZy1jb2xvciBtYXJrZXItZW5kIG1hcmtlci1taWQgbWFya2VyLXN0YXJ0IG92ZXJsaW5lLXBvc2l0aW9uIG92ZXJsaW5lLXRoaWNrbmVzcyBwYWludC1vcmRlciBwYW5vc2UtMSBwb2ludGVyLWV2ZW50cyByZW5kZXJpbmctaW50ZW50IHNoYXBlLXJlbmRlcmluZyBzdG9wLWNvbG9yIHN0b3Atb3BhY2l0eSBzdHJpa2V0aHJvdWdoLXBvc2l0aW9uIHN0cmlrZXRocm91Z2gtdGhpY2tuZXNzIHN0cm9rZS1kYXNoYXJyYXkgc3Ryb2tlLWRhc2hvZmZzZXQgc3Ryb2tlLWxpbmVjYXAgc3Ryb2tlLWxpbmVqb2luIHN0cm9rZS1taXRlcmxpbWl0IHN0cm9rZS1vcGFjaXR5IHN0cm9rZS13aWR0aCB0ZXh0LWFuY2hvciB0ZXh0LWRlY29yYXRpb24gdGV4dC1yZW5kZXJpbmcgdW5kZXJsaW5lLXBvc2l0aW9uIHVuZGVybGluZS10aGlja25lc3MgdW5pY29kZS1iaWRpIHVuaWNvZGUtcmFuZ2UgdW5pdHMtcGVyLWVtIHYtYWxwaGFiZXRpYyB2LWhhbmdpbmcgdi1pZGVvZ3JhcGhpYyB2LW1hdGhlbWF0aWNhbCB2ZWN0b3ItZWZmZWN0IHZlcnQtYWR2LXkgdmVydC1vcmlnaW4teCB2ZXJ0LW9yaWdpbi15IHdvcmQtc3BhY2luZyB3cml0aW5nLW1vZGUgeC1oZWlnaHQgeGxpbms6YWN0dWF0ZSB4bGluazphcmNyb2xlIHhsaW5rOmhyZWYgeGxpbms6cm9sZSB4bGluazpzaG93IHhsaW5rOnRpdGxlIHhsaW5rOnR5cGUgeG1sOmJhc2UgeG1sbnM6eGxpbmsgeG1sOmxhbmcgeG1sOnNwYWNlXCIuc3BsaXQoXCIgXCIpLmZvckVhY2goZnVuY3Rpb24oYSl7dmFyIGI9YS5yZXBsYWNlKERhLFxuRWEpO0NhLlByb3BlcnRpZXNbYl09MDtDYS5ET01BdHRyaWJ1dGVOYW1lc1tiXT1hfSk7dmEuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoQWEpO3ZhLmluamVjdERPTVByb3BlcnR5Q29uZmlnKENhKTtcbnZhciBOPXtfY2F1Z2h0RXJyb3I6bnVsbCxfaGFzQ2F1Z2h0RXJyb3I6ITEsX3JldGhyb3dFcnJvcjpudWxsLF9oYXNSZXRocm93RXJyb3I6ITEsaW5qZWN0aW9uOntpbmplY3RFcnJvclV0aWxzOmZ1bmN0aW9uKGEpe1wiZnVuY3Rpb25cIiE9PXR5cGVvZiBhLmludm9rZUd1YXJkZWRDYWxsYmFjaz9EKFwiMTk3XCIpOnZvaWQgMDtIYT1hLmludm9rZUd1YXJkZWRDYWxsYmFja319LGludm9rZUd1YXJkZWRDYWxsYmFjazpmdW5jdGlvbihhLGIsYyxkLGUsZixnLGssaCl7SGEuYXBwbHkoTixhcmd1bWVudHMpfSxpbnZva2VHdWFyZGVkQ2FsbGJhY2tBbmRDYXRjaEZpcnN0RXJyb3I6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsZyxrLGgpe04uaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KHRoaXMsYXJndW1lbnRzKTtpZihOLmhhc0NhdWdodEVycm9yKCkpe3ZhciByPU4uY2xlYXJDYXVnaHRFcnJvcigpO04uX2hhc1JldGhyb3dFcnJvcnx8KE4uX2hhc1JldGhyb3dFcnJvcj0hMCxOLl9yZXRocm93RXJyb3I9XG5yKX19LHJldGhyb3dDYXVnaHRFcnJvcjpmdW5jdGlvbigpe3JldHVybiBJYS5hcHBseShOLGFyZ3VtZW50cyl9LGhhc0NhdWdodEVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIE4uX2hhc0NhdWdodEVycm9yfSxjbGVhckNhdWdodEVycm9yOmZ1bmN0aW9uKCl7aWYoTi5faGFzQ2F1Z2h0RXJyb3Ipe3ZhciBhPU4uX2NhdWdodEVycm9yO04uX2NhdWdodEVycm9yPW51bGw7Ti5faGFzQ2F1Z2h0RXJyb3I9ITE7cmV0dXJuIGF9RChcIjE5OFwiKX19O2Z1bmN0aW9uIEhhKGEsYixjLGQsZSxmLGcsayxoKXtOLl9oYXNDYXVnaHRFcnJvcj0hMTtOLl9jYXVnaHRFcnJvcj1udWxsO3ZhciByPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywzKTt0cnl7Yi5hcHBseShjLHIpfWNhdGNoKG4pe04uX2NhdWdodEVycm9yPW4sTi5faGFzQ2F1Z2h0RXJyb3I9ITB9fVxuZnVuY3Rpb24gSWEoKXtpZihOLl9oYXNSZXRocm93RXJyb3Ipe3ZhciBhPU4uX3JldGhyb3dFcnJvcjtOLl9yZXRocm93RXJyb3I9bnVsbDtOLl9oYXNSZXRocm93RXJyb3I9ITE7dGhyb3cgYTt9fXZhciBKYT1udWxsLEthPXt9O1xuZnVuY3Rpb24gTGEoKXtpZihKYSlmb3IodmFyIGEgaW4gS2Epe3ZhciBiPUthW2FdLGM9SmEuaW5kZXhPZihhKTstMTxjP3ZvaWQgMDpEKFwiOTZcIixhKTtpZighTWFbY10pe2IuZXh0cmFjdEV2ZW50cz92b2lkIDA6RChcIjk3XCIsYSk7TWFbY109YjtjPWIuZXZlbnRUeXBlcztmb3IodmFyIGQgaW4gYyl7dmFyIGU9dm9pZCAwO3ZhciBmPWNbZF0sZz1iLGs9ZDtOYS5oYXNPd25Qcm9wZXJ0eShrKT9EKFwiOTlcIixrKTp2b2lkIDA7TmFba109Zjt2YXIgaD1mLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzO2lmKGgpe2ZvcihlIGluIGgpaC5oYXNPd25Qcm9wZXJ0eShlKSYmT2EoaFtlXSxnLGspO2U9ITB9ZWxzZSBmLnJlZ2lzdHJhdGlvbk5hbWU/KE9hKGYucmVnaXN0cmF0aW9uTmFtZSxnLGspLGU9ITApOmU9ITE7ZT92b2lkIDA6RChcIjk4XCIsZCxhKX19fX1cbmZ1bmN0aW9uIE9hKGEsYixjKXtQYVthXT9EKFwiMTAwXCIsYSk6dm9pZCAwO1BhW2FdPWI7UWFbYV09Yi5ldmVudFR5cGVzW2NdLmRlcGVuZGVuY2llc312YXIgTWE9W10sTmE9e30sUGE9e30sUWE9e307ZnVuY3Rpb24gUmEoYSl7SmE/RChcIjEwMVwiKTp2b2lkIDA7SmE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYSk7TGEoKX1mdW5jdGlvbiBTYShhKXt2YXIgYj0hMSxjO2ZvcihjIGluIGEpaWYoYS5oYXNPd25Qcm9wZXJ0eShjKSl7dmFyIGQ9YVtjXTtLYS5oYXNPd25Qcm9wZXJ0eShjKSYmS2FbY109PT1kfHwoS2FbY10/RChcIjEwMlwiLGMpOnZvaWQgMCxLYVtjXT1kLGI9ITApfWImJkxhKCl9XG52YXIgVGE9T2JqZWN0LmZyZWV6ZSh7cGx1Z2luczpNYSxldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6TmEscmVnaXN0cmF0aW9uTmFtZU1vZHVsZXM6UGEscmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llczpRYSxwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzOm51bGwsaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjpSYSxpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6U2F9KSxVYT1udWxsLFZhPW51bGwsV2E9bnVsbDtmdW5jdGlvbiBYYShhLGIsYyxkKXtiPWEudHlwZXx8XCJ1bmtub3duLWV2ZW50XCI7YS5jdXJyZW50VGFyZ2V0PVdhKGQpO04uaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yKGIsYyx2b2lkIDAsYSk7YS5jdXJyZW50VGFyZ2V0PW51bGx9XG5mdW5jdGlvbiBZYShhLGIpe251bGw9PWI/RChcIjMwXCIpOnZvaWQgMDtpZihudWxsPT1hKXJldHVybiBiO2lmKEFycmF5LmlzQXJyYXkoYSkpe2lmKEFycmF5LmlzQXJyYXkoYikpcmV0dXJuIGEucHVzaC5hcHBseShhLGIpLGE7YS5wdXNoKGIpO3JldHVybiBhfXJldHVybiBBcnJheS5pc0FycmF5KGIpP1thXS5jb25jYXQoYik6W2EsYl19ZnVuY3Rpb24gWmEoYSxiLGMpe0FycmF5LmlzQXJyYXkoYSk/YS5mb3JFYWNoKGIsYyk6YSYmYi5jYWxsKGMsYSl9dmFyICRhPW51bGw7XG5mdW5jdGlvbiBhYihhLGIpe2lmKGEpe3ZhciBjPWEuX2Rpc3BhdGNoTGlzdGVuZXJzLGQ9YS5fZGlzcGF0Y2hJbnN0YW5jZXM7aWYoQXJyYXkuaXNBcnJheShjKSlmb3IodmFyIGU9MDtlPGMubGVuZ3RoJiYhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO2UrKylYYShhLGIsY1tlXSxkW2VdKTtlbHNlIGMmJlhhKGEsYixjLGQpO2EuX2Rpc3BhdGNoTGlzdGVuZXJzPW51bGw7YS5fZGlzcGF0Y2hJbnN0YW5jZXM9bnVsbDthLmlzUGVyc2lzdGVudCgpfHxhLmNvbnN0cnVjdG9yLnJlbGVhc2UoYSl9fWZ1bmN0aW9uIGJiKGEpe3JldHVybiBhYihhLCEwKX1mdW5jdGlvbiBjYihhKXtyZXR1cm4gYWIoYSwhMSl9dmFyIGRiPXtpbmplY3RFdmVudFBsdWdpbk9yZGVyOlJhLGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTpTYX07XG5mdW5jdGlvbiBlYihhLGIpe3ZhciBjPWEuc3RhdGVOb2RlO2lmKCFjKXJldHVybiBudWxsO3ZhciBkPVVhKGMpO2lmKCFkKXJldHVybiBudWxsO2M9ZFtiXTthOnN3aXRjaChiKXtjYXNlIFwib25DbGlja1wiOmNhc2UgXCJvbkNsaWNrQ2FwdHVyZVwiOmNhc2UgXCJvbkRvdWJsZUNsaWNrXCI6Y2FzZSBcIm9uRG91YmxlQ2xpY2tDYXB0dXJlXCI6Y2FzZSBcIm9uTW91c2VEb3duXCI6Y2FzZSBcIm9uTW91c2VEb3duQ2FwdHVyZVwiOmNhc2UgXCJvbk1vdXNlTW92ZVwiOmNhc2UgXCJvbk1vdXNlTW92ZUNhcHR1cmVcIjpjYXNlIFwib25Nb3VzZVVwXCI6Y2FzZSBcIm9uTW91c2VVcENhcHR1cmVcIjooZD0hZC5kaXNhYmxlZCl8fChhPWEudHlwZSxkPSEoXCJidXR0b25cIj09PWF8fFwiaW5wdXRcIj09PWF8fFwic2VsZWN0XCI9PT1hfHxcInRleHRhcmVhXCI9PT1hKSk7YT0hZDticmVhayBhO2RlZmF1bHQ6YT0hMX1pZihhKXJldHVybiBudWxsO2MmJlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjP0QoXCIyMzFcIixiLHR5cGVvZiBjKTp2b2lkIDA7XG5yZXR1cm4gY31mdW5jdGlvbiBqYihhLGIsYyxkKXtmb3IodmFyIGUsZj0wO2Y8TWEubGVuZ3RoO2YrKyl7dmFyIGc9TWFbZl07ZyYmKGc9Zy5leHRyYWN0RXZlbnRzKGEsYixjLGQpKSYmKGU9WWEoZSxnKSl9cmV0dXJuIGV9ZnVuY3Rpb24ga2IoYSl7YSYmKCRhPVlhKCRhLGEpKX1mdW5jdGlvbiBsYihhKXt2YXIgYj0kYTskYT1udWxsO2E/WmEoYixiYik6WmEoYixjYik7JGE/RChcIjk1XCIpOnZvaWQgMDtOLnJldGhyb3dDYXVnaHRFcnJvcigpfXZhciBtYj1PYmplY3QuZnJlZXplKHtpbmplY3Rpb246ZGIsZ2V0TGlzdGVuZXI6ZWIsZXh0cmFjdEV2ZW50czpqYixlbnF1ZXVlRXZlbnRzOmtiLHByb2Nlc3NFdmVudFF1ZXVlOmxifSksbmI9TWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMiksTz1cIl9fcmVhY3RJbnRlcm5hbEluc3RhbmNlJFwiK25iLG9iPVwiX19yZWFjdEV2ZW50SGFuZGxlcnMkXCIrbmI7XG5mdW5jdGlvbiBwYihhKXtpZihhW09dKXJldHVybiBhW09dO2Zvcih2YXIgYj1bXTshYVtPXTspaWYoYi5wdXNoKGEpLGEucGFyZW50Tm9kZSlhPWEucGFyZW50Tm9kZTtlbHNlIHJldHVybiBudWxsO3ZhciBjPXZvaWQgMCxkPWFbT107aWYoNT09PWQudGFnfHw2PT09ZC50YWcpcmV0dXJuIGQ7Zm9yKDthJiYoZD1hW09dKTthPWIucG9wKCkpYz1kO3JldHVybiBjfWZ1bmN0aW9uIHFiKGEpe2lmKDU9PT1hLnRhZ3x8Nj09PWEudGFnKXJldHVybiBhLnN0YXRlTm9kZTtEKFwiMzNcIil9ZnVuY3Rpb24gcmIoYSl7cmV0dXJuIGFbb2JdfHxudWxsfVxudmFyIHNiPU9iamVjdC5mcmVlemUoe3ByZWNhY2hlRmliZXJOb2RlOmZ1bmN0aW9uKGEsYil7YltPXT1hfSxnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZTpwYixnZXRJbnN0YW5jZUZyb21Ob2RlOmZ1bmN0aW9uKGEpe2E9YVtPXTtyZXR1cm4hYXx8NSE9PWEudGFnJiY2IT09YS50YWc/bnVsbDphfSxnZXROb2RlRnJvbUluc3RhbmNlOnFiLGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6cmIsdXBkYXRlRmliZXJQcm9wczpmdW5jdGlvbihhLGIpe2Fbb2JdPWJ9fSk7ZnVuY3Rpb24gUShhKXtkbyBhPWFbXCJyZXR1cm5cIl07d2hpbGUoYSYmNSE9PWEudGFnKTtyZXR1cm4gYT9hOm51bGx9ZnVuY3Rpb24gdGIoYSxiLGMpe2Zvcih2YXIgZD1bXTthOylkLnB1c2goYSksYT1RKGEpO2ZvcihhPWQubGVuZ3RoOzA8YS0tOyliKGRbYV0sXCJjYXB0dXJlZFwiLGMpO2ZvcihhPTA7YTxkLmxlbmd0aDthKyspYihkW2FdLFwiYnViYmxlZFwiLGMpfVxuZnVuY3Rpb24gdWIoYSxiLGMpe2lmKGI9ZWIoYSxjLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW2JdKSljLl9kaXNwYXRjaExpc3RlbmVycz1ZYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz1ZYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKX1mdW5jdGlvbiB2YihhKXthJiZhLmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzJiZ0YihhLl90YXJnZXRJbnN0LHViLGEpfWZ1bmN0aW9uIHdiKGEpe2lmKGEmJmEuZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXMpe3ZhciBiPWEuX3RhcmdldEluc3Q7Yj1iP1EoYik6bnVsbDt0YihiLHViLGEpfX1cbmZ1bmN0aW9uIHhiKGEsYixjKXthJiZjJiZjLmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUmJihiPWViKGEsYy5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSkmJihjLl9kaXNwYXRjaExpc3RlbmVycz1ZYShjLl9kaXNwYXRjaExpc3RlbmVycyxiKSxjLl9kaXNwYXRjaEluc3RhbmNlcz1ZYShjLl9kaXNwYXRjaEluc3RhbmNlcyxhKSl9ZnVuY3Rpb24geWIoYSl7YSYmYS5kaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lJiZ4YihhLl90YXJnZXRJbnN0LG51bGwsYSl9ZnVuY3Rpb24gemIoYSl7WmEoYSx2Yil9XG5mdW5jdGlvbiBBYihhLGIsYyxkKXtpZihjJiZkKWE6e3ZhciBlPWM7Zm9yKHZhciBmPWQsZz0wLGs9ZTtrO2s9UShrKSlnKys7az0wO2Zvcih2YXIgaD1mO2g7aD1RKGgpKWsrKztmb3IoOzA8Zy1rOyllPVEoZSksZy0tO2Zvcig7MDxrLWc7KWY9UShmKSxrLS07Zm9yKDtnLS07KXtpZihlPT09Znx8ZT09PWYuYWx0ZXJuYXRlKWJyZWFrIGE7ZT1RKGUpO2Y9UShmKX1lPW51bGx9ZWxzZSBlPW51bGw7Zj1lO2ZvcihlPVtdO2MmJmMhPT1mOyl7Zz1jLmFsdGVybmF0ZTtpZihudWxsIT09ZyYmZz09PWYpYnJlYWs7ZS5wdXNoKGMpO2M9UShjKX1mb3IoYz1bXTtkJiZkIT09Zjspe2c9ZC5hbHRlcm5hdGU7aWYobnVsbCE9PWcmJmc9PT1mKWJyZWFrO2MucHVzaChkKTtkPVEoZCl9Zm9yKGQ9MDtkPGUubGVuZ3RoO2QrKyl4YihlW2RdLFwiYnViYmxlZFwiLGEpO2ZvcihhPWMubGVuZ3RoOzA8YS0tOyl4YihjW2FdLFwiY2FwdHVyZWRcIixiKX1cbnZhciBCYj1PYmplY3QuZnJlZXplKHthY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOnpiLGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OmZ1bmN0aW9uKGEpe1phKGEsd2IpfSxhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXM6QWIsYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXM6ZnVuY3Rpb24oYSl7WmEoYSx5Yil9fSksQ2I9bnVsbDtmdW5jdGlvbiBEYigpeyFDYiYmbS5jYW5Vc2VET00mJihDYj1cInRleHRDb250ZW50XCJpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ/XCJ0ZXh0Q29udGVudFwiOlwiaW5uZXJUZXh0XCIpO3JldHVybiBDYn12YXIgUj17X3Jvb3Q6bnVsbCxfc3RhcnRUZXh0Om51bGwsX2ZhbGxiYWNrVGV4dDpudWxsfTtcbmZ1bmN0aW9uIEViKCl7aWYoUi5fZmFsbGJhY2tUZXh0KXJldHVybiBSLl9mYWxsYmFja1RleHQ7dmFyIGEsYj1SLl9zdGFydFRleHQsYz1iLmxlbmd0aCxkLGU9RmIoKSxmPWUubGVuZ3RoO2ZvcihhPTA7YTxjJiZiW2FdPT09ZVthXTthKyspO3ZhciBnPWMtYTtmb3IoZD0xO2Q8PWcmJmJbYy1kXT09PWVbZi1kXTtkKyspO1IuX2ZhbGxiYWNrVGV4dD1lLnNsaWNlKGEsMTxkPzEtZDp2b2lkIDApO3JldHVybiBSLl9mYWxsYmFja1RleHR9ZnVuY3Rpb24gRmIoKXtyZXR1cm5cInZhbHVlXCJpbiBSLl9yb290P1IuX3Jvb3QudmFsdWU6Ui5fcm9vdFtEYigpXX1cbnZhciBHYj1cImRpc3BhdGNoQ29uZmlnIF90YXJnZXRJbnN0IG5hdGl2ZUV2ZW50IGlzRGVmYXVsdFByZXZlbnRlZCBpc1Byb3BhZ2F0aW9uU3RvcHBlZCBfZGlzcGF0Y2hMaXN0ZW5lcnMgX2Rpc3BhdGNoSW5zdGFuY2VzXCIuc3BsaXQoXCIgXCIpLEhiPXt0eXBlOm51bGwsdGFyZ2V0Om51bGwsY3VycmVudFRhcmdldDpCLnRoYXRSZXR1cm5zTnVsbCxldmVudFBoYXNlOm51bGwsYnViYmxlczpudWxsLGNhbmNlbGFibGU6bnVsbCx0aW1lU3RhbXA6ZnVuY3Rpb24oYSl7cmV0dXJuIGEudGltZVN0YW1wfHxEYXRlLm5vdygpfSxkZWZhdWx0UHJldmVudGVkOm51bGwsaXNUcnVzdGVkOm51bGx9O1xuZnVuY3Rpb24gUyhhLGIsYyxkKXt0aGlzLmRpc3BhdGNoQ29uZmlnPWE7dGhpcy5fdGFyZ2V0SW5zdD1iO3RoaXMubmF0aXZlRXZlbnQ9YzthPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO2Zvcih2YXIgZSBpbiBhKWEuaGFzT3duUHJvcGVydHkoZSkmJigoYj1hW2VdKT90aGlzW2VdPWIoYyk6XCJ0YXJnZXRcIj09PWU/dGhpcy50YXJnZXQ9ZDp0aGlzW2VdPWNbZV0pO3RoaXMuaXNEZWZhdWx0UHJldmVudGVkPShudWxsIT1jLmRlZmF1bHRQcmV2ZW50ZWQ/Yy5kZWZhdWx0UHJldmVudGVkOiExPT09Yy5yZXR1cm5WYWx1ZSk/Qi50aGF0UmV0dXJuc1RydWU6Qi50aGF0UmV0dXJuc0ZhbHNlO3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQ9Qi50aGF0UmV0dXJuc0ZhbHNlO3JldHVybiB0aGlzfVxuQShTLnByb3RvdHlwZSx7cHJldmVudERlZmF1bHQ6ZnVuY3Rpb24oKXt0aGlzLmRlZmF1bHRQcmV2ZW50ZWQ9ITA7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5wcmV2ZW50RGVmYXVsdD9hLnByZXZlbnREZWZhdWx0KCk6XCJ1bmtub3duXCIhPT10eXBlb2YgYS5yZXR1cm5WYWx1ZSYmKGEucmV0dXJuVmFsdWU9ITEpLHRoaXMuaXNEZWZhdWx0UHJldmVudGVkPUIudGhhdFJldHVybnNUcnVlKX0sc3RvcFByb3BhZ2F0aW9uOmZ1bmN0aW9uKCl7dmFyIGE9dGhpcy5uYXRpdmVFdmVudDthJiYoYS5zdG9wUHJvcGFnYXRpb24/YS5zdG9wUHJvcGFnYXRpb24oKTpcInVua25vd25cIiE9PXR5cGVvZiBhLmNhbmNlbEJ1YmJsZSYmKGEuY2FuY2VsQnViYmxlPSEwKSx0aGlzLmlzUHJvcGFnYXRpb25TdG9wcGVkPUIudGhhdFJldHVybnNUcnVlKX0scGVyc2lzdDpmdW5jdGlvbigpe3RoaXMuaXNQZXJzaXN0ZW50PUIudGhhdFJldHVybnNUcnVlfSxpc1BlcnNpc3RlbnQ6Qi50aGF0UmV0dXJuc0ZhbHNlLFxuZGVzdHJ1Y3RvcjpmdW5jdGlvbigpe3ZhciBhPXRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlLGI7Zm9yKGIgaW4gYSl0aGlzW2JdPW51bGw7Zm9yKGE9MDthPEdiLmxlbmd0aDthKyspdGhpc1tHYlthXV09bnVsbH19KTtTLkludGVyZmFjZT1IYjtTLmF1Z21lbnRDbGFzcz1mdW5jdGlvbihhLGIpe2Z1bmN0aW9uIGMoKXt9Yy5wcm90b3R5cGU9dGhpcy5wcm90b3R5cGU7dmFyIGQ9bmV3IGM7QShkLGEucHJvdG90eXBlKTthLnByb3RvdHlwZT1kO2EucHJvdG90eXBlLmNvbnN0cnVjdG9yPWE7YS5JbnRlcmZhY2U9QSh7fSx0aGlzLkludGVyZmFjZSxiKTthLmF1Z21lbnRDbGFzcz10aGlzLmF1Z21lbnRDbGFzcztJYihhKX07SWIoUyk7ZnVuY3Rpb24gSmIoYSxiLGMsZCl7aWYodGhpcy5ldmVudFBvb2wubGVuZ3RoKXt2YXIgZT10aGlzLmV2ZW50UG9vbC5wb3AoKTt0aGlzLmNhbGwoZSxhLGIsYyxkKTtyZXR1cm4gZX1yZXR1cm4gbmV3IHRoaXMoYSxiLGMsZCl9XG5mdW5jdGlvbiBRYihhKXthIGluc3RhbmNlb2YgdGhpcz92b2lkIDA6RChcIjIyM1wiKTthLmRlc3RydWN0b3IoKTsxMD50aGlzLmV2ZW50UG9vbC5sZW5ndGgmJnRoaXMuZXZlbnRQb29sLnB1c2goYSl9ZnVuY3Rpb24gSWIoYSl7YS5ldmVudFBvb2w9W107YS5nZXRQb29sZWQ9SmI7YS5yZWxlYXNlPVFifWZ1bmN0aW9uIFJiKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1TLmF1Z21lbnRDbGFzcyhSYix7ZGF0YTpudWxsfSk7ZnVuY3Rpb24gU2IoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVMuYXVnbWVudENsYXNzKFNiLHtkYXRhOm51bGx9KTt2YXIgVGI9WzksMTMsMjcsMzJdLFViPW0uY2FuVXNlRE9NJiZcIkNvbXBvc2l0aW9uRXZlbnRcImluIHdpbmRvdyxWYj1udWxsO20uY2FuVXNlRE9NJiZcImRvY3VtZW50TW9kZVwiaW4gZG9jdW1lbnQmJihWYj1kb2N1bWVudC5kb2N1bWVudE1vZGUpO3ZhciBXYjtcbmlmKFdiPW0uY2FuVXNlRE9NJiZcIlRleHRFdmVudFwiaW4gd2luZG93JiYhVmIpe3ZhciBYYj13aW5kb3cub3BlcmE7V2I9IShcIm9iamVjdFwiPT09dHlwZW9mIFhiJiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgWGIudmVyc2lvbiYmMTI+PXBhcnNlSW50KFhiLnZlcnNpb24oKSwxMCkpfVxudmFyIFliPVdiLFpiPW0uY2FuVXNlRE9NJiYoIVVifHxWYiYmODxWYiYmMTE+PVZiKSwkYj1TdHJpbmcuZnJvbUNoYXJDb2RlKDMyKSxhYz17YmVmb3JlSW5wdXQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25CZWZvcmVJbnB1dFwiLGNhcHR1cmVkOlwib25CZWZvcmVJbnB1dENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOltcInRvcENvbXBvc2l0aW9uRW5kXCIsXCJ0b3BLZXlQcmVzc1wiLFwidG9wVGV4dElucHV0XCIsXCJ0b3BQYXN0ZVwiXX0sY29tcG9zaXRpb25FbmQ6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25Db21wb3NpdGlvbkVuZFwiLGNhcHR1cmVkOlwib25Db21wb3NpdGlvbkVuZENhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDb21wb3NpdGlvbkVuZCB0b3BLZXlEb3duIHRvcEtleVByZXNzIHRvcEtleVVwIHRvcE1vdXNlRG93blwiLnNwbGl0KFwiIFwiKX0sY29tcG9zaXRpb25TdGFydDp7cGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6e2J1YmJsZWQ6XCJvbkNvbXBvc2l0aW9uU3RhcnRcIixcbmNhcHR1cmVkOlwib25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbXBvc2l0aW9uU3RhcnQgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9LGNvbXBvc2l0aW9uVXBkYXRlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVcIixjYXB0dXJlZDpcIm9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpcInRvcEJsdXIgdG9wQ29tcG9zaXRpb25VcGRhdGUgdG9wS2V5RG93biB0b3BLZXlQcmVzcyB0b3BLZXlVcCB0b3BNb3VzZURvd25cIi5zcGxpdChcIiBcIil9fSxiYz0hMTtcbmZ1bmN0aW9uIGNjKGEsYil7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlVcFwiOnJldHVybi0xIT09VGIuaW5kZXhPZihiLmtleUNvZGUpO2Nhc2UgXCJ0b3BLZXlEb3duXCI6cmV0dXJuIDIyOSE9PWIua2V5Q29kZTtjYXNlIFwidG9wS2V5UHJlc3NcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcEJsdXJcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBkYyhhKXthPWEuZGV0YWlsO3JldHVyblwib2JqZWN0XCI9PT10eXBlb2YgYSYmXCJkYXRhXCJpbiBhP2EuZGF0YTpudWxsfXZhciBlYz0hMTtmdW5jdGlvbiBmYyhhLGIpe3N3aXRjaChhKXtjYXNlIFwidG9wQ29tcG9zaXRpb25FbmRcIjpyZXR1cm4gZGMoYik7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoMzIhPT1iLndoaWNoKXJldHVybiBudWxsO2JjPSEwO3JldHVybiAkYjtjYXNlIFwidG9wVGV4dElucHV0XCI6cmV0dXJuIGE9Yi5kYXRhLGE9PT0kYiYmYmM/bnVsbDphO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxuZnVuY3Rpb24gZ2MoYSxiKXtpZihlYylyZXR1cm5cInRvcENvbXBvc2l0aW9uRW5kXCI9PT1hfHwhVWImJmNjKGEsYik/KGE9RWIoKSxSLl9yb290PW51bGwsUi5fc3RhcnRUZXh0PW51bGwsUi5fZmFsbGJhY2tUZXh0PW51bGwsZWM9ITEsYSk6bnVsbDtzd2l0Y2goYSl7Y2FzZSBcInRvcFBhc3RlXCI6cmV0dXJuIG51bGw7Y2FzZSBcInRvcEtleVByZXNzXCI6aWYoIShiLmN0cmxLZXl8fGIuYWx0S2V5fHxiLm1ldGFLZXkpfHxiLmN0cmxLZXkmJmIuYWx0S2V5KXtpZihiLmNoYXImJjE8Yi5jaGFyLmxlbmd0aClyZXR1cm4gYi5jaGFyO2lmKGIud2hpY2gpcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoYi53aGljaCl9cmV0dXJuIG51bGw7Y2FzZSBcInRvcENvbXBvc2l0aW9uRW5kXCI6cmV0dXJuIFpiP251bGw6Yi5kYXRhO2RlZmF1bHQ6cmV0dXJuIG51bGx9fVxudmFyIGhjPXtldmVudFR5cGVzOmFjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU7aWYoVWIpYjp7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BDb21wb3NpdGlvblN0YXJ0XCI6dmFyIGY9YWMuY29tcG9zaXRpb25TdGFydDticmVhayBiO2Nhc2UgXCJ0b3BDb21wb3NpdGlvbkVuZFwiOmY9YWMuY29tcG9zaXRpb25FbmQ7YnJlYWsgYjtjYXNlIFwidG9wQ29tcG9zaXRpb25VcGRhdGVcIjpmPWFjLmNvbXBvc2l0aW9uVXBkYXRlO2JyZWFrIGJ9Zj12b2lkIDB9ZWxzZSBlYz9jYyhhLGMpJiYoZj1hYy5jb21wb3NpdGlvbkVuZCk6XCJ0b3BLZXlEb3duXCI9PT1hJiYyMjk9PT1jLmtleUNvZGUmJihmPWFjLmNvbXBvc2l0aW9uU3RhcnQpO2Y/KFpiJiYoZWN8fGYhPT1hYy5jb21wb3NpdGlvblN0YXJ0P2Y9PT1hYy5jb21wb3NpdGlvbkVuZCYmZWMmJihlPUViKCkpOihSLl9yb290PWQsUi5fc3RhcnRUZXh0PUZiKCksZWM9ITApKSxmPVJiLmdldFBvb2xlZChmLGIsYyxkKSxlP2YuZGF0YT1cbmU6KGU9ZGMoYyksbnVsbCE9PWUmJihmLmRhdGE9ZSkpLHpiKGYpLGU9Zik6ZT1udWxsOyhhPVliP2ZjKGEsYyk6Z2MoYSxjKSk/KGI9U2IuZ2V0UG9vbGVkKGFjLmJlZm9yZUlucHV0LGIsYyxkKSxiLmRhdGE9YSx6YihiKSk6Yj1udWxsO3JldHVybltlLGJdfX0saWM9bnVsbCxqYz1udWxsLGtjPW51bGw7ZnVuY3Rpb24gbGMoYSl7aWYoYT1WYShhKSl7aWMmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBpYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlP3ZvaWQgMDpEKFwiMTk0XCIpO3ZhciBiPVVhKGEuc3RhdGVOb2RlKTtpYy5yZXN0b3JlQ29udHJvbGxlZFN0YXRlKGEuc3RhdGVOb2RlLGEudHlwZSxiKX19dmFyIG1jPXtpbmplY3RGaWJlckNvbnRyb2xsZWRIb3N0Q29tcG9uZW50OmZ1bmN0aW9uKGEpe2ljPWF9fTtmdW5jdGlvbiBuYyhhKXtqYz9rYz9rYy5wdXNoKGEpOmtjPVthXTpqYz1hfVxuZnVuY3Rpb24gb2MoKXtpZihqYyl7dmFyIGE9amMsYj1rYztrYz1qYz1udWxsO2xjKGEpO2lmKGIpZm9yKGE9MDthPGIubGVuZ3RoO2ErKylsYyhiW2FdKX19dmFyIHBjPU9iamVjdC5mcmVlemUoe2luamVjdGlvbjptYyxlbnF1ZXVlU3RhdGVSZXN0b3JlOm5jLHJlc3RvcmVTdGF0ZUlmTmVlZGVkOm9jfSk7ZnVuY3Rpb24gcWMoYSxiKXtyZXR1cm4gYShiKX12YXIgcmM9ITE7ZnVuY3Rpb24gc2MoYSxiKXtpZihyYylyZXR1cm4gcWMoYSxiKTtyYz0hMDt0cnl7cmV0dXJuIHFjKGEsYil9ZmluYWxseXtyYz0hMSxvYygpfX12YXIgdGM9e2NvbG9yOiEwLGRhdGU6ITAsZGF0ZXRpbWU6ITAsXCJkYXRldGltZS1sb2NhbFwiOiEwLGVtYWlsOiEwLG1vbnRoOiEwLG51bWJlcjohMCxwYXNzd29yZDohMCxyYW5nZTohMCxzZWFyY2g6ITAsdGVsOiEwLHRleHQ6ITAsdGltZTohMCx1cmw6ITAsd2VlazohMH07XG5mdW5jdGlvbiB1YyhhKXt2YXIgYj1hJiZhLm5vZGVOYW1lJiZhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuXCJpbnB1dFwiPT09Yj8hIXRjW2EudHlwZV06XCJ0ZXh0YXJlYVwiPT09Yj8hMDohMX1mdW5jdGlvbiB2YyhhKXthPWEudGFyZ2V0fHxhLnNyY0VsZW1lbnR8fHdpbmRvdzthLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50JiYoYT1hLmNvcnJlc3BvbmRpbmdVc2VFbGVtZW50KTtyZXR1cm4gMz09PWEubm9kZVR5cGU/YS5wYXJlbnROb2RlOmF9dmFyIHdjO20uY2FuVXNlRE9NJiYod2M9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24mJmRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUmJiEwIT09ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIlwiLFwiXCIpKTtcbmZ1bmN0aW9uIHhjKGEsYil7aWYoIW0uY2FuVXNlRE9NfHxiJiYhKFwiYWRkRXZlbnRMaXN0ZW5lclwiaW4gZG9jdW1lbnQpKXJldHVybiExO2I9XCJvblwiK2E7dmFyIGM9YiBpbiBkb2N1bWVudDtjfHwoYz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGMuc2V0QXR0cmlidXRlKGIsXCJyZXR1cm47XCIpLGM9XCJmdW5jdGlvblwiPT09dHlwZW9mIGNbYl0pOyFjJiZ3YyYmXCJ3aGVlbFwiPT09YSYmKGM9ZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZShcIkV2ZW50cy53aGVlbFwiLFwiMy4wXCIpKTtyZXR1cm4gY31mdW5jdGlvbiB5YyhhKXt2YXIgYj1hLnR5cGU7cmV0dXJuKGE9YS5ub2RlTmFtZSkmJlwiaW5wdXRcIj09PWEudG9Mb3dlckNhc2UoKSYmKFwiY2hlY2tib3hcIj09PWJ8fFwicmFkaW9cIj09PWIpfVxuZnVuY3Rpb24gemMoYSl7dmFyIGI9eWMoYSk/XCJjaGVja2VkXCI6XCJ2YWx1ZVwiLGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhLmNvbnN0cnVjdG9yLnByb3RvdHlwZSxiKSxkPVwiXCIrYVtiXTtpZighYS5oYXNPd25Qcm9wZXJ0eShiKSYmXCJmdW5jdGlvblwiPT09dHlwZW9mIGMuZ2V0JiZcImZ1bmN0aW9uXCI9PT10eXBlb2YgYy5zZXQpcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLGIse2VudW1lcmFibGU6Yy5lbnVtZXJhYmxlLGNvbmZpZ3VyYWJsZTohMCxnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gYy5nZXQuY2FsbCh0aGlzKX0sc2V0OmZ1bmN0aW9uKGEpe2Q9XCJcIithO2Muc2V0LmNhbGwodGhpcyxhKX19KSx7Z2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gZH0sc2V0VmFsdWU6ZnVuY3Rpb24oYSl7ZD1cIlwiK2F9LHN0b3BUcmFja2luZzpmdW5jdGlvbigpe2EuX3ZhbHVlVHJhY2tlcj1udWxsO2RlbGV0ZSBhW2JdfX19XG5mdW5jdGlvbiBBYyhhKXthLl92YWx1ZVRyYWNrZXJ8fChhLl92YWx1ZVRyYWNrZXI9emMoYSkpfWZ1bmN0aW9uIEJjKGEpe2lmKCFhKXJldHVybiExO3ZhciBiPWEuX3ZhbHVlVHJhY2tlcjtpZighYilyZXR1cm4hMDt2YXIgYz1iLmdldFZhbHVlKCk7dmFyIGQ9XCJcIjthJiYoZD15YyhhKT9hLmNoZWNrZWQ/XCJ0cnVlXCI6XCJmYWxzZVwiOmEudmFsdWUpO2E9ZDtyZXR1cm4gYSE9PWM/KGIuc2V0VmFsdWUoYSksITApOiExfXZhciBDYz17Y2hhbmdlOntwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpcIm9uQ2hhbmdlXCIsY2FwdHVyZWQ6XCJvbkNoYW5nZUNhcHR1cmVcIn0sZGVwZW5kZW5jaWVzOlwidG9wQmx1ciB0b3BDaGFuZ2UgdG9wQ2xpY2sgdG9wRm9jdXMgdG9wSW5wdXQgdG9wS2V5RG93biB0b3BLZXlVcCB0b3BTZWxlY3Rpb25DaGFuZ2VcIi5zcGxpdChcIiBcIil9fTtcbmZ1bmN0aW9uIERjKGEsYixjKXthPVMuZ2V0UG9vbGVkKENjLmNoYW5nZSxhLGIsYyk7YS50eXBlPVwiY2hhbmdlXCI7bmMoYyk7emIoYSk7cmV0dXJuIGF9dmFyIEVjPW51bGwsRmM9bnVsbDtmdW5jdGlvbiBHYyhhKXtrYihhKTtsYighMSl9ZnVuY3Rpb24gSGMoYSl7dmFyIGI9cWIoYSk7aWYoQmMoYikpcmV0dXJuIGF9ZnVuY3Rpb24gSWMoYSxiKXtpZihcInRvcENoYW5nZVwiPT09YSlyZXR1cm4gYn12YXIgSmM9ITE7bS5jYW5Vc2VET00mJihKYz14YyhcImlucHV0XCIpJiYoIWRvY3VtZW50LmRvY3VtZW50TW9kZXx8OTxkb2N1bWVudC5kb2N1bWVudE1vZGUpKTtmdW5jdGlvbiBRYygpe0VjJiYoRWMuZGV0YWNoRXZlbnQoXCJvbnByb3BlcnR5Y2hhbmdlXCIsUmMpLEZjPUVjPW51bGwpfWZ1bmN0aW9uIFJjKGEpe1widmFsdWVcIj09PWEucHJvcGVydHlOYW1lJiZIYyhGYykmJihhPURjKEZjLGEsdmMoYSkpLHNjKEdjLGEpKX1cbmZ1bmN0aW9uIFNjKGEsYixjKXtcInRvcEZvY3VzXCI9PT1hPyhRYygpLEVjPWIsRmM9YyxFYy5hdHRhY2hFdmVudChcIm9ucHJvcGVydHljaGFuZ2VcIixSYykpOlwidG9wQmx1clwiPT09YSYmUWMoKX1mdW5jdGlvbiBUYyhhKXtpZihcInRvcFNlbGVjdGlvbkNoYW5nZVwiPT09YXx8XCJ0b3BLZXlVcFwiPT09YXx8XCJ0b3BLZXlEb3duXCI9PT1hKXJldHVybiBIYyhGYyl9ZnVuY3Rpb24gVWMoYSxiKXtpZihcInRvcENsaWNrXCI9PT1hKXJldHVybiBIYyhiKX1mdW5jdGlvbiBWYyhhLGIpe2lmKFwidG9wSW5wdXRcIj09PWF8fFwidG9wQ2hhbmdlXCI9PT1hKXJldHVybiBIYyhiKX1cbnZhciBXYz17ZXZlbnRUeXBlczpDYyxfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOkpjLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9Yj9xYihiKTp3aW5kb3csZj1lLm5vZGVOYW1lJiZlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7aWYoXCJzZWxlY3RcIj09PWZ8fFwiaW5wdXRcIj09PWYmJlwiZmlsZVwiPT09ZS50eXBlKXZhciBnPUljO2Vsc2UgaWYodWMoZSkpaWYoSmMpZz1WYztlbHNle2c9VGM7dmFyIGs9U2N9ZWxzZSBmPWUubm9kZU5hbWUsIWZ8fFwiaW5wdXRcIiE9PWYudG9Mb3dlckNhc2UoKXx8XCJjaGVja2JveFwiIT09ZS50eXBlJiZcInJhZGlvXCIhPT1lLnR5cGV8fChnPVVjKTtpZihnJiYoZz1nKGEsYikpKXJldHVybiBEYyhnLGMsZCk7ayYmayhhLGUsYik7XCJ0b3BCbHVyXCI9PT1hJiZudWxsIT1iJiYoYT1iLl93cmFwcGVyU3RhdGV8fGUuX3dyYXBwZXJTdGF0ZSkmJmEuY29udHJvbGxlZCYmXCJudW1iZXJcIj09PWUudHlwZSYmKGE9XCJcIitlLnZhbHVlLGUuZ2V0QXR0cmlidXRlKFwidmFsdWVcIikhPT1cbmEmJmUuc2V0QXR0cmlidXRlKFwidmFsdWVcIixhKSl9fTtmdW5jdGlvbiBYYyhhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9Uy5hdWdtZW50Q2xhc3MoWGMse3ZpZXc6bnVsbCxkZXRhaWw6bnVsbH0pO3ZhciBZYz17QWx0OlwiYWx0S2V5XCIsQ29udHJvbDpcImN0cmxLZXlcIixNZXRhOlwibWV0YUtleVwiLFNoaWZ0Olwic2hpZnRLZXlcIn07ZnVuY3Rpb24gWmMoYSl7dmFyIGI9dGhpcy5uYXRpdmVFdmVudDtyZXR1cm4gYi5nZXRNb2RpZmllclN0YXRlP2IuZ2V0TW9kaWZpZXJTdGF0ZShhKTooYT1ZY1thXSk/ISFiW2FdOiExfWZ1bmN0aW9uICRjKCl7cmV0dXJuIFpjfWZ1bmN0aW9uIGFkKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1cblhjLmF1Z21lbnRDbGFzcyhhZCx7c2NyZWVuWDpudWxsLHNjcmVlblk6bnVsbCxjbGllbnRYOm51bGwsY2xpZW50WTpudWxsLHBhZ2VYOm51bGwscGFnZVk6bnVsbCxjdHJsS2V5Om51bGwsc2hpZnRLZXk6bnVsbCxhbHRLZXk6bnVsbCxtZXRhS2V5Om51bGwsZ2V0TW9kaWZpZXJTdGF0ZTokYyxidXR0b246bnVsbCxidXR0b25zOm51bGwscmVsYXRlZFRhcmdldDpmdW5jdGlvbihhKXtyZXR1cm4gYS5yZWxhdGVkVGFyZ2V0fHwoYS5mcm9tRWxlbWVudD09PWEuc3JjRWxlbWVudD9hLnRvRWxlbWVudDphLmZyb21FbGVtZW50KX19KTtcbnZhciBiZD17bW91c2VFbnRlcjp7cmVnaXN0cmF0aW9uTmFtZTpcIm9uTW91c2VFbnRlclwiLGRlcGVuZGVuY2llczpbXCJ0b3BNb3VzZU91dFwiLFwidG9wTW91c2VPdmVyXCJdfSxtb3VzZUxlYXZlOntyZWdpc3RyYXRpb25OYW1lOlwib25Nb3VzZUxlYXZlXCIsZGVwZW5kZW5jaWVzOltcInRvcE1vdXNlT3V0XCIsXCJ0b3BNb3VzZU92ZXJcIl19fSxjZD17ZXZlbnRUeXBlczpiZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe2lmKFwidG9wTW91c2VPdmVyXCI9PT1hJiYoYy5yZWxhdGVkVGFyZ2V0fHxjLmZyb21FbGVtZW50KXx8XCJ0b3BNb3VzZU91dFwiIT09YSYmXCJ0b3BNb3VzZU92ZXJcIiE9PWEpcmV0dXJuIG51bGw7dmFyIGU9ZC53aW5kb3c9PT1kP2Q6KGU9ZC5vd25lckRvY3VtZW50KT9lLmRlZmF1bHRWaWV3fHxlLnBhcmVudFdpbmRvdzp3aW5kb3c7XCJ0b3BNb3VzZU91dFwiPT09YT8oYT1iLGI9KGI9Yy5yZWxhdGVkVGFyZ2V0fHxjLnRvRWxlbWVudCk/cGIoYik6bnVsbCk6YT1udWxsO2lmKGE9PT1cbmIpcmV0dXJuIG51bGw7dmFyIGY9bnVsbD09YT9lOnFiKGEpO2U9bnVsbD09Yj9lOnFiKGIpO3ZhciBnPWFkLmdldFBvb2xlZChiZC5tb3VzZUxlYXZlLGEsYyxkKTtnLnR5cGU9XCJtb3VzZWxlYXZlXCI7Zy50YXJnZXQ9ZjtnLnJlbGF0ZWRUYXJnZXQ9ZTtjPWFkLmdldFBvb2xlZChiZC5tb3VzZUVudGVyLGIsYyxkKTtjLnR5cGU9XCJtb3VzZWVudGVyXCI7Yy50YXJnZXQ9ZTtjLnJlbGF0ZWRUYXJnZXQ9ZjtBYihnLGMsYSxiKTtyZXR1cm5bZyxjXX19LGRkPWFhLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVELlJlYWN0Q3VycmVudE93bmVyO2Z1bmN0aW9uIGVkKGEpe2E9YS50eXBlO3JldHVyblwic3RyaW5nXCI9PT10eXBlb2YgYT9hOlwiZnVuY3Rpb25cIj09PXR5cGVvZiBhP2EuZGlzcGxheU5hbWV8fGEubmFtZTpudWxsfVxuZnVuY3Rpb24gZmQoYSl7dmFyIGI9YTtpZihhLmFsdGVybmF0ZSlmb3IoO2JbXCJyZXR1cm5cIl07KWI9YltcInJldHVyblwiXTtlbHNle2lmKDAhPT0oYi5lZmZlY3RUYWcmMikpcmV0dXJuIDE7Zm9yKDtiW1wicmV0dXJuXCJdOylpZihiPWJbXCJyZXR1cm5cIl0sMCE9PShiLmVmZmVjdFRhZyYyKSlyZXR1cm4gMX1yZXR1cm4gMz09PWIudGFnPzI6M31mdW5jdGlvbiBnZChhKXtyZXR1cm4oYT1hLl9yZWFjdEludGVybmFsRmliZXIpPzI9PT1mZChhKTohMX1mdW5jdGlvbiBoZChhKXsyIT09ZmQoYSk/RChcIjE4OFwiKTp2b2lkIDB9XG5mdW5jdGlvbiBpZChhKXt2YXIgYj1hLmFsdGVybmF0ZTtpZighYilyZXR1cm4gYj1mZChhKSwzPT09Yj9EKFwiMTg4XCIpOnZvaWQgMCwxPT09Yj9udWxsOmE7Zm9yKHZhciBjPWEsZD1iOzspe3ZhciBlPWNbXCJyZXR1cm5cIl0sZj1lP2UuYWx0ZXJuYXRlOm51bGw7aWYoIWV8fCFmKWJyZWFrO2lmKGUuY2hpbGQ9PT1mLmNoaWxkKXtmb3IodmFyIGc9ZS5jaGlsZDtnOyl7aWYoZz09PWMpcmV0dXJuIGhkKGUpLGE7aWYoZz09PWQpcmV0dXJuIGhkKGUpLGI7Zz1nLnNpYmxpbmd9RChcIjE4OFwiKX1pZihjW1wicmV0dXJuXCJdIT09ZFtcInJldHVyblwiXSljPWUsZD1mO2Vsc2V7Zz0hMTtmb3IodmFyIGs9ZS5jaGlsZDtrOyl7aWYoaz09PWMpe2c9ITA7Yz1lO2Q9ZjticmVha31pZihrPT09ZCl7Zz0hMDtkPWU7Yz1mO2JyZWFrfWs9ay5zaWJsaW5nfWlmKCFnKXtmb3Ioaz1mLmNoaWxkO2s7KXtpZihrPT09Yyl7Zz0hMDtjPWY7ZD1lO2JyZWFrfWlmKGs9PT1kKXtnPSEwO2Q9ZjtjPWU7YnJlYWt9az1rLnNpYmxpbmd9Zz9cbnZvaWQgMDpEKFwiMTg5XCIpfX1jLmFsdGVybmF0ZSE9PWQ/RChcIjE5MFwiKTp2b2lkIDB9MyE9PWMudGFnP0QoXCIxODhcIik6dm9pZCAwO3JldHVybiBjLnN0YXRlTm9kZS5jdXJyZW50PT09Yz9hOmJ9ZnVuY3Rpb24gamQoYSl7YT1pZChhKTtpZighYSlyZXR1cm4gbnVsbDtmb3IodmFyIGI9YTs7KXtpZig1PT09Yi50YWd8fDY9PT1iLnRhZylyZXR1cm4gYjtpZihiLmNoaWxkKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH1cbmZ1bmN0aW9uIGtkKGEpe2E9aWQoYSk7aWYoIWEpcmV0dXJuIG51bGw7Zm9yKHZhciBiPWE7Oyl7aWYoNT09PWIudGFnfHw2PT09Yi50YWcpcmV0dXJuIGI7aWYoYi5jaGlsZCYmNCE9PWIudGFnKWIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGQ7ZWxzZXtpZihiPT09YSlicmVhaztmb3IoOyFiLnNpYmxpbmc7KXtpZighYltcInJldHVyblwiXXx8YltcInJldHVyblwiXT09PWEpcmV0dXJuIG51bGw7Yj1iW1wicmV0dXJuXCJdfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX1yZXR1cm4gbnVsbH12YXIgbGQ9W107XG5mdW5jdGlvbiBtZChhKXt2YXIgYj1hLnRhcmdldEluc3Q7ZG97aWYoIWIpe2EuYW5jZXN0b3JzLnB1c2goYik7YnJlYWt9dmFyIGM7Zm9yKGM9YjtjW1wicmV0dXJuXCJdOyljPWNbXCJyZXR1cm5cIl07Yz0zIT09Yy50YWc/bnVsbDpjLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO2lmKCFjKWJyZWFrO2EuYW5jZXN0b3JzLnB1c2goYik7Yj1wYihjKX13aGlsZShiKTtmb3IoYz0wO2M8YS5hbmNlc3RvcnMubGVuZ3RoO2MrKyliPWEuYW5jZXN0b3JzW2NdLG5kKGEudG9wTGV2ZWxUeXBlLGIsYS5uYXRpdmVFdmVudCx2YyhhLm5hdGl2ZUV2ZW50KSl9dmFyIG9kPSEwLG5kPXZvaWQgMDtmdW5jdGlvbiBwZChhKXtvZD0hIWF9ZnVuY3Rpb24gVShhLGIsYyl7cmV0dXJuIGM/Y2EubGlzdGVuKGMsYixxZC5iaW5kKG51bGwsYSkpOm51bGx9ZnVuY3Rpb24gcmQoYSxiLGMpe3JldHVybiBjP2NhLmNhcHR1cmUoYyxiLHFkLmJpbmQobnVsbCxhKSk6bnVsbH1cbmZ1bmN0aW9uIHFkKGEsYil7aWYob2Qpe3ZhciBjPXZjKGIpO2M9cGIoYyk7bnVsbD09PWN8fFwibnVtYmVyXCIhPT10eXBlb2YgYy50YWd8fDI9PT1mZChjKXx8KGM9bnVsbCk7aWYobGQubGVuZ3RoKXt2YXIgZD1sZC5wb3AoKTtkLnRvcExldmVsVHlwZT1hO2QubmF0aXZlRXZlbnQ9YjtkLnRhcmdldEluc3Q9YzthPWR9ZWxzZSBhPXt0b3BMZXZlbFR5cGU6YSxuYXRpdmVFdmVudDpiLHRhcmdldEluc3Q6YyxhbmNlc3RvcnM6W119O3RyeXtzYyhtZCxhKX1maW5hbGx5e2EudG9wTGV2ZWxUeXBlPW51bGwsYS5uYXRpdmVFdmVudD1udWxsLGEudGFyZ2V0SW5zdD1udWxsLGEuYW5jZXN0b3JzLmxlbmd0aD0wLDEwPmxkLmxlbmd0aCYmbGQucHVzaChhKX19fVxudmFyIHNkPU9iamVjdC5mcmVlemUoe2dldCBfZW5hYmxlZCgpe3JldHVybiBvZH0sZ2V0IF9oYW5kbGVUb3BMZXZlbCgpe3JldHVybiBuZH0sc2V0SGFuZGxlVG9wTGV2ZWw6ZnVuY3Rpb24oYSl7bmQ9YX0sc2V0RW5hYmxlZDpwZCxpc0VuYWJsZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gb2R9LHRyYXBCdWJibGVkRXZlbnQ6VSx0cmFwQ2FwdHVyZWRFdmVudDpyZCxkaXNwYXRjaEV2ZW50OnFkfSk7ZnVuY3Rpb24gdGQoYSxiKXt2YXIgYz17fTtjW2EudG9Mb3dlckNhc2UoKV09Yi50b0xvd2VyQ2FzZSgpO2NbXCJXZWJraXRcIithXT1cIndlYmtpdFwiK2I7Y1tcIk1velwiK2FdPVwibW96XCIrYjtjW1wibXNcIithXT1cIk1TXCIrYjtjW1wiT1wiK2FdPVwib1wiK2IudG9Mb3dlckNhc2UoKTtyZXR1cm4gY31cbnZhciB1ZD17YW5pbWF0aW9uZW5kOnRkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25FbmRcIiksYW5pbWF0aW9uaXRlcmF0aW9uOnRkKFwiQW5pbWF0aW9uXCIsXCJBbmltYXRpb25JdGVyYXRpb25cIiksYW5pbWF0aW9uc3RhcnQ6dGQoXCJBbmltYXRpb25cIixcIkFuaW1hdGlvblN0YXJ0XCIpLHRyYW5zaXRpb25lbmQ6dGQoXCJUcmFuc2l0aW9uXCIsXCJUcmFuc2l0aW9uRW5kXCIpfSx2ZD17fSx3ZD17fTttLmNhblVzZURPTSYmKHdkPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikuc3R5bGUsXCJBbmltYXRpb25FdmVudFwiaW4gd2luZG93fHwoZGVsZXRlIHVkLmFuaW1hdGlvbmVuZC5hbmltYXRpb24sZGVsZXRlIHVkLmFuaW1hdGlvbml0ZXJhdGlvbi5hbmltYXRpb24sZGVsZXRlIHVkLmFuaW1hdGlvbnN0YXJ0LmFuaW1hdGlvbiksXCJUcmFuc2l0aW9uRXZlbnRcImluIHdpbmRvd3x8ZGVsZXRlIHVkLnRyYW5zaXRpb25lbmQudHJhbnNpdGlvbik7XG5mdW5jdGlvbiB4ZChhKXtpZih2ZFthXSlyZXR1cm4gdmRbYV07aWYoIXVkW2FdKXJldHVybiBhO3ZhciBiPXVkW2FdLGM7Zm9yKGMgaW4gYilpZihiLmhhc093blByb3BlcnR5KGMpJiZjIGluIHdkKXJldHVybiB2ZFthXT1iW2NdO3JldHVyblwiXCJ9XG52YXIgeWQ9e3RvcEFib3J0OlwiYWJvcnRcIix0b3BBbmltYXRpb25FbmQ6eGQoXCJhbmltYXRpb25lbmRcIil8fFwiYW5pbWF0aW9uZW5kXCIsdG9wQW5pbWF0aW9uSXRlcmF0aW9uOnhkKFwiYW5pbWF0aW9uaXRlcmF0aW9uXCIpfHxcImFuaW1hdGlvbml0ZXJhdGlvblwiLHRvcEFuaW1hdGlvblN0YXJ0OnhkKFwiYW5pbWF0aW9uc3RhcnRcIil8fFwiYW5pbWF0aW9uc3RhcnRcIix0b3BCbHVyOlwiYmx1clwiLHRvcENhbmNlbDpcImNhbmNlbFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcENoYW5nZTpcImNoYW5nZVwiLHRvcENsaWNrOlwiY2xpY2tcIix0b3BDbG9zZTpcImNsb3NlXCIsdG9wQ29tcG9zaXRpb25FbmQ6XCJjb21wb3NpdGlvbmVuZFwiLHRvcENvbXBvc2l0aW9uU3RhcnQ6XCJjb21wb3NpdGlvbnN0YXJ0XCIsdG9wQ29tcG9zaXRpb25VcGRhdGU6XCJjb21wb3NpdGlvbnVwZGF0ZVwiLHRvcENvbnRleHRNZW51OlwiY29udGV4dG1lbnVcIix0b3BDb3B5OlwiY29weVwiLFxudG9wQ3V0OlwiY3V0XCIsdG9wRG91YmxlQ2xpY2s6XCJkYmxjbGlja1wiLHRvcERyYWc6XCJkcmFnXCIsdG9wRHJhZ0VuZDpcImRyYWdlbmRcIix0b3BEcmFnRW50ZXI6XCJkcmFnZW50ZXJcIix0b3BEcmFnRXhpdDpcImRyYWdleGl0XCIsdG9wRHJhZ0xlYXZlOlwiZHJhZ2xlYXZlXCIsdG9wRHJhZ092ZXI6XCJkcmFnb3ZlclwiLHRvcERyYWdTdGFydDpcImRyYWdzdGFydFwiLHRvcERyb3A6XCJkcm9wXCIsdG9wRHVyYXRpb25DaGFuZ2U6XCJkdXJhdGlvbmNoYW5nZVwiLHRvcEVtcHRpZWQ6XCJlbXB0aWVkXCIsdG9wRW5jcnlwdGVkOlwiZW5jcnlwdGVkXCIsdG9wRW5kZWQ6XCJlbmRlZFwiLHRvcEVycm9yOlwiZXJyb3JcIix0b3BGb2N1czpcImZvY3VzXCIsdG9wSW5wdXQ6XCJpbnB1dFwiLHRvcEtleURvd246XCJrZXlkb3duXCIsdG9wS2V5UHJlc3M6XCJrZXlwcmVzc1wiLHRvcEtleVVwOlwia2V5dXBcIix0b3BMb2FkZWREYXRhOlwibG9hZGVkZGF0YVwiLHRvcExvYWQ6XCJsb2FkXCIsdG9wTG9hZGVkTWV0YWRhdGE6XCJsb2FkZWRtZXRhZGF0YVwiLHRvcExvYWRTdGFydDpcImxvYWRzdGFydFwiLFxudG9wTW91c2VEb3duOlwibW91c2Vkb3duXCIsdG9wTW91c2VNb3ZlOlwibW91c2Vtb3ZlXCIsdG9wTW91c2VPdXQ6XCJtb3VzZW91dFwiLHRvcE1vdXNlT3ZlcjpcIm1vdXNlb3ZlclwiLHRvcE1vdXNlVXA6XCJtb3VzZXVwXCIsdG9wUGFzdGU6XCJwYXN0ZVwiLHRvcFBhdXNlOlwicGF1c2VcIix0b3BQbGF5OlwicGxheVwiLHRvcFBsYXlpbmc6XCJwbGF5aW5nXCIsdG9wUHJvZ3Jlc3M6XCJwcm9ncmVzc1wiLHRvcFJhdGVDaGFuZ2U6XCJyYXRlY2hhbmdlXCIsdG9wU2Nyb2xsOlwic2Nyb2xsXCIsdG9wU2Vla2VkOlwic2Vla2VkXCIsdG9wU2Vla2luZzpcInNlZWtpbmdcIix0b3BTZWxlY3Rpb25DaGFuZ2U6XCJzZWxlY3Rpb25jaGFuZ2VcIix0b3BTdGFsbGVkOlwic3RhbGxlZFwiLHRvcFN1c3BlbmQ6XCJzdXNwZW5kXCIsdG9wVGV4dElucHV0OlwidGV4dElucHV0XCIsdG9wVGltZVVwZGF0ZTpcInRpbWV1cGRhdGVcIix0b3BUb2dnbGU6XCJ0b2dnbGVcIix0b3BUb3VjaENhbmNlbDpcInRvdWNoY2FuY2VsXCIsdG9wVG91Y2hFbmQ6XCJ0b3VjaGVuZFwiLHRvcFRvdWNoTW92ZTpcInRvdWNobW92ZVwiLFxudG9wVG91Y2hTdGFydDpcInRvdWNoc3RhcnRcIix0b3BUcmFuc2l0aW9uRW5kOnhkKFwidHJhbnNpdGlvbmVuZFwiKXx8XCJ0cmFuc2l0aW9uZW5kXCIsdG9wVm9sdW1lQ2hhbmdlOlwidm9sdW1lY2hhbmdlXCIsdG9wV2FpdGluZzpcIndhaXRpbmdcIix0b3BXaGVlbDpcIndoZWVsXCJ9LHpkPXt9LEFkPTAsQmQ9XCJfcmVhY3RMaXN0ZW5lcnNJRFwiKyhcIlwiK01hdGgucmFuZG9tKCkpLnNsaWNlKDIpO2Z1bmN0aW9uIENkKGEpe09iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLEJkKXx8KGFbQmRdPUFkKyssemRbYVtCZF1dPXt9KTtyZXR1cm4gemRbYVtCZF1dfWZ1bmN0aW9uIERkKGEpe2Zvcig7YSYmYS5maXJzdENoaWxkOylhPWEuZmlyc3RDaGlsZDtyZXR1cm4gYX1cbmZ1bmN0aW9uIEVkKGEsYil7dmFyIGM9RGQoYSk7YT0wO2Zvcih2YXIgZDtjOyl7aWYoMz09PWMubm9kZVR5cGUpe2Q9YStjLnRleHRDb250ZW50Lmxlbmd0aDtpZihhPD1iJiZkPj1iKXJldHVybntub2RlOmMsb2Zmc2V0OmItYX07YT1kfWE6e2Zvcig7Yzspe2lmKGMubmV4dFNpYmxpbmcpe2M9Yy5uZXh0U2libGluZzticmVhayBhfWM9Yy5wYXJlbnROb2RlfWM9dm9pZCAwfWM9RGQoYyl9fWZ1bmN0aW9uIEZkKGEpe3ZhciBiPWEmJmEubm9kZU5hbWUmJmEubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gYiYmKFwiaW5wdXRcIj09PWImJlwidGV4dFwiPT09YS50eXBlfHxcInRleHRhcmVhXCI9PT1ifHxcInRydWVcIj09PWEuY29udGVudEVkaXRhYmxlKX1cbnZhciBHZD1tLmNhblVzZURPTSYmXCJkb2N1bWVudE1vZGVcImluIGRvY3VtZW50JiYxMT49ZG9jdW1lbnQuZG9jdW1lbnRNb2RlLEhkPXtzZWxlY3Q6e3BoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOntidWJibGVkOlwib25TZWxlY3RcIixjYXB0dXJlZDpcIm9uU2VsZWN0Q2FwdHVyZVwifSxkZXBlbmRlbmNpZXM6XCJ0b3BCbHVyIHRvcENvbnRleHRNZW51IHRvcEZvY3VzIHRvcEtleURvd24gdG9wS2V5VXAgdG9wTW91c2VEb3duIHRvcE1vdXNlVXAgdG9wU2VsZWN0aW9uQ2hhbmdlXCIuc3BsaXQoXCIgXCIpfX0sSWQ9bnVsbCxKZD1udWxsLEtkPW51bGwsTGQ9ITE7XG5mdW5jdGlvbiBNZChhLGIpe2lmKExkfHxudWxsPT1JZHx8SWQhPT1kYSgpKXJldHVybiBudWxsO3ZhciBjPUlkO1wic2VsZWN0aW9uU3RhcnRcImluIGMmJkZkKGMpP2M9e3N0YXJ0OmMuc2VsZWN0aW9uU3RhcnQsZW5kOmMuc2VsZWN0aW9uRW5kfTp3aW5kb3cuZ2V0U2VsZWN0aW9uPyhjPXdpbmRvdy5nZXRTZWxlY3Rpb24oKSxjPXthbmNob3JOb2RlOmMuYW5jaG9yTm9kZSxhbmNob3JPZmZzZXQ6Yy5hbmNob3JPZmZzZXQsZm9jdXNOb2RlOmMuZm9jdXNOb2RlLGZvY3VzT2Zmc2V0OmMuZm9jdXNPZmZzZXR9KTpjPXZvaWQgMDtyZXR1cm4gS2QmJmVhKEtkLGMpP251bGw6KEtkPWMsYT1TLmdldFBvb2xlZChIZC5zZWxlY3QsSmQsYSxiKSxhLnR5cGU9XCJzZWxlY3RcIixhLnRhcmdldD1JZCx6YihhKSxhKX1cbnZhciBOZD17ZXZlbnRUeXBlczpIZCxleHRyYWN0RXZlbnRzOmZ1bmN0aW9uKGEsYixjLGQpe3ZhciBlPWQud2luZG93PT09ZD9kLmRvY3VtZW50Ojk9PT1kLm5vZGVUeXBlP2Q6ZC5vd25lckRvY3VtZW50LGY7aWYoIShmPSFlKSl7YTp7ZT1DZChlKTtmPVFhLm9uU2VsZWN0O2Zvcih2YXIgZz0wO2c8Zi5sZW5ndGg7ZysrKXt2YXIgaz1mW2ddO2lmKCFlLmhhc093blByb3BlcnR5KGspfHwhZVtrXSl7ZT0hMTticmVhayBhfX1lPSEwfWY9IWV9aWYoZilyZXR1cm4gbnVsbDtlPWI/cWIoYik6d2luZG93O3N3aXRjaChhKXtjYXNlIFwidG9wRm9jdXNcIjppZih1YyhlKXx8XCJ0cnVlXCI9PT1lLmNvbnRlbnRFZGl0YWJsZSlJZD1lLEpkPWIsS2Q9bnVsbDticmVhaztjYXNlIFwidG9wQmx1clwiOktkPUpkPUlkPW51bGw7YnJlYWs7Y2FzZSBcInRvcE1vdXNlRG93blwiOkxkPSEwO2JyZWFrO2Nhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6cmV0dXJuIExkPSExLE1kKGMsZCk7Y2FzZSBcInRvcFNlbGVjdGlvbkNoYW5nZVwiOmlmKEdkKWJyZWFrO1xuY2FzZSBcInRvcEtleURvd25cIjpjYXNlIFwidG9wS2V5VXBcIjpyZXR1cm4gTWQoYyxkKX1yZXR1cm4gbnVsbH19O2Z1bmN0aW9uIE9kKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1TLmF1Z21lbnRDbGFzcyhPZCx7YW5pbWF0aW9uTmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7ZnVuY3Rpb24gUGQoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVMuYXVnbWVudENsYXNzKFBkLHtjbGlwYm9hcmREYXRhOmZ1bmN0aW9uKGEpe3JldHVyblwiY2xpcGJvYXJkRGF0YVwiaW4gYT9hLmNsaXBib2FyZERhdGE6d2luZG93LmNsaXBib2FyZERhdGF9fSk7ZnVuY3Rpb24gUWQoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfVhjLmF1Z21lbnRDbGFzcyhRZCx7cmVsYXRlZFRhcmdldDpudWxsfSk7XG5mdW5jdGlvbiBSZChhKXt2YXIgYj1hLmtleUNvZGU7XCJjaGFyQ29kZVwiaW4gYT8oYT1hLmNoYXJDb2RlLDA9PT1hJiYxMz09PWImJihhPTEzKSk6YT1iO3JldHVybiAzMjw9YXx8MTM9PT1hP2E6MH1cbnZhciBTZD17RXNjOlwiRXNjYXBlXCIsU3BhY2ViYXI6XCIgXCIsTGVmdDpcIkFycm93TGVmdFwiLFVwOlwiQXJyb3dVcFwiLFJpZ2h0OlwiQXJyb3dSaWdodFwiLERvd246XCJBcnJvd0Rvd25cIixEZWw6XCJEZWxldGVcIixXaW46XCJPU1wiLE1lbnU6XCJDb250ZXh0TWVudVwiLEFwcHM6XCJDb250ZXh0TWVudVwiLFNjcm9sbDpcIlNjcm9sbExvY2tcIixNb3pQcmludGFibGVLZXk6XCJVbmlkZW50aWZpZWRcIn0sVGQ9ezg6XCJCYWNrc3BhY2VcIiw5OlwiVGFiXCIsMTI6XCJDbGVhclwiLDEzOlwiRW50ZXJcIiwxNjpcIlNoaWZ0XCIsMTc6XCJDb250cm9sXCIsMTg6XCJBbHRcIiwxOTpcIlBhdXNlXCIsMjA6XCJDYXBzTG9ja1wiLDI3OlwiRXNjYXBlXCIsMzI6XCIgXCIsMzM6XCJQYWdlVXBcIiwzNDpcIlBhZ2VEb3duXCIsMzU6XCJFbmRcIiwzNjpcIkhvbWVcIiwzNzpcIkFycm93TGVmdFwiLDM4OlwiQXJyb3dVcFwiLDM5OlwiQXJyb3dSaWdodFwiLDQwOlwiQXJyb3dEb3duXCIsNDU6XCJJbnNlcnRcIiw0NjpcIkRlbGV0ZVwiLDExMjpcIkYxXCIsMTEzOlwiRjJcIiwxMTQ6XCJGM1wiLDExNTpcIkY0XCIsXG4xMTY6XCJGNVwiLDExNzpcIkY2XCIsMTE4OlwiRjdcIiwxMTk6XCJGOFwiLDEyMDpcIkY5XCIsMTIxOlwiRjEwXCIsMTIyOlwiRjExXCIsMTIzOlwiRjEyXCIsMTQ0OlwiTnVtTG9ja1wiLDE0NTpcIlNjcm9sbExvY2tcIiwyMjQ6XCJNZXRhXCJ9O2Z1bmN0aW9uIFVkKGEsYixjLGQpe3JldHVybiBTLmNhbGwodGhpcyxhLGIsYyxkKX1cblhjLmF1Z21lbnRDbGFzcyhVZCx7a2V5OmZ1bmN0aW9uKGEpe2lmKGEua2V5KXt2YXIgYj1TZFthLmtleV18fGEua2V5O2lmKFwiVW5pZGVudGlmaWVkXCIhPT1iKXJldHVybiBifXJldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT8oYT1SZChhKSwxMz09PWE/XCJFbnRlclwiOlN0cmluZy5mcm9tQ2hhckNvZGUoYSkpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/VGRbYS5rZXlDb2RlXXx8XCJVbmlkZW50aWZpZWRcIjpcIlwifSxsb2NhdGlvbjpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGFsdEtleTpudWxsLG1ldGFLZXk6bnVsbCxyZXBlYXQ6bnVsbCxsb2NhbGU6bnVsbCxnZXRNb2RpZmllclN0YXRlOiRjLGNoYXJDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PWEudHlwZT9SZChhKTowfSxrZXlDb2RlOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9LHdoaWNoOmZ1bmN0aW9uKGEpe3JldHVyblwia2V5cHJlc3NcIj09PVxuYS50eXBlP1JkKGEpOlwia2V5ZG93blwiPT09YS50eXBlfHxcImtleXVwXCI9PT1hLnR5cGU/YS5rZXlDb2RlOjB9fSk7ZnVuY3Rpb24gVmQoYSxiLGMsZCl7cmV0dXJuIFMuY2FsbCh0aGlzLGEsYixjLGQpfWFkLmF1Z21lbnRDbGFzcyhWZCx7ZGF0YVRyYW5zZmVyOm51bGx9KTtmdW5jdGlvbiBXZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9WGMuYXVnbWVudENsYXNzKFdkLHt0b3VjaGVzOm51bGwsdGFyZ2V0VG91Y2hlczpudWxsLGNoYW5nZWRUb3VjaGVzOm51bGwsYWx0S2V5Om51bGwsbWV0YUtleTpudWxsLGN0cmxLZXk6bnVsbCxzaGlmdEtleTpudWxsLGdldE1vZGlmaWVyU3RhdGU6JGN9KTtmdW5jdGlvbiBYZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9Uy5hdWdtZW50Q2xhc3MoWGQse3Byb3BlcnR5TmFtZTpudWxsLGVsYXBzZWRUaW1lOm51bGwscHNldWRvRWxlbWVudDpudWxsfSk7XG5mdW5jdGlvbiBZZChhLGIsYyxkKXtyZXR1cm4gUy5jYWxsKHRoaXMsYSxiLGMsZCl9YWQuYXVnbWVudENsYXNzKFlkLHtkZWx0YVg6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVhcImluIGE/YS5kZWx0YVg6XCJ3aGVlbERlbHRhWFwiaW4gYT8tYS53aGVlbERlbHRhWDowfSxkZWx0YVk6ZnVuY3Rpb24oYSl7cmV0dXJuXCJkZWx0YVlcImluIGE/YS5kZWx0YVk6XCJ3aGVlbERlbHRhWVwiaW4gYT8tYS53aGVlbERlbHRhWTpcIndoZWVsRGVsdGFcImluIGE/LWEud2hlZWxEZWx0YTowfSxkZWx0YVo6bnVsbCxkZWx0YU1vZGU6bnVsbH0pO3ZhciBaZD17fSwkZD17fTtcblwiYWJvcnQgYW5pbWF0aW9uRW5kIGFuaW1hdGlvbkl0ZXJhdGlvbiBhbmltYXRpb25TdGFydCBibHVyIGNhbmNlbCBjYW5QbGF5IGNhblBsYXlUaHJvdWdoIGNsaWNrIGNsb3NlIGNvbnRleHRNZW51IGNvcHkgY3V0IGRvdWJsZUNsaWNrIGRyYWcgZHJhZ0VuZCBkcmFnRW50ZXIgZHJhZ0V4aXQgZHJhZ0xlYXZlIGRyYWdPdmVyIGRyYWdTdGFydCBkcm9wIGR1cmF0aW9uQ2hhbmdlIGVtcHRpZWQgZW5jcnlwdGVkIGVuZGVkIGVycm9yIGZvY3VzIGlucHV0IGludmFsaWQga2V5RG93biBrZXlQcmVzcyBrZXlVcCBsb2FkIGxvYWRlZERhdGEgbG9hZGVkTWV0YWRhdGEgbG9hZFN0YXJ0IG1vdXNlRG93biBtb3VzZU1vdmUgbW91c2VPdXQgbW91c2VPdmVyIG1vdXNlVXAgcGFzdGUgcGF1c2UgcGxheSBwbGF5aW5nIHByb2dyZXNzIHJhdGVDaGFuZ2UgcmVzZXQgc2Nyb2xsIHNlZWtlZCBzZWVraW5nIHN0YWxsZWQgc3VibWl0IHN1c3BlbmQgdGltZVVwZGF0ZSB0b2dnbGUgdG91Y2hDYW5jZWwgdG91Y2hFbmQgdG91Y2hNb3ZlIHRvdWNoU3RhcnQgdHJhbnNpdGlvbkVuZCB2b2x1bWVDaGFuZ2Ugd2FpdGluZyB3aGVlbFwiLnNwbGl0KFwiIFwiKS5mb3JFYWNoKGZ1bmN0aW9uKGEpe3ZhciBiPWFbMF0udG9VcHBlckNhc2UoKStcbmEuc2xpY2UoMSksYz1cIm9uXCIrYjtiPVwidG9wXCIrYjtjPXtwaGFzZWRSZWdpc3RyYXRpb25OYW1lczp7YnViYmxlZDpjLGNhcHR1cmVkOmMrXCJDYXB0dXJlXCJ9LGRlcGVuZGVuY2llczpbYl19O1pkW2FdPWM7JGRbYl09Y30pO1xudmFyIGFlPXtldmVudFR5cGVzOlpkLGV4dHJhY3RFdmVudHM6ZnVuY3Rpb24oYSxiLGMsZCl7dmFyIGU9JGRbYV07aWYoIWUpcmV0dXJuIG51bGw7c3dpdGNoKGEpe2Nhc2UgXCJ0b3BLZXlQcmVzc1wiOmlmKDA9PT1SZChjKSlyZXR1cm4gbnVsbDtjYXNlIFwidG9wS2V5RG93blwiOmNhc2UgXCJ0b3BLZXlVcFwiOmE9VWQ7YnJlYWs7Y2FzZSBcInRvcEJsdXJcIjpjYXNlIFwidG9wRm9jdXNcIjphPVFkO2JyZWFrO2Nhc2UgXCJ0b3BDbGlja1wiOmlmKDI9PT1jLmJ1dHRvbilyZXR1cm4gbnVsbDtjYXNlIFwidG9wRG91YmxlQ2xpY2tcIjpjYXNlIFwidG9wTW91c2VEb3duXCI6Y2FzZSBcInRvcE1vdXNlTW92ZVwiOmNhc2UgXCJ0b3BNb3VzZVVwXCI6Y2FzZSBcInRvcE1vdXNlT3V0XCI6Y2FzZSBcInRvcE1vdXNlT3ZlclwiOmNhc2UgXCJ0b3BDb250ZXh0TWVudVwiOmE9YWQ7YnJlYWs7Y2FzZSBcInRvcERyYWdcIjpjYXNlIFwidG9wRHJhZ0VuZFwiOmNhc2UgXCJ0b3BEcmFnRW50ZXJcIjpjYXNlIFwidG9wRHJhZ0V4aXRcIjpjYXNlIFwidG9wRHJhZ0xlYXZlXCI6Y2FzZSBcInRvcERyYWdPdmVyXCI6Y2FzZSBcInRvcERyYWdTdGFydFwiOmNhc2UgXCJ0b3BEcm9wXCI6YT1cblZkO2JyZWFrO2Nhc2UgXCJ0b3BUb3VjaENhbmNlbFwiOmNhc2UgXCJ0b3BUb3VjaEVuZFwiOmNhc2UgXCJ0b3BUb3VjaE1vdmVcIjpjYXNlIFwidG9wVG91Y2hTdGFydFwiOmE9V2Q7YnJlYWs7Y2FzZSBcInRvcEFuaW1hdGlvbkVuZFwiOmNhc2UgXCJ0b3BBbmltYXRpb25JdGVyYXRpb25cIjpjYXNlIFwidG9wQW5pbWF0aW9uU3RhcnRcIjphPU9kO2JyZWFrO2Nhc2UgXCJ0b3BUcmFuc2l0aW9uRW5kXCI6YT1YZDticmVhaztjYXNlIFwidG9wU2Nyb2xsXCI6YT1YYzticmVhaztjYXNlIFwidG9wV2hlZWxcIjphPVlkO2JyZWFrO2Nhc2UgXCJ0b3BDb3B5XCI6Y2FzZSBcInRvcEN1dFwiOmNhc2UgXCJ0b3BQYXN0ZVwiOmE9UGQ7YnJlYWs7ZGVmYXVsdDphPVN9Yj1hLmdldFBvb2xlZChlLGIsYyxkKTt6YihiKTtyZXR1cm4gYn19O25kPWZ1bmN0aW9uKGEsYixjLGQpe2E9amIoYSxiLGMsZCk7a2IoYSk7bGIoITEpfTtkYi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKFwiUmVzcG9uZGVyRXZlbnRQbHVnaW4gU2ltcGxlRXZlbnRQbHVnaW4gVGFwRXZlbnRQbHVnaW4gRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIENoYW5nZUV2ZW50UGx1Z2luIFNlbGVjdEV2ZW50UGx1Z2luIEJlZm9yZUlucHV0RXZlbnRQbHVnaW5cIi5zcGxpdChcIiBcIikpO1xuVWE9c2IuZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZTtWYT1zYi5nZXRJbnN0YW5jZUZyb21Ob2RlO1dhPXNiLmdldE5vZGVGcm9tSW5zdGFuY2U7ZGIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtTaW1wbGVFdmVudFBsdWdpbjphZSxFbnRlckxlYXZlRXZlbnRQbHVnaW46Y2QsQ2hhbmdlRXZlbnRQbHVnaW46V2MsU2VsZWN0RXZlbnRQbHVnaW46TmQsQmVmb3JlSW5wdXRFdmVudFBsdWdpbjpoY30pO3ZhciBiZT1bXSxjZT0tMTtmdW5jdGlvbiBWKGEpezA+Y2V8fChhLmN1cnJlbnQ9YmVbY2VdLGJlW2NlXT1udWxsLGNlLS0pfWZ1bmN0aW9uIFcoYSxiKXtjZSsrO2JlW2NlXT1hLmN1cnJlbnQ7YS5jdXJyZW50PWJ9bmV3IFNldDt2YXIgZGU9e2N1cnJlbnQ6Q30sWD17Y3VycmVudDohMX0sZWU9QztmdW5jdGlvbiBmZShhKXtyZXR1cm4gZ2UoYSk/ZWU6ZGUuY3VycmVudH1cbmZ1bmN0aW9uIGhlKGEsYil7dmFyIGM9YS50eXBlLmNvbnRleHRUeXBlcztpZighYylyZXR1cm4gQzt2YXIgZD1hLnN0YXRlTm9kZTtpZihkJiZkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkVW5tYXNrZWRDaGlsZENvbnRleHQ9PT1iKXJldHVybiBkLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWFza2VkQ2hpbGRDb250ZXh0O3ZhciBlPXt9LGY7Zm9yKGYgaW4gYyllW2ZdPWJbZl07ZCYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWIsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1lKTtyZXR1cm4gZX1mdW5jdGlvbiBnZShhKXtyZXR1cm4gMj09PWEudGFnJiZudWxsIT1hLnR5cGUuY2hpbGRDb250ZXh0VHlwZXN9ZnVuY3Rpb24gaWUoYSl7Z2UoYSkmJihWKFgsYSksVihkZSxhKSl9XG5mdW5jdGlvbiBqZShhLGIsYyl7bnVsbCE9ZGUuY3Vyc29yP0QoXCIxNjhcIik6dm9pZCAwO1coZGUsYixhKTtXKFgsYyxhKX1mdW5jdGlvbiBrZShhLGIpe3ZhciBjPWEuc3RhdGVOb2RlLGQ9YS50eXBlLmNoaWxkQ29udGV4dFR5cGVzO2lmKFwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLmdldENoaWxkQ29udGV4dClyZXR1cm4gYjtjPWMuZ2V0Q2hpbGRDb250ZXh0KCk7Zm9yKHZhciBlIGluIGMpZSBpbiBkP3ZvaWQgMDpEKFwiMTA4XCIsZWQoYSl8fFwiVW5rbm93blwiLGUpO3JldHVybiBBKHt9LGIsYyl9ZnVuY3Rpb24gbGUoYSl7aWYoIWdlKGEpKXJldHVybiExO3ZhciBiPWEuc3RhdGVOb2RlO2I9YiYmYi5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dHx8QztlZT1kZS5jdXJyZW50O1coZGUsYixhKTtXKFgsWC5jdXJyZW50LGEpO3JldHVybiEwfVxuZnVuY3Rpb24gbWUoYSxiKXt2YXIgYz1hLnN0YXRlTm9kZTtjP3ZvaWQgMDpEKFwiMTY5XCIpO2lmKGIpe3ZhciBkPWtlKGEsZWUpO2MuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQ9ZDtWKFgsYSk7VihkZSxhKTtXKGRlLGQsYSl9ZWxzZSBWKFgsYSk7VyhYLGIsYSl9XG5mdW5jdGlvbiBZKGEsYixjKXt0aGlzLnRhZz1hO3RoaXMua2V5PWI7dGhpcy5zdGF0ZU5vZGU9dGhpcy50eXBlPW51bGw7dGhpcy5zaWJsaW5nPXRoaXMuY2hpbGQ9dGhpc1tcInJldHVyblwiXT1udWxsO3RoaXMuaW5kZXg9MDt0aGlzLm1lbW9pemVkU3RhdGU9dGhpcy51cGRhdGVRdWV1ZT10aGlzLm1lbW9pemVkUHJvcHM9dGhpcy5wZW5kaW5nUHJvcHM9dGhpcy5yZWY9bnVsbDt0aGlzLmludGVybmFsQ29udGV4dFRhZz1jO3RoaXMuZWZmZWN0VGFnPTA7dGhpcy5sYXN0RWZmZWN0PXRoaXMuZmlyc3RFZmZlY3Q9dGhpcy5uZXh0RWZmZWN0PW51bGw7dGhpcy5leHBpcmF0aW9uVGltZT0wO3RoaXMuYWx0ZXJuYXRlPW51bGx9XG5mdW5jdGlvbiBuZShhLGIsYyl7dmFyIGQ9YS5hbHRlcm5hdGU7bnVsbD09PWQ/KGQ9bmV3IFkoYS50YWcsYS5rZXksYS5pbnRlcm5hbENvbnRleHRUYWcpLGQudHlwZT1hLnR5cGUsZC5zdGF0ZU5vZGU9YS5zdGF0ZU5vZGUsZC5hbHRlcm5hdGU9YSxhLmFsdGVybmF0ZT1kKTooZC5lZmZlY3RUYWc9MCxkLm5leHRFZmZlY3Q9bnVsbCxkLmZpcnN0RWZmZWN0PW51bGwsZC5sYXN0RWZmZWN0PW51bGwpO2QuZXhwaXJhdGlvblRpbWU9YztkLnBlbmRpbmdQcm9wcz1iO2QuY2hpbGQ9YS5jaGlsZDtkLm1lbW9pemVkUHJvcHM9YS5tZW1vaXplZFByb3BzO2QubWVtb2l6ZWRTdGF0ZT1hLm1lbW9pemVkU3RhdGU7ZC51cGRhdGVRdWV1ZT1hLnVwZGF0ZVF1ZXVlO2Quc2libGluZz1hLnNpYmxpbmc7ZC5pbmRleD1hLmluZGV4O2QucmVmPWEucmVmO3JldHVybiBkfVxuZnVuY3Rpb24gb2UoYSxiLGMpe3ZhciBkPXZvaWQgMCxlPWEudHlwZSxmPWEua2V5O1wiZnVuY3Rpb25cIj09PXR5cGVvZiBlPyhkPWUucHJvdG90eXBlJiZlLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50P25ldyBZKDIsZixiKTpuZXcgWSgwLGYsYiksZC50eXBlPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6XCJzdHJpbmdcIj09PXR5cGVvZiBlPyhkPW5ldyBZKDUsZixiKSxkLnR5cGU9ZSxkLnBlbmRpbmdQcm9wcz1hLnByb3BzKTpcIm9iamVjdFwiPT09dHlwZW9mIGUmJm51bGwhPT1lJiZcIm51bWJlclwiPT09dHlwZW9mIGUudGFnPyhkPWUsZC5wZW5kaW5nUHJvcHM9YS5wcm9wcyk6RChcIjEzMFwiLG51bGw9PWU/ZTp0eXBlb2YgZSxcIlwiKTtkLmV4cGlyYXRpb25UaW1lPWM7cmV0dXJuIGR9ZnVuY3Rpb24gcGUoYSxiLGMsZCl7Yj1uZXcgWSgxMCxkLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifVxuZnVuY3Rpb24gcWUoYSxiLGMpe2I9bmV3IFkoNixudWxsLGIpO2IucGVuZGluZ1Byb3BzPWE7Yi5leHBpcmF0aW9uVGltZT1jO3JldHVybiBifWZ1bmN0aW9uIHJlKGEsYixjKXtiPW5ldyBZKDcsYS5rZXksYik7Yi50eXBlPWEuaGFuZGxlcjtiLnBlbmRpbmdQcm9wcz1hO2IuZXhwaXJhdGlvblRpbWU9YztyZXR1cm4gYn1mdW5jdGlvbiBzZShhLGIsYyl7YT1uZXcgWSg5LG51bGwsYik7YS5leHBpcmF0aW9uVGltZT1jO3JldHVybiBhfWZ1bmN0aW9uIHRlKGEsYixjKXtiPW5ldyBZKDQsYS5rZXksYik7Yi5wZW5kaW5nUHJvcHM9YS5jaGlsZHJlbnx8W107Yi5leHBpcmF0aW9uVGltZT1jO2Iuc3RhdGVOb2RlPXtjb250YWluZXJJbmZvOmEuY29udGFpbmVySW5mbyxwZW5kaW5nQ2hpbGRyZW46bnVsbCxpbXBsZW1lbnRhdGlvbjphLmltcGxlbWVudGF0aW9ufTtyZXR1cm4gYn12YXIgdWU9bnVsbCx2ZT1udWxsO1xuZnVuY3Rpb24gd2UoYSl7cmV0dXJuIGZ1bmN0aW9uKGIpe3RyeXtyZXR1cm4gYShiKX1jYXRjaChjKXt9fX1mdW5jdGlvbiB4ZShhKXtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXylyZXR1cm4hMTt2YXIgYj1fX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187aWYoYi5pc0Rpc2FibGVkfHwhYi5zdXBwb3J0c0ZpYmVyKXJldHVybiEwO3RyeXt2YXIgYz1iLmluamVjdChhKTt1ZT13ZShmdW5jdGlvbihhKXtyZXR1cm4gYi5vbkNvbW1pdEZpYmVyUm9vdChjLGEpfSk7dmU9d2UoZnVuY3Rpb24oYSl7cmV0dXJuIGIub25Db21taXRGaWJlclVubW91bnQoYyxhKX0pfWNhdGNoKGQpe31yZXR1cm4hMH1mdW5jdGlvbiB5ZShhKXtcImZ1bmN0aW9uXCI9PT10eXBlb2YgdWUmJnVlKGEpfWZ1bmN0aW9uIHplKGEpe1wiZnVuY3Rpb25cIj09PXR5cGVvZiB2ZSYmdmUoYSl9XG5mdW5jdGlvbiBBZShhKXtyZXR1cm57YmFzZVN0YXRlOmEsZXhwaXJhdGlvblRpbWU6MCxmaXJzdDpudWxsLGxhc3Q6bnVsbCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMSxpc0luaXRpYWxpemVkOiExfX1mdW5jdGlvbiBCZShhLGIpe251bGw9PT1hLmxhc3Q/YS5maXJzdD1hLmxhc3Q9YjooYS5sYXN0Lm5leHQ9YixhLmxhc3Q9Yik7aWYoMD09PWEuZXhwaXJhdGlvblRpbWV8fGEuZXhwaXJhdGlvblRpbWU+Yi5leHBpcmF0aW9uVGltZSlhLmV4cGlyYXRpb25UaW1lPWIuZXhwaXJhdGlvblRpbWV9XG5mdW5jdGlvbiBDZShhLGIpe3ZhciBjPWEuYWx0ZXJuYXRlLGQ9YS51cGRhdGVRdWV1ZTtudWxsPT09ZCYmKGQ9YS51cGRhdGVRdWV1ZT1BZShudWxsKSk7bnVsbCE9PWM/KGE9Yy51cGRhdGVRdWV1ZSxudWxsPT09YSYmKGE9Yy51cGRhdGVRdWV1ZT1BZShudWxsKSkpOmE9bnVsbDthPWEhPT1kP2E6bnVsbDtudWxsPT09YT9CZShkLGIpOm51bGw9PT1kLmxhc3R8fG51bGw9PT1hLmxhc3Q/KEJlKGQsYiksQmUoYSxiKSk6KEJlKGQsYiksYS5sYXN0PWIpfWZ1bmN0aW9uIERlKGEsYixjLGQpe2E9YS5wYXJ0aWFsU3RhdGU7cmV0dXJuXCJmdW5jdGlvblwiPT09dHlwZW9mIGE/YS5jYWxsKGIsYyxkKTphfVxuZnVuY3Rpb24gS2UoYSxiLGMsZCxlLGYpe251bGwhPT1hJiZhLnVwZGF0ZVF1ZXVlPT09YyYmKGM9Yi51cGRhdGVRdWV1ZT17YmFzZVN0YXRlOmMuYmFzZVN0YXRlLGV4cGlyYXRpb25UaW1lOmMuZXhwaXJhdGlvblRpbWUsZmlyc3Q6Yy5maXJzdCxsYXN0OmMubGFzdCxpc0luaXRpYWxpemVkOmMuaXNJbml0aWFsaXplZCxjYWxsYmFja0xpc3Q6bnVsbCxoYXNGb3JjZVVwZGF0ZTohMX0pO2MuZXhwaXJhdGlvblRpbWU9MDtjLmlzSW5pdGlhbGl6ZWQ/YT1jLmJhc2VTdGF0ZTooYT1jLmJhc2VTdGF0ZT1iLm1lbW9pemVkU3RhdGUsYy5pc0luaXRpYWxpemVkPSEwKTtmb3IodmFyIGc9ITAsaz1jLmZpcnN0LGg9ITE7bnVsbCE9PWs7KXt2YXIgcj1rLmV4cGlyYXRpb25UaW1lO2lmKHI+Zil7dmFyIG49Yy5leHBpcmF0aW9uVGltZTtpZigwPT09bnx8bj5yKWMuZXhwaXJhdGlvblRpbWU9cjtofHwoaD0hMCxjLmJhc2VTdGF0ZT1hKX1lbHNle2h8fChjLmZpcnN0PWsubmV4dCxudWxsPT09XG5jLmZpcnN0JiYoYy5sYXN0PW51bGwpKTtpZihrLmlzUmVwbGFjZSlhPURlKGssZCxhLGUpLGc9ITA7ZWxzZSBpZihyPURlKGssZCxhLGUpKWE9Zz9BKHt9LGEscik6QShhLHIpLGc9ITE7ay5pc0ZvcmNlZCYmKGMuaGFzRm9yY2VVcGRhdGU9ITApO251bGwhPT1rLmNhbGxiYWNrJiYocj1jLmNhbGxiYWNrTGlzdCxudWxsPT09ciYmKHI9Yy5jYWxsYmFja0xpc3Q9W10pLHIucHVzaChrKSl9az1rLm5leHR9bnVsbCE9PWMuY2FsbGJhY2tMaXN0P2IuZWZmZWN0VGFnfD0zMjpudWxsIT09Yy5maXJzdHx8Yy5oYXNGb3JjZVVwZGF0ZXx8KGIudXBkYXRlUXVldWU9bnVsbCk7aHx8KGMuYmFzZVN0YXRlPWEpO3JldHVybiBhfVxuZnVuY3Rpb24gTGUoYSxiKXt2YXIgYz1hLmNhbGxiYWNrTGlzdDtpZihudWxsIT09Yylmb3IoYS5jYWxsYmFja0xpc3Q9bnVsbCxhPTA7YTxjLmxlbmd0aDthKyspe3ZhciBkPWNbYV0sZT1kLmNhbGxiYWNrO2QuY2FsbGJhY2s9bnVsbDtcImZ1bmN0aW9uXCIhPT10eXBlb2YgZT9EKFwiMTkxXCIsZSk6dm9pZCAwO2UuY2FsbChiKX19XG5mdW5jdGlvbiBNZShhLGIsYyxkKXtmdW5jdGlvbiBlKGEsYil7Yi51cGRhdGVyPWY7YS5zdGF0ZU5vZGU9YjtiLl9yZWFjdEludGVybmFsRmliZXI9YX12YXIgZj17aXNNb3VudGVkOmdkLGVucXVldWVTZXRTdGF0ZTpmdW5jdGlvbihjLGQsZSl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZT12b2lkIDA9PT1lP251bGw6ZTt2YXIgZz1iKGMpO0NlKGMse2V4cGlyYXRpb25UaW1lOmcscGFydGlhbFN0YXRlOmQsY2FsbGJhY2s6ZSxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITEsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGcpfSxlbnF1ZXVlUmVwbGFjZVN0YXRlOmZ1bmN0aW9uKGMsZCxlKXtjPWMuX3JlYWN0SW50ZXJuYWxGaWJlcjtlPXZvaWQgMD09PWU/bnVsbDplO3ZhciBmPWIoYyk7Q2UoYyx7ZXhwaXJhdGlvblRpbWU6ZixwYXJ0aWFsU3RhdGU6ZCxjYWxsYmFjazplLGlzUmVwbGFjZTohMCxpc0ZvcmNlZDohMSxuZXh0Q2FsbGJhY2s6bnVsbCxuZXh0Om51bGx9KTtcbmEoYyxmKX0sZW5xdWV1ZUZvcmNlVXBkYXRlOmZ1bmN0aW9uKGMsZCl7Yz1jLl9yZWFjdEludGVybmFsRmliZXI7ZD12b2lkIDA9PT1kP251bGw6ZDt2YXIgZT1iKGMpO0NlKGMse2V4cGlyYXRpb25UaW1lOmUscGFydGlhbFN0YXRlOm51bGwsY2FsbGJhY2s6ZCxpc1JlcGxhY2U6ITEsaXNGb3JjZWQ6ITAsbmV4dENhbGxiYWNrOm51bGwsbmV4dDpudWxsfSk7YShjLGUpfX07cmV0dXJue2Fkb3B0Q2xhc3NJbnN0YW5jZTplLGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6ZnVuY3Rpb24oYSxiKXt2YXIgYz1hLnR5cGUsZD1mZShhKSxmPTI9PT1hLnRhZyYmbnVsbCE9YS50eXBlLmNvbnRleHRUeXBlcyxnPWY/aGUoYSxkKTpDO2I9bmV3IGMoYixnKTtlKGEsYik7ZiYmKGE9YS5zdGF0ZU5vZGUsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0PWQsYS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dD1nKTtyZXR1cm4gYn0sbW91bnRDbGFzc0luc3RhbmNlOmZ1bmN0aW9uKGEsXG5iKXt2YXIgYz1hLmFsdGVybmF0ZSxkPWEuc3RhdGVOb2RlLGU9ZC5zdGF0ZXx8bnVsbCxnPWEucGVuZGluZ1Byb3BzO2c/dm9pZCAwOkQoXCIxNThcIik7dmFyIGs9ZmUoYSk7ZC5wcm9wcz1nO2Quc3RhdGU9YS5tZW1vaXplZFN0YXRlPWU7ZC5yZWZzPUM7ZC5jb250ZXh0PWhlKGEsayk7bnVsbCE9YS50eXBlJiZudWxsIT1hLnR5cGUucHJvdG90eXBlJiYhMD09PWEudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50JiYoYS5pbnRlcm5hbENvbnRleHRUYWd8PTEpO1wiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxNb3VudCYmKGU9ZC5zdGF0ZSxkLmNvbXBvbmVudFdpbGxNb3VudCgpLGUhPT1kLnN0YXRlJiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZCxkLnN0YXRlLG51bGwpLGU9YS51cGRhdGVRdWV1ZSxudWxsIT09ZSYmKGQuc3RhdGU9S2UoYyxhLGUsZCxnLGIpKSk7XCJmdW5jdGlvblwiPT09dHlwZW9mIGQuY29tcG9uZW50RGlkTW91bnQmJihhLmVmZmVjdFRhZ3w9XG40KX0sdXBkYXRlQ2xhc3NJbnN0YW5jZTpmdW5jdGlvbihhLGIsZSl7dmFyIGc9Yi5zdGF0ZU5vZGU7Zy5wcm9wcz1iLm1lbW9pemVkUHJvcHM7Zy5zdGF0ZT1iLm1lbW9pemVkU3RhdGU7dmFyIGs9Yi5tZW1vaXplZFByb3BzLGg9Yi5wZW5kaW5nUHJvcHM7aHx8KGg9ayxudWxsPT1oP0QoXCIxNTlcIik6dm9pZCAwKTt2YXIgdT1nLmNvbnRleHQseD1mZShiKTt4PWhlKGIseCk7XCJmdW5jdGlvblwiIT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc3x8az09PWgmJnU9PT14fHwodT1nLnN0YXRlLGcuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhoLHgpLGcuc3RhdGUhPT11JiZmLmVucXVldWVSZXBsYWNlU3RhdGUoZyxnLnN0YXRlLG51bGwpKTt1PWIubWVtb2l6ZWRTdGF0ZTtlPW51bGwhPT1iLnVwZGF0ZVF1ZXVlP0tlKGEsYixiLnVwZGF0ZVF1ZXVlLGcsaCxlKTp1O2lmKCEoayE9PWh8fHUhPT1lfHxYLmN1cnJlbnR8fG51bGwhPT1iLnVwZGF0ZVF1ZXVlJiZiLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSlyZXR1cm5cImZ1bmN0aW9uXCIhPT1cbnR5cGVvZiBnLmNvbXBvbmVudERpZFVwZGF0ZXx8az09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSwhMTt2YXIgRj1oO2lmKG51bGw9PT1rfHxudWxsIT09Yi51cGRhdGVRdWV1ZSYmYi51cGRhdGVRdWV1ZS5oYXNGb3JjZVVwZGF0ZSlGPSEwO2Vsc2V7dmFyIEw9Yi5zdGF0ZU5vZGUsRz1iLnR5cGU7Rj1cImZ1bmN0aW9uXCI9PT10eXBlb2YgTC5zaG91bGRDb21wb25lbnRVcGRhdGU/TC5zaG91bGRDb21wb25lbnRVcGRhdGUoRixlLHgpOkcucHJvdG90eXBlJiZHLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudD8hZWEoayxGKXx8IWVhKHUsZSk6ITB9Rj8oXCJmdW5jdGlvblwiPT09dHlwZW9mIGcuY29tcG9uZW50V2lsbFVwZGF0ZSYmZy5jb21wb25lbnRXaWxsVXBkYXRlKGgsZSx4KSxcImZ1bmN0aW9uXCI9PT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGUmJihiLmVmZmVjdFRhZ3w9NCkpOihcImZ1bmN0aW9uXCIhPT10eXBlb2YgZy5jb21wb25lbnREaWRVcGRhdGV8fFxuaz09PWEubWVtb2l6ZWRQcm9wcyYmdT09PWEubWVtb2l6ZWRTdGF0ZXx8KGIuZWZmZWN0VGFnfD00KSxjKGIsaCksZChiLGUpKTtnLnByb3BzPWg7Zy5zdGF0ZT1lO2cuY29udGV4dD14O3JldHVybiBGfX19dmFyIE5lPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXSYmU3ltYm9sW1wiZm9yXCJdKFwicmVhY3QucG9ydGFsXCIpfHw2MDEwNjtmdW5jdGlvbiBPZShhLGIsYyl7dmFyIGQ9Mzxhcmd1bWVudHMubGVuZ3RoJiZ2b2lkIDAhPT1hcmd1bWVudHNbM10/YXJndW1lbnRzWzNdOm51bGw7cmV0dXJueyQkdHlwZW9mOk5lLGtleTpudWxsPT1kP251bGw6XCJcIitkLGNoaWxkcmVuOmEsY29udGFpbmVySW5mbzpiLGltcGxlbWVudGF0aW9uOmN9fXZhciBQZT1BcnJheS5pc0FycmF5LFFlPVwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbC5pdGVyYXRvcixSZSxTZSxUZSxVZTtcblwiZnVuY3Rpb25cIj09PXR5cGVvZiBTeW1ib2wmJlN5bWJvbFtcImZvclwiXT8oUmU9U3ltYm9sW1wiZm9yXCJdKFwicmVhY3QuZWxlbWVudFwiKSxTZT1TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5jYWxsXCIpLFRlPVN5bWJvbFtcImZvclwiXShcInJlYWN0LnJldHVyblwiKSxVZT1TeW1ib2xbXCJmb3JcIl0oXCJyZWFjdC5mcmFnbWVudFwiKSk6KFJlPTYwMTAzLFNlPTYwMTA0LFRlPTYwMTA1LFVlPTYwMTA3KTtmdW5jdGlvbiBWZShhKXtpZihudWxsPT09YXx8XCJ1bmRlZmluZWRcIj09PXR5cGVvZiBhKXJldHVybiBudWxsO2E9UWUmJmFbUWVdfHxhW1wiQEBpdGVyYXRvclwiXTtyZXR1cm5cImZ1bmN0aW9uXCI9PT10eXBlb2YgYT9hOm51bGx9XG5mdW5jdGlvbiBXZShhLGIpe3ZhciBjPWIucmVmO2lmKG51bGwhPT1jJiZcImZ1bmN0aW9uXCIhPT10eXBlb2YgYyl7aWYoYi5fb3duZXIpe2I9Yi5fb3duZXI7dmFyIGQ9dm9pZCAwO2ImJigyIT09Yi50YWc/RChcIjExMFwiKTp2b2lkIDAsZD1iLnN0YXRlTm9kZSk7ZD92b2lkIDA6RChcIjE0N1wiLGMpO3ZhciBlPVwiXCIrYztpZihudWxsIT09YSYmbnVsbCE9PWEucmVmJiZhLnJlZi5fc3RyaW5nUmVmPT09ZSlyZXR1cm4gYS5yZWY7YT1mdW5jdGlvbihhKXt2YXIgYj1kLnJlZnM9PT1DP2QucmVmcz17fTpkLnJlZnM7bnVsbD09PWE/ZGVsZXRlIGJbZV06YltlXT1hfTthLl9zdHJpbmdSZWY9ZTtyZXR1cm4gYX1cInN0cmluZ1wiIT09dHlwZW9mIGM/RChcIjE0OFwiKTp2b2lkIDA7Yi5fb3duZXI/dm9pZCAwOkQoXCIxNDlcIixjKX1yZXR1cm4gY31cbmZ1bmN0aW9uIFhlKGEsYil7XCJ0ZXh0YXJlYVwiIT09YS50eXBlJiZEKFwiMzFcIixcIltvYmplY3QgT2JqZWN0XVwiPT09T2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGIpP1wib2JqZWN0IHdpdGgga2V5cyB7XCIrT2JqZWN0LmtleXMoYikuam9pbihcIiwgXCIpK1wifVwiOmIsXCJcIil9XG5mdW5jdGlvbiBZZShhLGIpe2Z1bmN0aW9uIGMoYyxkKXtpZihiKXtpZighYSl7aWYobnVsbD09PWQuYWx0ZXJuYXRlKXJldHVybjtkPWQuYWx0ZXJuYXRlfXZhciBwPWMubGFzdEVmZmVjdDtudWxsIT09cD8ocC5uZXh0RWZmZWN0PWQsYy5sYXN0RWZmZWN0PWQpOmMuZmlyc3RFZmZlY3Q9Yy5sYXN0RWZmZWN0PWQ7ZC5uZXh0RWZmZWN0PW51bGw7ZC5lZmZlY3RUYWc9OH19ZnVuY3Rpb24gZChhLGQpe2lmKCFiKXJldHVybiBudWxsO2Zvcig7bnVsbCE9PWQ7KWMoYSxkKSxkPWQuc2libGluZztyZXR1cm4gbnVsbH1mdW5jdGlvbiBlKGEsYil7Zm9yKGE9bmV3IE1hcDtudWxsIT09YjspbnVsbCE9PWIua2V5P2Euc2V0KGIua2V5LGIpOmEuc2V0KGIuaW5kZXgsYiksYj1iLnNpYmxpbmc7cmV0dXJuIGF9ZnVuY3Rpb24gZihiLGMsZCl7aWYoYSlyZXR1cm4gYj1uZShiLGMsZCksYi5pbmRleD0wLGIuc2libGluZz1udWxsLGI7Yi5leHBpcmF0aW9uVGltZT1kO2IuZWZmZWN0VGFnPTA7Yi5pbmRleD1cbjA7Yi5zaWJsaW5nPW51bGw7Yi5wZW5kaW5nUHJvcHM9YztyZXR1cm4gYn1mdW5jdGlvbiBnKGEsYyxkKXthLmluZGV4PWQ7aWYoIWIpcmV0dXJuIGM7ZD1hLmFsdGVybmF0ZTtpZihudWxsIT09ZClyZXR1cm4gZD1kLmluZGV4LGQ8Yz8oYS5lZmZlY3RUYWc9MixjKTpkO2EuZWZmZWN0VGFnPTI7cmV0dXJuIGN9ZnVuY3Rpb24gayhhKXtiJiZudWxsPT09YS5hbHRlcm5hdGUmJihhLmVmZmVjdFRhZz0yKTtyZXR1cm4gYX1mdW5jdGlvbiBoKGEsYixjLGQpe2lmKG51bGw9PT1ifHw2IT09Yi50YWcpcmV0dXJuIGI9cWUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWYoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiByKGEsYixjLGQpe2lmKG51bGwhPT1iJiZiLnR5cGU9PT1jLnR5cGUpcmV0dXJuIGQ9ZihiLGMucHJvcHMsZCksZC5yZWY9V2UoYixjKSxkW1wicmV0dXJuXCJdPWEsZDtkPW9lKGMsYS5pbnRlcm5hbENvbnRleHRUYWcsZCk7XG5kLnJlZj1XZShiLGMpO2RbXCJyZXR1cm5cIl09YTtyZXR1cm4gZH1mdW5jdGlvbiBuKGEsYixjLGQpe2lmKG51bGw9PT1ifHw3IT09Yi50YWcpcmV0dXJuIGI9cmUoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiW1wicmV0dXJuXCJdPWEsYjtiPWYoYixjLGQpO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB5KGEsYixjLGQpe2lmKG51bGw9PT1ifHw5IT09Yi50YWcpcmV0dXJuIGI9c2UoYyxhLmludGVybmFsQ29udGV4dFRhZyxkKSxiLnR5cGU9Yy52YWx1ZSxiW1wicmV0dXJuXCJdPWEsYjtiPWYoYixudWxsLGQpO2IudHlwZT1jLnZhbHVlO2JbXCJyZXR1cm5cIl09YTtyZXR1cm4gYn1mdW5jdGlvbiB1KGEsYixjLGQpe2lmKG51bGw9PT1ifHw0IT09Yi50YWd8fGIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8hPT1jLmNvbnRhaW5lckluZm98fGIuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uIT09Yy5pbXBsZW1lbnRhdGlvbilyZXR1cm4gYj10ZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLFxuZCksYltcInJldHVyblwiXT1hLGI7Yj1mKGIsYy5jaGlsZHJlbnx8W10sZCk7YltcInJldHVyblwiXT1hO3JldHVybiBifWZ1bmN0aW9uIHgoYSxiLGMsZCxlKXtpZihudWxsPT09Ynx8MTAhPT1iLnRhZylyZXR1cm4gYj1wZShjLGEuaW50ZXJuYWxDb250ZXh0VGFnLGQsZSksYltcInJldHVyblwiXT1hLGI7Yj1mKGIsYyxkKTtiW1wicmV0dXJuXCJdPWE7cmV0dXJuIGJ9ZnVuY3Rpb24gRihhLGIsYyl7aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBifHxcIm51bWJlclwiPT09dHlwZW9mIGIpcmV0dXJuIGI9cWUoXCJcIitiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2lmKFwib2JqZWN0XCI9PT10eXBlb2YgYiYmbnVsbCE9PWIpe3N3aXRjaChiLiQkdHlwZW9mKXtjYXNlIFJlOmlmKGIudHlwZT09PVVlKXJldHVybiBiPXBlKGIucHJvcHMuY2hpbGRyZW4sYS5pbnRlcm5hbENvbnRleHRUYWcsYyxiLmtleSksYltcInJldHVyblwiXT1hLGI7Yz1vZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpO1xuYy5yZWY9V2UobnVsbCxiKTtjW1wicmV0dXJuXCJdPWE7cmV0dXJuIGM7Y2FzZSBTZTpyZXR1cm4gYj1yZShiLGEuaW50ZXJuYWxDb250ZXh0VGFnLGMpLGJbXCJyZXR1cm5cIl09YSxiO2Nhc2UgVGU6cmV0dXJuIGM9c2UoYixhLmludGVybmFsQ29udGV4dFRhZyxjKSxjLnR5cGU9Yi52YWx1ZSxjW1wicmV0dXJuXCJdPWEsYztjYXNlIE5lOnJldHVybiBiPXRlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyksYltcInJldHVyblwiXT1hLGJ9aWYoUGUoYil8fFZlKGIpKXJldHVybiBiPXBlKGIsYS5pbnRlcm5hbENvbnRleHRUYWcsYyxudWxsKSxiW1wicmV0dXJuXCJdPWEsYjtYZShhLGIpfXJldHVybiBudWxsfWZ1bmN0aW9uIEwoYSxiLGMsZCl7dmFyIGU9bnVsbCE9PWI/Yi5rZXk6bnVsbDtpZihcInN0cmluZ1wiPT09dHlwZW9mIGN8fFwibnVtYmVyXCI9PT10eXBlb2YgYylyZXR1cm4gbnVsbCE9PWU/bnVsbDpoKGEsYixcIlwiK2MsZCk7aWYoXCJvYmplY3RcIj09PXR5cGVvZiBjJiZudWxsIT09Yyl7c3dpdGNoKGMuJCR0eXBlb2Ype2Nhc2UgUmU6cmV0dXJuIGMua2V5PT09XG5lP2MudHlwZT09PVVlP3goYSxiLGMucHJvcHMuY2hpbGRyZW4sZCxlKTpyKGEsYixjLGQpOm51bGw7Y2FzZSBTZTpyZXR1cm4gYy5rZXk9PT1lP24oYSxiLGMsZCk6bnVsbDtjYXNlIFRlOnJldHVybiBudWxsPT09ZT95KGEsYixjLGQpOm51bGw7Y2FzZSBOZTpyZXR1cm4gYy5rZXk9PT1lP3UoYSxiLGMsZCk6bnVsbH1pZihQZShjKXx8VmUoYykpcmV0dXJuIG51bGwhPT1lP251bGw6eChhLGIsYyxkLG51bGwpO1hlKGEsYyl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gRyhhLGIsYyxkLGUpe2lmKFwic3RyaW5nXCI9PT10eXBlb2YgZHx8XCJudW1iZXJcIj09PXR5cGVvZiBkKXJldHVybiBhPWEuZ2V0KGMpfHxudWxsLGgoYixhLFwiXCIrZCxlKTtpZihcIm9iamVjdFwiPT09dHlwZW9mIGQmJm51bGwhPT1kKXtzd2l0Y2goZC4kJHR5cGVvZil7Y2FzZSBSZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsZC50eXBlPT09VWU/eChiLGEsZC5wcm9wcy5jaGlsZHJlbixlLGQua2V5KTpcbnIoYixhLGQsZSk7Y2FzZSBTZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsbihiLGEsZCxlKTtjYXNlIFRlOnJldHVybiBhPWEuZ2V0KGMpfHxudWxsLHkoYixhLGQsZSk7Y2FzZSBOZTpyZXR1cm4gYT1hLmdldChudWxsPT09ZC5rZXk/YzpkLmtleSl8fG51bGwsdShiLGEsZCxlKX1pZihQZShkKXx8VmUoZCkpcmV0dXJuIGE9YS5nZXQoYyl8fG51bGwseChiLGEsZCxlLG51bGwpO1hlKGIsZCl9cmV0dXJuIG51bGx9ZnVuY3Rpb24gVChhLGYsdixrKXtmb3IodmFyIHA9bnVsbCx6PW51bGwsbD1mLGg9Zj0wLHQ9bnVsbDtudWxsIT09bCYmaDx2Lmxlbmd0aDtoKyspe2wuaW5kZXg+aD8odD1sLGw9bnVsbCk6dD1sLnNpYmxpbmc7dmFyIHc9TChhLGwsdltoXSxrKTtpZihudWxsPT09dyl7bnVsbD09PWwmJihsPXQpO2JyZWFrfWImJmwmJm51bGw9PT13LmFsdGVybmF0ZSYmYyhhLGwpO2Y9Zyh3LGYsaCk7bnVsbD09PXo/cD13Onouc2libGluZz13O3o9dztcbmw9dH1pZihoPT09di5sZW5ndGgpcmV0dXJuIGQoYSxsKSxwO2lmKG51bGw9PT1sKXtmb3IoO2g8di5sZW5ndGg7aCsrKWlmKGw9RihhLHZbaF0saykpZj1nKGwsZixoKSxudWxsPT09ej9wPWw6ei5zaWJsaW5nPWwsej1sO3JldHVybiBwfWZvcihsPWUoYSxsKTtoPHYubGVuZ3RoO2grKylpZih0PUcobCxhLGgsdltoXSxrKSl7aWYoYiYmbnVsbCE9PXQuYWx0ZXJuYXRlKWxbXCJkZWxldGVcIl0obnVsbD09PXQua2V5P2g6dC5rZXkpO2Y9Zyh0LGYsaCk7bnVsbD09PXo/cD10Onouc2libGluZz10O3o9dH1iJiZsLmZvckVhY2goZnVuY3Rpb24oYil7cmV0dXJuIGMoYSxiKX0pO3JldHVybiBwfWZ1bmN0aW9uIEkoYSxmLHYsayl7dmFyIHA9VmUodik7XCJmdW5jdGlvblwiIT09dHlwZW9mIHA/RChcIjE1MFwiKTp2b2lkIDA7dj1wLmNhbGwodik7bnVsbD09dj9EKFwiMTUxXCIpOnZvaWQgMDtmb3IodmFyIGg9cD1udWxsLGw9Zix6PWY9MCx0PW51bGwsdz12Lm5leHQoKTtudWxsIT09bCYmIXcuZG9uZTt6KyssXG53PXYubmV4dCgpKXtsLmluZGV4Pno/KHQ9bCxsPW51bGwpOnQ9bC5zaWJsaW5nO3ZhciBuPUwoYSxsLHcudmFsdWUsayk7aWYobnVsbD09PW4pe2x8fChsPXQpO2JyZWFrfWImJmwmJm51bGw9PT1uLmFsdGVybmF0ZSYmYyhhLGwpO2Y9ZyhuLGYseik7bnVsbD09PWg/cD1uOmguc2libGluZz1uO2g9bjtsPXR9aWYody5kb25lKXJldHVybiBkKGEsbCkscDtpZihudWxsPT09bCl7Zm9yKDshdy5kb25lO3orKyx3PXYubmV4dCgpKXc9RihhLHcudmFsdWUsayksbnVsbCE9PXcmJihmPWcodyxmLHopLG51bGw9PT1oP3A9dzpoLnNpYmxpbmc9dyxoPXcpO3JldHVybiBwfWZvcihsPWUoYSxsKTshdy5kb25lO3orKyx3PXYubmV4dCgpKWlmKHc9RyhsLGEseix3LnZhbHVlLGspLG51bGwhPT13KXtpZihiJiZudWxsIT09dy5hbHRlcm5hdGUpbFtcImRlbGV0ZVwiXShudWxsPT09dy5rZXk/ejp3LmtleSk7Zj1nKHcsZix6KTtudWxsPT09aD9wPXc6aC5zaWJsaW5nPXc7aD13fWImJmwuZm9yRWFjaChmdW5jdGlvbihiKXtyZXR1cm4gYyhhLFxuYil9KTtyZXR1cm4gcH1yZXR1cm4gZnVuY3Rpb24oYSxiLGUsZyl7dmFyIGg9XCJvYmplY3RcIj09PXR5cGVvZiBlJiZudWxsIT09ZTtpZihoKXN3aXRjaChlLiQkdHlwZW9mKXtjYXNlIFJlOmE6e3ZhciB2PWUua2V5O2ZvcihoPWI7bnVsbCE9PWg7KXtpZihoLmtleT09PXYpaWYoMTA9PT1oLnRhZz9lLnR5cGU9PT1VZTpoLnR5cGU9PT1lLnR5cGUpe2QoYSxoLnNpYmxpbmcpO2I9ZihoLGUudHlwZT09PVVlP2UucHJvcHMuY2hpbGRyZW46ZS5wcm9wcyxnKTtiLnJlZj1XZShoLGUpO2JbXCJyZXR1cm5cIl09YTthPWI7YnJlYWsgYX1lbHNle2QoYSxoKTticmVha31lbHNlIGMoYSxoKTtoPWguc2libGluZ31lLnR5cGU9PT1VZT8oZT1wZShlLnByb3BzLmNoaWxkcmVuLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcsZS5rZXkpLGVbXCJyZXR1cm5cIl09YSxhPWUpOihnPW9lKGUsYS5pbnRlcm5hbENvbnRleHRUYWcsZyksZy5yZWY9V2UoYixlKSxnW1wicmV0dXJuXCJdPWEsYT1nKX1yZXR1cm4gayhhKTtcbmNhc2UgU2U6YTp7Zm9yKGg9ZS5rZXk7bnVsbCE9PWI7KXtpZihiLmtleT09PWgpaWYoNz09PWIudGFnKXtkKGEsYi5zaWJsaW5nKTtlPWYoYixlLGcpO2VbXCJyZXR1cm5cIl09YTthPWU7YnJlYWsgYX1lbHNle2QoYSxiKTticmVha31lbHNlIGMoYSxiKTtiPWIuc2libGluZ31lPXJlKGUsYS5pbnRlcm5hbENvbnRleHRUYWcsZyk7ZVtcInJldHVyblwiXT1hO2E9ZX1yZXR1cm4gayhhKTtjYXNlIFRlOmE6e2lmKG51bGwhPT1iKWlmKDk9PT1iLnRhZyl7ZChhLGIuc2libGluZyk7Yj1mKGIsbnVsbCxnKTtiLnR5cGU9ZS52YWx1ZTtiW1wicmV0dXJuXCJdPWE7YT1iO2JyZWFrIGF9ZWxzZSBkKGEsYik7Yj1zZShlLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcpO2IudHlwZT1lLnZhbHVlO2JbXCJyZXR1cm5cIl09YTthPWJ9cmV0dXJuIGsoYSk7Y2FzZSBOZTphOntmb3IoaD1lLmtleTtudWxsIT09Yjspe2lmKGIua2V5PT09aClpZig0PT09Yi50YWcmJmIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm89PT1lLmNvbnRhaW5lckluZm8mJlxuYi5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb249PT1lLmltcGxlbWVudGF0aW9uKXtkKGEsYi5zaWJsaW5nKTtlPWYoYixlLmNoaWxkcmVufHxbXSxnKTtlW1wicmV0dXJuXCJdPWE7YT1lO2JyZWFrIGF9ZWxzZXtkKGEsYik7YnJlYWt9ZWxzZSBjKGEsYik7Yj1iLnNpYmxpbmd9ZT10ZShlLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcpO2VbXCJyZXR1cm5cIl09YTthPWV9cmV0dXJuIGsoYSl9aWYoXCJzdHJpbmdcIj09PXR5cGVvZiBlfHxcIm51bWJlclwiPT09dHlwZW9mIGUpcmV0dXJuIGU9XCJcIitlLG51bGwhPT1iJiY2PT09Yi50YWc/KGQoYSxiLnNpYmxpbmcpLGU9ZihiLGUsZykpOihkKGEsYiksZT1xZShlLGEuaW50ZXJuYWxDb250ZXh0VGFnLGcpKSxlW1wicmV0dXJuXCJdPWEsYT1lLGsoYSk7aWYoUGUoZSkpcmV0dXJuIFQoYSxiLGUsZyk7aWYoVmUoZSkpcmV0dXJuIEkoYSxiLGUsZyk7aCYmWGUoYSxlKTtpZihcInVuZGVmaW5lZFwiPT09dHlwZW9mIGUpc3dpdGNoKGEudGFnKXtjYXNlIDI6Y2FzZSAxOmU9XG5hLnR5cGUsRChcIjE1MlwiLGUuZGlzcGxheU5hbWV8fGUubmFtZXx8XCJDb21wb25lbnRcIil9cmV0dXJuIGQoYSxiKX19dmFyIFplPVllKCEwLCEwKSwkZT1ZZSghMSwhMCksYWY9WWUoITEsITEpO1xuZnVuY3Rpb24gYmYoYSxiLGMsZCxlKXtmdW5jdGlvbiBmKGEsYixjKXtnKGEsYixjLGIuZXhwaXJhdGlvblRpbWUpfWZ1bmN0aW9uIGcoYSxiLGMsZCl7Yi5jaGlsZD1udWxsPT09YT9hZihiLGIuY2hpbGQsYyxkKTphLmNoaWxkPT09Yi5jaGlsZD9aZShiLGIuY2hpbGQsYyxkKTokZShiLGIuY2hpbGQsYyxkKX1mdW5jdGlvbiBrKGEsYil7dmFyIGM9Yi5yZWY7bnVsbD09PWN8fGEmJmEucmVmPT09Y3x8KGIuZWZmZWN0VGFnfD0xMjgpfWZ1bmN0aW9uIGgoYSxiLGMsZCl7ayhhLGIpO2lmKCFjKXJldHVybiBkJiZtZShiLCExKSxuKGEsYik7Yz1iLnN0YXRlTm9kZTtkZC5jdXJyZW50PWI7dmFyIGU9Yy5yZW5kZXIoKTtiLmVmZmVjdFRhZ3w9MTtmKGEsYixlKTtiLm1lbW9pemVkU3RhdGU9Yy5zdGF0ZTtiLm1lbW9pemVkUHJvcHM9Yy5wcm9wcztkJiZtZShiLCEwKTtyZXR1cm4gYi5jaGlsZH1mdW5jdGlvbiByKGEpe3ZhciBiPWEuc3RhdGVOb2RlO2IucGVuZGluZ0NvbnRleHQ/amUoYSxcbmIucGVuZGluZ0NvbnRleHQsYi5wZW5kaW5nQ29udGV4dCE9PWIuY29udGV4dCk6Yi5jb250ZXh0JiZqZShhLGIuY29udGV4dCwhMSk7RyhhLGIuY29udGFpbmVySW5mbyl9ZnVuY3Rpb24gbihhLGIpe251bGwhPT1hJiZiLmNoaWxkIT09YS5jaGlsZD9EKFwiMTUzXCIpOnZvaWQgMDtpZihudWxsIT09Yi5jaGlsZCl7YT1iLmNoaWxkO3ZhciBjPW5lKGEsYS5wZW5kaW5nUHJvcHMsYS5leHBpcmF0aW9uVGltZSk7Yi5jaGlsZD1jO2ZvcihjW1wicmV0dXJuXCJdPWI7bnVsbCE9PWEuc2libGluZzspYT1hLnNpYmxpbmcsYz1jLnNpYmxpbmc9bmUoYSxhLnBlbmRpbmdQcm9wcyxhLmV4cGlyYXRpb25UaW1lKSxjW1wicmV0dXJuXCJdPWI7Yy5zaWJsaW5nPW51bGx9cmV0dXJuIGIuY2hpbGR9ZnVuY3Rpb24geShhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAzOnIoYik7YnJlYWs7Y2FzZSAyOmxlKGIpO2JyZWFrO2Nhc2UgNDpHKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyl9cmV0dXJuIG51bGx9dmFyIHU9XG5hLnNob3VsZFNldFRleHRDb250ZW50LHg9YS51c2VTeW5jU2NoZWR1bGluZyxGPWEuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZSxMPWIucHVzaEhvc3RDb250ZXh0LEc9Yi5wdXNoSG9zdENvbnRhaW5lcixUPWMuZW50ZXJIeWRyYXRpb25TdGF0ZSxJPWMucmVzZXRIeWRyYXRpb25TdGF0ZSx6PWMudHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U7YT1NZShkLGUsZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkUHJvcHM9Yn0sZnVuY3Rpb24oYSxiKXthLm1lbW9pemVkU3RhdGU9Yn0pO3ZhciBwPWEuYWRvcHRDbGFzc0luc3RhbmNlLHY9YS5jb25zdHJ1Y3RDbGFzc0luc3RhbmNlLHQ9YS5tb3VudENsYXNzSW5zdGFuY2UsS2I9YS51cGRhdGVDbGFzc0luc3RhbmNlO3JldHVybntiZWdpbldvcms6ZnVuY3Rpb24oYSxiLGMpe2lmKDA9PT1iLmV4cGlyYXRpb25UaW1lfHxiLmV4cGlyYXRpb25UaW1lPmMpcmV0dXJuIHkoYSxiKTtzd2l0Y2goYi50YWcpe2Nhc2UgMDpudWxsIT09YT9cbkQoXCIxNTVcIik6dm9pZCAwO3ZhciBkPWIudHlwZSxlPWIucGVuZGluZ1Byb3BzLGc9ZmUoYik7Zz1oZShiLGcpO2Q9ZChlLGcpO2IuZWZmZWN0VGFnfD0xO1wib2JqZWN0XCI9PT10eXBlb2YgZCYmbnVsbCE9PWQmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLnJlbmRlcj8oYi50YWc9MixlPWxlKGIpLHAoYixkKSx0KGIsYyksYj1oKGEsYiwhMCxlKSk6KGIudGFnPTEsZihhLGIsZCksYi5tZW1vaXplZFByb3BzPWUsYj1iLmNoaWxkKTtyZXR1cm4gYjtjYXNlIDE6YTp7ZT1iLnR5cGU7Yz1iLnBlbmRpbmdQcm9wcztkPWIubWVtb2l6ZWRQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWQpO2Vsc2UgaWYobnVsbD09PWN8fGQ9PT1jKXtiPW4oYSxiKTticmVhayBhfWQ9ZmUoYik7ZD1oZShiLGQpO2U9ZShjLGQpO2IuZWZmZWN0VGFnfD0xO2YoYSxiLGUpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtjYXNlIDI6cmV0dXJuIGU9bGUoYiksZD12b2lkIDAsbnVsbD09PVxuYT9iLnN0YXRlTm9kZT9EKFwiMTUzXCIpOih2KGIsYi5wZW5kaW5nUHJvcHMpLHQoYixjKSxkPSEwKTpkPUtiKGEsYixjKSxoKGEsYixkLGUpO2Nhc2UgMzpyZXR1cm4gcihiKSxlPWIudXBkYXRlUXVldWUsbnVsbCE9PWU/KGQ9Yi5tZW1vaXplZFN0YXRlLGU9S2UoYSxiLGUsbnVsbCxudWxsLGMpLGQ9PT1lPyhJKCksYj1uKGEsYikpOihkPWUuZWxlbWVudCxnPWIuc3RhdGVOb2RlLChudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpJiZnLmh5ZHJhdGUmJlQoYik/KGIuZWZmZWN0VGFnfD0yLGIuY2hpbGQ9YWYoYixiLmNoaWxkLGQsYykpOihJKCksZihhLGIsZCkpLGIubWVtb2l6ZWRTdGF0ZT1lLGI9Yi5jaGlsZCkpOihJKCksYj1uKGEsYikpLGI7Y2FzZSA1OkwoYik7bnVsbD09PWEmJnooYik7ZT1iLnR5cGU7dmFyIGw9Yi5tZW1vaXplZFByb3BzO2Q9Yi5wZW5kaW5nUHJvcHM7bnVsbD09PWQmJihkPWwsbnVsbD09PWQ/RChcIjE1NFwiKTp2b2lkIDApO2c9bnVsbCE9PWE/YS5tZW1vaXplZFByb3BzOlxubnVsbDtYLmN1cnJlbnR8fG51bGwhPT1kJiZsIT09ZD8obD1kLmNoaWxkcmVuLHUoZSxkKT9sPW51bGw6ZyYmdShlLGcpJiYoYi5lZmZlY3RUYWd8PTE2KSxrKGEsYiksMjE0NzQ4MzY0NyE9PWMmJiF4JiZGKGUsZCk/KGIuZXhwaXJhdGlvblRpbWU9MjE0NzQ4MzY0NyxiPW51bGwpOihmKGEsYixsKSxiLm1lbW9pemVkUHJvcHM9ZCxiPWIuY2hpbGQpKTpiPW4oYSxiKTtyZXR1cm4gYjtjYXNlIDY6cmV0dXJuIG51bGw9PT1hJiZ6KGIpLGE9Yi5wZW5kaW5nUHJvcHMsbnVsbD09PWEmJihhPWIubWVtb2l6ZWRQcm9wcyksYi5tZW1vaXplZFByb3BzPWEsbnVsbDtjYXNlIDg6Yi50YWc9NztjYXNlIDc6ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT09ZT9EKFwiMTU0XCIpOnZvaWQgMCk7ZWxzZSBpZihudWxsPT09ZXx8Yi5tZW1vaXplZFByb3BzPT09ZSllPWIubWVtb2l6ZWRQcm9wcztkPWUuY2hpbGRyZW47Yi5zdGF0ZU5vZGU9XG5udWxsPT09YT9hZihiLGIuc3RhdGVOb2RlLGQsYyk6YS5jaGlsZD09PWIuY2hpbGQ/WmUoYixiLnN0YXRlTm9kZSxkLGMpOiRlKGIsYi5zdGF0ZU5vZGUsZCxjKTtiLm1lbW9pemVkUHJvcHM9ZTtyZXR1cm4gYi5zdGF0ZU5vZGU7Y2FzZSA5OnJldHVybiBudWxsO2Nhc2UgNDphOntHKGIsYi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7ZT1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWUmJihlPWEmJmEubWVtb2l6ZWRQcm9wcyxudWxsPT1lP0QoXCIxNTRcIik6dm9pZCAwKTtlbHNlIGlmKG51bGw9PT1lfHxiLm1lbW9pemVkUHJvcHM9PT1lKXtiPW4oYSxiKTticmVhayBhfW51bGw9PT1hP2IuY2hpbGQ9JGUoYixiLmNoaWxkLGUsYyk6ZihhLGIsZSk7Yi5tZW1vaXplZFByb3BzPWU7Yj1iLmNoaWxkfXJldHVybiBiO2Nhc2UgMTA6YTp7Yz1iLnBlbmRpbmdQcm9wcztpZihYLmN1cnJlbnQpbnVsbD09PWMmJihjPWIubWVtb2l6ZWRQcm9wcyk7ZWxzZSBpZihudWxsPT09Y3x8XG5iLm1lbW9pemVkUHJvcHM9PT1jKXtiPW4oYSxiKTticmVhayBhfWYoYSxiLGMpO2IubWVtb2l6ZWRQcm9wcz1jO2I9Yi5jaGlsZH1yZXR1cm4gYjtkZWZhdWx0OkQoXCIxNTZcIil9fSxiZWdpbkZhaWxlZFdvcms6ZnVuY3Rpb24oYSxiLGMpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmxlKGIpO2JyZWFrO2Nhc2UgMzpyKGIpO2JyZWFrO2RlZmF1bHQ6RChcIjE1N1wiKX1iLmVmZmVjdFRhZ3w9NjQ7bnVsbD09PWE/Yi5jaGlsZD1udWxsOmIuY2hpbGQhPT1hLmNoaWxkJiYoYi5jaGlsZD1hLmNoaWxkKTtpZigwPT09Yi5leHBpcmF0aW9uVGltZXx8Yi5leHBpcmF0aW9uVGltZT5jKXJldHVybiB5KGEsYik7Yi5maXJzdEVmZmVjdD1udWxsO2IubGFzdEVmZmVjdD1udWxsO2coYSxiLG51bGwsYyk7Mj09PWIudGFnJiYoYT1iLnN0YXRlTm9kZSxiLm1lbW9pemVkUHJvcHM9YS5wcm9wcyxiLm1lbW9pemVkU3RhdGU9YS5zdGF0ZSk7cmV0dXJuIGIuY2hpbGR9fX1cbmZ1bmN0aW9uIGNmKGEsYixjKXtmdW5jdGlvbiBkKGEpe2EuZWZmZWN0VGFnfD00fXZhciBlPWEuY3JlYXRlSW5zdGFuY2UsZj1hLmNyZWF0ZVRleHRJbnN0YW5jZSxnPWEuYXBwZW5kSW5pdGlhbENoaWxkLGs9YS5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbixoPWEucHJlcGFyZVVwZGF0ZSxyPWEucGVyc2lzdGVuY2Usbj1iLmdldFJvb3RIb3N0Q29udGFpbmVyLHk9Yi5wb3BIb3N0Q29udGV4dCx1PWIuZ2V0SG9zdENvbnRleHQseD1iLnBvcEhvc3RDb250YWluZXIsRj1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UsTD1jLnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLEc9Yy5wb3BIeWRyYXRpb25TdGF0ZSxUPXZvaWQgMCxJPXZvaWQgMCx6PXZvaWQgMDthLm11dGF0aW9uPyhUPWZ1bmN0aW9uKCl7fSxJPWZ1bmN0aW9uKGEsYixjKXsoYi51cGRhdGVRdWV1ZT1jKSYmZChiKX0sej1mdW5jdGlvbihhLGIsYyxlKXtjIT09ZSYmZChiKX0pOnI/RChcIjIzNVwiKTpEKFwiMjM2XCIpO1xucmV0dXJue2NvbXBsZXRlV29yazpmdW5jdGlvbihhLGIsYyl7dmFyIHA9Yi5wZW5kaW5nUHJvcHM7aWYobnVsbD09PXApcD1iLm1lbW9pemVkUHJvcHM7ZWxzZSBpZigyMTQ3NDgzNjQ3IT09Yi5leHBpcmF0aW9uVGltZXx8MjE0NzQ4MzY0Nz09PWMpYi5wZW5kaW5nUHJvcHM9bnVsbDtzd2l0Y2goYi50YWcpe2Nhc2UgMTpyZXR1cm4gbnVsbDtjYXNlIDI6cmV0dXJuIGllKGIpLG51bGw7Y2FzZSAzOngoYik7VihYLGIpO1YoZGUsYik7cD1iLnN0YXRlTm9kZTtwLnBlbmRpbmdDb250ZXh0JiYocC5jb250ZXh0PXAucGVuZGluZ0NvbnRleHQscC5wZW5kaW5nQ29udGV4dD1udWxsKTtpZihudWxsPT09YXx8bnVsbD09PWEuY2hpbGQpRyhiKSxiLmVmZmVjdFRhZyY9LTM7VChiKTtyZXR1cm4gbnVsbDtjYXNlIDU6eShiKTtjPW4oKTt2YXIgdj1iLnR5cGU7aWYobnVsbCE9PWEmJm51bGwhPWIuc3RhdGVOb2RlKXt2YXIgbD1hLm1lbW9pemVkUHJvcHMsdD1iLnN0YXRlTm9kZSxyPXUoKTt0PVxuaCh0LHYsbCxwLGMscik7SShhLGIsdCx2LGwscCxjKTthLnJlZiE9PWIucmVmJiYoYi5lZmZlY3RUYWd8PTEyOCl9ZWxzZXtpZighcClyZXR1cm4gbnVsbD09PWIuc3RhdGVOb2RlP0QoXCIxNjZcIik6dm9pZCAwLG51bGw7YT11KCk7aWYoRyhiKSlGKGIsYyxhKSYmZChiKTtlbHNle2E9ZSh2LHAsYyxhLGIpO2E6Zm9yKGw9Yi5jaGlsZDtudWxsIT09bDspe2lmKDU9PT1sLnRhZ3x8Nj09PWwudGFnKWcoYSxsLnN0YXRlTm9kZSk7ZWxzZSBpZig0IT09bC50YWcmJm51bGwhPT1sLmNoaWxkKXtsLmNoaWxkW1wicmV0dXJuXCJdPWw7bD1sLmNoaWxkO2NvbnRpbnVlfWlmKGw9PT1iKWJyZWFrO2Zvcig7bnVsbD09PWwuc2libGluZzspe2lmKG51bGw9PT1sW1wicmV0dXJuXCJdfHxsW1wicmV0dXJuXCJdPT09YilicmVhayBhO2w9bFtcInJldHVyblwiXX1sLnNpYmxpbmdbXCJyZXR1cm5cIl09bFtcInJldHVyblwiXTtsPWwuc2libGluZ31rKGEsdixwLGMpJiZkKGIpO2Iuc3RhdGVOb2RlPWF9bnVsbCE9PWIucmVmJiZcbihiLmVmZmVjdFRhZ3w9MTI4KX1yZXR1cm4gbnVsbDtjYXNlIDY6aWYoYSYmbnVsbCE9Yi5zdGF0ZU5vZGUpeihhLGIsYS5tZW1vaXplZFByb3BzLHApO2Vsc2V7aWYoXCJzdHJpbmdcIiE9PXR5cGVvZiBwKXJldHVybiBudWxsPT09Yi5zdGF0ZU5vZGU/RChcIjE2NlwiKTp2b2lkIDAsbnVsbDthPW4oKTtjPXUoKTtHKGIpP0woYikmJmQoYik6Yi5zdGF0ZU5vZGU9ZihwLGEsYyxiKX1yZXR1cm4gbnVsbDtjYXNlIDc6KHA9Yi5tZW1vaXplZFByb3BzKT92b2lkIDA6RChcIjE2NVwiKTtiLnRhZz04O3Y9W107YTpmb3IoKGw9Yi5zdGF0ZU5vZGUpJiYobFtcInJldHVyblwiXT1iKTtudWxsIT09bDspe2lmKDU9PT1sLnRhZ3x8Nj09PWwudGFnfHw0PT09bC50YWcpRChcIjI0N1wiKTtlbHNlIGlmKDk9PT1sLnRhZyl2LnB1c2gobC50eXBlKTtlbHNlIGlmKG51bGwhPT1sLmNoaWxkKXtsLmNoaWxkW1wicmV0dXJuXCJdPWw7bD1sLmNoaWxkO2NvbnRpbnVlfWZvcig7bnVsbD09PWwuc2libGluZzspe2lmKG51bGw9PT1cbmxbXCJyZXR1cm5cIl18fGxbXCJyZXR1cm5cIl09PT1iKWJyZWFrIGE7bD1sW1wicmV0dXJuXCJdfWwuc2libGluZ1tcInJldHVyblwiXT1sW1wicmV0dXJuXCJdO2w9bC5zaWJsaW5nfWw9cC5oYW5kbGVyO3A9bChwLnByb3BzLHYpO2IuY2hpbGQ9WmUoYixudWxsIT09YT9hLmNoaWxkOm51bGwscCxjKTtyZXR1cm4gYi5jaGlsZDtjYXNlIDg6cmV0dXJuIGIudGFnPTcsbnVsbDtjYXNlIDk6cmV0dXJuIG51bGw7Y2FzZSAxMDpyZXR1cm4gbnVsbDtjYXNlIDQ6cmV0dXJuIHgoYiksVChiKSxudWxsO2Nhc2UgMDpEKFwiMTY3XCIpO2RlZmF1bHQ6RChcIjE1NlwiKX19fX1cbmZ1bmN0aW9uIGRmKGEsYil7ZnVuY3Rpb24gYyhhKXt2YXIgYz1hLnJlZjtpZihudWxsIT09Yyl0cnl7YyhudWxsKX1jYXRjaCh2KXtiKGEsdil9fWZ1bmN0aW9uIGQoYSl7XCJmdW5jdGlvblwiPT09dHlwZW9mIHplJiZ6ZShhKTtzd2l0Y2goYS50YWcpe2Nhc2UgMjpjKGEpO3ZhciBkPWEuc3RhdGVOb2RlO2lmKFwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLmNvbXBvbmVudFdpbGxVbm1vdW50KXRyeXtkLnByb3BzPWEubWVtb2l6ZWRQcm9wcyxkLnN0YXRlPWEubWVtb2l6ZWRTdGF0ZSxkLmNvbXBvbmVudFdpbGxVbm1vdW50KCl9Y2F0Y2godil7YihhLHYpfWJyZWFrO2Nhc2UgNTpjKGEpO2JyZWFrO2Nhc2UgNzplKGEuc3RhdGVOb2RlKTticmVhaztjYXNlIDQ6aCYmZyhhKX19ZnVuY3Rpb24gZShhKXtmb3IodmFyIGI9YTs7KWlmKGQoYiksbnVsbD09PWIuY2hpbGR8fGgmJjQ9PT1iLnRhZyl7aWYoYj09PWEpYnJlYWs7Zm9yKDtudWxsPT09Yi5zaWJsaW5nOyl7aWYobnVsbD09PWJbXCJyZXR1cm5cIl18fFxuYltcInJldHVyblwiXT09PWEpcmV0dXJuO2I9YltcInJldHVyblwiXX1iLnNpYmxpbmdbXCJyZXR1cm5cIl09YltcInJldHVyblwiXTtiPWIuc2libGluZ31lbHNlIGIuY2hpbGRbXCJyZXR1cm5cIl09YixiPWIuY2hpbGR9ZnVuY3Rpb24gZihhKXtyZXR1cm4gNT09PWEudGFnfHwzPT09YS50YWd8fDQ9PT1hLnRhZ31mdW5jdGlvbiBnKGEpe2Zvcih2YXIgYj1hLGM9ITEsZj12b2lkIDAsZz12b2lkIDA7Oyl7aWYoIWMpe2M9YltcInJldHVyblwiXTthOmZvcig7Oyl7bnVsbD09PWM/RChcIjE2MFwiKTp2b2lkIDA7c3dpdGNoKGMudGFnKXtjYXNlIDU6Zj1jLnN0YXRlTm9kZTtnPSExO2JyZWFrIGE7Y2FzZSAzOmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGE7Y2FzZSA0OmY9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztnPSEwO2JyZWFrIGF9Yz1jW1wicmV0dXJuXCJdfWM9ITB9aWYoNT09PWIudGFnfHw2PT09Yi50YWcpZShiKSxnP0koZixiLnN0YXRlTm9kZSk6VChmLGIuc3RhdGVOb2RlKTtcbmVsc2UgaWYoND09PWIudGFnP2Y9Yi5zdGF0ZU5vZGUuY29udGFpbmVySW5mbzpkKGIpLG51bGwhPT1iLmNoaWxkKXtiLmNoaWxkW1wicmV0dXJuXCJdPWI7Yj1iLmNoaWxkO2NvbnRpbnVlfWlmKGI9PT1hKWJyZWFrO2Zvcig7bnVsbD09PWIuc2libGluZzspe2lmKG51bGw9PT1iW1wicmV0dXJuXCJdfHxiW1wicmV0dXJuXCJdPT09YSlyZXR1cm47Yj1iW1wicmV0dXJuXCJdOzQ9PT1iLnRhZyYmKGM9ITEpfWIuc2libGluZ1tcInJldHVyblwiXT1iW1wicmV0dXJuXCJdO2I9Yi5zaWJsaW5nfX12YXIgaz1hLmdldFB1YmxpY0luc3RhbmNlLGg9YS5tdXRhdGlvbjthPWEucGVyc2lzdGVuY2U7aHx8KGE/RChcIjIzNVwiKTpEKFwiMjM2XCIpKTt2YXIgcj1oLmNvbW1pdE1vdW50LG49aC5jb21taXRVcGRhdGUseT1oLnJlc2V0VGV4dENvbnRlbnQsdT1oLmNvbW1pdFRleHRVcGRhdGUseD1oLmFwcGVuZENoaWxkLEY9aC5hcHBlbmRDaGlsZFRvQ29udGFpbmVyLEw9aC5pbnNlcnRCZWZvcmUsRz1oLmluc2VydEluQ29udGFpbmVyQmVmb3JlLFxuVD1oLnJlbW92ZUNoaWxkLEk9aC5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7cmV0dXJue2NvbW1pdFJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7eShhLnN0YXRlTm9kZSl9LGNvbW1pdFBsYWNlbWVudDpmdW5jdGlvbihhKXthOntmb3IodmFyIGI9YVtcInJldHVyblwiXTtudWxsIT09Yjspe2lmKGYoYikpe3ZhciBjPWI7YnJlYWsgYX1iPWJbXCJyZXR1cm5cIl19RChcIjE2MFwiKTtjPXZvaWQgMH12YXIgZD1iPXZvaWQgMDtzd2l0Y2goYy50YWcpe2Nhc2UgNTpiPWMuc3RhdGVOb2RlO2Q9ITE7YnJlYWs7Y2FzZSAzOmI9Yy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztkPSEwO2JyZWFrO2Nhc2UgNDpiPWMuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87ZD0hMDticmVhaztkZWZhdWx0OkQoXCIxNjFcIil9Yy5lZmZlY3RUYWcmMTYmJih5KGIpLGMuZWZmZWN0VGFnJj0tMTcpO2E6Yjpmb3IoYz1hOzspe2Zvcig7bnVsbD09PWMuc2libGluZzspe2lmKG51bGw9PT1jW1wicmV0dXJuXCJdfHxmKGNbXCJyZXR1cm5cIl0pKXtjPVxubnVsbDticmVhayBhfWM9Y1tcInJldHVyblwiXX1jLnNpYmxpbmdbXCJyZXR1cm5cIl09Y1tcInJldHVyblwiXTtmb3IoYz1jLnNpYmxpbmc7NSE9PWMudGFnJiY2IT09Yy50YWc7KXtpZihjLmVmZmVjdFRhZyYyKWNvbnRpbnVlIGI7aWYobnVsbD09PWMuY2hpbGR8fDQ9PT1jLnRhZyljb250aW51ZSBiO2Vsc2UgYy5jaGlsZFtcInJldHVyblwiXT1jLGM9Yy5jaGlsZH1pZighKGMuZWZmZWN0VGFnJjIpKXtjPWMuc3RhdGVOb2RlO2JyZWFrIGF9fWZvcih2YXIgZT1hOzspe2lmKDU9PT1lLnRhZ3x8Nj09PWUudGFnKWM/ZD9HKGIsZS5zdGF0ZU5vZGUsYyk6TChiLGUuc3RhdGVOb2RlLGMpOmQ/RihiLGUuc3RhdGVOb2RlKTp4KGIsZS5zdGF0ZU5vZGUpO2Vsc2UgaWYoNCE9PWUudGFnJiZudWxsIT09ZS5jaGlsZCl7ZS5jaGlsZFtcInJldHVyblwiXT1lO2U9ZS5jaGlsZDtjb250aW51ZX1pZihlPT09YSlicmVhaztmb3IoO251bGw9PT1lLnNpYmxpbmc7KXtpZihudWxsPT09ZVtcInJldHVyblwiXXx8ZVtcInJldHVyblwiXT09PVxuYSlyZXR1cm47ZT1lW1wicmV0dXJuXCJdfWUuc2libGluZ1tcInJldHVyblwiXT1lW1wicmV0dXJuXCJdO2U9ZS5zaWJsaW5nfX0sY29tbWl0RGVsZXRpb246ZnVuY3Rpb24oYSl7ZyhhKTthW1wicmV0dXJuXCJdPW51bGw7YS5jaGlsZD1udWxsO2EuYWx0ZXJuYXRlJiYoYS5hbHRlcm5hdGUuY2hpbGQ9bnVsbCxhLmFsdGVybmF0ZVtcInJldHVyblwiXT1udWxsKX0sY29tbWl0V29yazpmdW5jdGlvbihhLGIpe3N3aXRjaChiLnRhZyl7Y2FzZSAyOmJyZWFrO2Nhc2UgNTp2YXIgYz1iLnN0YXRlTm9kZTtpZihudWxsIT1jKXt2YXIgZD1iLm1lbW9pemVkUHJvcHM7YT1udWxsIT09YT9hLm1lbW9pemVkUHJvcHM6ZDt2YXIgZT1iLnR5cGUsZj1iLnVwZGF0ZVF1ZXVlO2IudXBkYXRlUXVldWU9bnVsbDtudWxsIT09ZiYmbihjLGYsZSxhLGQsYil9YnJlYWs7Y2FzZSA2Om51bGw9PT1iLnN0YXRlTm9kZT9EKFwiMTYyXCIpOnZvaWQgMDtjPWIubWVtb2l6ZWRQcm9wczt1KGIuc3RhdGVOb2RlLG51bGwhPT1hP2EubWVtb2l6ZWRQcm9wczpcbmMsYyk7YnJlYWs7Y2FzZSAzOmJyZWFrO2RlZmF1bHQ6RChcIjE2M1wiKX19LGNvbW1pdExpZmVDeWNsZXM6ZnVuY3Rpb24oYSxiKXtzd2l0Y2goYi50YWcpe2Nhc2UgMjp2YXIgYz1iLnN0YXRlTm9kZTtpZihiLmVmZmVjdFRhZyY0KWlmKG51bGw9PT1hKWMucHJvcHM9Yi5tZW1vaXplZFByb3BzLGMuc3RhdGU9Yi5tZW1vaXplZFN0YXRlLGMuY29tcG9uZW50RGlkTW91bnQoKTtlbHNle3ZhciBkPWEubWVtb2l6ZWRQcm9wczthPWEubWVtb2l6ZWRTdGF0ZTtjLnByb3BzPWIubWVtb2l6ZWRQcm9wcztjLnN0YXRlPWIubWVtb2l6ZWRTdGF0ZTtjLmNvbXBvbmVudERpZFVwZGF0ZShkLGEpfWI9Yi51cGRhdGVRdWV1ZTtudWxsIT09YiYmTGUoYixjKTticmVhaztjYXNlIDM6Yz1iLnVwZGF0ZVF1ZXVlO251bGwhPT1jJiZMZShjLG51bGwhPT1iLmNoaWxkP2IuY2hpbGQuc3RhdGVOb2RlOm51bGwpO2JyZWFrO2Nhc2UgNTpjPWIuc3RhdGVOb2RlO251bGw9PT1hJiZiLmVmZmVjdFRhZyY0JiZyKGMsXG5iLnR5cGUsYi5tZW1vaXplZFByb3BzLGIpO2JyZWFrO2Nhc2UgNjpicmVhaztjYXNlIDQ6YnJlYWs7ZGVmYXVsdDpEKFwiMTYzXCIpfX0sY29tbWl0QXR0YWNoUmVmOmZ1bmN0aW9uKGEpe3ZhciBiPWEucmVmO2lmKG51bGwhPT1iKXt2YXIgYz1hLnN0YXRlTm9kZTtzd2l0Y2goYS50YWcpe2Nhc2UgNTpiKGsoYykpO2JyZWFrO2RlZmF1bHQ6YihjKX19fSxjb21taXREZXRhY2hSZWY6ZnVuY3Rpb24oYSl7YT1hLnJlZjtudWxsIT09YSYmYShudWxsKX19fXZhciBlZj17fTtcbmZ1bmN0aW9uIGZmKGEpe2Z1bmN0aW9uIGIoYSl7YT09PWVmP0QoXCIxNzRcIik6dm9pZCAwO3JldHVybiBhfXZhciBjPWEuZ2V0Q2hpbGRIb3N0Q29udGV4dCxkPWEuZ2V0Um9vdEhvc3RDb250ZXh0LGU9e2N1cnJlbnQ6ZWZ9LGY9e2N1cnJlbnQ6ZWZ9LGc9e2N1cnJlbnQ6ZWZ9O3JldHVybntnZXRIb3N0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiBiKGUuY3VycmVudCl9LGdldFJvb3RIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7cmV0dXJuIGIoZy5jdXJyZW50KX0scG9wSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhKXtWKGUsYSk7VihmLGEpO1YoZyxhKX0scG9wSG9zdENvbnRleHQ6ZnVuY3Rpb24oYSl7Zi5jdXJyZW50PT09YSYmKFYoZSxhKSxWKGYsYSkpfSxwdXNoSG9zdENvbnRhaW5lcjpmdW5jdGlvbihhLGIpe1coZyxiLGEpO2I9ZChiKTtXKGYsYSxhKTtXKGUsYixhKX0scHVzaEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBkPWIoZy5jdXJyZW50KSxrPWIoZS5jdXJyZW50KTtcbmQ9YyhrLGEudHlwZSxkKTtrIT09ZCYmKFcoZixhLGEpLFcoZSxkLGEpKX0scmVzZXRIb3N0Q29udGFpbmVyOmZ1bmN0aW9uKCl7ZS5jdXJyZW50PWVmO2cuY3VycmVudD1lZn19fVxuZnVuY3Rpb24gZ2YoYSl7ZnVuY3Rpb24gYihhLGIpe3ZhciBjPW5ldyBZKDUsbnVsbCwwKTtjLnR5cGU9XCJERUxFVEVEXCI7Yy5zdGF0ZU5vZGU9YjtjW1wicmV0dXJuXCJdPWE7Yy5lZmZlY3RUYWc9ODtudWxsIT09YS5sYXN0RWZmZWN0PyhhLmxhc3RFZmZlY3QubmV4dEVmZmVjdD1jLGEubGFzdEVmZmVjdD1jKTphLmZpcnN0RWZmZWN0PWEubGFzdEVmZmVjdD1jfWZ1bmN0aW9uIGMoYSxiKXtzd2l0Y2goYS50YWcpe2Nhc2UgNTpyZXR1cm4gZihiLGEudHlwZSxhLnBlbmRpbmdQcm9wcyk7Y2FzZSA2OnJldHVybiBnKGIsYS5wZW5kaW5nUHJvcHMpO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIGQoYSl7Zm9yKGE9YVtcInJldHVyblwiXTtudWxsIT09YSYmNSE9PWEudGFnJiYzIT09YS50YWc7KWE9YVtcInJldHVyblwiXTt5PWF9dmFyIGU9YS5zaG91bGRTZXRUZXh0Q29udGVudDthPWEuaHlkcmF0aW9uO2lmKCFhKXJldHVybntlbnRlckh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LFxucmVzZXRIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbigpe30sdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oKXtEKFwiMTc1XCIpfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbigpe0QoXCIxNzZcIil9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7cmV0dXJuITF9fTt2YXIgZj1hLmNhbkh5ZHJhdGVJbnN0YW5jZSxnPWEuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxrPWEuZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nLGg9YS5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxyPWEuaHlkcmF0ZUluc3RhbmNlLG49YS5oeWRyYXRlVGV4dEluc3RhbmNlLHk9bnVsbCx1PW51bGwseD0hMTtyZXR1cm57ZW50ZXJIeWRyYXRpb25TdGF0ZTpmdW5jdGlvbihhKXt1PWgoYS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7eT1hO3JldHVybiB4PSEwfSxyZXNldEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKCl7dT1cbnk9bnVsbDt4PSExfSx0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTpmdW5jdGlvbihhKXtpZih4KXt2YXIgZD11O2lmKGQpe2lmKCFjKGEsZCkpe2Q9ayhkKTtpZighZHx8IWMoYSxkKSl7YS5lZmZlY3RUYWd8PTI7eD0hMTt5PWE7cmV0dXJufWIoeSx1KX1hLnN0YXRlTm9kZT1kO3k9YTt1PWgoZCl9ZWxzZSBhLmVmZmVjdFRhZ3w9Mix4PSExLHk9YX19LHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMpe2I9cihhLnN0YXRlTm9kZSxhLnR5cGUsYS5tZW1vaXplZFByb3BzLGIsYyxhKTthLnVwZGF0ZVF1ZXVlPWI7cmV0dXJuIG51bGwhPT1iPyEwOiExfSxwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTpmdW5jdGlvbihhKXtyZXR1cm4gbihhLnN0YXRlTm9kZSxhLm1lbW9pemVkUHJvcHMsYSl9LHBvcEh5ZHJhdGlvblN0YXRlOmZ1bmN0aW9uKGEpe2lmKGEhPT15KXJldHVybiExO2lmKCF4KXJldHVybiBkKGEpLHg9ITAsITE7dmFyIGM9XG5hLnR5cGU7aWYoNSE9PWEudGFnfHxcImhlYWRcIiE9PWMmJlwiYm9keVwiIT09YyYmIWUoYyxhLm1lbW9pemVkUHJvcHMpKWZvcihjPXU7YzspYihhLGMpLGM9ayhjKTtkKGEpO3U9eT9rKGEuc3RhdGVOb2RlKTpudWxsO3JldHVybiEwfX19XG5mdW5jdGlvbiBoZihhKXtmdW5jdGlvbiBiKGEpe0xiPW1hPSEwO3ZhciBiPWEuc3RhdGVOb2RlO2IuY3VycmVudD09PWE/RChcIjE3N1wiKTp2b2lkIDA7Yi5pc1JlYWR5Rm9yQ29tbWl0PSExO2RkLmN1cnJlbnQ9bnVsbDtpZigxPGEuZWZmZWN0VGFnKWlmKG51bGwhPT1hLmxhc3RFZmZlY3Qpe2EubGFzdEVmZmVjdC5uZXh0RWZmZWN0PWE7dmFyIGM9YS5maXJzdEVmZmVjdH1lbHNlIGM9YTtlbHNlIGM9YS5maXJzdEVmZmVjdDt1ZygpO2ZvcihxPWM7bnVsbCE9PXE7KXt2YXIgZD0hMSxlPXZvaWQgMDt0cnl7Zm9yKDtudWxsIT09cTspe3ZhciBmPXEuZWZmZWN0VGFnO2YmMTYmJnZnKHEpO2lmKGYmMTI4KXt2YXIgZz1xLmFsdGVybmF0ZTtudWxsIT09ZyYmd2coZyl9c3dpdGNoKGYmLTI0Mil7Y2FzZSAyOkdlKHEpO3EuZWZmZWN0VGFnJj0tMzticmVhaztjYXNlIDY6R2UocSk7cS5lZmZlY3RUYWcmPS0zO0hlKHEuYWx0ZXJuYXRlLHEpO2JyZWFrO2Nhc2UgNDpIZShxLmFsdGVybmF0ZSxcbnEpO2JyZWFrO2Nhc2UgODpMYz0hMCx4ZyhxKSxMYz0hMX1xPXEubmV4dEVmZmVjdH19Y2F0Y2goTWMpe2Q9ITAsZT1NY31kJiYobnVsbD09PXE/RChcIjE3OFwiKTp2b2lkIDAsayhxLGUpLG51bGwhPT1xJiYocT1xLm5leHRFZmZlY3QpKX15ZygpO2IuY3VycmVudD1hO2ZvcihxPWM7bnVsbCE9PXE7KXtjPSExO2Q9dm9pZCAwO3RyeXtmb3IoO251bGwhPT1xOyl7dmFyIGg9cS5lZmZlY3RUYWc7aCYzNiYmemcocS5hbHRlcm5hdGUscSk7aCYxMjgmJkFnKHEpO2lmKGgmNjQpc3dpdGNoKGU9cSxmPXZvaWQgMCxudWxsIT09UCYmKGY9UC5nZXQoZSksUFtcImRlbGV0ZVwiXShlKSxudWxsPT1mJiZudWxsIT09ZS5hbHRlcm5hdGUmJihlPWUuYWx0ZXJuYXRlLGY9UC5nZXQoZSksUFtcImRlbGV0ZVwiXShlKSkpLG51bGw9PWY/RChcIjE4NFwiKTp2b2lkIDAsZS50YWcpe2Nhc2UgMjplLnN0YXRlTm9kZS5jb21wb25lbnREaWRDYXRjaChmLmVycm9yLHtjb21wb25lbnRTdGFjazpmLmNvbXBvbmVudFN0YWNrfSk7XG5icmVhaztjYXNlIDM6bnVsbD09PWJhJiYoYmE9Zi5lcnJvcik7YnJlYWs7ZGVmYXVsdDpEKFwiMTU3XCIpfXZhciBGYT1xLm5leHRFZmZlY3Q7cS5uZXh0RWZmZWN0PW51bGw7cT1GYX19Y2F0Y2goTWMpe2M9ITAsZD1NY31jJiYobnVsbD09PXE/RChcIjE3OFwiKTp2b2lkIDAsayhxLGQpLG51bGwhPT1xJiYocT1xLm5leHRFZmZlY3QpKX1tYT1MYj0hMTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgeWUmJnllKGEuc3RhdGVOb2RlKTtmYSYmKGZhLmZvckVhY2goRiksZmE9bnVsbCk7bnVsbCE9PWJhJiYoYT1iYSxiYT1udWxsLHYoYSkpO2I9Yi5jdXJyZW50LmV4cGlyYXRpb25UaW1lOzA9PT1iJiYobmE9UD1udWxsKTtyZXR1cm4gYn1mdW5jdGlvbiBjKGEpe2Zvcig7Oyl7dmFyIGI9bmcoYS5hbHRlcm5hdGUsYSxKKSxjPWFbXCJyZXR1cm5cIl0sZD1hLnNpYmxpbmc7dmFyIGU9YTtpZigyMTQ3NDgzNjQ3PT09Snx8MjE0NzQ4MzY0NyE9PWUuZXhwaXJhdGlvblRpbWUpe2lmKDIhPT1lLnRhZyYmMyE9PVxuZS50YWcpdmFyIGY9MDtlbHNlIGY9ZS51cGRhdGVRdWV1ZSxmPW51bGw9PT1mPzA6Zi5leHBpcmF0aW9uVGltZTtmb3IodmFyIGc9ZS5jaGlsZDtudWxsIT09ZzspMCE9PWcuZXhwaXJhdGlvblRpbWUmJigwPT09Znx8Zj5nLmV4cGlyYXRpb25UaW1lKSYmKGY9Zy5leHBpcmF0aW9uVGltZSksZz1nLnNpYmxpbmc7ZS5leHBpcmF0aW9uVGltZT1mfWlmKG51bGwhPT1iKXJldHVybiBiO251bGwhPT1jJiYobnVsbD09PWMuZmlyc3RFZmZlY3QmJihjLmZpcnN0RWZmZWN0PWEuZmlyc3RFZmZlY3QpLG51bGwhPT1hLmxhc3RFZmZlY3QmJihudWxsIT09Yy5sYXN0RWZmZWN0JiYoYy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YS5maXJzdEVmZmVjdCksYy5sYXN0RWZmZWN0PWEubGFzdEVmZmVjdCksMTxhLmVmZmVjdFRhZyYmKG51bGwhPT1jLmxhc3RFZmZlY3Q/Yy5sYXN0RWZmZWN0Lm5leHRFZmZlY3Q9YTpjLmZpcnN0RWZmZWN0PWEsYy5sYXN0RWZmZWN0PWEpKTtpZihudWxsIT09ZClyZXR1cm4gZDtcbmlmKG51bGwhPT1jKWE9YztlbHNle2Euc3RhdGVOb2RlLmlzUmVhZHlGb3JDb21taXQ9ITA7YnJlYWt9fXJldHVybiBudWxsfWZ1bmN0aW9uIGQoYSl7dmFyIGI9dyhhLmFsdGVybmF0ZSxhLEopO251bGw9PT1iJiYoYj1jKGEpKTtkZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZShhKXt2YXIgYj1tZyhhLmFsdGVybmF0ZSxhLEopO251bGw9PT1iJiYoYj1jKGEpKTtkZC5jdXJyZW50PW51bGw7cmV0dXJuIGJ9ZnVuY3Rpb24gZihhKXtpZihudWxsIT09UCl7aWYoISgwPT09Snx8Sj5hKSlpZihKPD1OYylmb3IoO251bGwhPT1FOylFPWgoRSk/ZShFKTpkKEUpO2Vsc2UgZm9yKDtudWxsIT09RSYmIXAoKTspRT1oKEUpP2UoRSk6ZChFKX1lbHNlIGlmKCEoMD09PUp8fEo+YSkpaWYoSjw9TmMpZm9yKDtudWxsIT09RTspRT1kKEUpO2Vsc2UgZm9yKDtudWxsIT09RSYmIXAoKTspRT1kKEUpfWZ1bmN0aW9uIGcoYSxiKXttYT9EKFwiMjQzXCIpOnZvaWQgMDttYT0hMDthLmlzUmVhZHlGb3JDb21taXQ9XG4hMTtpZihhIT09ZmJ8fGIhPT1KfHxudWxsPT09RSl7Zm9yKDstMTxjZTspYmVbY2VdPW51bGwsY2UtLTtlZT1DO2RlLmN1cnJlbnQ9QztYLmN1cnJlbnQ9ITE7bGcoKTtmYj1hO0o9YjtFPW5lKGZiLmN1cnJlbnQsbnVsbCxiKX12YXIgYz0hMSxkPW51bGw7dHJ5e2YoYil9Y2F0Y2goS2Mpe2M9ITAsZD1LY31mb3IoO2M7KXtpZihnYil7YmE9ZDticmVha312YXIgZz1FO2lmKG51bGw9PT1nKWdiPSEwO2Vsc2V7dmFyIGg9ayhnLGQpO251bGw9PT1oP0QoXCIxODNcIik6dm9pZCAwO2lmKCFnYil7dHJ5e2M9aDtkPWI7Zm9yKGg9YztudWxsIT09Zzspe3N3aXRjaChnLnRhZyl7Y2FzZSAyOmllKGcpO2JyZWFrO2Nhc2UgNTpsKGcpO2JyZWFrO2Nhc2UgMzpFZShnKTticmVhaztjYXNlIDQ6RWUoZyl9aWYoZz09PWh8fGcuYWx0ZXJuYXRlPT09aClicmVhaztnPWdbXCJyZXR1cm5cIl19RT1lKGMpO2YoZCl9Y2F0Y2goS2Mpe2M9ITA7ZD1LYztjb250aW51ZX1icmVha319fWI9YmE7Z2I9bWE9ITE7XG5iYT1udWxsO251bGwhPT1iJiZ2KGIpO3JldHVybiBhLmlzUmVhZHlGb3JDb21taXQ/YS5jdXJyZW50LmFsdGVybmF0ZTpudWxsfWZ1bmN0aW9uIGsoYSxiKXt2YXIgYz1kZC5jdXJyZW50PW51bGwsZD0hMSxlPSExLGY9bnVsbDtpZigzPT09YS50YWcpYz1hLHIoYSkmJihnYj0hMCk7ZWxzZSBmb3IodmFyIGc9YVtcInJldHVyblwiXTtudWxsIT09ZyYmbnVsbD09PWM7KXsyPT09Zy50YWc/XCJmdW5jdGlvblwiPT09dHlwZW9mIGcuc3RhdGVOb2RlLmNvbXBvbmVudERpZENhdGNoJiYoZD0hMCxmPWVkKGcpLGM9ZyxlPSEwKTozPT09Zy50YWcmJihjPWcpO2lmKHIoZykpe2lmKExjfHxudWxsIT09ZmEmJihmYS5oYXMoZyl8fG51bGwhPT1nLmFsdGVybmF0ZSYmZmEuaGFzKGcuYWx0ZXJuYXRlKSkpcmV0dXJuIG51bGw7Yz1udWxsO2U9ITF9Zz1nW1wicmV0dXJuXCJdfWlmKG51bGwhPT1jKXtudWxsPT09bmEmJihuYT1uZXcgU2V0KTtuYS5hZGQoYyk7dmFyIGg9XCJcIjtnPWE7ZG97YTpzd2l0Y2goZy50YWcpe2Nhc2UgMDpjYXNlIDE6Y2FzZSAyOmNhc2UgNTp2YXIgaz1cbmcuX2RlYnVnT3duZXIsbD1nLl9kZWJ1Z1NvdXJjZTt2YXIgRmE9ZWQoZyk7dmFyIG49bnVsbDtrJiYobj1lZChrKSk7az1sO0ZhPVwiXFxuICAgIGluIFwiKyhGYXx8XCJVbmtub3duXCIpKyhrP1wiIChhdCBcIitrLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sXCJcIikrXCI6XCIray5saW5lTnVtYmVyK1wiKVwiOm4/XCIgKGNyZWF0ZWQgYnkgXCIrbitcIilcIjpcIlwiKTticmVhayBhO2RlZmF1bHQ6RmE9XCJcIn1oKz1GYTtnPWdbXCJyZXR1cm5cIl19d2hpbGUoZyk7Zz1oO2E9ZWQoYSk7bnVsbD09PVAmJihQPW5ldyBNYXApO2I9e2NvbXBvbmVudE5hbWU6YSxjb21wb25lbnRTdGFjazpnLGVycm9yOmIsZXJyb3JCb3VuZGFyeTpkP2Muc3RhdGVOb2RlOm51bGwsZXJyb3JCb3VuZGFyeUZvdW5kOmQsZXJyb3JCb3VuZGFyeU5hbWU6Zix3aWxsUmV0cnk6ZX07UC5zZXQoYyxiKTt0cnl7Y29uc29sZS5lcnJvcihiLmVycm9yKX1jYXRjaChCZyl7Y29uc29sZS5lcnJvcihCZyl9TGI/KG51bGw9PT1mYSYmKGZhPW5ldyBTZXQpLFxuZmEuYWRkKGMpKTpGKGMpO3JldHVybiBjfW51bGw9PT1iYSYmKGJhPWIpO3JldHVybiBudWxsfWZ1bmN0aW9uIGgoYSl7cmV0dXJuIG51bGwhPT1QJiYoUC5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmUC5oYXMoYS5hbHRlcm5hdGUpKX1mdW5jdGlvbiByKGEpe3JldHVybiBudWxsIT09bmEmJihuYS5oYXMoYSl8fG51bGwhPT1hLmFsdGVybmF0ZSYmbmEuaGFzKGEuYWx0ZXJuYXRlKSl9ZnVuY3Rpb24gbigpe3JldHVybiAyMCooKChMKCkrMTAwKS8yMHwwKSsxKX1mdW5jdGlvbiB5KGEpe3JldHVybiAwIT09amE/amE6bWE/TGI/MTpKOiFDZ3x8YS5pbnRlcm5hbENvbnRleHRUYWcmMT9uKCk6MX1mdW5jdGlvbiB1KGEsYil7cmV0dXJuIHgoYSxiLCExKX1mdW5jdGlvbiB4KGEsYil7Zm9yKDtudWxsIT09YTspe2lmKDA9PT1hLmV4cGlyYXRpb25UaW1lfHxhLmV4cGlyYXRpb25UaW1lPmIpYS5leHBpcmF0aW9uVGltZT1iO251bGwhPT1hLmFsdGVybmF0ZSYmKDA9PT1hLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZXx8XG5hLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZT5iKSYmKGEuYWx0ZXJuYXRlLmV4cGlyYXRpb25UaW1lPWIpO2lmKG51bGw9PT1hW1wicmV0dXJuXCJdKWlmKDM9PT1hLnRhZyl7dmFyIGM9YS5zdGF0ZU5vZGU7IW1hJiZjPT09ZmImJmI8PUomJihFPWZiPW51bGwsSj0wKTt2YXIgZD1iO01iPkRnJiZEKFwiMTg1XCIpO2lmKG51bGw9PT1jLm5leHRTY2hlZHVsZWRSb290KWMucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZCxudWxsPT09TT8ob2E9TT1jLGMubmV4dFNjaGVkdWxlZFJvb3Q9Yyk6KE09TS5uZXh0U2NoZWR1bGVkUm9vdD1jLE0ubmV4dFNjaGVkdWxlZFJvb3Q9b2EpO2Vsc2V7dmFyIGU9Yy5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtpZigwPT09ZXx8ZDxlKWMucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9ZH1HYXx8KGthP05iJiZ6KGMsMSk6MT09PWQ/SSgxLG51bGwpOmhifHwoaGI9ITAsSWUoVCkpKX1lbHNlIGJyZWFrO2E9YVtcInJldHVyblwiXX19ZnVuY3Rpb24gRihhKXt4KGEsMSxcbiEwKX1mdW5jdGlvbiBMKCl7cmV0dXJuIE5jPSgoSmUoKS1FZykvMTB8MCkrMn1mdW5jdGlvbiBHKCl7dmFyIGE9MCxiPW51bGw7aWYobnVsbCE9PU0pZm9yKHZhciBjPU0sZD1vYTtudWxsIT09ZDspe3ZhciBlPWQucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7aWYoMD09PWUpe251bGw9PT1jfHxudWxsPT09TT9EKFwiMjQ0XCIpOnZvaWQgMDtpZihkPT09ZC5uZXh0U2NoZWR1bGVkUm9vdCl7b2E9TT1kLm5leHRTY2hlZHVsZWRSb290PW51bGw7YnJlYWt9ZWxzZSBpZihkPT09b2Epb2E9ZT1kLm5leHRTY2hlZHVsZWRSb290LE0ubmV4dFNjaGVkdWxlZFJvb3Q9ZSxkLm5leHRTY2hlZHVsZWRSb290PW51bGw7ZWxzZSBpZihkPT09TSl7TT1jO00ubmV4dFNjaGVkdWxlZFJvb3Q9b2E7ZC5uZXh0U2NoZWR1bGVkUm9vdD1udWxsO2JyZWFrfWVsc2UgYy5uZXh0U2NoZWR1bGVkUm9vdD1kLm5leHRTY2hlZHVsZWRSb290LGQubmV4dFNjaGVkdWxlZFJvb3Q9bnVsbDtkPWMubmV4dFNjaGVkdWxlZFJvb3R9ZWxzZXtpZigwPT09XG5hfHxlPGEpYT1lLGI9ZDtpZihkPT09TSlicmVhaztjPWQ7ZD1kLm5leHRTY2hlZHVsZWRSb290fX1jPXBhO251bGwhPT1jJiZjPT09Yj9NYisrOk1iPTA7cGE9YjtPYj1hfWZ1bmN0aW9uIFQoYSl7SSgwLGEpfWZ1bmN0aW9uIEkoYSxiKXtpYj1iO2ZvcihHKCk7bnVsbCE9PXBhJiYwIT09T2ImJigwPT09YXx8T2I8PWEpJiYhT2M7KXoocGEsT2IpLEcoKTtudWxsIT09aWImJihoYj0hMSk7bnVsbD09PXBhfHxoYnx8KGhiPSEwLEllKFQpKTtpYj1udWxsO09jPSExO01iPTA7aWYoUGIpdGhyb3cgYT1QYyxQYz1udWxsLFBiPSExLGE7fWZ1bmN0aW9uIHooYSxjKXtHYT9EKFwiMjQ1XCIpOnZvaWQgMDtHYT0hMDtpZihjPD1MKCkpe3ZhciBkPWEuZmluaXNoZWRXb3JrO251bGwhPT1kPyhhLmZpbmlzaGVkV29yaz1udWxsLGEucmVtYWluaW5nRXhwaXJhdGlvblRpbWU9YihkKSk6KGEuZmluaXNoZWRXb3JrPW51bGwsZD1nKGEsYyksbnVsbCE9PWQmJihhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPVxuYihkKSkpfWVsc2UgZD1hLmZpbmlzaGVkV29yayxudWxsIT09ZD8oYS5maW5pc2hlZFdvcms9bnVsbCxhLnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lPWIoZCkpOihhLmZpbmlzaGVkV29yaz1udWxsLGQ9ZyhhLGMpLG51bGwhPT1kJiYocCgpP2EuZmluaXNoZWRXb3JrPWQ6YS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT1iKGQpKSk7R2E9ITF9ZnVuY3Rpb24gcCgpe3JldHVybiBudWxsPT09aWJ8fGliLnRpbWVSZW1haW5pbmcoKT5GZz8hMTpPYz0hMH1mdW5jdGlvbiB2KGEpe251bGw9PT1wYT9EKFwiMjQ2XCIpOnZvaWQgMDtwYS5yZW1haW5pbmdFeHBpcmF0aW9uVGltZT0wO1BifHwoUGI9ITAsUGM9YSl9dmFyIHQ9ZmYoYSksS2I9Z2YoYSksRWU9dC5wb3BIb3N0Q29udGFpbmVyLGw9dC5wb3BIb3N0Q29udGV4dCxsZz10LnJlc2V0SG9zdENvbnRhaW5lcixGZT1iZihhLHQsS2IsdSx5KSx3PUZlLmJlZ2luV29yayxtZz1GZS5iZWdpbkZhaWxlZFdvcmssbmc9Y2YoYSx0LEtiKS5jb21wbGV0ZVdvcms7XG50PWRmKGEsayk7dmFyIHZnPXQuY29tbWl0UmVzZXRUZXh0Q29udGVudCxHZT10LmNvbW1pdFBsYWNlbWVudCx4Zz10LmNvbW1pdERlbGV0aW9uLEhlPXQuY29tbWl0V29yayx6Zz10LmNvbW1pdExpZmVDeWNsZXMsQWc9dC5jb21taXRBdHRhY2hSZWYsd2c9dC5jb21taXREZXRhY2hSZWYsSmU9YS5ub3csSWU9YS5zY2hlZHVsZURlZmVycmVkQ2FsbGJhY2ssQ2c9YS51c2VTeW5jU2NoZWR1bGluZyx1Zz1hLnByZXBhcmVGb3JDb21taXQseWc9YS5yZXNldEFmdGVyQ29tbWl0LEVnPUplKCksTmM9MixqYT0wLG1hPSExLEU9bnVsbCxmYj1udWxsLEo9MCxxPW51bGwsUD1udWxsLG5hPW51bGwsZmE9bnVsbCxiYT1udWxsLGdiPSExLExiPSExLExjPSExLG9hPW51bGwsTT1udWxsLGhiPSExLEdhPSExLHBhPW51bGwsT2I9MCxPYz0hMSxQYj0hMSxQYz1udWxsLGliPW51bGwsa2E9ITEsTmI9ITEsRGc9MUUzLE1iPTAsRmc9MTtyZXR1cm57Y29tcHV0ZUFzeW5jRXhwaXJhdGlvbjpuLGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6eSxcbnNjaGVkdWxlV29yazp1LGJhdGNoZWRVcGRhdGVzOmZ1bmN0aW9uKGEsYil7dmFyIGM9a2E7a2E9ITA7dHJ5e3JldHVybiBhKGIpfWZpbmFsbHl7KGthPWMpfHxHYXx8SSgxLG51bGwpfX0sdW5iYXRjaGVkVXBkYXRlczpmdW5jdGlvbihhKXtpZihrYSYmIU5iKXtOYj0hMDt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e05iPSExfX1yZXR1cm4gYSgpfSxmbHVzaFN5bmM6ZnVuY3Rpb24oYSl7dmFyIGI9a2E7a2E9ITA7dHJ5e2E6e3ZhciBjPWphO2phPTE7dHJ5e3ZhciBkPWEoKTticmVhayBhfWZpbmFsbHl7amE9Y31kPXZvaWQgMH1yZXR1cm4gZH1maW5hbGx5e2thPWIsR2E/RChcIjE4N1wiKTp2b2lkIDAsSSgxLG51bGwpfX0sZGVmZXJyZWRVcGRhdGVzOmZ1bmN0aW9uKGEpe3ZhciBiPWphO2phPW4oKTt0cnl7cmV0dXJuIGEoKX1maW5hbGx5e2phPWJ9fX19XG5mdW5jdGlvbiBqZihhKXtmdW5jdGlvbiBiKGEpe2E9amQoYSk7cmV0dXJuIG51bGw9PT1hP251bGw6YS5zdGF0ZU5vZGV9dmFyIGM9YS5nZXRQdWJsaWNJbnN0YW5jZTthPWhmKGEpO3ZhciBkPWEuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixlPWEuY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcixmPWEuc2NoZWR1bGVXb3JrO3JldHVybntjcmVhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1uZXcgWSgzLG51bGwsMCk7YT17Y3VycmVudDpjLGNvbnRhaW5lckluZm86YSxwZW5kaW5nQ2hpbGRyZW46bnVsbCxyZW1haW5pbmdFeHBpcmF0aW9uVGltZTowLGlzUmVhZHlGb3JDb21taXQ6ITEsZmluaXNoZWRXb3JrOm51bGwsY29udGV4dDpudWxsLHBlbmRpbmdDb250ZXh0Om51bGwsaHlkcmF0ZTpiLG5leHRTY2hlZHVsZWRSb290Om51bGx9O3JldHVybiBjLnN0YXRlTm9kZT1hfSx1cGRhdGVDb250YWluZXI6ZnVuY3Rpb24oYSxiLGMscil7dmFyIGc9Yi5jdXJyZW50O2lmKGMpe2M9XG5jLl9yZWFjdEludGVybmFsRmliZXI7dmFyIGg7Yjp7Mj09PWZkKGMpJiYyPT09Yy50YWc/dm9pZCAwOkQoXCIxNzBcIik7Zm9yKGg9YzszIT09aC50YWc7KXtpZihnZShoKSl7aD1oLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDticmVhayBifShoPWhbXCJyZXR1cm5cIl0pP3ZvaWQgMDpEKFwiMTcxXCIpfWg9aC5zdGF0ZU5vZGUuY29udGV4dH1jPWdlKGMpP2tlKGMsaCk6aH1lbHNlIGM9QztudWxsPT09Yi5jb250ZXh0P2IuY29udGV4dD1jOmIucGVuZGluZ0NvbnRleHQ9YztiPXI7Yj12b2lkIDA9PT1iP251bGw6YjtyPW51bGwhPWEmJm51bGwhPWEudHlwZSYmbnVsbCE9YS50eXBlLnByb3RvdHlwZSYmITA9PT1hLnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudD9kKCk6ZShnKTtDZShnLHtleHBpcmF0aW9uVGltZTpyLHBhcnRpYWxTdGF0ZTp7ZWxlbWVudDphfSxjYWxsYmFjazpiLGlzUmVwbGFjZTohMSxpc0ZvcmNlZDohMSxcbm5leHRDYWxsYmFjazpudWxsLG5leHQ6bnVsbH0pO2YoZyxyKX0sYmF0Y2hlZFVwZGF0ZXM6YS5iYXRjaGVkVXBkYXRlcyx1bmJhdGNoZWRVcGRhdGVzOmEudW5iYXRjaGVkVXBkYXRlcyxkZWZlcnJlZFVwZGF0ZXM6YS5kZWZlcnJlZFVwZGF0ZXMsZmx1c2hTeW5jOmEuZmx1c2hTeW5jLGdldFB1YmxpY1Jvb3RJbnN0YW5jZTpmdW5jdGlvbihhKXthPWEuY3VycmVudDtpZighYS5jaGlsZClyZXR1cm4gbnVsbDtzd2l0Y2goYS5jaGlsZC50YWcpe2Nhc2UgNTpyZXR1cm4gYyhhLmNoaWxkLnN0YXRlTm9kZSk7ZGVmYXVsdDpyZXR1cm4gYS5jaGlsZC5zdGF0ZU5vZGV9fSxmaW5kSG9zdEluc3RhbmNlOmIsZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHM6ZnVuY3Rpb24oYSl7YT1rZChhKTtyZXR1cm4gbnVsbD09PWE/bnVsbDphLnN0YXRlTm9kZX0saW5qZWN0SW50b0RldlRvb2xzOmZ1bmN0aW9uKGEpe3ZhciBjPWEuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7cmV0dXJuIHhlKEEoe30sXG5hLHtmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjpmdW5jdGlvbihhKXtyZXR1cm4gYihhKX0sZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6ZnVuY3Rpb24oYSl7cmV0dXJuIGM/YyhhKTpudWxsfX0pKX19fXZhciBrZj1PYmplY3QuZnJlZXplKHtkZWZhdWx0OmpmfSksbGY9a2YmJmpmfHxrZixtZj1sZltcImRlZmF1bHRcIl0/bGZbXCJkZWZhdWx0XCJdOmxmLG5mPVwib2JqZWN0XCI9PT10eXBlb2YgcGVyZm9ybWFuY2UmJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBwZXJmb3JtYW5jZS5ub3csb2Y9dm9pZCAwO29mPW5mP2Z1bmN0aW9uKCl7cmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpfTpmdW5jdGlvbigpe3JldHVybiBEYXRlLm5vdygpfTt2YXIgcGY9dm9pZCAwO1xuaWYobS5jYW5Vc2VET00paWYoXCJmdW5jdGlvblwiIT09dHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2spe3ZhciBxZj1udWxsLHJmPSExLHNmPSExLHRmPTAsdWY9MzMsdmY9MzMsd2Y7d2Y9bmY/e3RpbWVSZW1haW5pbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGYtcGVyZm9ybWFuY2Uubm93KCl9fTp7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiB0Zi1EYXRlLm5vdygpfX07dmFyIHhmPVwiX19yZWFjdElkbGVDYWxsYmFjayRcIitNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTt3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIixmdW5jdGlvbihhKXthLnNvdXJjZT09PXdpbmRvdyYmYS5kYXRhPT09eGYmJihyZj0hMSxhPXFmLHFmPW51bGwsbnVsbCE9PWEmJmEod2YpKX0sITEpO3ZhciB5Zj1mdW5jdGlvbihhKXtzZj0hMTt2YXIgYj1hLXRmK3ZmO2I8dmYmJnVmPHZmPyg4PmImJihiPTgpLHZmPWI8dWY/dWY6Yik6dWY9Yjt0Zj1hK3ZmO3JmfHwocmY9ITAsXG53aW5kb3cucG9zdE1lc3NhZ2UoeGYsXCIqXCIpKX07cGY9ZnVuY3Rpb24oYSl7cWY9YTtzZnx8KHNmPSEwLHJlcXVlc3RBbmltYXRpb25GcmFtZSh5ZikpO3JldHVybiAwfX1lbHNlIHBmPXJlcXVlc3RJZGxlQ2FsbGJhY2s7ZWxzZSBwZj1mdW5jdGlvbihhKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7YSh7dGltZVJlbWFpbmluZzpmdW5jdGlvbigpe3JldHVybiBJbmZpbml0eX19KX0pO3JldHVybiAwfTtcbnZhciB6Zj0vXls6QS1aX2EtelxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRF1bOkEtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRcXC0uMC05XFx1MDBCN1xcdTAzMDAtXFx1MDM2RlxcdTIwM0YtXFx1MjA0MF0qJC8sQWY9e30sQmY9e307ZnVuY3Rpb24gQ2YoYSl7aWYoQmYuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITA7aWYoQWYuaGFzT3duUHJvcGVydHkoYSkpcmV0dXJuITE7aWYoemYudGVzdChhKSlyZXR1cm4gQmZbYV09ITA7QWZbYV09ITA7cmV0dXJuITF9XG5mdW5jdGlvbiBEZihhLGIsYyl7dmFyIGQ9dWEoYik7aWYoZCYmdGEoYixjKSl7dmFyIGU9ZC5tdXRhdGlvbk1ldGhvZDtlP2UoYSxjKTpudWxsPT1jfHxkLmhhc0Jvb2xlYW5WYWx1ZSYmIWN8fGQuaGFzTnVtZXJpY1ZhbHVlJiZpc05hTihjKXx8ZC5oYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSYmMT5jfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiExPT09Yz9FZihhLGIpOmQubXVzdFVzZVByb3BlcnR5P2FbZC5wcm9wZXJ0eU5hbWVdPWM6KGI9ZC5hdHRyaWJ1dGVOYW1lLChlPWQuYXR0cmlidXRlTmFtZXNwYWNlKT9hLnNldEF0dHJpYnV0ZU5TKGUsYixcIlwiK2MpOmQuaGFzQm9vbGVhblZhbHVlfHxkLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUmJiEwPT09Yz9hLnNldEF0dHJpYnV0ZShiLFwiXCIpOmEuc2V0QXR0cmlidXRlKGIsXCJcIitjKSl9ZWxzZSBGZihhLGIsdGEoYixjKT9jOm51bGwpfVxuZnVuY3Rpb24gRmYoYSxiLGMpe0NmKGIpJiYobnVsbD09Yz9hLnJlbW92ZUF0dHJpYnV0ZShiKTphLnNldEF0dHJpYnV0ZShiLFwiXCIrYykpfWZ1bmN0aW9uIEVmKGEsYil7dmFyIGM9dWEoYik7Yz8oYj1jLm11dGF0aW9uTWV0aG9kKT9iKGEsdm9pZCAwKTpjLm11c3RVc2VQcm9wZXJ0eT9hW2MucHJvcGVydHlOYW1lXT1jLmhhc0Jvb2xlYW5WYWx1ZT8hMTpcIlwiOmEucmVtb3ZlQXR0cmlidXRlKGMuYXR0cmlidXRlTmFtZSk6YS5yZW1vdmVBdHRyaWJ1dGUoYil9XG5mdW5jdGlvbiBHZihhLGIpe3ZhciBjPWIudmFsdWUsZD1iLmNoZWNrZWQ7cmV0dXJuIEEoe3R5cGU6dm9pZCAwLHN0ZXA6dm9pZCAwLG1pbjp2b2lkIDAsbWF4OnZvaWQgMH0sYix7ZGVmYXVsdENoZWNrZWQ6dm9pZCAwLGRlZmF1bHRWYWx1ZTp2b2lkIDAsdmFsdWU6bnVsbCE9Yz9jOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUsY2hlY2tlZDpudWxsIT1kP2Q6YS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkfSl9ZnVuY3Rpb24gSGYoYSxiKXt2YXIgYz1iLmRlZmF1bHRWYWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxDaGVja2VkOm51bGwhPWIuY2hlY2tlZD9iLmNoZWNrZWQ6Yi5kZWZhdWx0Q2hlY2tlZCxpbml0aWFsVmFsdWU6bnVsbCE9Yi52YWx1ZT9iLnZhbHVlOmMsY29udHJvbGxlZDpcImNoZWNrYm94XCI9PT1iLnR5cGV8fFwicmFkaW9cIj09PWIudHlwZT9udWxsIT1iLmNoZWNrZWQ6bnVsbCE9Yi52YWx1ZX19XG5mdW5jdGlvbiBJZihhLGIpe3ZhciBjPWIuY2hlY2tlZDtudWxsIT1jJiZEZihhLFwiY2hlY2tlZFwiLGN8fCExKTtjPWIudmFsdWU7aWYobnVsbCE9YylpZigwPT09YyYmXCJcIj09PWEudmFsdWUpYS52YWx1ZT1cIjBcIjtlbHNlIGlmKFwibnVtYmVyXCI9PT1iLnR5cGUpe2lmKGI9cGFyc2VGbG9hdChhLnZhbHVlKXx8MCxjIT1ifHxjPT1iJiZhLnZhbHVlIT1jKWEudmFsdWU9XCJcIitjfWVsc2UgYS52YWx1ZSE9PVwiXCIrYyYmKGEudmFsdWU9XCJcIitjKTtlbHNlIG51bGw9PWIudmFsdWUmJm51bGwhPWIuZGVmYXVsdFZhbHVlJiZhLmRlZmF1bHRWYWx1ZSE9PVwiXCIrYi5kZWZhdWx0VmFsdWUmJihhLmRlZmF1bHRWYWx1ZT1cIlwiK2IuZGVmYXVsdFZhbHVlKSxudWxsPT1iLmNoZWNrZWQmJm51bGwhPWIuZGVmYXVsdENoZWNrZWQmJihhLmRlZmF1bHRDaGVja2VkPSEhYi5kZWZhdWx0Q2hlY2tlZCl9XG5mdW5jdGlvbiBKZihhLGIpe3N3aXRjaChiLnR5cGUpe2Nhc2UgXCJzdWJtaXRcIjpjYXNlIFwicmVzZXRcIjpicmVhaztjYXNlIFwiY29sb3JcIjpjYXNlIFwiZGF0ZVwiOmNhc2UgXCJkYXRldGltZVwiOmNhc2UgXCJkYXRldGltZS1sb2NhbFwiOmNhc2UgXCJtb250aFwiOmNhc2UgXCJ0aW1lXCI6Y2FzZSBcIndlZWtcIjphLnZhbHVlPVwiXCI7YS52YWx1ZT1hLmRlZmF1bHRWYWx1ZTticmVhaztkZWZhdWx0OmEudmFsdWU9YS52YWx1ZX1iPWEubmFtZTtcIlwiIT09YiYmKGEubmFtZT1cIlwiKTthLmRlZmF1bHRDaGVja2VkPSFhLmRlZmF1bHRDaGVja2VkO2EuZGVmYXVsdENoZWNrZWQ9IWEuZGVmYXVsdENoZWNrZWQ7XCJcIiE9PWImJihhLm5hbWU9Yil9ZnVuY3Rpb24gS2YoYSl7dmFyIGI9XCJcIjthYS5DaGlsZHJlbi5mb3JFYWNoKGEsZnVuY3Rpb24oYSl7bnVsbD09YXx8XCJzdHJpbmdcIiE9PXR5cGVvZiBhJiZcIm51bWJlclwiIT09dHlwZW9mIGF8fChiKz1hKX0pO3JldHVybiBifVxuZnVuY3Rpb24gTGYoYSxiKXthPUEoe2NoaWxkcmVuOnZvaWQgMH0sYik7aWYoYj1LZihiLmNoaWxkcmVuKSlhLmNoaWxkcmVuPWI7cmV0dXJuIGF9ZnVuY3Rpb24gTWYoYSxiLGMsZCl7YT1hLm9wdGlvbnM7aWYoYil7Yj17fTtmb3IodmFyIGU9MDtlPGMubGVuZ3RoO2UrKyliW1wiJFwiK2NbZV1dPSEwO2ZvcihjPTA7YzxhLmxlbmd0aDtjKyspZT1iLmhhc093blByb3BlcnR5KFwiJFwiK2FbY10udmFsdWUpLGFbY10uc2VsZWN0ZWQhPT1lJiYoYVtjXS5zZWxlY3RlZD1lKSxlJiZkJiYoYVtjXS5kZWZhdWx0U2VsZWN0ZWQ9ITApfWVsc2V7Yz1cIlwiK2M7Yj1udWxsO2ZvcihlPTA7ZTxhLmxlbmd0aDtlKyspe2lmKGFbZV0udmFsdWU9PT1jKXthW2VdLnNlbGVjdGVkPSEwO2QmJihhW2VdLmRlZmF1bHRTZWxlY3RlZD0hMCk7cmV0dXJufW51bGwhPT1ifHxhW2VdLmRpc2FibGVkfHwoYj1hW2VdKX1udWxsIT09YiYmKGIuc2VsZWN0ZWQ9ITApfX1cbmZ1bmN0aW9uIE5mKGEsYil7dmFyIGM9Yi52YWx1ZTthLl93cmFwcGVyU3RhdGU9e2luaXRpYWxWYWx1ZTpudWxsIT1jP2M6Yi5kZWZhdWx0VmFsdWUsd2FzTXVsdGlwbGU6ISFiLm11bHRpcGxlfX1mdW5jdGlvbiBPZihhLGIpe251bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RChcIjkxXCIpOnZvaWQgMDtyZXR1cm4gQSh7fSxiLHt2YWx1ZTp2b2lkIDAsZGVmYXVsdFZhbHVlOnZvaWQgMCxjaGlsZHJlbjpcIlwiK2EuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWV9KX1mdW5jdGlvbiBQZihhLGIpe3ZhciBjPWIudmFsdWUsZD1jO251bGw9PWMmJihjPWIuZGVmYXVsdFZhbHVlLGI9Yi5jaGlsZHJlbixudWxsIT1iJiYobnVsbCE9Yz9EKFwiOTJcIik6dm9pZCAwLEFycmF5LmlzQXJyYXkoYikmJigxPj1iLmxlbmd0aD92b2lkIDA6RChcIjkzXCIpLGI9YlswXSksYz1cIlwiK2IpLG51bGw9PWMmJihjPVwiXCIpLGQ9Yyk7YS5fd3JhcHBlclN0YXRlPXtpbml0aWFsVmFsdWU6XCJcIitkfX1cbmZ1bmN0aW9uIFFmKGEsYil7dmFyIGM9Yi52YWx1ZTtudWxsIT1jJiYoYz1cIlwiK2MsYyE9PWEudmFsdWUmJihhLnZhbHVlPWMpLG51bGw9PWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9YykpO251bGwhPWIuZGVmYXVsdFZhbHVlJiYoYS5kZWZhdWx0VmFsdWU9Yi5kZWZhdWx0VmFsdWUpfWZ1bmN0aW9uIFJmKGEpe3ZhciBiPWEudGV4dENvbnRlbnQ7Yj09PWEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUmJihhLnZhbHVlPWIpfXZhciBTZj17aHRtbDpcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWxcIixtYXRobWw6XCJodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MXCIsc3ZnOlwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIn07XG5mdW5jdGlvbiBUZihhKXtzd2l0Y2goYSl7Y2FzZSBcInN2Z1wiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtjYXNlIFwibWF0aFwiOnJldHVyblwiaHR0cDovL3d3dy53My5vcmcvMTk5OC9NYXRoL01hdGhNTFwiO2RlZmF1bHQ6cmV0dXJuXCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCJ9fWZ1bmN0aW9uIFVmKGEsYil7cmV0dXJuIG51bGw9PWF8fFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiPT09YT9UZihiKTpcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI9PT1hJiZcImZvcmVpZ25PYmplY3RcIj09PWI/XCJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hodG1sXCI6YX1cbnZhciBWZj12b2lkIDAsV2Y9ZnVuY3Rpb24oYSl7cmV0dXJuXCJ1bmRlZmluZWRcIiE9PXR5cGVvZiBNU0FwcCYmTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24/ZnVuY3Rpb24oYixjLGQsZSl7TVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24oKXtyZXR1cm4gYShiLGMsZCxlKX0pfTphfShmdW5jdGlvbihhLGIpe2lmKGEubmFtZXNwYWNlVVJJIT09U2Yuc3ZnfHxcImlubmVySFRNTFwiaW4gYSlhLmlubmVySFRNTD1iO2Vsc2V7VmY9VmZ8fGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7VmYuaW5uZXJIVE1MPVwiXFx4M2NzdmdcXHgzZVwiK2IrXCJcXHgzYy9zdmdcXHgzZVwiO2ZvcihiPVZmLmZpcnN0Q2hpbGQ7YS5maXJzdENoaWxkOylhLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCk7Zm9yKDtiLmZpcnN0Q2hpbGQ7KWEuYXBwZW5kQ2hpbGQoYi5maXJzdENoaWxkKX19KSxYZj0vW1wiJyY8Pl0vO1xuZnVuY3Rpb24gWWYoYSxiKXtpZihiKXt2YXIgYz1hLmZpcnN0Q2hpbGQ7aWYoYyYmYz09PWEubGFzdENoaWxkJiYzPT09Yy5ub2RlVHlwZSl7Yy5ub2RlVmFsdWU9YjtyZXR1cm59fWEudGV4dENvbnRlbnQ9Yn1cbm0uY2FuVXNlRE9NJiYoXCJ0ZXh0Q29udGVudFwiaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50fHwoWWY9ZnVuY3Rpb24oYSxiKXtpZigzPT09YS5ub2RlVHlwZSlhLm5vZGVWYWx1ZT1iO2Vsc2V7aWYoXCJib29sZWFuXCI9PT10eXBlb2YgYnx8XCJudW1iZXJcIj09PXR5cGVvZiBiKWI9XCJcIitiO2Vsc2V7Yj1cIlwiK2I7dmFyIGM9WGYuZXhlYyhiKTtpZihjKXt2YXIgZD1cIlwiLGUsZj0wO2ZvcihlPWMuaW5kZXg7ZTxiLmxlbmd0aDtlKyspe3N3aXRjaChiLmNoYXJDb2RlQXQoZSkpe2Nhc2UgMzQ6Yz1cIlxceDI2cXVvdDtcIjticmVhaztjYXNlIDM4OmM9XCJcXHgyNmFtcDtcIjticmVhaztjYXNlIDM5OmM9XCJcXHgyNiN4Mjc7XCI7YnJlYWs7Y2FzZSA2MDpjPVwiXFx4MjZsdDtcIjticmVhaztjYXNlIDYyOmM9XCJcXHgyNmd0O1wiO2JyZWFrO2RlZmF1bHQ6Y29udGludWV9ZiE9PWUmJihkKz1iLnN1YnN0cmluZyhmLGUpKTtmPWUrMTtkKz1jfWI9ZiE9PWU/ZCtiLnN1YnN0cmluZyhmLGUpOmR9fVdmKGEsYil9fSkpO1xudmFyIFpmPVlmLCRmPXthbmltYXRpb25JdGVyYXRpb25Db3VudDohMCxib3JkZXJJbWFnZU91dHNldDohMCxib3JkZXJJbWFnZVNsaWNlOiEwLGJvcmRlckltYWdlV2lkdGg6ITAsYm94RmxleDohMCxib3hGbGV4R3JvdXA6ITAsYm94T3JkaW5hbEdyb3VwOiEwLGNvbHVtbkNvdW50OiEwLGNvbHVtbnM6ITAsZmxleDohMCxmbGV4R3JvdzohMCxmbGV4UG9zaXRpdmU6ITAsZmxleFNocmluazohMCxmbGV4TmVnYXRpdmU6ITAsZmxleE9yZGVyOiEwLGdyaWRSb3c6ITAsZ3JpZFJvd0VuZDohMCxncmlkUm93U3BhbjohMCxncmlkUm93U3RhcnQ6ITAsZ3JpZENvbHVtbjohMCxncmlkQ29sdW1uRW5kOiEwLGdyaWRDb2x1bW5TcGFuOiEwLGdyaWRDb2x1bW5TdGFydDohMCxmb250V2VpZ2h0OiEwLGxpbmVDbGFtcDohMCxsaW5lSGVpZ2h0OiEwLG9wYWNpdHk6ITAsb3JkZXI6ITAsb3JwaGFuczohMCx0YWJTaXplOiEwLHdpZG93czohMCx6SW5kZXg6ITAsem9vbTohMCxmaWxsT3BhY2l0eTohMCxcbmZsb29kT3BhY2l0eTohMCxzdG9wT3BhY2l0eTohMCxzdHJva2VEYXNoYXJyYXk6ITAsc3Ryb2tlRGFzaG9mZnNldDohMCxzdHJva2VNaXRlcmxpbWl0OiEwLHN0cm9rZU9wYWNpdHk6ITAsc3Ryb2tlV2lkdGg6ITB9LGFnPVtcIldlYmtpdFwiLFwibXNcIixcIk1velwiLFwiT1wiXTtPYmplY3Qua2V5cygkZikuZm9yRWFjaChmdW5jdGlvbihhKXthZy5mb3JFYWNoKGZ1bmN0aW9uKGIpe2I9YithLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpK2Euc3Vic3RyaW5nKDEpOyRmW2JdPSRmW2FdfSl9KTtcbmZ1bmN0aW9uIGJnKGEsYil7YT1hLnN0eWxlO2Zvcih2YXIgYyBpbiBiKWlmKGIuaGFzT3duUHJvcGVydHkoYykpe3ZhciBkPTA9PT1jLmluZGV4T2YoXCItLVwiKTt2YXIgZT1jO3ZhciBmPWJbY107ZT1udWxsPT1mfHxcImJvb2xlYW5cIj09PXR5cGVvZiBmfHxcIlwiPT09Zj9cIlwiOmR8fFwibnVtYmVyXCIhPT10eXBlb2YgZnx8MD09PWZ8fCRmLmhhc093blByb3BlcnR5KGUpJiYkZltlXT8oXCJcIitmKS50cmltKCk6ZitcInB4XCI7XCJmbG9hdFwiPT09YyYmKGM9XCJjc3NGbG9hdFwiKTtkP2Euc2V0UHJvcGVydHkoYyxlKTphW2NdPWV9fXZhciBjZz1BKHttZW51aXRlbTohMH0se2FyZWE6ITAsYmFzZTohMCxicjohMCxjb2w6ITAsZW1iZWQ6ITAsaHI6ITAsaW1nOiEwLGlucHV0OiEwLGtleWdlbjohMCxsaW5rOiEwLG1ldGE6ITAscGFyYW06ITAsc291cmNlOiEwLHRyYWNrOiEwLHdicjohMH0pO1xuZnVuY3Rpb24gZGcoYSxiLGMpe2ImJihjZ1thXSYmKG51bGwhPWIuY2hpbGRyZW58fG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw/RChcIjEzN1wiLGEsYygpKTp2b2lkIDApLG51bGwhPWIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJihudWxsIT1iLmNoaWxkcmVuP0QoXCI2MFwiKTp2b2lkIDAsXCJvYmplY3RcIj09PXR5cGVvZiBiLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcIl9faHRtbFwiaW4gYi5kYW5nZXJvdXNseVNldElubmVySFRNTD92b2lkIDA6RChcIjYxXCIpKSxudWxsIT1iLnN0eWxlJiZcIm9iamVjdFwiIT09dHlwZW9mIGIuc3R5bGU/RChcIjYyXCIsYygpKTp2b2lkIDApfVxuZnVuY3Rpb24gZWcoYSxiKXtpZigtMT09PWEuaW5kZXhPZihcIi1cIikpcmV0dXJuXCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzO3N3aXRjaChhKXtjYXNlIFwiYW5ub3RhdGlvbi14bWxcIjpjYXNlIFwiY29sb3ItcHJvZmlsZVwiOmNhc2UgXCJmb250LWZhY2VcIjpjYXNlIFwiZm9udC1mYWNlLXNyY1wiOmNhc2UgXCJmb250LWZhY2UtdXJpXCI6Y2FzZSBcImZvbnQtZmFjZS1mb3JtYXRcIjpjYXNlIFwiZm9udC1mYWNlLW5hbWVcIjpjYXNlIFwibWlzc2luZy1nbHlwaFwiOnJldHVybiExO2RlZmF1bHQ6cmV0dXJuITB9fXZhciBmZz1TZi5odG1sLGdnPUIudGhhdFJldHVybnMoXCJcIik7XG5mdW5jdGlvbiBoZyhhLGIpe2E9OT09PWEubm9kZVR5cGV8fDExPT09YS5ub2RlVHlwZT9hOmEub3duZXJEb2N1bWVudDt2YXIgYz1DZChhKTtiPVFhW2JdO2Zvcih2YXIgZD0wO2Q8Yi5sZW5ndGg7ZCsrKXt2YXIgZT1iW2RdO2MuaGFzT3duUHJvcGVydHkoZSkmJmNbZV18fChcInRvcFdoZWVsXCI9PT1lP3hjKFwid2hlZWxcIik/VShcInRvcFdoZWVsXCIsXCJ3aGVlbFwiLGEpOnhjKFwibW91c2V3aGVlbFwiKT9VKFwidG9wV2hlZWxcIixcIm1vdXNld2hlZWxcIixhKTpVKFwidG9wV2hlZWxcIixcIkRPTU1vdXNlU2Nyb2xsXCIsYSk6XCJ0b3BTY3JvbGxcIj09PWU/cmQoXCJ0b3BTY3JvbGxcIixcInNjcm9sbFwiLGEpOlwidG9wRm9jdXNcIj09PWV8fFwidG9wQmx1clwiPT09ZT8ocmQoXCJ0b3BGb2N1c1wiLFwiZm9jdXNcIixhKSxyZChcInRvcEJsdXJcIixcImJsdXJcIixhKSxjLnRvcEJsdXI9ITAsYy50b3BGb2N1cz0hMCk6XCJ0b3BDYW5jZWxcIj09PWU/KHhjKFwiY2FuY2VsXCIsITApJiZyZChcInRvcENhbmNlbFwiLFwiY2FuY2VsXCIsYSksYy50b3BDYW5jZWw9XG4hMCk6XCJ0b3BDbG9zZVwiPT09ZT8oeGMoXCJjbG9zZVwiLCEwKSYmcmQoXCJ0b3BDbG9zZVwiLFwiY2xvc2VcIixhKSxjLnRvcENsb3NlPSEwKTp5ZC5oYXNPd25Qcm9wZXJ0eShlKSYmVShlLHlkW2VdLGEpLGNbZV09ITApfX1cbnZhciBpZz17dG9wQWJvcnQ6XCJhYm9ydFwiLHRvcENhblBsYXk6XCJjYW5wbGF5XCIsdG9wQ2FuUGxheVRocm91Z2g6XCJjYW5wbGF5dGhyb3VnaFwiLHRvcER1cmF0aW9uQ2hhbmdlOlwiZHVyYXRpb25jaGFuZ2VcIix0b3BFbXB0aWVkOlwiZW1wdGllZFwiLHRvcEVuY3J5cHRlZDpcImVuY3J5cHRlZFwiLHRvcEVuZGVkOlwiZW5kZWRcIix0b3BFcnJvcjpcImVycm9yXCIsdG9wTG9hZGVkRGF0YTpcImxvYWRlZGRhdGFcIix0b3BMb2FkZWRNZXRhZGF0YTpcImxvYWRlZG1ldGFkYXRhXCIsdG9wTG9hZFN0YXJ0OlwibG9hZHN0YXJ0XCIsdG9wUGF1c2U6XCJwYXVzZVwiLHRvcFBsYXk6XCJwbGF5XCIsdG9wUGxheWluZzpcInBsYXlpbmdcIix0b3BQcm9ncmVzczpcInByb2dyZXNzXCIsdG9wUmF0ZUNoYW5nZTpcInJhdGVjaGFuZ2VcIix0b3BTZWVrZWQ6XCJzZWVrZWRcIix0b3BTZWVraW5nOlwic2Vla2luZ1wiLHRvcFN0YWxsZWQ6XCJzdGFsbGVkXCIsdG9wU3VzcGVuZDpcInN1c3BlbmRcIix0b3BUaW1lVXBkYXRlOlwidGltZXVwZGF0ZVwiLHRvcFZvbHVtZUNoYW5nZTpcInZvbHVtZWNoYW5nZVwiLFxudG9wV2FpdGluZzpcIndhaXRpbmdcIn07ZnVuY3Rpb24gamcoYSxiLGMsZCl7Yz05PT09Yy5ub2RlVHlwZT9jOmMub3duZXJEb2N1bWVudDtkPT09ZmcmJihkPVRmKGEpKTtkPT09Zmc/XCJzY3JpcHRcIj09PWE/KGE9Yy5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLGEuaW5uZXJIVE1MPVwiXFx4M2NzY3JpcHRcXHgzZVxceDNjL3NjcmlwdFxceDNlXCIsYT1hLnJlbW92ZUNoaWxkKGEuZmlyc3RDaGlsZCkpOmE9XCJzdHJpbmdcIj09PXR5cGVvZiBiLmlzP2MuY3JlYXRlRWxlbWVudChhLHtpczpiLmlzfSk6Yy5jcmVhdGVFbGVtZW50KGEpOmE9Yy5jcmVhdGVFbGVtZW50TlMoZCxhKTtyZXR1cm4gYX1mdW5jdGlvbiBrZyhhLGIpe3JldHVybig5PT09Yi5ub2RlVHlwZT9iOmIub3duZXJEb2N1bWVudCkuY3JlYXRlVGV4dE5vZGUoYSl9XG5mdW5jdGlvbiBvZyhhLGIsYyxkKXt2YXIgZT1lZyhiLGMpO3N3aXRjaChiKXtjYXNlIFwiaWZyYW1lXCI6Y2FzZSBcIm9iamVjdFwiOlUoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7dmFyIGY9YzticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IoZiBpbiBpZylpZy5oYXNPd25Qcm9wZXJ0eShmKSYmVShmLGlnW2ZdLGEpO2Y9YzticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW1nXCI6Y2FzZSBcImltYWdlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO1UoXCJ0b3BMb2FkXCIsXCJsb2FkXCIsYSk7Zj1jO2JyZWFrO2Nhc2UgXCJmb3JtXCI6VShcInRvcFJlc2V0XCIsXCJyZXNldFwiLGEpO1UoXCJ0b3BTdWJtaXRcIixcInN1Ym1pdFwiLGEpO2Y9YzticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2Y9YzticmVhaztjYXNlIFwiaW5wdXRcIjpIZihhLGMpO2Y9R2YoYSxjKTtVKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO1xuaGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpmPUxmKGEsYyk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOk5mKGEsYyk7Zj1BKHt9LGMse3ZhbHVlOnZvaWQgMH0pO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7aGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlBmKGEsYyk7Zj1PZihhLGMpO1UoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSk7aGcoZCxcIm9uQ2hhbmdlXCIpO2JyZWFrO2RlZmF1bHQ6Zj1jfWRnKGIsZixnZyk7dmFyIGc9ZixrO2ZvcihrIGluIGcpaWYoZy5oYXNPd25Qcm9wZXJ0eShrKSl7dmFyIGg9Z1trXTtcInN0eWxlXCI9PT1rP2JnKGEsaCxnZyk6XCJkYW5nZXJvdXNseVNldElubmVySFRNTFwiPT09az8oaD1oP2guX19odG1sOnZvaWQgMCxudWxsIT1oJiZXZihhLGgpKTpcImNoaWxkcmVuXCI9PT1rP1wic3RyaW5nXCI9PT10eXBlb2YgaD8oXCJ0ZXh0YXJlYVwiIT09Ynx8XCJcIiE9PWgpJiZaZihhLGgpOlwibnVtYmVyXCI9PT10eXBlb2YgaCYmWmYoYSxcblwiXCIraCk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWsmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1rJiZcImF1dG9Gb2N1c1wiIT09ayYmKFBhLmhhc093blByb3BlcnR5KGspP251bGwhPWgmJmhnKGQsayk6ZT9GZihhLGssaCk6bnVsbCE9aCYmRGYoYSxrLGgpKX1zd2l0Y2goYil7Y2FzZSBcImlucHV0XCI6QWMoYSk7SmYoYSxjKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpBYyhhKTtSZihhLGMpO2JyZWFrO2Nhc2UgXCJvcHRpb25cIjpudWxsIT1jLnZhbHVlJiZhLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsYy52YWx1ZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEubXVsdGlwbGU9ISFjLm11bHRpcGxlO2I9Yy52YWx1ZTtudWxsIT1iP01mKGEsISFjLm11bHRpcGxlLGIsITEpOm51bGwhPWMuZGVmYXVsdFZhbHVlJiZNZihhLCEhYy5tdWx0aXBsZSxjLmRlZmF1bHRWYWx1ZSwhMCk7YnJlYWs7ZGVmYXVsdDpcImZ1bmN0aW9uXCI9PT10eXBlb2YgZi5vbkNsaWNrJiYoYS5vbmNsaWNrPVxuQil9fVxuZnVuY3Rpb24gcGcoYSxiLGMsZCxlKXt2YXIgZj1udWxsO3N3aXRjaChiKXtjYXNlIFwiaW5wdXRcIjpjPUdmKGEsYyk7ZD1HZihhLGQpO2Y9W107YnJlYWs7Y2FzZSBcIm9wdGlvblwiOmM9TGYoYSxjKTtkPUxmKGEsZCk7Zj1bXTticmVhaztjYXNlIFwic2VsZWN0XCI6Yz1BKHt9LGMse3ZhbHVlOnZvaWQgMH0pO2Q9QSh7fSxkLHt2YWx1ZTp2b2lkIDB9KTtmPVtdO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOmM9T2YoYSxjKTtkPU9mKGEsZCk7Zj1bXTticmVhaztkZWZhdWx0OlwiZnVuY3Rpb25cIiE9PXR5cGVvZiBjLm9uQ2xpY2smJlwiZnVuY3Rpb25cIj09PXR5cGVvZiBkLm9uQ2xpY2smJihhLm9uY2xpY2s9Qil9ZGcoYixkLGdnKTt2YXIgZyxrO2E9bnVsbDtmb3IoZyBpbiBjKWlmKCFkLmhhc093blByb3BlcnR5KGcpJiZjLmhhc093blByb3BlcnR5KGcpJiZudWxsIT1jW2ddKWlmKFwic3R5bGVcIj09PWcpZm9yKGsgaW4gYj1jW2ddLGIpYi5oYXNPd25Qcm9wZXJ0eShrKSYmKGF8fChhPXt9KSxhW2tdPVxuXCJcIik7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIiE9PWcmJlwiY2hpbGRyZW5cIiE9PWcmJlwic3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nXCIhPT1nJiZcInN1cHByZXNzSHlkcmF0aW9uV2FybmluZ1wiIT09ZyYmXCJhdXRvRm9jdXNcIiE9PWcmJihQYS5oYXNPd25Qcm9wZXJ0eShnKT9mfHwoZj1bXSk6KGY9Znx8W10pLnB1c2goZyxudWxsKSk7Zm9yKGcgaW4gZCl7dmFyIGg9ZFtnXTtiPW51bGwhPWM/Y1tnXTp2b2lkIDA7aWYoZC5oYXNPd25Qcm9wZXJ0eShnKSYmaCE9PWImJihudWxsIT1ofHxudWxsIT1iKSlpZihcInN0eWxlXCI9PT1nKWlmKGIpe2ZvcihrIGluIGIpIWIuaGFzT3duUHJvcGVydHkoayl8fGgmJmguaGFzT3duUHJvcGVydHkoayl8fChhfHwoYT17fSksYVtrXT1cIlwiKTtmb3IoayBpbiBoKWguaGFzT3duUHJvcGVydHkoaykmJmJba10hPT1oW2tdJiYoYXx8KGE9e30pLGFba109aFtrXSl9ZWxzZSBhfHwoZnx8KGY9W10pLGYucHVzaChnLGEpKSxhPWg7ZWxzZVwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PVxuZz8oaD1oP2guX19odG1sOnZvaWQgMCxiPWI/Yi5fX2h0bWw6dm9pZCAwLG51bGwhPWgmJmIhPT1oJiYoZj1mfHxbXSkucHVzaChnLFwiXCIraCkpOlwiY2hpbGRyZW5cIj09PWc/Yj09PWh8fFwic3RyaW5nXCIhPT10eXBlb2YgaCYmXCJudW1iZXJcIiE9PXR5cGVvZiBofHwoZj1mfHxbXSkucHVzaChnLFwiXCIraCk6XCJzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmdcIiE9PWcmJlwic3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nXCIhPT1nJiYoUGEuaGFzT3duUHJvcGVydHkoZyk/KG51bGwhPWgmJmhnKGUsZyksZnx8Yj09PWh8fChmPVtdKSk6KGY9Znx8W10pLnB1c2goZyxoKSl9YSYmKGY9Znx8W10pLnB1c2goXCJzdHlsZVwiLGEpO3JldHVybiBmfVxuZnVuY3Rpb24gcWcoYSxiLGMsZCxlKXtlZyhjLGQpO2Q9ZWcoYyxlKTtmb3IodmFyIGY9MDtmPGIubGVuZ3RoO2YrPTIpe3ZhciBnPWJbZl0saz1iW2YrMV07XCJzdHlsZVwiPT09Zz9iZyhhLGssZ2cpOlwiZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxcIj09PWc/V2YoYSxrKTpcImNoaWxkcmVuXCI9PT1nP1pmKGEsayk6ZD9udWxsIT1rP0ZmKGEsZyxrKTphLnJlbW92ZUF0dHJpYnV0ZShnKTpudWxsIT1rP0RmKGEsZyxrKTpFZihhLGcpfXN3aXRjaChjKXtjYXNlIFwiaW5wdXRcIjpJZihhLGUpO0JjKGEpO2JyZWFrO2Nhc2UgXCJ0ZXh0YXJlYVwiOlFmKGEsZSk7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOmEuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWU9dm9pZCAwLGI9YS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlLGEuX3dyYXBwZXJTdGF0ZS53YXNNdWx0aXBsZT0hIWUubXVsdGlwbGUsYz1lLnZhbHVlLG51bGwhPWM/TWYoYSwhIWUubXVsdGlwbGUsYywhMSk6YiE9PSEhZS5tdWx0aXBsZSYmKG51bGwhPVxuZS5kZWZhdWx0VmFsdWU/TWYoYSwhIWUubXVsdGlwbGUsZS5kZWZhdWx0VmFsdWUsITApOk1mKGEsISFlLm11bHRpcGxlLGUubXVsdGlwbGU/W106XCJcIiwhMSkpfX1cbmZ1bmN0aW9uIHJnKGEsYixjLGQsZSl7c3dpdGNoKGIpe2Nhc2UgXCJpZnJhbWVcIjpjYXNlIFwib2JqZWN0XCI6VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwidmlkZW9cIjpjYXNlIFwiYXVkaW9cIjpmb3IodmFyIGYgaW4gaWcpaWcuaGFzT3duUHJvcGVydHkoZikmJlUoZixpZ1tmXSxhKTticmVhaztjYXNlIFwic291cmNlXCI6VShcInRvcEVycm9yXCIsXCJlcnJvclwiLGEpO2JyZWFrO2Nhc2UgXCJpbWdcIjpjYXNlIFwiaW1hZ2VcIjpVKFwidG9wRXJyb3JcIixcImVycm9yXCIsYSk7VShcInRvcExvYWRcIixcImxvYWRcIixhKTticmVhaztjYXNlIFwiZm9ybVwiOlUoXCJ0b3BSZXNldFwiLFwicmVzZXRcIixhKTtVKFwidG9wU3VibWl0XCIsXCJzdWJtaXRcIixhKTticmVhaztjYXNlIFwiZGV0YWlsc1wiOlUoXCJ0b3BUb2dnbGVcIixcInRvZ2dsZVwiLGEpO2JyZWFrO2Nhc2UgXCJpbnB1dFwiOkhmKGEsYyk7VShcInRvcEludmFsaWRcIixcImludmFsaWRcIixhKTtoZyhlLFwib25DaGFuZ2VcIik7YnJlYWs7Y2FzZSBcInNlbGVjdFwiOk5mKGEsYyk7XG5VKFwidG9wSW52YWxpZFwiLFwiaW52YWxpZFwiLGEpO2hnKGUsXCJvbkNoYW5nZVwiKTticmVhaztjYXNlIFwidGV4dGFyZWFcIjpQZihhLGMpLFUoXCJ0b3BJbnZhbGlkXCIsXCJpbnZhbGlkXCIsYSksaGcoZSxcIm9uQ2hhbmdlXCIpfWRnKGIsYyxnZyk7ZD1udWxsO2Zvcih2YXIgZyBpbiBjKWMuaGFzT3duUHJvcGVydHkoZykmJihmPWNbZ10sXCJjaGlsZHJlblwiPT09Zz9cInN0cmluZ1wiPT09dHlwZW9mIGY/YS50ZXh0Q29udGVudCE9PWYmJihkPVtcImNoaWxkcmVuXCIsZl0pOlwibnVtYmVyXCI9PT10eXBlb2YgZiYmYS50ZXh0Q29udGVudCE9PVwiXCIrZiYmKGQ9W1wiY2hpbGRyZW5cIixcIlwiK2ZdKTpQYS5oYXNPd25Qcm9wZXJ0eShnKSYmbnVsbCE9ZiYmaGcoZSxnKSk7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOkFjKGEpO0pmKGEsYyk7YnJlYWs7Y2FzZSBcInRleHRhcmVhXCI6QWMoYSk7UmYoYSxjKTticmVhaztjYXNlIFwic2VsZWN0XCI6Y2FzZSBcIm9wdGlvblwiOmJyZWFrO2RlZmF1bHQ6XCJmdW5jdGlvblwiPT09dHlwZW9mIGMub25DbGljayYmXG4oYS5vbmNsaWNrPUIpfXJldHVybiBkfWZ1bmN0aW9uIHNnKGEsYil7cmV0dXJuIGEubm9kZVZhbHVlIT09Yn1cbnZhciB0Zz1PYmplY3QuZnJlZXplKHtjcmVhdGVFbGVtZW50OmpnLGNyZWF0ZVRleHROb2RlOmtnLHNldEluaXRpYWxQcm9wZXJ0aWVzOm9nLGRpZmZQcm9wZXJ0aWVzOnBnLHVwZGF0ZVByb3BlcnRpZXM6cWcsZGlmZkh5ZHJhdGVkUHJvcGVydGllczpyZyxkaWZmSHlkcmF0ZWRUZXh0OnNnLHdhcm5Gb3JVbm1hdGNoZWRUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50OmZ1bmN0aW9uKCl7fSx3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OmZ1bmN0aW9uKCl7fSx3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQ6ZnVuY3Rpb24oKXt9LHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDpmdW5jdGlvbigpe30scmVzdG9yZUNvbnRyb2xsZWRTdGF0ZTpmdW5jdGlvbihhLGIsYyl7c3dpdGNoKGIpe2Nhc2UgXCJpbnB1dFwiOklmKGEsYyk7Yj1jLm5hbWU7aWYoXCJyYWRpb1wiPT09Yy50eXBlJiZudWxsIT1iKXtmb3IoYz1hO2MucGFyZW50Tm9kZTspYz1cbmMucGFyZW50Tm9kZTtjPWMucXVlcnlTZWxlY3RvckFsbChcImlucHV0W25hbWVcXHgzZFwiK0pTT04uc3RyaW5naWZ5KFwiXCIrYikrJ11bdHlwZVxceDNkXCJyYWRpb1wiXScpO2ZvcihiPTA7YjxjLmxlbmd0aDtiKyspe3ZhciBkPWNbYl07aWYoZCE9PWEmJmQuZm9ybT09PWEuZm9ybSl7dmFyIGU9cmIoZCk7ZT92b2lkIDA6RChcIjkwXCIpO0lmKGQsZSl9fX1icmVhaztjYXNlIFwidGV4dGFyZWFcIjpRZihhLGMpO2JyZWFrO2Nhc2UgXCJzZWxlY3RcIjpiPWMudmFsdWUsbnVsbCE9YiYmTWYoYSwhIWMubXVsdGlwbGUsYiwhMSl9fX0pO21jLmluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQodGcpO3ZhciBHZz1udWxsLEhnPW51bGw7ZnVuY3Rpb24gSWcoYSl7cmV0dXJuISghYXx8MSE9PWEubm9kZVR5cGUmJjkhPT1hLm5vZGVUeXBlJiYxMSE9PWEubm9kZVR5cGUmJig4IT09YS5ub2RlVHlwZXx8XCIgcmVhY3QtbW91bnQtcG9pbnQtdW5zdGFibGUgXCIhPT1hLm5vZGVWYWx1ZSkpfVxuZnVuY3Rpb24gSmcoYSl7YT1hPzk9PT1hLm5vZGVUeXBlP2EuZG9jdW1lbnRFbGVtZW50OmEuZmlyc3RDaGlsZDpudWxsO3JldHVybiEoIWF8fDEhPT1hLm5vZGVUeXBlfHwhYS5oYXNBdHRyaWJ1dGUoXCJkYXRhLXJlYWN0cm9vdFwiKSl9XG52YXIgWj1tZih7Z2V0Um9vdEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEpe3ZhciBiPWEubm9kZVR5cGU7c3dpdGNoKGIpe2Nhc2UgOTpjYXNlIDExOmE9KGE9YS5kb2N1bWVudEVsZW1lbnQpP2EubmFtZXNwYWNlVVJJOlVmKG51bGwsXCJcIik7YnJlYWs7ZGVmYXVsdDpiPTg9PT1iP2EucGFyZW50Tm9kZTphLGE9Yi5uYW1lc3BhY2VVUkl8fG51bGwsYj1iLnRhZ05hbWUsYT1VZihhLGIpfXJldHVybiBhfSxnZXRDaGlsZEhvc3RDb250ZXh0OmZ1bmN0aW9uKGEsYil7cmV0dXJuIFVmKGEsYil9LGdldFB1YmxpY0luc3RhbmNlOmZ1bmN0aW9uKGEpe3JldHVybiBhfSxwcmVwYXJlRm9yQ29tbWl0OmZ1bmN0aW9uKCl7R2c9b2Q7dmFyIGE9ZGEoKTtpZihGZChhKSl7aWYoXCJzZWxlY3Rpb25TdGFydFwiaW4gYSl2YXIgYj17c3RhcnQ6YS5zZWxlY3Rpb25TdGFydCxlbmQ6YS5zZWxlY3Rpb25FbmR9O2Vsc2UgYTp7dmFyIGM9d2luZG93LmdldFNlbGVjdGlvbiYmd2luZG93LmdldFNlbGVjdGlvbigpO1xuaWYoYyYmMCE9PWMucmFuZ2VDb3VudCl7Yj1jLmFuY2hvck5vZGU7dmFyIGQ9Yy5hbmNob3JPZmZzZXQsZT1jLmZvY3VzTm9kZTtjPWMuZm9jdXNPZmZzZXQ7dHJ5e2Iubm9kZVR5cGUsZS5ub2RlVHlwZX1jYXRjaCh4KXtiPW51bGw7YnJlYWsgYX12YXIgZj0wLGc9LTEsaz0tMSxoPTAscj0wLG49YSx5PW51bGw7Yjpmb3IoOzspe2Zvcih2YXIgdTs7KXtuIT09Ynx8MCE9PWQmJjMhPT1uLm5vZGVUeXBlfHwoZz1mK2QpO24hPT1lfHwwIT09YyYmMyE9PW4ubm9kZVR5cGV8fChrPWYrYyk7Mz09PW4ubm9kZVR5cGUmJihmKz1uLm5vZGVWYWx1ZS5sZW5ndGgpO2lmKG51bGw9PT0odT1uLmZpcnN0Q2hpbGQpKWJyZWFrO3k9bjtuPXV9Zm9yKDs7KXtpZihuPT09YSlicmVhayBiO3k9PT1iJiYrK2g9PT1kJiYoZz1mKTt5PT09ZSYmKytyPT09YyYmKGs9Zik7aWYobnVsbCE9PSh1PW4ubmV4dFNpYmxpbmcpKWJyZWFrO249eTt5PW4ucGFyZW50Tm9kZX1uPXV9Yj0tMT09PWd8fC0xPT09az9udWxsOlxue3N0YXJ0OmcsZW5kOmt9fWVsc2UgYj1udWxsfWI9Ynx8e3N0YXJ0OjAsZW5kOjB9fWVsc2UgYj1udWxsO0hnPXtmb2N1c2VkRWxlbTphLHNlbGVjdGlvblJhbmdlOmJ9O3BkKCExKX0scmVzZXRBZnRlckNvbW1pdDpmdW5jdGlvbigpe3ZhciBhPUhnLGI9ZGEoKSxjPWEuZm9jdXNlZEVsZW0sZD1hLnNlbGVjdGlvblJhbmdlO2lmKGIhPT1jJiZoYShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsYykpe2lmKEZkKGMpKWlmKGI9ZC5zdGFydCxhPWQuZW5kLHZvaWQgMD09PWEmJihhPWIpLFwic2VsZWN0aW9uU3RhcnRcImluIGMpYy5zZWxlY3Rpb25TdGFydD1iLGMuc2VsZWN0aW9uRW5kPU1hdGgubWluKGEsYy52YWx1ZS5sZW5ndGgpO2Vsc2UgaWYod2luZG93LmdldFNlbGVjdGlvbil7Yj13aW5kb3cuZ2V0U2VsZWN0aW9uKCk7dmFyIGU9Y1tEYigpXS5sZW5ndGg7YT1NYXRoLm1pbihkLnN0YXJ0LGUpO2Q9dm9pZCAwPT09ZC5lbmQ/YTpNYXRoLm1pbihkLmVuZCxlKTshYi5leHRlbmQmJmE+XG5kJiYoZT1kLGQ9YSxhPWUpO2U9RWQoYyxhKTt2YXIgZj1FZChjLGQpO2lmKGUmJmYmJigxIT09Yi5yYW5nZUNvdW50fHxiLmFuY2hvck5vZGUhPT1lLm5vZGV8fGIuYW5jaG9yT2Zmc2V0IT09ZS5vZmZzZXR8fGIuZm9jdXNOb2RlIT09Zi5ub2RlfHxiLmZvY3VzT2Zmc2V0IT09Zi5vZmZzZXQpKXt2YXIgZz1kb2N1bWVudC5jcmVhdGVSYW5nZSgpO2cuc2V0U3RhcnQoZS5ub2RlLGUub2Zmc2V0KTtiLnJlbW92ZUFsbFJhbmdlcygpO2E+ZD8oYi5hZGRSYW5nZShnKSxiLmV4dGVuZChmLm5vZGUsZi5vZmZzZXQpKTooZy5zZXRFbmQoZi5ub2RlLGYub2Zmc2V0KSxiLmFkZFJhbmdlKGcpKX19Yj1bXTtmb3IoYT1jO2E9YS5wYXJlbnROb2RlOykxPT09YS5ub2RlVHlwZSYmYi5wdXNoKHtlbGVtZW50OmEsbGVmdDphLnNjcm9sbExlZnQsdG9wOmEuc2Nyb2xsVG9wfSk7aWEoYyk7Zm9yKGM9MDtjPGIubGVuZ3RoO2MrKylhPWJbY10sYS5lbGVtZW50LnNjcm9sbExlZnQ9YS5sZWZ0LGEuZWxlbWVudC5zY3JvbGxUb3A9XG5hLnRvcH1IZz1udWxsO3BkKEdnKTtHZz1udWxsfSxjcmVhdGVJbnN0YW5jZTpmdW5jdGlvbihhLGIsYyxkLGUpe2E9amcoYSxiLGMsZCk7YVtPXT1lO2Fbb2JdPWI7cmV0dXJuIGF9LGFwcGVuZEluaXRpYWxDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGZpbmFsaXplSW5pdGlhbENoaWxkcmVuOmZ1bmN0aW9uKGEsYixjLGQpe29nKGEsYixjLGQpO2E6e3N3aXRjaChiKXtjYXNlIFwiYnV0dG9uXCI6Y2FzZSBcImlucHV0XCI6Y2FzZSBcInNlbGVjdFwiOmNhc2UgXCJ0ZXh0YXJlYVwiOmE9ISFjLmF1dG9Gb2N1czticmVhayBhfWE9ITF9cmV0dXJuIGF9LHByZXBhcmVVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXtyZXR1cm4gcGcoYSxiLGMsZCxlKX0sc2hvdWxkU2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSxiKXtyZXR1cm5cInRleHRhcmVhXCI9PT1hfHxcInN0cmluZ1wiPT09dHlwZW9mIGIuY2hpbGRyZW58fFwibnVtYmVyXCI9PT10eXBlb2YgYi5jaGlsZHJlbnx8XCJvYmplY3RcIj09PVxudHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwmJm51bGwhPT1iLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MJiZcInN0cmluZ1wiPT09dHlwZW9mIGIuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwuX19odG1sfSxzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlOmZ1bmN0aW9uKGEsYil7cmV0dXJuISFiLmhpZGRlbn0sY3JlYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjLGQpe2E9a2coYSxiKTthW09dPWQ7cmV0dXJuIGF9LG5vdzpvZixtdXRhdGlvbjp7Y29tbWl0TW91bnQ6ZnVuY3Rpb24oYSl7YS5mb2N1cygpfSxjb21taXRVcGRhdGU6ZnVuY3Rpb24oYSxiLGMsZCxlKXthW29iXT1lO3FnKGEsYixjLGQsZSl9LHJlc2V0VGV4dENvbnRlbnQ6ZnVuY3Rpb24oYSl7YS50ZXh0Q29udGVudD1cIlwifSxjb21taXRUZXh0VXBkYXRlOmZ1bmN0aW9uKGEsYixjKXthLm5vZGVWYWx1ZT1jfSxhcHBlbmRDaGlsZDpmdW5jdGlvbihhLGIpe2EuYXBwZW5kQ2hpbGQoYil9LGFwcGVuZENoaWxkVG9Db250YWluZXI6ZnVuY3Rpb24oYSxcbmIpezg9PT1hLm5vZGVUeXBlP2EucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoYixhKTphLmFwcGVuZENoaWxkKGIpfSxpbnNlcnRCZWZvcmU6ZnVuY3Rpb24oYSxiLGMpe2EuaW5zZXJ0QmVmb3JlKGIsYyl9LGluc2VydEluQ29udGFpbmVyQmVmb3JlOmZ1bmN0aW9uKGEsYixjKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGIsYyk6YS5pbnNlcnRCZWZvcmUoYixjKX0scmVtb3ZlQ2hpbGQ6ZnVuY3Rpb24oYSxiKXthLnJlbW92ZUNoaWxkKGIpfSxyZW1vdmVDaGlsZEZyb21Db250YWluZXI6ZnVuY3Rpb24oYSxiKXs4PT09YS5ub2RlVHlwZT9hLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoYik6YS5yZW1vdmVDaGlsZChiKX19LGh5ZHJhdGlvbjp7Y2FuSHlkcmF0ZUluc3RhbmNlOmZ1bmN0aW9uKGEsYil7cmV0dXJuIDE9PT1hLm5vZGVUeXBlJiZiLnRvTG93ZXJDYXNlKCk9PT1hLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCl9LGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oYSxcbmIpe3JldHVyblwiXCI9PT1iPyExOjM9PT1hLm5vZGVUeXBlfSxnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5uZXh0U2libGluZzthJiYxIT09YS5ub2RlVHlwZSYmMyE9PWEubm9kZVR5cGU7KWE9YS5uZXh0U2libGluZztyZXR1cm4gYX0sZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ6ZnVuY3Rpb24oYSl7Zm9yKGE9YS5maXJzdENoaWxkO2EmJjEhPT1hLm5vZGVUeXBlJiYzIT09YS5ub2RlVHlwZTspYT1hLm5leHRTaWJsaW5nO3JldHVybiBhfSxoeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2FbT109ZjthW29iXT1jO3JldHVybiByZyhhLGIsYyxlLGQpfSxoeWRyYXRlVGV4dEluc3RhbmNlOmZ1bmN0aW9uKGEsYixjKXthW09dPWM7cmV0dXJuIHNnKGEsYil9LGRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6ZnVuY3Rpb24oKXt9LFxuZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RIeWRyYXRlSW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6ZnVuY3Rpb24oKXt9LGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlOmZ1bmN0aW9uKCl7fSxkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZTpmdW5jdGlvbigpe319LHNjaGVkdWxlRGVmZXJyZWRDYWxsYmFjazpwZix1c2VTeW5jU2NoZWR1bGluZzohMH0pO3FjPVouYmF0Y2hlZFVwZGF0ZXM7XG5mdW5jdGlvbiBLZyhhLGIsYyxkLGUpe0lnKGMpP3ZvaWQgMDpEKFwiMjAwXCIpO3ZhciBmPWMuX3JlYWN0Um9vdENvbnRhaW5lcjtpZihmKVoudXBkYXRlQ29udGFpbmVyKGIsZixhLGUpO2Vsc2V7ZD1kfHxKZyhjKTtpZighZClmb3IoZj12b2lkIDA7Zj1jLmxhc3RDaGlsZDspYy5yZW1vdmVDaGlsZChmKTt2YXIgZz1aLmNyZWF0ZUNvbnRhaW5lcihjLGQpO2Y9Yy5fcmVhY3RSb290Q29udGFpbmVyPWc7Wi51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uKCl7Wi51cGRhdGVDb250YWluZXIoYixnLGEsZSl9KX1yZXR1cm4gWi5nZXRQdWJsaWNSb290SW5zdGFuY2UoZil9ZnVuY3Rpb24gTGcoYSxiKXt2YXIgYz0yPGFyZ3VtZW50cy5sZW5ndGgmJnZvaWQgMCE9PWFyZ3VtZW50c1syXT9hcmd1bWVudHNbMl06bnVsbDtJZyhiKT92b2lkIDA6RChcIjIwMFwiKTtyZXR1cm4gT2UoYSxiLG51bGwsYyl9XG5mdW5jdGlvbiBNZyhhLGIpe3RoaXMuX3JlYWN0Um9vdENvbnRhaW5lcj1aLmNyZWF0ZUNvbnRhaW5lcihhLGIpfU1nLnByb3RvdHlwZS5yZW5kZXI9ZnVuY3Rpb24oYSxiKXtaLnVwZGF0ZUNvbnRhaW5lcihhLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGIpfTtNZy5wcm90b3R5cGUudW5tb3VudD1mdW5jdGlvbihhKXtaLnVwZGF0ZUNvbnRhaW5lcihudWxsLHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcixudWxsLGEpfTtcbnZhciBOZz17Y3JlYXRlUG9ydGFsOkxnLGZpbmRET01Ob2RlOmZ1bmN0aW9uKGEpe2lmKG51bGw9PWEpcmV0dXJuIG51bGw7aWYoMT09PWEubm9kZVR5cGUpcmV0dXJuIGE7dmFyIGI9YS5fcmVhY3RJbnRlcm5hbEZpYmVyO2lmKGIpcmV0dXJuIFouZmluZEhvc3RJbnN0YW5jZShiKTtcImZ1bmN0aW9uXCI9PT10eXBlb2YgYS5yZW5kZXI/RChcIjE4OFwiKTpEKFwiMjEzXCIsT2JqZWN0LmtleXMoYSkpfSxoeWRyYXRlOmZ1bmN0aW9uKGEsYixjKXtyZXR1cm4gS2cobnVsbCxhLGIsITAsYyl9LHJlbmRlcjpmdW5jdGlvbihhLGIsYyl7cmV0dXJuIEtnKG51bGwsYSxiLCExLGMpfSx1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjpmdW5jdGlvbihhLGIsYyxkKXtudWxsPT1hfHx2b2lkIDA9PT1hLl9yZWFjdEludGVybmFsRmliZXI/RChcIjM4XCIpOnZvaWQgMDtyZXR1cm4gS2coYSxiLGMsITEsZCl9LHVubW91bnRDb21wb25lbnRBdE5vZGU6ZnVuY3Rpb24oYSl7SWcoYSk/dm9pZCAwOlxuRChcIjQwXCIpO3JldHVybiBhLl9yZWFjdFJvb3RDb250YWluZXI/KFoudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbigpe0tnKG51bGwsbnVsbCxhLCExLGZ1bmN0aW9uKCl7YS5fcmVhY3RSb290Q29udGFpbmVyPW51bGx9KX0pLCEwKTohMX0sdW5zdGFibGVfY3JlYXRlUG9ydGFsOkxnLHVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzOnNjLHVuc3RhYmxlX2RlZmVycmVkVXBkYXRlczpaLmRlZmVycmVkVXBkYXRlcyxmbHVzaFN5bmM6Wi5mbHVzaFN5bmMsX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6e0V2ZW50UGx1Z2luSHViOm1iLEV2ZW50UGx1Z2luUmVnaXN0cnk6VGEsRXZlbnRQcm9wYWdhdG9yczpCYixSZWFjdENvbnRyb2xsZWRDb21wb25lbnQ6cGMsUmVhY3RET01Db21wb25lbnRUcmVlOnNiLFJlYWN0RE9NRXZlbnRMaXN0ZW5lcjpzZH19O1xuWi5pbmplY3RJbnRvRGV2VG9vbHMoe2ZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOnBiLGJ1bmRsZVR5cGU6MCx2ZXJzaW9uOlwiMTYuMS4wXCIscmVuZGVyZXJQYWNrYWdlTmFtZTpcInJlYWN0LWRvbVwifSk7dmFyIE9nPU9iamVjdC5mcmVlemUoe2RlZmF1bHQ6Tmd9KSxQZz1PZyYmTmd8fE9nO21vZHVsZS5leHBvcnRzPVBnW1wiZGVmYXVsdFwiXT9QZ1tcImRlZmF1bHRcIl06UGc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2Nqcy9yZWFjdC1kb20ucHJvZHVjdGlvbi5taW4uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSBub2RlLlxuICovXG5mdW5jdGlvbiBpc05vZGUob2JqZWN0KSB7XG4gIHZhciBkb2MgPSBvYmplY3QgPyBvYmplY3Qub3duZXJEb2N1bWVudCB8fCBvYmplY3QgOiBkb2N1bWVudDtcbiAgdmFyIGRlZmF1bHRWaWV3ID0gZG9jLmRlZmF1bHRWaWV3IHx8IHdpbmRvdztcbiAgcmV0dXJuICEhKG9iamVjdCAmJiAodHlwZW9mIGRlZmF1bHRWaWV3Lk5vZGUgPT09ICdmdW5jdGlvbicgPyBvYmplY3QgaW5zdGFuY2VvZiBkZWZhdWx0Vmlldy5Ob2RlIDogdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iamVjdC5ub2RlVHlwZSA9PT0gJ251bWJlcicgJiYgdHlwZW9mIG9iamVjdC5ub2RlTmFtZSA9PT0gJ3N0cmluZycpKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2lzTm9kZS5qcyIsIi8qKiBAbGljZW5zZSBSZWFjdCB2MTYuMS4wXG4gKiByZWFjdC1kb20uZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIF9hc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiQxID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcbnZhciBzaGFsbG93RXF1YWwgPSByZXF1aXJlKCdmYmpzL2xpYi9zaGFsbG93RXF1YWwnKTtcbnZhciBjb250YWluc05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9jb250YWluc05vZGUnKTtcbnZhciBmb2N1c05vZGUgPSByZXF1aXJlKCdmYmpzL2xpYi9mb2N1c05vZGUnKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJyk7XG52YXIgaHlwaGVuYXRlU3R5bGVOYW1lID0gcmVxdWlyZSgnZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lJyk7XG52YXIgY2FtZWxpemVTdHlsZU5hbWUgPSByZXF1aXJlKCdmYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZScpO1xuXG4vKipcbiAqIFdBUk5JTkc6IERPIE5PVCBtYW51YWxseSByZXF1aXJlIHRoaXMgbW9kdWxlLlxuICogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBgaW52YXJpYW50KC4uLilgIHVzZWQgYnkgdGhlIGVycm9yIGNvZGUgc3lzdGVtXG4gKiBhbmQgd2lsbCBfb25seV8gYmUgcmVxdWlyZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYmFiZWwgcGFzcy5cbiAqIEl0IGFsd2F5cyB0aHJvd3MuXG4gKi9cblxuIVJlYWN0ID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET00gd2FzIGxvYWRlZCBiZWZvcmUgUmVhY3QuIE1ha2Ugc3VyZSB5b3UgbG9hZCB0aGUgUmVhY3QgcGFja2FnZSBiZWZvcmUgbG9hZGluZyBSZWFjdERPTS4nKSA6IHZvaWQgMDtcblxuLy8gVGhlc2UgYXR0cmlidXRlcyBzaG91bGQgYmUgYWxsIGxvd2VyY2FzZSB0byBhbGxvdyBmb3Jcbi8vIGNhc2UgaW5zZW5zaXRpdmUgY2hlY2tzXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGNoaWxkcmVuOiB0cnVlLFxuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogdHJ1ZSxcbiAgZGVmYXVsdFZhbHVlOiB0cnVlLFxuICBkZWZhdWx0Q2hlY2tlZDogdHJ1ZSxcbiAgaW5uZXJIVE1MOiB0cnVlLFxuICBzdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmc6IHRydWUsXG4gIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZzogdHJ1ZSxcbiAgc3R5bGU6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGNoZWNrTWFzayh2YWx1ZSwgYml0bWFzaykge1xuICByZXR1cm4gKHZhbHVlICYgYml0bWFzaykgPT09IGJpdG1hc2s7XG59XG5cbnZhciBET01Qcm9wZXJ0eUluamVjdGlvbiA9IHtcbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBub3JtYWxpemVkLCBjYW1lbGNhc2VkIHByb3BlcnR5IG5hbWVzIHRvIGEgY29uZmlndXJhdGlvbiB0aGF0XG4gICAqIHNwZWNpZmllcyBob3cgdGhlIGFzc29jaWF0ZWQgRE9NIHByb3BlcnR5IHNob3VsZCBiZSBhY2Nlc3NlZCBvciByZW5kZXJlZC5cbiAgICovXG4gIE1VU1RfVVNFX1BST1BFUlRZOiAweDEsXG4gIEhBU19CT09MRUFOX1ZBTFVFOiAweDQsXG4gIEhBU19OVU1FUklDX1ZBTFVFOiAweDgsXG4gIEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFOiAweDEwIHwgMHg4LFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDIwLFxuICBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUU6IDB4NDAsXG5cbiAgLyoqXG4gICAqIEluamVjdCBzb21lIHNwZWNpYWxpemVkIGtub3dsZWRnZSBhYm91dCB0aGUgRE9NLiBUaGlzIHRha2VzIGEgY29uZmlnIG9iamVjdFxuICAgKiB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01NdXRhdGlvbk1ldGhvZHMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01NdXRhdGlvbk1ldGhvZHMgfHwge307XG5cbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBQcm9wZXJ0aWVzKSB7XG4gICAgICAhIXByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpID8gaW52YXJpYW50KGZhbHNlLCBcImluamVjdERPTVByb3BlcnR5Q29uZmlnKC4uLik6IFlvdSdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnJXMnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5IGluamVjdGluZyB0aGUgc2FtZSBET00gcHJvcGVydHkgY29uZmlnIHR3aWNlLCBvciB5b3UgbWF5IGJlIGluamVjdGluZyB0d28gY29uZmlncyB0aGF0IGhhdmUgY29uZmxpY3RpbmcgcHJvcGVydHkgbmFtZXMuXCIsIHByb3BOYW1lKSA6IHZvaWQgMDtcblxuICAgICAgdmFyIGxvd2VyQ2FzZWQgPSBwcm9wTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHByb3BDb25maWcgPSBQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcblxuICAgICAgdmFyIHByb3BlcnR5SW5mbyA9IHtcbiAgICAgICAgYXR0cmlidXRlTmFtZTogbG93ZXJDYXNlZCxcbiAgICAgICAgYXR0cmlidXRlTmFtZXNwYWNlOiBudWxsLFxuICAgICAgICBwcm9wZXJ0eU5hbWU6IHByb3BOYW1lLFxuICAgICAgICBtdXRhdGlvbk1ldGhvZDogbnVsbCxcblxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX0JPT0xFQU5fVkFMVUUpLFxuICAgICAgICBoYXNOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSksXG4gICAgICAgIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSksXG4gICAgICAgIGhhc1N0cmluZ0Jvb2xlYW5WYWx1ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuICAgICAgIShwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICsgcHJvcGVydHlJbmZvLmhhc051bWVyaWNWYWx1ZSArIHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCBcIkRPTVByb3BlcnR5OiBWYWx1ZSBjYW4gYmUgb25lIG9mIGJvb2xlYW4sIG92ZXJsb2FkZWQgYm9vbGVhbiwgb3IgbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlc1wiLCBwcm9wTmFtZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG5cbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGVOYW1lO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NQXR0cmlidXRlTmFtZXNwYWNlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZSA9IERPTUF0dHJpYnV0ZU5hbWVzcGFjZXNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICBpZiAoRE9NTXV0YXRpb25NZXRob2RzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2QgPSBET01NdXRhdGlvbk1ldGhvZHNbcHJvcE5hbWVdO1xuICAgICAgfVxuXG4gICAgICAvLyBEb3duY2FzZSByZWZlcmVuY2VzIHRvIHdoaXRlbGlzdCBwcm9wZXJ0aWVzIHRvIGNoZWNrIGZvciBtZW1iZXJzaGlwXG4gICAgICAvLyB3aXRob3V0IGNhc2Utc2Vuc2l0aXZpdHkuIFRoaXMgYWxsb3dzIHRoZSB3aGl0ZWxpc3QgdG8gcGljayB1cFxuICAgICAgLy8gYGFsbG93ZnVsbHNjcmVlbmAsIHdoaWNoIHNob3VsZCBiZSB3cml0dGVuIHVzaW5nIHRoZSBwcm9wZXJ0eSBjb25maWd1cmF0aW9uXG4gICAgICAvLyBmb3IgYGFsbG93RnVsbHNjcmVlbmBcbiAgICAgIHByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcblxuLyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgPSBcIjpBLVpfYS16XFxcXHUwMEMwLVxcXFx1MDBENlxcXFx1MDBEOC1cXFxcdTAwRjZcXFxcdTAwRjgtXFxcXHUwMkZGXFxcXHUwMzcwLVxcXFx1MDM3RFxcXFx1MDM3Ri1cXFxcdTFGRkZcXFxcdTIwMEMtXFxcXHUyMDBEXFxcXHUyMDcwLVxcXFx1MjE4RlxcXFx1MkMwMC1cXFxcdTJGRUZcXFxcdTMwMDEtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRkRcIjtcbi8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xudmFyIEFUVFJJQlVURV9OQU1FX0NIQVIgPSBBVFRSSUJVVEVfTkFNRV9TVEFSVF9DSEFSICsgXCJcXFxcLS4wLTlcXFxcdTAwQjdcXFxcdTAzMDAtXFxcXHUwMzZGXFxcXHUyMDNGLVxcXFx1MjA0MFwiO1xuXG5cbnZhciBST09UX0FUVFJJQlVURV9OQU1FID0gJ2RhdGEtcmVhY3Ryb290JztcblxuLyoqXG4gKiBNYXAgZnJvbSBwcm9wZXJ0eSBcInN0YW5kYXJkIG5hbWVcIiB0byBhbiBvYmplY3Qgd2l0aCBpbmZvIGFib3V0IGhvdyB0byBzZXRcbiAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAqXG4gKiBhdHRyaWJ1dGVOYW1lOlxuICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICogYXR0cmlidXRlTmFtZXNwYWNlXG4gKiBwcm9wZXJ0eU5hbWU6XG4gKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICogICBleHRlcm5hbCBmYWN0b3JzLilcbiAqIG11dGF0aW9uTWV0aG9kOlxuICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gKiAgIGluaXRpYWwgcmVuZGVyLlxuICogbXVzdFVzZVByb3BlcnR5OlxuICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBtdXN0IGJlIGFjY2Vzc2VkIGFuZCBtdXRhdGVkIGFzIGFuIG9iamVjdCBwcm9wZXJ0eS5cbiAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gKiBoYXNOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICogICByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6XG4gKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gKiAgIG51bWVyaWMgYW5kIHNob3VsZCBiZSByZW1vdmVkIHdoZW4gc2V0IHRvIGEgZmFsc2V5IHZhbHVlLlxuICogaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZTpcbiAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICogICBSZW1vdmVkIHdoZW4gc3RyaWN0bHkgZXF1YWwgdG8gZmFsc2U7IHByZXNlbnQgd2l0aG91dCBhIHZhbHVlIHdoZW5cbiAqICAgc3RyaWN0bHkgZXF1YWwgdG8gdHJ1ZTsgcHJlc2VudCB3aXRoIGEgdmFsdWUgb3RoZXJ3aXNlLlxuICovXG52YXIgcHJvcGVydGllcyA9IHt9O1xuXG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgcHJvcGVydHkgbmFtZSBpcyBhIHdyaXRlYWJsZSBhdHRyaWJ1dGUuXG4gKiBAbWV0aG9kXG4gKi9cbmZ1bmN0aW9uIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICBpZiAoaXNSZXNlcnZlZFByb3AobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKG5hbWUubGVuZ3RoID4gMiAmJiAobmFtZVswXSA9PT0gJ28nIHx8IG5hbWVbMF0gPT09ICdPJykgJiYgKG5hbWVbMV0gPT09ICduJyB8fCBuYW1lWzFdID09PSAnTicpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpO1xuICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZnVuY3Rpb24sIHN5bWJvbFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5SW5mbyhuYW1lKSB7XG4gIHJldHVybiBwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gcHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNob3VsZEF0dHJpYnV0ZUFjY2VwdEJvb2xlYW5WYWx1ZShuYW1lKSB7XG4gIGlmIChpc1Jlc2VydmVkUHJvcChuYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICByZXR1cm4gcHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzU3RyaW5nQm9vbGVhblZhbHVlIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlO1xuICB9XG4gIHZhciBwcmVmaXggPSBuYW1lLnRvTG93ZXJDYXNlKCkuc2xpY2UoMCwgNSk7XG4gIHJldHVybiBwcmVmaXggPT09ICdkYXRhLScgfHwgcHJlZml4ID09PSAnYXJpYS0nO1xufVxuXG4vKipcbiAqIENoZWNrcyB0byBzZWUgaWYgYSBwcm9wZXJ0eSBuYW1lIGlzIHdpdGhpbiB0aGUgbGlzdCBvZiBwcm9wZXJ0aWVzXG4gKiByZXNlcnZlZCBmb3IgaW50ZXJuYWwgUmVhY3Qgb3BlcmF0aW9ucy4gVGhlc2UgcHJvcGVydGllcyBzaG91bGRcbiAqIG5vdCBiZSBzZXQgb24gYW4gSFRNTCBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn0gSWYgdGhlIG5hbWUgaXMgd2l0aGluIHJlc2VydmVkIHByb3BzXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWRQcm9wKG5hbWUpIHtcbiAgcmV0dXJuIFJFU0VSVkVEX1BST1BTLmhhc093blByb3BlcnR5KG5hbWUpO1xufVxuXG52YXIgaW5qZWN0aW9uID0gRE9NUHJvcGVydHlJbmplY3Rpb247XG5cbnZhciBNVVNUX1VTRV9QUk9QRVJUWSA9IGluamVjdGlvbi5NVVNUX1VTRV9QUk9QRVJUWTtcbnZhciBIQVNfQk9PTEVBTl9WQUxVRSA9IGluamVjdGlvbi5IQVNfQk9PTEVBTl9WQUxVRTtcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IGluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFID0gaW5qZWN0aW9uLkhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRTtcblxudmFyIEhUTUxET01Qcm9wZXJ0eUNvbmZpZyA9IHtcbiAgLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGlzIGxpc3QsIGJlIHN1cmUgdG8gYWxzbyBhZGQgdGhlbSB0b1xuICAvLyB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICAvLyBuYW1lIHdhcm5pbmdzLlxuICBQcm9wZXJ0aWVzOiB7XG4gICAgYWxsb3dGdWxsU2NyZWVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhdXRvRm9jdXM6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBzcGVjaWZpZXMgdGFyZ2V0IGNvbnRleHQgZm9yIGxpbmtzIHdpdGggYHByZWxvYWRgIHR5cGVcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gYXV0b0ZvY3VzIGlzIHBvbHlmaWxsZWQvbm9ybWFsaXplZCBieSBBdXRvRm9jdXNVdGlsc1xuICAgIC8vIGF1dG9Gb2N1czogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b1BsYXk6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNhcHR1cmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGNoZWNrZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgY29sczogSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgY29udGVudEVkaXRhYmxlOiBIQVNfU1RSSU5HX0JPT0xFQU5fVkFMVUUsXG4gICAgY29udHJvbHM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgICdkZWZhdWx0JzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGVmZXI6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGRpc2FibGVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtTm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlkZGVuOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBsb29wOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBDYXV0aW9uOyBgb3B0aW9uLnNlbGVjdGVkYCBpcyBub3QgdXBkYXRlZCBpZiBgc2VsZWN0Lm11bHRpcGxlYCBpc1xuICAgIC8vIGRpc2FibGVkIHdpdGggYHJlbW92ZUF0dHJpYnV0ZWAuXG4gICAgbXVsdGlwbGU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbXV0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcGxheXNJbmxpbmU6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJlYWRPbmx5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXF1aXJlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmV2ZXJzZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHJvd3M6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHNjb3BlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VhbWxlc3M6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNlbGVjdGVkOiBNVVNUX1VTRV9QUk9QRVJUWSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNpemU6IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHN0YXJ0OiBIQVNfTlVNRVJJQ19WQUxVRSxcbiAgICAvLyBzdXBwb3J0IGZvciBwcm9qZWN0aW5nIHJlZ3VsYXIgRE9NIEVsZW1lbnRzIHZpYSBWMSBuYW1lZCBzbG90cyAoIHNoYWRvdyBkb20gKVxuICAgIHNwYW46IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHNwZWxsQ2hlY2s6IEhBU19TVFJJTkdfQk9PTEVBTl9WQUxVRSxcbiAgICAvLyBTdHlsZSBtdXN0IGJlIGV4cGxpY2l0bHkgc2V0IGluIHRoZSBhdHRyaWJ1dGUgbGlzdC4gUmVhY3QgY29tcG9uZW50c1xuICAgIC8vIGV4cGVjdCBhIHN0eWxlIG9iamVjdFxuICAgIHN0eWxlOiAwLFxuICAgIC8vIEtlZXAgaXQgaW4gdGhlIHdoaXRlbGlzdCBiZWNhdXNlIGl0IGlzIGNhc2Utc2Vuc2l0aXZlIGZvciBTVkcuXG4gICAgdGFiSW5kZXg6IDAsXG4gICAgLy8gaXRlbVNjb3BlIGlzIGZvciBmb3IgTWljcm9kYXRhIHN1cHBvcnQuXG4gICAgLy8gU2VlIGh0dHA6Ly9zY2hlbWEub3JnL2RvY3MvZ3MuaHRtbFxuICAgIGl0ZW1TY29wZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgLy8gVGhlc2UgYXR0cmlidXRlcyBtdXN0IHN0YXkgaW4gdGhlIHdoaXRlLWxpc3QgYmVjYXVzZSB0aGV5IGhhdmVcbiAgICAvLyBkaWZmZXJlbnQgYXR0cmlidXRlIG5hbWVzIChzZWUgRE9NQXR0cmlidXRlTmFtZXMgYmVsb3cpXG4gICAgYWNjZXB0Q2hhcnNldDogMCxcbiAgICBjbGFzc05hbWU6IDAsXG4gICAgaHRtbEZvcjogMCxcbiAgICBodHRwRXF1aXY6IDAsXG4gICAgLy8gQXR0cmlidXRlcyB3aXRoIG11dGF0aW9uIG1ldGhvZHMgbXVzdCBiZSBzcGVjaWZpZWQgaW4gdGhlIHdoaXRlbGlzdFxuICAgIC8vIFNldCB0aGUgc3RyaW5nIGJvb2xlYW4gZmxhZyB0byBhbGxvdyB0aGUgYmVoYXZpb3JcbiAgICB2YWx1ZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NTXV0YXRpb25NZXRob2RzOiB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChub2RlLCB2YWx1ZSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUucmVtb3ZlQXR0cmlidXRlKCd2YWx1ZScpO1xuICAgICAgfVxuXG4gICAgICAvLyBOdW1iZXIgaW5wdXRzIGdldCBzcGVjaWFsIHRyZWF0bWVudCBkdWUgdG8gc29tZSBlZGdlIGNhc2VzIGluXG4gICAgICAvLyBDaHJvbWUuIExldCBldmVyeXRoaW5nIGVsc2UgYXNzaWduIHRoZSB2YWx1ZSBhdHRyaWJ1dGUgYXMgbm9ybWFsLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MjUzI2lzc3VlY29tbWVudC0yMzYwNzQzMjZcbiAgICAgIGlmIChub2RlLnR5cGUgIT09ICdudW1iZXInIHx8IG5vZGUuaGFzQXR0cmlidXRlKCd2YWx1ZScpID09PSBmYWxzZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS52YWxpZGl0eSAmJiAhbm9kZS52YWxpZGl0eS5iYWRJbnB1dCAmJiBub2RlLm93bmVyRG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gbm9kZSkge1xuICAgICAgICAvLyBEb24ndCBhc3NpZ24gYW4gYXR0cmlidXRlIGlmIHZhbGlkYXRpb24gcmVwb3J0cyBiYWRcbiAgICAgICAgLy8gaW5wdXQuIENocm9tZSB3aWxsIGNsZWFyIHRoZSB2YWx1ZS4gQWRkaXRpb25hbGx5LCBkb24ndFxuICAgICAgICAvLyBvcGVyYXRlIG9uIGlucHV0cyB0aGF0IGhhdmUgZm9jdXMsIG90aGVyd2lzZSBDaHJvbWUgbWlnaHRcbiAgICAgICAgLy8gc3RyaXAgb2ZmIHRyYWlsaW5nIGRlY2ltYWwgcGxhY2VzIGFuZCBjYXVzZSB0aGUgdXNlcidzXG4gICAgICAgIC8vIGN1cnNvciBwb3NpdGlvbiB0byBqdW1wIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGlucHV0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBJbiBSZWFjdERPTUlucHV0LCB3ZSBoYXZlIGFuIG9uQmx1ciBldmVudCB0aGF0IHdpbGwgdHJpZ2dlclxuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIGFnYWluIHdoZW4gZm9jdXMgaXMgbG9zdC5cbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3ZhbHVlJywgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEgPSBpbmplY3Rpb24uSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFO1xuXG5cbnZhciBOUyA9IHtcbiAgeGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcbiAgeG1sOiAnaHR0cDovL3d3dy53My5vcmcvWE1MLzE5OTgvbmFtZXNwYWNlJ1xufTtcblxuLyoqXG4gKiBUaGlzIGlzIGEgbGlzdCBvZiBhbGwgU1ZHIGF0dHJpYnV0ZXMgdGhhdCBuZWVkIHNwZWNpYWwgY2FzaW5nLFxuICogbmFtZXNwYWNpbmcsIG9yIGJvb2xlYW4gdmFsdWUgYXNzaWdubWVudC5cbiAqXG4gKiBXaGVuIGFkZGluZyBhdHRyaWJ1dGVzIHRvIHRoaXMgbGlzdCwgYmUgc3VyZSB0byBhbHNvIGFkZCB0aGVtIHRvXG4gKiB0aGUgYHBvc3NpYmxlU3RhbmRhcmROYW1lc2AgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdFxuICogbmFtZSB3YXJuaW5ncy5cbiAqXG4gKiBTVkcgQXR0cmlidXRlcyBMaXN0OlxuICogaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRy9hdHRpbmRleC5odG1sXG4gKiBTTUlMIFNwZWM6XG4gKiBodHRwczovL3d3dy53My5vcmcvVFIvc21pbFxuICovXG52YXIgQVRUUlMgPSBbJ2FjY2VudC1oZWlnaHQnLCAnYWxpZ25tZW50LWJhc2VsaW5lJywgJ2FyYWJpYy1mb3JtJywgJ2Jhc2VsaW5lLXNoaWZ0JywgJ2NhcC1oZWlnaHQnLCAnY2xpcC1wYXRoJywgJ2NsaXAtcnVsZScsICdjb2xvci1pbnRlcnBvbGF0aW9uJywgJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdjb2xvci1wcm9maWxlJywgJ2NvbG9yLXJlbmRlcmluZycsICdkb21pbmFudC1iYXNlbGluZScsICdlbmFibGUtYmFja2dyb3VuZCcsICdmaWxsLW9wYWNpdHknLCAnZmlsbC1ydWxlJywgJ2Zsb29kLWNvbG9yJywgJ2Zsb29kLW9wYWNpdHknLCAnZm9udC1mYW1pbHknLCAnZm9udC1zaXplJywgJ2ZvbnQtc2l6ZS1hZGp1c3QnLCAnZm9udC1zdHJldGNoJywgJ2ZvbnQtc3R5bGUnLCAnZm9udC12YXJpYW50JywgJ2ZvbnQtd2VpZ2h0JywgJ2dseXBoLW5hbWUnLCAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCcsICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCcsICdob3Jpei1hZHYteCcsICdob3Jpei1vcmlnaW4teCcsICdpbWFnZS1yZW5kZXJpbmcnLCAnbGV0dGVyLXNwYWNpbmcnLCAnbGlnaHRpbmctY29sb3InLCAnbWFya2VyLWVuZCcsICdtYXJrZXItbWlkJywgJ21hcmtlci1zdGFydCcsICdvdmVybGluZS1wb3NpdGlvbicsICdvdmVybGluZS10aGlja25lc3MnLCAncGFpbnQtb3JkZXInLCAncGFub3NlLTEnLCAncG9pbnRlci1ldmVudHMnLCAncmVuZGVyaW5nLWludGVudCcsICdzaGFwZS1yZW5kZXJpbmcnLCAnc3RvcC1jb2xvcicsICdzdG9wLW9wYWNpdHknLCAnc3RyaWtldGhyb3VnaC1wb3NpdGlvbicsICdzdHJpa2V0aHJvdWdoLXRoaWNrbmVzcycsICdzdHJva2UtZGFzaGFycmF5JywgJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ3N0cm9rZS1saW5lY2FwJywgJ3N0cm9rZS1saW5lam9pbicsICdzdHJva2UtbWl0ZXJsaW1pdCcsICdzdHJva2Utb3BhY2l0eScsICdzdHJva2Utd2lkdGgnLCAndGV4dC1hbmNob3InLCAndGV4dC1kZWNvcmF0aW9uJywgJ3RleHQtcmVuZGVyaW5nJywgJ3VuZGVybGluZS1wb3NpdGlvbicsICd1bmRlcmxpbmUtdGhpY2tuZXNzJywgJ3VuaWNvZGUtYmlkaScsICd1bmljb2RlLXJhbmdlJywgJ3VuaXRzLXBlci1lbScsICd2LWFscGhhYmV0aWMnLCAndi1oYW5naW5nJywgJ3YtaWRlb2dyYXBoaWMnLCAndi1tYXRoZW1hdGljYWwnLCAndmVjdG9yLWVmZmVjdCcsICd2ZXJ0LWFkdi15JywgJ3ZlcnQtb3JpZ2luLXgnLCAndmVydC1vcmlnaW4teScsICd3b3JkLXNwYWNpbmcnLCAnd3JpdGluZy1tb2RlJywgJ3gtaGVpZ2h0JywgJ3hsaW5rOmFjdHVhdGUnLCAneGxpbms6YXJjcm9sZScsICd4bGluazpocmVmJywgJ3hsaW5rOnJvbGUnLCAneGxpbms6c2hvdycsICd4bGluazp0aXRsZScsICd4bGluazp0eXBlJywgJ3htbDpiYXNlJywgJ3htbG5zOnhsaW5rJywgJ3htbDpsYW5nJywgJ3htbDpzcGFjZSddO1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZDogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDEsXG4gICAgcHJlc2VydmVBbHBoYTogSEFTX1NUUklOR19CT09MRUFOX1ZBTFVFJDFcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXM6IHtcbiAgICBhdXRvUmV2ZXJzZTogJ2F1dG9SZXZlcnNlJyxcbiAgICBleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkOiAnZXh0ZXJuYWxSZXNvdXJjZXNSZXF1aXJlZCcsXG4gICAgcHJlc2VydmVBbHBoYTogJ3ByZXNlcnZlQWxwaGEnXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IHtcbiAgICB4bGlua0FjdHVhdGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rQXJjcm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtIcmVmOiBOUy54bGluayxcbiAgICB4bGlua1JvbGU6IE5TLnhsaW5rLFxuICAgIHhsaW5rU2hvdzogTlMueGxpbmssXG4gICAgeGxpbmtUaXRsZTogTlMueGxpbmssXG4gICAgeGxpbmtUeXBlOiBOUy54bGluayxcbiAgICB4bWxCYXNlOiBOUy54bWwsXG4gICAgeG1sTGFuZzogTlMueG1sLFxuICAgIHhtbFNwYWNlOiBOUy54bWxcbiAgfVxufTtcblxudmFyIENBTUVMSVpFID0gL1tcXC1cXDpdKFthLXpdKS9nO1xudmFyIGNhcGl0YWxpemUgPSBmdW5jdGlvbiAodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuWzFdLnRvVXBwZXJDYXNlKCk7XG59O1xuXG5BVFRSUy5mb3JFYWNoKGZ1bmN0aW9uIChvcmlnaW5hbCkge1xuICB2YXIgcmVhY3ROYW1lID0gb3JpZ2luYWwucmVwbGFjZShDQU1FTElaRSwgY2FwaXRhbGl6ZSk7XG5cbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuUHJvcGVydGllc1tyZWFjdE5hbWVdID0gMDtcbiAgU1ZHRE9NUHJvcGVydHlDb25maWcuRE9NQXR0cmlidXRlTmFtZXNbcmVhY3ROYW1lXSA9IG9yaWdpbmFsO1xufSk7XG5cbmluamVjdGlvbi5pbmplY3RET01Qcm9wZXJ0eUNvbmZpZyhIVE1MRE9NUHJvcGVydHlDb25maWcpO1xuaW5qZWN0aW9uLmluamVjdERPTVByb3BlcnR5Q29uZmlnKFNWR0RPTVByb3BlcnR5Q29uZmlnKTtcblxudmFyIFJlYWN0RXJyb3JVdGlscyA9IHtcbiAgLy8gVXNlZCBieSBGaWJlciB0byBzaW11bGF0ZSBhIHRyeS1jYXRjaC5cbiAgX2NhdWdodEVycm9yOiBudWxsLFxuICBfaGFzQ2F1Z2h0RXJyb3I6IGZhbHNlLFxuXG4gIC8vIFVzZWQgYnkgZXZlbnQgc3lzdGVtIHRvIGNhcHR1cmUvcmV0aHJvdyB0aGUgZmlyc3QgZXJyb3IuXG4gIF9yZXRocm93RXJyb3I6IG51bGwsXG4gIF9oYXNSZXRocm93RXJyb3I6IGZhbHNlLFxuXG4gIGluamVjdGlvbjoge1xuICAgIGluamVjdEVycm9yVXRpbHM6IGZ1bmN0aW9uIChpbmplY3RlZEVycm9yVXRpbHMpIHtcbiAgICAgICEodHlwZW9mIGluamVjdGVkRXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2sgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnSW5qZWN0ZWQgaW52b2tlR3VhcmRlZENhbGxiYWNrKCkgbXVzdCBiZSBhIGZ1bmN0aW9uLicpIDogdm9pZCAwO1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW5qZWN0ZWRFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICAgKiBSZXR1cm5zIGFuIGVycm9yIGlmIGl0IHRocm93cywgb3RoZXJ3aXNlIG51bGwuXG4gICAqXG4gICAqIEluIHByb2R1Y3Rpb24sIHRoaXMgaXMgaW1wbGVtZW50ZWQgdXNpbmcgYSB0cnktY2F0Y2guIFRoZSByZWFzb24gd2UgZG9uJ3RcbiAgICogdXNlIGEgdHJ5LWNhdGNoIGRpcmVjdGx5IGlzIHNvIHRoYXQgd2UgY2FuIHN3YXAgb3V0IGEgZGlmZmVyZW50XG4gICAqIGltcGxlbWVudGF0aW9uIGluIERFViBtb2RlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2VcbiAgICogQHBhcmFtIHsqfSBjb250ZXh0IFRoZSBjb250ZXh0IHRvIHVzZSB3aGVuIGNhbGxpbmcgdGhlIGZ1bmN0aW9uXG4gICAqIEBwYXJhbSB7Li4uKn0gYXJncyBBcmd1bWVudHMgZm9yIGZ1bmN0aW9uXG4gICAqL1xuICBpbnZva2VHdWFyZGVkQ2FsbGJhY2s6IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICAvKipcbiAgICogU2FtZSBhcyBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssIGJ1dCBpbnN0ZWFkIG9mIHJldHVybmluZyBhbiBlcnJvciwgaXQgc3RvcmVzXG4gICAqIGl0IGluIGEgZ2xvYmFsIHNvIGl0IGNhbiBiZSByZXRocm93biBieSBgcmV0aHJvd0NhdWdodEVycm9yYCBsYXRlci5cbiAgICogVE9ETzogU2VlIGlmIF9jYXVnaHRFcnJvciBhbmQgX3JldGhyb3dFcnJvciBjYW4gYmUgdW5pZmllZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgb2YgdGhlIGd1YXJkIHRvIHVzZSBmb3IgbG9nZ2luZyBvciBkZWJ1Z2dpbmdcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gICAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBmdW5jdGlvblxuICAgKiBAcGFyYW0gey4uLip9IGFyZ3MgQXJndW1lbnRzIGZvciBmdW5jdGlvblxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrQW5kQ2F0Y2hGaXJzdEVycm9yOiBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yKCkpIHtcbiAgICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yKCk7XG4gICAgICBpZiAoIVJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yKSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzUmV0aHJvd0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9yZXRocm93RXJyb3IgPSBlcnJvcjtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcmV0aHJvd0NhdWdodEVycm9yLmFwcGx5KFJlYWN0RXJyb3JVdGlscywgYXJndW1lbnRzKTtcbiAgfSxcblxuICBoYXNDYXVnaHRFcnJvcjogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yO1xuICB9LFxuXG4gIGNsZWFyQ2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvcikge1xuICAgICAgdmFyIGVycm9yID0gUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvcjtcbiAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdjbGVhckNhdWdodEVycm9yIHdhcyBjYWxsZWQgYnV0IG5vIGVycm9yIHdhcyBjYXB0dXJlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2sgPSBmdW5jdGlvbiAobmFtZSwgZnVuYywgY29udGV4dCwgYSwgYiwgYywgZCwgZSwgZikge1xuICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gZmFsc2U7XG4gIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZnVuY0FyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuICB0cnkge1xuICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc0NhdWdodEVycm9yID0gdHJ1ZTtcbiAgfVxufTtcblxue1xuICAvLyBJbiBERVYgbW9kZSwgd2Ugc3dhcCBvdXQgaW52b2tlR3VhcmRlZENhbGxiYWNrIGZvciBhIHNwZWNpYWwgdmVyc2lvblxuICAvLyB0aGF0IHBsYXlzIG1vcmUgbmljZWx5IHdpdGggdGhlIGJyb3dzZXIncyBEZXZUb29scy4gVGhlIGlkZWEgaXMgdG8gcHJlc2VydmVcbiAgLy8gXCJQYXVzZSBvbiBleGNlcHRpb25zXCIgYmVoYXZpb3IuIEJlY2F1c2UgUmVhY3Qgd3JhcHMgYWxsIHVzZXItcHJvdmlkZWRcbiAgLy8gZnVuY3Rpb25zIGluIGludm9rZUd1YXJkZWRDYWxsYmFjaywgYW5kIHRoZSBwcm9kdWN0aW9uIHZlcnNpb24gb2ZcbiAgLy8gaW52b2tlR3VhcmRlZENhbGxiYWNrIHVzZXMgYSB0cnktY2F0Y2gsIGFsbCB1c2VyIGV4Y2VwdGlvbnMgYXJlIHRyZWF0ZWRcbiAgLy8gbGlrZSBjYXVnaHQgZXhjZXB0aW9ucywgYW5kIHRoZSBEZXZUb29scyB3b24ndCBwYXVzZSB1bmxlc3MgdGhlIGRldmVsb3BlclxuICAvLyB0YWtlcyB0aGUgZXh0cmEgc3RlcCBvZiBlbmFibGluZyBwYXVzZSBvbiBjYXVnaHQgZXhjZXB0aW9ucy4gVGhpcyBpc1xuICAvLyB1bnRpbnR1aXRpdmUsIHRob3VnaCwgYmVjYXVzZSBldmVuIHRob3VnaCBSZWFjdCBoYXMgY2F1Z2h0IHRoZSBlcnJvciwgZnJvbVxuICAvLyB0aGUgZGV2ZWxvcGVyJ3MgcGVyc3BlY3RpdmUsIHRoZSBlcnJvciBpcyB1bmNhdWdodC5cbiAgLy9cbiAgLy8gVG8gcHJlc2VydmUgdGhlIGV4cGVjdGVkIFwiUGF1c2Ugb24gZXhjZXB0aW9uc1wiIGJlaGF2aW9yLCB3ZSBkb24ndCB1c2UgYVxuICAvLyB0cnktY2F0Y2ggaW4gREVWLiBJbnN0ZWFkLCB3ZSBzeW5jaHJvbm91c2x5IGRpc3BhdGNoIGEgZmFrZSBldmVudCB0byBhIGZha2VcbiAgLy8gRE9NIG5vZGUsIGFuZCBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIGZyb20gaW5zaWRlIGFuIGV2ZW50IGhhbmRsZXJcbiAgLy8gZm9yIHRoYXQgZmFrZSBldmVudC4gSWYgdGhlIGNhbGxiYWNrIHRocm93cywgdGhlIGVycm9yIGlzIFwiY2FwdHVyZWRcIiB1c2luZ1xuICAvLyBhIGdsb2JhbCBldmVudCBoYW5kbGVyLiBCdXQgYmVjYXVzZSB0aGUgZXJyb3IgaGFwcGVucyBpbiBhIGRpZmZlcmVudFxuICAvLyBldmVudCBsb29wIGNvbnRleHQsIGl0IGRvZXMgbm90IGludGVycnVwdCB0aGUgbm9ybWFsIHByb2dyYW0gZmxvdy5cbiAgLy8gRWZmZWN0aXZlbHksIHRoaXMgZ2l2ZXMgdXMgdHJ5LWNhdGNoIGJlaGF2aW9yIHdpdGhvdXQgYWN0dWFsbHkgdXNpbmdcbiAgLy8gdHJ5LWNhdGNoLiBOZWF0IVxuXG4gIC8vIENoZWNrIHRoYXQgdGhlIGJyb3dzZXIgc3VwcG9ydHMgdGhlIEFQSXMgd2UgbmVlZCB0byBpbXBsZW1lbnQgb3VyIHNwZWNpYWxcbiAgLy8gREVWIHZlcnNpb24gb2YgaW52b2tlR3VhcmRlZENhbGxiYWNrXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93LmRpc3BhdGNoRXZlbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZmFrZU5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdyZWFjdCcpO1xuXG4gICAgdmFyIGludm9rZUd1YXJkZWRDYWxsYmFja0RldiA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBjb250ZXh0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgICAvLyBLZWVwcyB0cmFjayBvZiB3aGV0aGVyIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrIHRocmV3IGFuIGVycm9yLiBXZVxuICAgICAgLy8gc2V0IHRoaXMgdG8gdHJ1ZSBhdCB0aGUgYmVnaW5uaW5nLCB0aGVuIHNldCBpdCB0byBmYWxzZSByaWdodCBhZnRlclxuICAgICAgLy8gY2FsbGluZyB0aGUgZnVuY3Rpb24uIElmIHRoZSBmdW5jdGlvbiBlcnJvcnMsIGBkaWRFcnJvcmAgd2lsbCBuZXZlciBiZVxuICAgICAgLy8gc2V0IHRvIGZhbHNlLiBUaGlzIHN0cmF0ZWd5IHdvcmtzIGV2ZW4gaWYgdGhlIGJyb3dzZXIgaXMgZmxha3kgYW5kXG4gICAgICAvLyBmYWlscyB0byBjYWxsIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlciwgYmVjYXVzZSBpdCBkb2Vzbid0IHJlbHkgb25cbiAgICAgIC8vIHRoZSBlcnJvciBldmVudCBhdCBhbGwuXG4gICAgICB2YXIgZGlkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAvLyBDcmVhdGUgYW4gZXZlbnQgaGFuZGxlciBmb3Igb3VyIGZha2UgZXZlbnQuIFdlIHdpbGwgc3luY2hyb25vdXNseVxuICAgICAgLy8gZGlzcGF0Y2ggb3VyIGZha2UgZXZlbnQgdXNpbmcgYGRpc3BhdGNoRXZlbnRgLiBJbnNpZGUgdGhlIGhhbmRsZXIsIHdlXG4gICAgICAvLyBjYWxsIHRoZSB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrLlxuICAgICAgdmFyIGZ1bmNBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAzKTtcbiAgICAgIGZ1bmN0aW9uIGNhbGxDYWxsYmFjaygpIHtcbiAgICAgICAgLy8gV2UgaW1tZWRpYXRlbHkgcmVtb3ZlIHRoZSBjYWxsYmFjayBmcm9tIGV2ZW50IGxpc3RlbmVycyBzbyB0aGF0XG4gICAgICAgIC8vIG5lc3RlZCBgaW52b2tlR3VhcmRlZENhbGxiYWNrYCBjYWxscyBkbyBub3QgY2xhc2guIE90aGVyd2lzZSwgYVxuICAgICAgICAvLyBuZXN0ZWQgY2FsbCB3b3VsZCB0cmlnZ2VyIHRoZSBmYWtlIGV2ZW50IGhhbmRsZXJzIG9mIGFueSBjYWxsIGhpZ2hlclxuICAgICAgICAvLyBpbiB0aGUgc3RhY2suXG4gICAgICAgIGZha2VOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZ0VHlwZSwgY2FsbENhbGxiYWNrLCBmYWxzZSk7XG4gICAgICAgIGZ1bmMuYXBwbHkoY29udGV4dCwgZnVuY0FyZ3MpO1xuICAgICAgICBkaWRFcnJvciA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBnbG9iYWwgZXJyb3IgZXZlbnQgaGFuZGxlci4gV2UgdXNlIHRoaXMgdG8gY2FwdHVyZSB0aGUgdmFsdWVcbiAgICAgIC8vIHRoYXQgd2FzIHRocm93bi4gSXQncyBwb3NzaWJsZSB0aGF0IHRoaXMgZXJyb3IgaGFuZGxlciB3aWxsIGZpcmUgbW9yZVxuICAgICAgLy8gdGhhbiBvbmNlOyBmb3IgZXhhbXBsZSwgaWYgbm9uLVJlYWN0IGNvZGUgYWxzbyBjYWxscyBgZGlzcGF0Y2hFdmVudGBcbiAgICAgIC8vIGFuZCBhIGhhbmRsZXIgZm9yIHRoYXQgZXZlbnQgdGhyb3dzLiBXZSBzaG91bGQgYmUgcmVzaWxpZW50IHRvIG1vc3Qgb2ZcbiAgICAgIC8vIHRob3NlIGNhc2VzLiBFdmVuIGlmIG91ciBlcnJvciBldmVudCBoYW5kbGVyIGZpcmVzIG1vcmUgdGhhbiBvbmNlLCB0aGVcbiAgICAgIC8vIGxhc3QgZXJyb3IgZXZlbnQgaXMgYWx3YXlzIHVzZWQuIElmIHRoZSBjYWxsYmFjayBhY3R1YWxseSBkb2VzIGVycm9yLFxuICAgICAgLy8gd2Uga25vdyB0aGF0IHRoZSBsYXN0IGVycm9yIGV2ZW50IGlzIHRoZSBjb3JyZWN0IG9uZSwgYmVjYXVzZSBpdCdzIG5vdFxuICAgICAgLy8gcG9zc2libGUgZm9yIGFueXRoaW5nIGVsc2UgdG8gaGF2ZSBoYXBwZW5lZCBpbiBiZXR3ZWVuIG91ciBjYWxsYmFja1xuICAgICAgLy8gZXJyb3JpbmcgYW5kIHRoZSBjb2RlIHRoYXQgZm9sbG93cyB0aGUgYGRpc3BhdGNoRXZlbnRgIGNhbGwgYmVsb3cuIElmXG4gICAgICAvLyB0aGUgY2FsbGJhY2sgZG9lc24ndCBlcnJvciwgYnV0IHRoZSBlcnJvciBldmVudCB3YXMgZmlyZWQsIHdlIGtub3cgdG9cbiAgICAgIC8vIGlnbm9yZSBpdCBiZWNhdXNlIGBkaWRFcnJvcmAgd2lsbCBiZSBmYWxzZSwgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgICAgdmFyIGVycm9yID0gdm9pZCAwO1xuICAgICAgLy8gVXNlIHRoaXMgdG8gdHJhY2sgd2hldGhlciB0aGUgZXJyb3IgZXZlbnQgaXMgZXZlciBjYWxsZWQuXG4gICAgICB2YXIgZGlkU2V0RXJyb3IgPSBmYWxzZTtcbiAgICAgIHZhciBpc0Nyb3NzT3JpZ2luRXJyb3IgPSBmYWxzZTtcblxuICAgICAgZnVuY3Rpb24gb25FcnJvcihldmVudCkge1xuICAgICAgICBlcnJvciA9IGV2ZW50LmVycm9yO1xuICAgICAgICBkaWRTZXRFcnJvciA9IHRydWU7XG4gICAgICAgIGlmIChlcnJvciA9PT0gbnVsbCAmJiBldmVudC5jb2xubyA9PT0gMCAmJiBldmVudC5saW5lbm8gPT09IDApIHtcbiAgICAgICAgICBpc0Nyb3NzT3JpZ2luRXJyb3IgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIGZha2UgZXZlbnQgdHlwZS5cbiAgICAgIHZhciBldnRUeXBlID0gJ3JlYWN0LScgKyAobmFtZSA/IG5hbWUgOiAnaW52b2tlZ3VhcmRlZGNhbGxiYWNrJyk7XG5cbiAgICAgIC8vIEF0dGFjaCBvdXIgZXZlbnQgaGFuZGxlcnNcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIG9uRXJyb3IpO1xuICAgICAgZmFrZU5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBjYWxsQ2FsbGJhY2ssIGZhbHNlKTtcblxuICAgICAgLy8gU3luY2hyb25vdXNseSBkaXNwYXRjaCBvdXIgZmFrZSBldmVudC4gSWYgdGhlIHVzZXItcHJvdmlkZWQgZnVuY3Rpb25cbiAgICAgIC8vIGVycm9ycywgaXQgd2lsbCB0cmlnZ2VyIG91ciBnbG9iYWwgZXJyb3IgaGFuZGxlci5cbiAgICAgIHZhciBldnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgIGV2dC5pbml0RXZlbnQoZXZ0VHlwZSwgZmFsc2UsIGZhbHNlKTtcbiAgICAgIGZha2VOb2RlLmRpc3BhdGNoRXZlbnQoZXZ0KTtcblxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgIGlmICghZGlkU2V0RXJyb3IpIHtcbiAgICAgICAgICAvLyBUaGUgY2FsbGJhY2sgZXJyb3JlZCwgYnV0IHRoZSBlcnJvciBldmVudCBuZXZlciBmaXJlZC5cbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcignQW4gZXJyb3Igd2FzIHRocm93biBpbnNpZGUgb25lIG9mIHlvdXIgY29tcG9uZW50cywgYnV0IFJlYWN0ICcgKyBcImRvZXNuJ3Qga25vdyB3aGF0IGl0IHdhcy4gVGhpcyBpcyBsaWtlbHkgZHVlIHRvIGJyb3dzZXIgXCIgKyAnZmxha2luZXNzLiBSZWFjdCBkb2VzIGl0cyBiZXN0IHRvIHByZXNlcnZlIHRoZSBcIlBhdXNlIG9uICcgKyAnZXhjZXB0aW9uc1wiIGJlaGF2aW9yIG9mIHRoZSBEZXZUb29scywgd2hpY2ggcmVxdWlyZXMgc29tZSAnICsgXCJERVYtbW9kZSBvbmx5IHRyaWNrcy4gSXQncyBwb3NzaWJsZSB0aGF0IHRoZXNlIGRvbid0IHdvcmsgaW4gXCIgKyAneW91ciBicm93c2VyLiBUcnkgdHJpZ2dlcmluZyB0aGUgZXJyb3IgaW4gcHJvZHVjdGlvbiBtb2RlLCAnICsgJ29yIHN3aXRjaGluZyB0byBhIG1vZGVybiBicm93c2VyLiBJZiB5b3Ugc3VzcGVjdCB0aGF0IHRoaXMgaXMgJyArICdhY3R1YWxseSBhbiBpc3N1ZSB3aXRoIFJlYWN0LCBwbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nyb3NzT3JpZ2luRXJyb3IpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcIkEgY3Jvc3Mtb3JpZ2luIGVycm9yIHdhcyB0aHJvd24uIFJlYWN0IGRvZXNuJ3QgaGF2ZSBhY2Nlc3MgdG8gXCIgKyAndGhlIGFjdHVhbCBlcnJvciBvYmplY3QgaW4gZGV2ZWxvcG1lbnQuICcgKyAnU2VlIGh0dHBzOi8vZmIubWUvcmVhY3QtY3Jvc3NvcmlnaW4tZXJyb3IgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyk7XG4gICAgICAgIH1cbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9oYXNDYXVnaHRFcnJvciA9IHRydWU7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5fY2F1Z2h0RXJyb3IgPSBlcnJvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFJlYWN0RXJyb3JVdGlscy5faGFzQ2F1Z2h0RXJyb3IgPSBmYWxzZTtcbiAgICAgICAgUmVhY3RFcnJvclV0aWxzLl9jYXVnaHRFcnJvciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSBvdXIgZXZlbnQgbGlzdGVuZXJzXG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBvbkVycm9yKTtcbiAgICB9O1xuXG4gICAgaW52b2tlR3VhcmRlZENhbGxiYWNrID0gaW52b2tlR3VhcmRlZENhbGxiYWNrRGV2O1xuICB9XG59XG5cbnZhciByZXRocm93Q2F1Z2h0RXJyb3IgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvcikge1xuICAgIHZhciBlcnJvciA9IFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yO1xuICAgIFJlYWN0RXJyb3JVdGlscy5fcmV0aHJvd0Vycm9yID0gbnVsbDtcbiAgICBSZWFjdEVycm9yVXRpbHMuX2hhc1JldGhyb3dFcnJvciA9IGZhbHNlO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vKipcbiAqIEluamVjdGFibGUgb3JkZXJpbmcgb2YgZXZlbnQgcGx1Z2lucy5cbiAqL1xudmFyIGV2ZW50UGx1Z2luT3JkZXIgPSBudWxsO1xuXG4vKipcbiAqIEluamVjdGFibGUgbWFwcGluZyBmcm9tIG5hbWVzIHRvIGV2ZW50IHBsdWdpbiBtb2R1bGVzLlxuICovXG52YXIgbmFtZXNUb1BsdWdpbnMgPSB7fTtcblxuLyoqXG4gKiBSZWNvbXB1dGVzIHRoZSBwbHVnaW4gbGlzdCB1c2luZyB0aGUgaW5qZWN0ZWQgcGx1Z2lucyBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCkge1xuICBpZiAoIWV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAvLyBXYWl0IHVudGlsIGFuIGBldmVudFBsdWdpbk9yZGVyYCBpcyBpbmplY3RlZC5cbiAgICByZXR1cm47XG4gIH1cbiAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICB2YXIgcGx1Z2luSW5kZXggPSBldmVudFBsdWdpbk9yZGVyLmluZGV4T2YocGx1Z2luTmFtZSk7XG4gICAgIShwbHVnaW5JbmRleCA+IC0xKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiB0aGUgcGx1Z2luIG9yZGVyaW5nLCBgJXNgLicsIHBsdWdpbk5hbWUpIDogdm9pZCAwO1xuICAgIGlmIChwbHVnaW5zW3BsdWdpbkluZGV4XSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgICFwbHVnaW5Nb2R1bGUuZXh0cmFjdEV2ZW50cyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgIG1ldGhvZCwgYnV0IGAlc2AgZG9lcyBub3QuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgcGx1Z2luc1twbHVnaW5JbmRleF0gPSBwbHVnaW5Nb2R1bGU7XG4gICAgdmFyIHB1Ymxpc2hlZEV2ZW50cyA9IHBsdWdpbk1vZHVsZS5ldmVudFR5cGVzO1xuICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBwdWJsaXNoZWRFdmVudHMpIHtcbiAgICAgICFwdWJsaXNoRXZlbnRGb3JQbHVnaW4ocHVibGlzaGVkRXZlbnRzW2V2ZW50TmFtZV0sIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUHVibGlzaGVzIGFuIGV2ZW50IHNvIHRoYXQgaXQgY2FuIGJlIGRpc3BhdGNoZWQgYnkgdGhlIHN1cHBsaWVkIHBsdWdpbi5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgRGlzcGF0Y2ggY29uZmlndXJhdGlvbiBmb3IgdGhlIGV2ZW50LlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBldmVudCB3YXMgc3VjY2Vzc2Z1bGx5IHB1Ymxpc2hlZC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hFdmVudEZvclBsdWdpbihkaXNwYXRjaENvbmZpZywgcGx1Z2luTW9kdWxlLCBldmVudE5hbWUpIHtcbiAgISFldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luSHViOiBNb3JlIHRoYW4gb25lIHBsdWdpbiBhdHRlbXB0ZWQgdG8gcHVibGlzaCB0aGUgc2FtZSBldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiB2b2lkIDA7XG4gIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBwbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBSZWdpc3RyYXRpb24gbmFtZSB0byBhZGQuXG4gKiBAcGFyYW0ge29iamVjdH0gUGx1Z2luTW9kdWxlIFBsdWdpbiBwdWJsaXNoaW5nIHRoZSBldmVudC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHB1Ymxpc2hSZWdpc3RyYXRpb25OYW1lKHJlZ2lzdHJhdGlvbk5hbWUsIHBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgcmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiB2b2lkIDA7XG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlO1xuICByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gcGx1Z2luTW9kdWxlLmV2ZW50VHlwZXNbZXZlbnROYW1lXS5kZXBlbmRlbmNpZXM7XG5cbiAge1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IHJlZ2lzdHJhdGlvbk5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzW2xvd2VyQ2FzZWROYW1lXSA9IHJlZ2lzdHJhdGlvbk5hbWU7XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gJ29uRG91YmxlQ2xpY2snKSB7XG4gICAgICBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLm9uZGJsY2xpY2sgPSByZWdpc3RyYXRpb25OYW1lO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlZ2lzdGVycyBwbHVnaW5zIHNvIHRoYXQgdGhleSBjYW4gZXh0cmFjdCBhbmQgZGlzcGF0Y2ggZXZlbnRzLlxuICpcbiAqIEBzZWUge0V2ZW50UGx1Z2luSHVifVxuICovXG5cbi8qKlxuICogT3JkZXJlZCBsaXN0IG9mIGluamVjdGVkIHBsdWdpbnMuXG4gKi9cbnZhciBwbHVnaW5zID0gW107XG5cbi8qKlxuICogTWFwcGluZyBmcm9tIGV2ZW50IG5hbWUgdG8gZGlzcGF0Y2ggY29uZmlnXG4gKi9cbnZhciBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gcGx1Z2luIG1vZHVsZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSB7fTtcblxuLyoqXG4gKiBNYXBwaW5nIGZyb20gcmVnaXN0cmF0aW9uIG5hbWUgdG8gZXZlbnQgbmFtZVxuICovXG52YXIgcmVnaXN0cmF0aW9uTmFtZURlcGVuZGVuY2llcyA9IHt9O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBsb3dlcmNhc2UgcmVnaXN0cmF0aW9uIG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLFxuICogdXNlZCB0byB3YXJuIGluIHRoZSBjYXNlIG9mIG1pc3NpbmcgZXZlbnQgaGFuZGxlcnMuIEF2YWlsYWJsZVxuICogb25seSBpbiB0cnVlLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xudmFyIHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMgPSB7fTtcbi8vIFRydXN0IHRoZSBkZXZlbG9wZXIgdG8gb25seSB1c2UgcG9zc2libGVSZWdpc3RyYXRpb25OYW1lcyBpbiB0cnVlXG5cbi8qKlxuICogSW5qZWN0cyBhbiBvcmRlcmluZyBvZiBwbHVnaW5zIChieSBwbHVnaW4gbmFtZSkuIFRoaXMgYWxsb3dzIHRoZSBvcmRlcmluZ1xuICogdG8gYmUgZGVjb3VwbGVkIGZyb20gaW5qZWN0aW9uIG9mIHRoZSBhY3R1YWwgcGx1Z2lucyBzbyB0aGF0IG9yZGVyaW5nIGlzXG4gKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAqXG4gKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAqIEBpbnRlcm5hbFxuICogQHNlZSB7RXZlbnRQbHVnaW5IdWIuaW5qZWN0aW9uLmluamVjdEV2ZW50UGx1Z2luT3JkZXJ9XG4gKi9cbmZ1bmN0aW9uIGluamVjdEV2ZW50UGx1Z2luT3JkZXIoaW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyKSB7XG4gICEhZXZlbnRQbHVnaW5PcmRlciA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2luIG9yZGVyaW5nIG1vcmUgdGhhbiBvbmNlLiBZb3UgYXJlIGxpa2VseSB0cnlpbmcgdG8gbG9hZCBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QuJykgOiB2b2lkIDA7XG4gIC8vIENsb25lIHRoZSBvcmRlcmluZyBzbyBpdCBjYW5ub3QgYmUgZHluYW1pY2FsbHkgbXV0YXRlZC5cbiAgZXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gIHJlY29tcHV0ZVBsdWdpbk9yZGVyaW5nKCk7XG59XG5cbi8qKlxuICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gKiBpbiB0aGUgb3JkZXJpbmcgaW5qZWN0ZWQgYnkgYGluamVjdEV2ZW50UGx1Z2luT3JkZXJgLlxuICpcbiAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zIE1hcCBmcm9tIG5hbWVzIHRvIHBsdWdpbiBtb2R1bGVzLlxuICogQGludGVybmFsXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lfVxuICovXG5mdW5jdGlvbiBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUoaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICB2YXIgaXNPcmRlcmluZ0RpcnR5ID0gZmFsc2U7XG4gIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgIGlmICghaW5qZWN0ZWROYW1lc1RvUGx1Z2lucy5oYXNPd25Qcm9wZXJ0eShwbHVnaW5OYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBwbHVnaW5Nb2R1bGUgPSBpbmplY3RlZE5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIGlmICghbmFtZXNUb1BsdWdpbnMuaGFzT3duUHJvcGVydHkocGx1Z2luTmFtZSkgfHwgbmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV0gIT09IHBsdWdpbk1vZHVsZSkge1xuICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgdHdvIGRpZmZlcmVudCBldmVudCBwbHVnaW5zIHVzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiB2b2lkIDA7XG4gICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IHBsdWdpbk1vZHVsZTtcbiAgICAgIGlzT3JkZXJpbmdEaXJ0eSA9IHRydWU7XG4gICAgfVxuICB9XG4gIGlmIChpc09yZGVyaW5nRGlydHkpIHtcbiAgICByZWNvbXB1dGVQbHVnaW5PcmRlcmluZygpO1xuICB9XG59XG5cbnZhciBFdmVudFBsdWdpblJlZ2lzdHJ5ID0gT2JqZWN0LmZyZWV6ZSh7XG5cdHBsdWdpbnM6IHBsdWdpbnMsXG5cdGV2ZW50TmFtZURpc3BhdGNoQ29uZmlnczogZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzLFxuXHRyZWdpc3RyYXRpb25OYW1lTW9kdWxlczogcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cdHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMsXG5cdHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXM6IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXMsXG5cdGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGluamVjdEV2ZW50UGx1Z2luT3JkZXIsXG5cdGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59KTtcblxudmFyIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSBudWxsO1xudmFyIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBudWxsO1xuXG52YXIgaW5qZWN0aW9uJDIgPSB7XG4gIGluamVjdENvbXBvbmVudFRyZWU6IGZ1bmN0aW9uIChJbmplY3RlZCkge1xuICAgIGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlO1xuICAgIGdldEluc3RhbmNlRnJvbU5vZGUgPSBJbmplY3RlZC5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuICAgIGdldE5vZGVGcm9tSW5zdGFuY2UgPSBJbmplY3RlZC5nZXROb2RlRnJvbUluc3RhbmNlO1xuXG4gICAge1xuICAgICAgd2FybmluZyhnZXROb2RlRnJvbUluc3RhbmNlICYmIGdldEluc3RhbmNlRnJvbU5vZGUsICdFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RDb21wb25lbnRUcmVlKC4uLik6IEluamVjdGVkICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZUZyb21JbnN0YW5jZSBvciBnZXRJbnN0YW5jZUZyb21Ob2RlLicpO1xuICAgIH1cbiAgfVxufTtcblxuXG5cblxuXG5cbnZhciB2YWxpZGF0ZUV2ZW50RGlzcGF0Y2hlcztcbntcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSW5zdGFuY2VzID0gZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGxpc3RlbmVyc0xlbiA9IGxpc3RlbmVyc0lzQXJyID8gZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoIDogZGlzcGF0Y2hMaXN0ZW5lcnMgPyAxIDogMDtcblxuICAgIHZhciBpbnN0YW5jZXNJc0FyciA9IEFycmF5LmlzQXJyYXkoZGlzcGF0Y2hJbnN0YW5jZXMpO1xuICAgIHZhciBpbnN0YW5jZXNMZW4gPSBpbnN0YW5jZXNJc0FyciA/IGRpc3BhdGNoSW5zdGFuY2VzLmxlbmd0aCA6IGRpc3BhdGNoSW5zdGFuY2VzID8gMSA6IDA7XG5cbiAgICB3YXJuaW5nKGluc3RhbmNlc0lzQXJyID09PSBsaXN0ZW5lcnNJc0FyciAmJiBpbnN0YW5jZXNMZW4gPT09IGxpc3RlbmVyc0xlbiwgJ0V2ZW50UGx1Z2luVXRpbHM6IEludmFsaWQgYGV2ZW50YC4nKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCB0aGUgZXZlbnQgdG8gdGhlIGxpc3RlbmVyLlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnQgU3ludGhldGljRXZlbnQgdG8gaGFuZGxlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHNpbXVsYXRlZCBJZiB0aGUgZXZlbnQgaXMgc2ltdWxhdGVkIChjaGFuZ2VzIGV4biBiZWhhdmlvcilcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGxpc3RlbmVyIEFwcGxpY2F0aW9uLWxldmVsIGNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IGluc3QgSW50ZXJuYWwgY29tcG9uZW50IGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgaW5zdCkge1xuICB2YXIgdHlwZSA9IGV2ZW50LnR5cGUgfHwgJ3Vua25vd24tZXZlbnQnO1xuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gZ2V0Tm9kZUZyb21JbnN0YW5jZShpbnN0KTtcbiAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFja0FuZENhdGNoRmlyc3RFcnJvcih0eXBlLCBsaXN0ZW5lciwgdW5kZWZpbmVkLCBldmVudCk7XG4gIGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLlxuICovXG5mdW5jdGlvbiBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIoZXZlbnQsIHNpbXVsYXRlZCkge1xuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gIHZhciBkaXNwYXRjaEluc3RhbmNlcyA9IGV2ZW50Ll9kaXNwYXRjaEluc3RhbmNlcztcbiAge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSW5zdGFuY2VzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzW2ldLCBkaXNwYXRjaEluc3RhbmNlc1tpXSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRpc3BhdGNoTGlzdGVuZXJzKSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoKGV2ZW50LCBzaW11bGF0ZWQsIGRpc3BhdGNoTGlzdGVuZXJzLCBkaXNwYXRjaEluc3RhbmNlcyk7XG4gIH1cbiAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gbnVsbDtcbiAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gbnVsbDtcbn1cblxuLyoqXG4gKiBAc2VlIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsXG4gKi9cblxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cblxuXG4vKipcbiAqIEBwYXJhbSB7U3ludGhldGljRXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmZiBudW1iZXIgb2YgZGlzcGF0Y2hlcyBhY2N1bXVsYXRlZCBpcyBncmVhdGVyIHRoYW4gMC5cbiAqL1xuXG4vKipcbiAqIEFjY3VtdWxhdGVzIGl0ZW1zIHRoYXQgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQgaW50byB0aGUgZmlyc3Qgb25lLiBUaGlzXG4gKiBpcyB1c2VkIHRvIGNvbnNlcnZlIG1lbW9yeSBieSBhdm9pZGluZyBhcnJheSBhbGxvY2F0aW9ucywgYW5kIHRodXMgc2FjcmlmaWNlc1xuICogQVBJIGNsZWFubmVzcy4gU2luY2UgYGN1cnJlbnRgIGNhbiBiZSBudWxsIGJlZm9yZSBiZWluZyBwYXNzZWQgaW4gYW5kIG5vdFxuICogbnVsbCBhZnRlciB0aGlzIGZ1bmN0aW9uLCBtYWtlIHN1cmUgdG8gYXNzaWduIGl0IGJhY2sgdG8gYGN1cnJlbnRgOlxuICpcbiAqIGBhID0gYWNjdW11bGF0ZUludG8oYSwgYik7YFxuICpcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBzcGFyaW5nbHkgdXNlZC4gVHJ5IGBhY2N1bXVsYXRlYCBmb3Igc29tZXRoaW5nIGNsZWFuZXIuXG4gKlxuICogQHJldHVybiB7KnxhcnJheTwqPn0gQW4gYWNjdW11bGF0aW9uIG9mIGl0ZW1zLlxuICovXG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVJbnRvKGN1cnJlbnQsIG5leHQpIHtcbiAgIShuZXh0ICE9IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnYWNjdW11bGF0ZUludG8oLi4uKTogQWNjdW11bGF0ZWQgaXRlbXMgbXVzdCBub3QgYmUgbnVsbCBvciB1bmRlZmluZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIHJldHVybiBuZXh0O1xuICB9XG5cbiAgLy8gQm90aCBhcmUgbm90IGVtcHR5LiBXYXJuaW5nOiBOZXZlciBjYWxsIHguY29uY2F0KHkpIHdoZW4geW91IGFyZSBub3RcbiAgLy8gY2VydGFpbiB0aGF0IHggaXMgYW4gQXJyYXkgKHggY291bGQgYmUgYSBzdHJpbmcgd2l0aCBjb25jYXQgbWV0aG9kKS5cbiAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgfVxuICAgIGN1cnJlbnQucHVzaChuZXh0KTtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KG5leHQpKSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge2FycmF5fSBhcnIgYW4gXCJhY2N1bXVsYXRpb25cIiBvZiBpdGVtcyB3aGljaCBpcyBlaXRoZXIgYW4gQXJyYXkgb3JcbiAqIGEgc2luZ2xlIGl0ZW0uIFVzZWZ1bCB3aGVuIHBhaXJlZCB3aXRoIHRoZSBgYWNjdW11bGF0ZWAgbW9kdWxlLiBUaGlzIGlzIGFcbiAqIHNpbXBsZSB1dGlsaXR5IHRoYXQgYWxsb3dzIHVzIHRvIHJlYXNvbiBhYm91dCBhIGNvbGxlY3Rpb24gb2YgaXRlbXMsIGJ1dFxuICogaGFuZGxpbmcgdGhlIGNhc2Ugd2hlbiB0aGVyZSBpcyBleGFjdGx5IG9uZSBpdGVtIChhbmQgd2UgZG8gbm90IG5lZWQgdG9cbiAqIGFsbG9jYXRlIGFuIGFycmF5KS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIGludm9rZWQgd2l0aCBlYWNoIGVsZW1lbnQgb3IgYSBjb2xsZWN0aW9uLlxuICogQHBhcmFtIHs/fSBbc2NvcGVdIFNjb3BlIHVzZWQgYXMgYHRoaXNgIGluIGEgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2hBY2N1bXVsYXRlZChhcnIsIGNiLCBzY29wZSkge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7XG4gICAgYXJyLmZvckVhY2goY2IsIHNjb3BlKTtcbiAgfSBlbHNlIGlmIChhcnIpIHtcbiAgICBjYi5jYWxsKHNjb3BlLCBhcnIpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwgcXVldWUgb2YgZXZlbnRzIHRoYXQgaGF2ZSBhY2N1bXVsYXRlZCB0aGVpciBkaXNwYXRjaGVzIGFuZCBhcmVcbiAqIHdhaXRpbmcgdG8gaGF2ZSB0aGVpciBkaXNwYXRjaGVzIGV4ZWN1dGVkLlxuICovXG52YXIgZXZlbnRRdWV1ZSA9IG51bGw7XG5cbi8qKlxuICogRGlzcGF0Y2hlcyBhbiBldmVudCBhbmQgcmVsZWFzZXMgaXQgYmFjayBpbnRvIHRoZSBwb29sLCB1bmxlc3MgcGVyc2lzdGVudC5cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IGV2ZW50IFN5bnRoZXRpYyBldmVudCB0byBiZSBkaXNwYXRjaGVkLlxuICogQHBhcmFtIHtib29sZWFufSBzaW11bGF0ZWQgSWYgdGhlIGV2ZW50IGlzIHNpbXVsYXRlZCAoY2hhbmdlcyBleG4gYmVoYXZpb3IpXG4gKiBAcHJpdmF0ZVxuICovXG52YXIgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlID0gZnVuY3Rpb24gKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgaWYgKGV2ZW50KSB7XG4gICAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiBpc0ludGVyYWN0aXZlKHRhZykge1xuICByZXR1cm4gdGFnID09PSAnYnV0dG9uJyB8fCB0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAnc2VsZWN0JyB8fCB0YWcgPT09ICd0ZXh0YXJlYSc7XG59XG5cbmZ1bmN0aW9uIHNob3VsZFByZXZlbnRNb3VzZUV2ZW50KG5hbWUsIHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAobmFtZSkge1xuICAgIGNhc2UgJ29uQ2xpY2snOlxuICAgIGNhc2UgJ29uQ2xpY2tDYXB0dXJlJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrJzpcbiAgICBjYXNlICdvbkRvdWJsZUNsaWNrQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZURvd24nOlxuICAgIGNhc2UgJ29uTW91c2VEb3duQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZU1vdmUnOlxuICAgIGNhc2UgJ29uTW91c2VNb3ZlQ2FwdHVyZSc6XG4gICAgY2FzZSAnb25Nb3VzZVVwJzpcbiAgICBjYXNlICdvbk1vdXNlVXBDYXB0dXJlJzpcbiAgICAgIHJldHVybiAhIShwcm9wcy5kaXNhYmxlZCAmJiBpc0ludGVyYWN0aXZlKHR5cGUpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyBhIHVuaWZpZWQgaW50ZXJmYWNlIGZvciBldmVudCBwbHVnaW5zIHRvIGJlIGluc3RhbGxlZCBhbmQgY29uZmlndXJlZC5cbiAqXG4gKiBFdmVudCBwbHVnaW5zIGNhbiBpbXBsZW1lbnQgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqICAgYGV4dHJhY3RFdmVudHNgIHtmdW5jdGlvbihzdHJpbmcsIERPTUV2ZW50VGFyZ2V0LCBzdHJpbmcsIG9iamVjdCk6ICp9XG4gKiAgICAgUmVxdWlyZWQuIFdoZW4gYSB0b3AtbGV2ZWwgZXZlbnQgaXMgZmlyZWQsIHRoaXMgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gKiAgICAgZXh0cmFjdCBzeW50aGV0aWMgZXZlbnRzIHRoYXQgd2lsbCBpbiB0dXJuIGJlIHF1ZXVlZCBhbmQgZGlzcGF0Y2hlZC5cbiAqXG4gKiAgIGBldmVudFR5cGVzYCB7b2JqZWN0fVxuICogICAgIE9wdGlvbmFsLCBwbHVnaW5zIHRoYXQgZmlyZSBldmVudHMgbXVzdCBwdWJsaXNoIGEgbWFwcGluZyBvZiByZWdpc3RyYXRpb25cbiAqICAgICBuYW1lcyB0aGF0IGFyZSB1c2VkIHRvIHJlZ2lzdGVyIGxpc3RlbmVycy4gVmFsdWVzIG9mIHRoaXMgbWFwcGluZyBtdXN0XG4gKiAgICAgYmUgb2JqZWN0cyB0aGF0IGNvbnRhaW4gYHJlZ2lzdHJhdGlvbk5hbWVgIG9yIGBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc2AuXG4gKlxuICogICBgZXhlY3V0ZURpc3BhdGNoYCB7ZnVuY3Rpb24ob2JqZWN0LCBmdW5jdGlvbiwgc3RyaW5nKX1cbiAqICAgICBPcHRpb25hbCwgYWxsb3dzIHBsdWdpbnMgdG8gb3ZlcnJpZGUgaG93IGFuIGV2ZW50IGdldHMgZGlzcGF0Y2hlZC4gQnlcbiAqICAgICBkZWZhdWx0LCB0aGUgbGlzdGVuZXIgaXMgc2ltcGx5IGludm9rZWQuXG4gKlxuICogRWFjaCBwbHVnaW4gdGhhdCBpcyBpbmplY3RlZCBpbnRvIGBFdmVudHNQbHVnaW5IdWJgIGlzIGltbWVkaWF0ZWx5IG9wZXJhYmxlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuXG4vKipcbiAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciBpbmplY3Rpb24kMSA9IHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7YXJyYXl9IEluamVjdGVkRXZlbnRQbHVnaW5PcmRlclxuICAgKiBAcHVibGljXG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbk9yZGVyOiBpbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luc0J5TmFtZTogaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBpbnN0IFRoZSBpbnN0YW5jZSwgd2hpY2ggaXMgdGhlIHNvdXJjZSBvZiBldmVudHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gKiBAcmV0dXJuIHs/ZnVuY3Rpb259IFRoZSBzdG9yZWQgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgdmFyIGxpc3RlbmVyO1xuXG4gIC8vIFRPRE86IHNob3VsZFByZXZlbnRNb3VzZUV2ZW50IGlzIERPTS1zcGVjaWZpYyBhbmQgZGVmaW5pdGVseSBzaG91bGQgbm90XG4gIC8vIGxpdmUgaGVyZTsgbmVlZHMgdG8gYmUgbW92ZWQgdG8gYSBiZXR0ZXIgcGxhY2Ugc29vblxuICB2YXIgc3RhdGVOb2RlID0gaW5zdC5zdGF0ZU5vZGU7XG4gIGlmICghc3RhdGVOb2RlKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcyAoZXg6IG9ubG9hZCBldmVudHMgaW4gaW5jcmVtZW50YWwgbW9kZSkuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgdmFyIHByb3BzID0gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZShzdGF0ZU5vZGUpO1xuICBpZiAoIXByb3BzKSB7XG4gICAgLy8gV29yayBpbiBwcm9ncmVzcy5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBsaXN0ZW5lciA9IHByb3BzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICBpZiAoc2hvdWxkUHJldmVudE1vdXNlRXZlbnQocmVnaXN0cmF0aW9uTmFtZSwgaW5zdC50eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAhKCFsaXN0ZW5lciB8fCB0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpID8gaW52YXJpYW50KGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4nLCByZWdpc3RyYXRpb25OYW1lLCB0eXBlb2YgbGlzdGVuZXIpIDogdm9pZCAwO1xuICByZXR1cm4gbGlzdGVuZXI7XG59XG5cbi8qKlxuICogQWxsb3dzIHJlZ2lzdGVyZWQgcGx1Z2lucyBhbiBvcHBvcnR1bml0eSB0byBleHRyYWN0IGV2ZW50cyBmcm9tIHRvcC1sZXZlbFxuICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICpcbiAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50cztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwbHVnaW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gTm90IGV2ZXJ5IHBsdWdpbiBpbiB0aGUgb3JkZXJpbmcgbWF5IGJlIGxvYWRlZCBhdCBydW50aW1lLlxuICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgaWYgKHBvc3NpYmxlUGx1Z2luKSB7XG4gICAgICB2YXIgZXh0cmFjdGVkRXZlbnRzID0gcG9zc2libGVQbHVnaW4uZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgICBpZiAoZXh0cmFjdGVkRXZlbnRzKSB7XG4gICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cztcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAqIGBwcm9jZXNzRXZlbnRRdWV1ZWAgaXMgaW52b2tlZC5cbiAqXG4gKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBlbnF1ZXVlRXZlbnRzKGV2ZW50cykge1xuICBpZiAoZXZlbnRzKSB7XG4gICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0V2ZW50UXVldWUoc2ltdWxhdGVkKSB7XG4gIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgLy8gZXZlbnRzIGdldCBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nLlxuICB2YXIgcHJvY2Vzc2luZ0V2ZW50UXVldWUgPSBldmVudFF1ZXVlO1xuICBldmVudFF1ZXVlID0gbnVsbDtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlU2ltdWxhdGVkKTtcbiAgfSBlbHNlIHtcbiAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsKTtcbiAgfVxuICAhIWV2ZW50UXVldWUgPyBpbnZhcmlhbnQoZmFsc2UsICdwcm9jZXNzRXZlbnRRdWV1ZSgpOiBBZGRpdGlvbmFsIGV2ZW50cyB3ZXJlIGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcgYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IHZvaWQgMDtcbiAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gIFJlYWN0RXJyb3JVdGlscy5yZXRocm93Q2F1Z2h0RXJyb3IoKTtcbn1cblxudmFyIEV2ZW50UGx1Z2luSHViID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGluamVjdGlvbjogaW5qZWN0aW9uJDEsXG5cdGdldExpc3RlbmVyOiBnZXRMaXN0ZW5lcixcblx0ZXh0cmFjdEV2ZW50czogZXh0cmFjdEV2ZW50cyxcblx0ZW5xdWV1ZUV2ZW50czogZW5xdWV1ZUV2ZW50cyxcblx0cHJvY2Vzc0V2ZW50UXVldWU6IHByb2Nlc3NFdmVudFF1ZXVlXG59KTtcblxudmFyIEluZGV0ZXJtaW5hdGVDb21wb25lbnQgPSAwOyAvLyBCZWZvcmUgd2Uga25vdyB3aGV0aGVyIGl0IGlzIGZ1bmN0aW9uYWwgb3IgY2xhc3NcbnZhciBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDI7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cbnZhciBIb3N0Q29tcG9uZW50ID0gNTtcbnZhciBIb3N0VGV4dCA9IDY7XG52YXIgQ2FsbENvbXBvbmVudCA9IDc7XG52YXIgQ2FsbEhhbmRsZXJQaGFzZSA9IDg7XG52YXIgUmV0dXJuQ29tcG9uZW50ID0gOTtcbnZhciBGcmFnbWVudCA9IDEwO1xuXG52YXIgcmFuZG9tS2V5ID0gTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG52YXIgaW50ZXJuYWxJbnN0YW5jZUtleSA9ICdfX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSQnICsgcmFuZG9tS2V5O1xudmFyIGludGVybmFsRXZlbnRIYW5kbGVyc0tleSA9ICdfX3JlYWN0RXZlbnRIYW5kbGVycyQnICsgcmFuZG9tS2V5O1xuXG5mdW5jdGlvbiBwcmVjYWNoZUZpYmVyTm9kZSQxKGhvc3RJbnN0LCBub2RlKSB7XG4gIG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0gPSBob3N0SW5zdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIGNsb3Nlc3QgUmVhY3RET01Db21wb25lbnQgb3JcbiAqIFJlYWN0RE9NVGV4dENvbXBvbmVudCBpbnN0YW5jZSBhbmNlc3Rvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobm9kZSkge1xuICBpZiAobm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSkge1xuICAgIHJldHVybiBub2RlW2ludGVybmFsSW5zdGFuY2VLZXldO1xuICB9XG5cbiAgLy8gV2FsayB1cCB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGFuIGFuY2VzdG9yIHdob3NlIGluc3RhbmNlIHdlIGhhdmUgY2FjaGVkLlxuICB2YXIgcGFyZW50cyA9IFtdO1xuICB3aGlsZSAoIW5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV0pIHtcbiAgICBwYXJlbnRzLnB1c2gobm9kZSk7XG4gICAgaWYgKG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVG9wIG9mIHRoZSB0cmVlLiBUaGlzIG5vZGUgbXVzdCBub3QgYmUgcGFydCBvZiBhIFJlYWN0IHRyZWUgKG9yIGlzXG4gICAgICAvLyB1bm1vdW50ZWQsIHBvdGVudGlhbGx5KS5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjbG9zZXN0ID0gdm9pZCAwO1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0LnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBpbnN0LnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBJbiBGaWJlciwgdGhpcyB3aWxsIGFsd2F5cyBiZSB0aGUgZGVlcGVzdCByb290LlxuICAgIHJldHVybiBpbnN0O1xuICB9XG4gIGZvciAoOyBub2RlICYmIChpbnN0ID0gbm9kZVtpbnRlcm5hbEluc3RhbmNlS2V5XSk7IG5vZGUgPSBwYXJlbnRzLnBvcCgpKSB7XG4gICAgY2xvc2VzdCA9IGluc3Q7XG4gIH1cblxuICByZXR1cm4gY2xvc2VzdDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIERPTSBub2RlLCByZXR1cm4gdGhlIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogaW5zdGFuY2UsIG9yIG51bGwgaWYgdGhlIG5vZGUgd2FzIG5vdCByZW5kZXJlZCBieSB0aGlzIFJlYWN0LlxuICovXG5mdW5jdGlvbiBnZXRJbnN0YW5jZUZyb21Ob2RlJDEobm9kZSkge1xuICB2YXIgaW5zdCA9IG5vZGVbaW50ZXJuYWxJbnN0YW5jZUtleV07XG4gIGlmIChpbnN0KSB7XG4gICAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIGluc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIFJlYWN0RE9NQ29tcG9uZW50IG9yIFJlYWN0RE9NVGV4dENvbXBvbmVudCwgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nXG4gKiBET00gbm9kZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGluc3QpIHtcbiAgaWYgKGluc3QudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IGluc3QudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIEluIEZpYmVyIHRoaXMsIGlzIGp1c3QgdGhlIHN0YXRlIG5vZGUgcmlnaHQgbm93LiBXZSBhc3N1bWUgaXQgd2lsbCBiZVxuICAgIC8vIGEgaG9zdCBjb21wb25lbnQgb3IgaG9zdCB0ZXh0LlxuICAgIHJldHVybiBpbnN0LnN0YXRlTm9kZTtcbiAgfVxuXG4gIC8vIFdpdGhvdXQgdGhpcyBmaXJzdCBpbnZhcmlhbnQsIHBhc3NpbmcgYSBub24tRE9NLWNvbXBvbmVudCB0cmlnZ2VycyB0aGUgbmV4dFxuICAvLyBpbnZhcmlhbnQgZm9yIGEgbWlzc2luZyBwYXJlbnQsIHdoaWNoIGlzIHN1cGVyIGNvbmZ1c2luZy5cbiAgaW52YXJpYW50KGZhbHNlLCAnZ2V0Tm9kZUZyb21JbnN0YW5jZTogSW52YWxpZCBhcmd1bWVudC4nKTtcbn1cblxuZnVuY3Rpb24gZ2V0RmliZXJDdXJyZW50UHJvcHNGcm9tTm9kZSQxKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGVbaW50ZXJuYWxFdmVudEhhbmRsZXJzS2V5XSB8fCBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVGaWJlclByb3BzJDEobm9kZSwgcHJvcHMpIHtcbiAgbm9kZVtpbnRlcm5hbEV2ZW50SGFuZGxlcnNLZXldID0gcHJvcHM7XG59XG5cbnZhciBSZWFjdERPTUNvbXBvbmVudFRyZWUgPSBPYmplY3QuZnJlZXplKHtcblx0cHJlY2FjaGVGaWJlck5vZGU6IHByZWNhY2hlRmliZXJOb2RlJDEsXG5cdGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlOiBnZXRDbG9zZXN0SW5zdGFuY2VGcm9tTm9kZSxcblx0Z2V0SW5zdGFuY2VGcm9tTm9kZTogZ2V0SW5zdGFuY2VGcm9tTm9kZSQxLFxuXHRnZXROb2RlRnJvbUluc3RhbmNlOiBnZXROb2RlRnJvbUluc3RhbmNlJDEsXG5cdGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGU6IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMSxcblx0dXBkYXRlRmliZXJQcm9wczogdXBkYXRlRmliZXJQcm9wcyQxXG59KTtcblxuZnVuY3Rpb24gZ2V0UGFyZW50KGluc3QpIHtcbiAgZG8ge1xuICAgIGluc3QgPSBpbnN0WydyZXR1cm4nXTtcbiAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgSG9zdFJvb3Qgd2UgbWlnaHQgd2FudCB0byBiYWlsIG91dC5cbiAgICAvLyBUaGF0IGlzIGRlcGVuZGluZyBvbiBpZiB3ZSB3YW50IG5lc3RlZCBzdWJ0cmVlcyAobGF5ZXJzKSB0byBidWJibGVcbiAgICAvLyBldmVudHMgdG8gdGhlaXIgcGFyZW50LiBXZSBjb3VsZCBhbHNvIGdvIHRocm91Z2ggcGFyZW50Tm9kZSBvbiB0aGVcbiAgICAvLyBob3N0IG5vZGUgYnV0IHRoYXQgd291bGRuJ3Qgd29yayBmb3IgUmVhY3QgTmF0aXZlIGFuZCBkb2Vzbid0IGxldCB1c1xuICAgIC8vIGRvIHRoZSBwb3J0YWwgZmVhdHVyZS5cbiAgfSB3aGlsZSAoaW5zdCAmJiBpbnN0LnRhZyAhPT0gSG9zdENvbXBvbmVudCk7XG4gIGlmIChpbnN0KSB7XG4gICAgcmV0dXJuIGluc3Q7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsb3dlc3QgY29tbW9uIGFuY2VzdG9yIG9mIEEgYW5kIEIsIG9yIG51bGwgaWYgdGhleSBhcmUgaW5cbiAqIGRpZmZlcmVudCB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0TG93ZXN0Q29tbW9uQW5jZXN0b3IoaW5zdEEsIGluc3RCKSB7XG4gIHZhciBkZXB0aEEgPSAwO1xuICBmb3IgKHZhciB0ZW1wQSA9IGluc3RBOyB0ZW1wQTsgdGVtcEEgPSBnZXRQYXJlbnQodGVtcEEpKSB7XG4gICAgZGVwdGhBKys7XG4gIH1cbiAgdmFyIGRlcHRoQiA9IDA7XG4gIGZvciAodmFyIHRlbXBCID0gaW5zdEI7IHRlbXBCOyB0ZW1wQiA9IGdldFBhcmVudCh0ZW1wQikpIHtcbiAgICBkZXB0aEIrKztcbiAgfVxuXG4gIC8vIElmIEEgaXMgZGVlcGVyLCBjcmF3bCB1cC5cbiAgd2hpbGUgKGRlcHRoQSAtIGRlcHRoQiA+IDApIHtcbiAgICBpbnN0QSA9IGdldFBhcmVudChpbnN0QSk7XG4gICAgZGVwdGhBLS07XG4gIH1cblxuICAvLyBJZiBCIGlzIGRlZXBlciwgY3Jhd2wgdXAuXG4gIHdoaWxlIChkZXB0aEIgLSBkZXB0aEEgPiAwKSB7XG4gICAgaW5zdEIgPSBnZXRQYXJlbnQoaW5zdEIpO1xuICAgIGRlcHRoQi0tO1xuICB9XG5cbiAgLy8gV2FsayBpbiBsb2Nrc3RlcCB1bnRpbCB3ZSBmaW5kIGEgbWF0Y2guXG4gIHZhciBkZXB0aCA9IGRlcHRoQTtcbiAgd2hpbGUgKGRlcHRoLS0pIHtcbiAgICBpZiAoaW5zdEEgPT09IGluc3RCIHx8IGluc3RBID09PSBpbnN0Qi5hbHRlcm5hdGUpIHtcbiAgICAgIHJldHVybiBpbnN0QTtcbiAgICB9XG4gICAgaW5zdEEgPSBnZXRQYXJlbnQoaW5zdEEpO1xuICAgIGluc3RCID0gZ2V0UGFyZW50KGluc3RCKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gaWYgQSBpcyBhbiBhbmNlc3RvciBvZiBCLlxuICovXG5cblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBhcmVudCBpbnN0YW5jZSBvZiB0aGUgcGFzc2VkLWluIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnRJbnN0YW5jZShpbnN0KSB7XG4gIHJldHVybiBnZXRQYXJlbnQoaW5zdCk7XG59XG5cbi8qKlxuICogU2ltdWxhdGVzIHRoZSB0cmF2ZXJzYWwgb2YgYSB0d28tcGhhc2UsIGNhcHR1cmUvYnViYmxlIGV2ZW50IGRpc3BhdGNoLlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZVR3b1BoYXNlKGluc3QsIGZuLCBhcmcpIHtcbiAgdmFyIHBhdGggPSBbXTtcbiAgd2hpbGUgKGluc3QpIHtcbiAgICBwYXRoLnB1c2goaW5zdCk7XG4gICAgaW5zdCA9IGdldFBhcmVudChpbnN0KTtcbiAgfVxuICB2YXIgaTtcbiAgZm9yIChpID0gcGF0aC5sZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgZm4ocGF0aFtpXSwgJ2NhcHR1cmVkJywgYXJnKTtcbiAgfVxuICBmb3IgKGkgPSAwOyBpIDwgcGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGZuKHBhdGhbaV0sICdidWJibGVkJywgYXJnKTtcbiAgfVxufVxuXG4vKipcbiAqIFRyYXZlcnNlcyB0aGUgSUQgaGllcmFyY2h5IGFuZCBpbnZva2VzIHRoZSBzdXBwbGllZCBgY2JgIG9uIGFueSBJRHMgdGhhdFxuICogc2hvdWxkIHdvdWxkIHJlY2VpdmUgYSBgbW91c2VFbnRlcmAgb3IgYG1vdXNlTGVhdmVgIGV2ZW50LlxuICpcbiAqIERvZXMgbm90IGludm9rZSB0aGUgY2FsbGJhY2sgb24gdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIGJlY2F1c2Ugbm90aGluZ1xuICogXCJlbnRlcmVkXCIgb3IgXCJsZWZ0XCIgdGhhdCBlbGVtZW50LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZUVudGVyTGVhdmUoZnJvbSwgdG8sIGZuLCBhcmdGcm9tLCBhcmdUbykge1xuICB2YXIgY29tbW9uID0gZnJvbSAmJiB0byA/IGdldExvd2VzdENvbW1vbkFuY2VzdG9yKGZyb20sIHRvKSA6IG51bGw7XG4gIHZhciBwYXRoRnJvbSA9IFtdO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmICghZnJvbSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChmcm9tID09PSBjb21tb24pIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICB2YXIgYWx0ZXJuYXRlID0gZnJvbS5hbHRlcm5hdGU7XG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGNvbW1vbikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHBhdGhGcm9tLnB1c2goZnJvbSk7XG4gICAgZnJvbSA9IGdldFBhcmVudChmcm9tKTtcbiAgfVxuICB2YXIgcGF0aFRvID0gW107XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKCF0bykge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICh0byA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIF9hbHRlcm5hdGUgPSB0by5hbHRlcm5hdGU7XG4gICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwgJiYgX2FsdGVybmF0ZSA9PT0gY29tbW9uKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcGF0aFRvLnB1c2godG8pO1xuICAgIHRvID0gZ2V0UGFyZW50KHRvKTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGhGcm9tLmxlbmd0aDsgaSsrKSB7XG4gICAgZm4ocGF0aEZyb21baV0sICdidWJibGVkJywgYXJnRnJvbSk7XG4gIH1cbiAgZm9yICh2YXIgX2kgPSBwYXRoVG8ubGVuZ3RoOyBfaS0tID4gMDspIHtcbiAgICBmbihwYXRoVG9bX2ldLCAnY2FwdHVyZWQnLCBhcmdUbyk7XG4gIH1cbn1cblxuLyoqXG4gKiBTb21lIGV2ZW50IHR5cGVzIGhhdmUgYSBub3Rpb24gb2YgZGlmZmVyZW50IHJlZ2lzdHJhdGlvbiBuYW1lcyBmb3IgZGlmZmVyZW50XG4gKiBcInBoYXNlc1wiIG9mIHByb3BhZ2F0aW9uLiBUaGlzIGZpbmRzIGxpc3RlbmVycyBieSBhIGdpdmVuIHBoYXNlLlxuICovXG5mdW5jdGlvbiBsaXN0ZW5lckF0UGhhc2UoaW5zdCwgZXZlbnQsIHByb3BhZ2F0aW9uUGhhc2UpIHtcbiAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twcm9wYWdhdGlvblBoYXNlXTtcbiAgcmV0dXJuIGdldExpc3RlbmVyKGluc3QsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIEEgc21hbGwgc2V0IG9mIHByb3BhZ2F0aW9uIHBhdHRlcm5zLCBlYWNoIG9mIHdoaWNoIHdpbGwgYWNjZXB0IGEgc21hbGwgYW1vdW50XG4gKiBvZiBpbmZvcm1hdGlvbiwgYW5kIGdlbmVyYXRlIGEgc2V0IG9mIFwiZGlzcGF0Y2ggcmVhZHkgZXZlbnQgb2JqZWN0c1wiIC0gd2hpY2hcbiAqIGFyZSBzZXRzIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWxyZWFkeSBiZWVuIGFubm90YXRlZCB3aXRoIGEgc2V0IG9mIGRpc3BhdGNoZWRcbiAqIGxpc3RlbmVyIGZ1bmN0aW9ucy9pZHMuIFRoZSBBUEkgaXMgZGVzaWduZWQgdGhpcyB3YXkgdG8gZGlzY291cmFnZSB0aGVzZVxuICogcHJvcGFnYXRpb24gc3RyYXRlZ2llcyBmcm9tIGFjdHVhbGx5IGV4ZWN1dGluZyB0aGUgZGlzcGF0Y2hlcywgc2luY2Ugd2VcbiAqIGFsd2F5cyB3YW50IHRvIGNvbGxlY3QgdGhlIGVudGlyZSBzZXQgb2YgZGlzcGF0Y2hlcyBiZWZvcmUgZXhlY3V0aW5nIGV2ZW4gYVxuICogc2luZ2xlIG9uZS5cbiAqL1xuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhpbnN0LCBwaGFzZSwgZXZlbnQpIHtcbiAge1xuICAgIHdhcm5pbmcoaW5zdCwgJ0Rpc3BhdGNoaW5nIGluc3QgbXVzdCBub3QgYmUgbnVsbCcpO1xuICB9XG4gIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyQXRQaGFzZShpbnN0LCBldmVudCwgcGhhc2UpO1xuICBpZiAobGlzdGVuZXIpIHtcbiAgICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMsIGxpc3RlbmVyKTtcbiAgICBldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJbnN0YW5jZXMsIGluc3QpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuX3RhcmdldEluc3QsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIHZhciB0YXJnZXRJbnN0ID0gZXZlbnQuX3RhcmdldEluc3Q7XG4gICAgdmFyIHBhcmVudEluc3QgPSB0YXJnZXRJbnN0ID8gZ2V0UGFyZW50SW5zdGFuY2UodGFyZ2V0SW5zdCkgOiBudWxsO1xuICAgIHRyYXZlcnNlVHdvUGhhc2UocGFyZW50SW5zdCwgYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcywgZXZlbnQpO1xuICB9XG59XG5cbi8qKlxuICogQWNjdW11bGF0ZXMgd2l0aG91dCByZWdhcmQgdG8gZGlyZWN0aW9uLCBkb2VzIG5vdCBsb29rIGZvciBwaGFzZWRcbiAqIHJlZ2lzdHJhdGlvbiBuYW1lcy4gU2FtZSBhcyBgYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXNTaW5nbGVgIGJ1dCB3aXRob3V0XG4gKiByZXF1aXJpbmcgdGhhdCB0aGUgYGRpc3BhdGNoTWFya2VyYCBiZSB0aGUgc2FtZSBhcyB0aGUgZGlzcGF0Y2hlZCBJRC5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpc3BhdGNoZXMoaW5zdCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGluc3QgJiYgZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciByZWdpc3RyYXRpb25OYW1lID0gZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZTtcbiAgICB2YXIgbGlzdGVuZXIgPSBnZXRMaXN0ZW5lcihpbnN0LCByZWdpc3RyYXRpb25OYW1lKTtcbiAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoSW5zdGFuY2VzLCBpbnN0KTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50Ll90YXJnZXRJbnN0LCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb20sIHRvKSB7XG4gIHRyYXZlcnNlRW50ZXJMZWF2ZShmcm9tLCB0bywgYWNjdW11bGF0ZURpc3BhdGNoZXMsIGxlYXZlLCBlbnRlcik7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzKGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbnZhciBFdmVudFByb3BhZ2F0b3JzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXM6IGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0OiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldCxcblx0YWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMsXG5cdGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1xufSk7XG5cbnZhciBjb250ZW50S2V5ID0gbnVsbDtcblxuLyoqXG4gKiBHZXRzIHRoZSBrZXkgdXNlZCB0byBhY2Nlc3MgdGV4dCBjb250ZW50IG9uIGEgRE9NIG5vZGUuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gS2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXRUZXh0Q29udGVudEFjY2Vzc29yKCkge1xuICBpZiAoIWNvbnRlbnRLZXkgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gICAgLy8gUHJlZmVyIHRleHRDb250ZW50IHRvIGlubmVyVGV4dCBiZWNhdXNlIG1hbnkgYnJvd3NlcnMgc3VwcG9ydCBib3RoIGJ1dFxuICAgIC8vIFNWRyA8dGV4dD4gZWxlbWVudHMgZG9uJ3Qgc3VwcG9ydCBpbm5lclRleHQgZXZlbiB3aGVuIDxkaXY+IGRvZXMuXG4gICAgY29udGVudEtleSA9ICd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ID8gJ3RleHRDb250ZW50JyA6ICdpbm5lclRleHQnO1xuICB9XG4gIHJldHVybiBjb250ZW50S2V5O1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIG9iamVjdCBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKlxuICovXG52YXIgY29tcG9zaXRpb25TdGF0ZSA9IHtcbiAgX3Jvb3Q6IG51bGwsXG4gIF9zdGFydFRleHQ6IG51bGwsXG4gIF9mYWxsYmFja1RleHQ6IG51bGxcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICBjb21wb3NpdGlvblN0YXRlLl9zdGFydFRleHQgPSBnZXRUZXh0KCk7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXNldCgpIHtcbiAgY29tcG9zaXRpb25TdGF0ZS5fcm9vdCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dCA9IG51bGw7XG4gIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dCA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldERhdGEoKSB7XG4gIGlmIChjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQpIHtcbiAgICByZXR1cm4gY29tcG9zaXRpb25TdGF0ZS5fZmFsbGJhY2tUZXh0O1xuICB9XG5cbiAgdmFyIHN0YXJ0O1xuICB2YXIgc3RhcnRWYWx1ZSA9IGNvbXBvc2l0aW9uU3RhdGUuX3N0YXJ0VGV4dDtcbiAgdmFyIHN0YXJ0TGVuZ3RoID0gc3RhcnRWYWx1ZS5sZW5ndGg7XG4gIHZhciBlbmQ7XG4gIHZhciBlbmRWYWx1ZSA9IGdldFRleHQoKTtcbiAgdmFyIGVuZExlbmd0aCA9IGVuZFZhbHVlLmxlbmd0aDtcblxuICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0XSAhPT0gZW5kVmFsdWVbc3RhcnRdKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgbWluRW5kID0gc3RhcnRMZW5ndGggLSBzdGFydDtcbiAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgIGlmIChzdGFydFZhbHVlW3N0YXJ0TGVuZ3RoIC0gZW5kXSAhPT0gZW5kVmFsdWVbZW5kTGVuZ3RoIC0gZW5kXSkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNsaWNlVGFpbCA9IGVuZCA+IDEgPyAxIC0gZW5kIDogdW5kZWZpbmVkO1xuICBjb21wb3NpdGlvblN0YXRlLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgcmV0dXJuIGNvbXBvc2l0aW9uU3RhdGUuX2ZhbGxiYWNrVGV4dDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dCgpIHtcbiAgaWYgKCd2YWx1ZScgaW4gY29tcG9zaXRpb25TdGF0ZS5fcm9vdCkge1xuICAgIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290LnZhbHVlO1xuICB9XG4gIHJldHVybiBjb21wb3NpdGlvblN0YXRlLl9yb290W2dldFRleHRDb250ZW50QWNjZXNzb3IoKV07XG59XG5cbi8qIGVzbGludCB2YWxpZC10eXBlb2Y6IDAgKi9cblxudmFyIGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5ID0gZmFsc2U7XG52YXIgaXNQcm94eVN1cHBvcnRlZCA9IHR5cGVvZiBQcm94eSA9PT0gJ2Z1bmN0aW9uJztcbnZhciBFVkVOVF9QT09MX1NJWkUgPSAxMDtcblxudmFyIHNob3VsZEJlUmVsZWFzZWRQcm9wZXJ0aWVzID0gWydkaXNwYXRjaENvbmZpZycsICdfdGFyZ2V0SW5zdCcsICduYXRpdmVFdmVudCcsICdpc0RlZmF1bHRQcmV2ZW50ZWQnLCAnaXNQcm9wYWdhdGlvblN0b3BwZWQnLCAnX2Rpc3BhdGNoTGlzdGVuZXJzJywgJ19kaXNwYXRjaEluc3RhbmNlcyddO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNOdWxsLFxuICBldmVudFBoYXNlOiBudWxsLFxuICBidWJibGVzOiBudWxsLFxuICBjYW5jZWxhYmxlOiBudWxsLFxuICB0aW1lU3RhbXA6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiBldmVudC50aW1lU3RhbXAgfHwgRGF0ZS5ub3coKTtcbiAgfSxcbiAgZGVmYXVsdFByZXZlbnRlZDogbnVsbCxcbiAgaXNUcnVzdGVkOiBudWxsXG59O1xuXG4vKipcbiAqIFN5bnRoZXRpYyBldmVudHMgYXJlIGRpc3BhdGNoZWQgYnkgZXZlbnQgcGx1Z2lucywgdHlwaWNhbGx5IGluIHJlc3BvbnNlIHRvIGFcbiAqIHRvcC1sZXZlbCBldmVudCBkZWxlZ2F0aW9uIGhhbmRsZXIuXG4gKlxuICogVGhlc2Ugc3lzdGVtcyBzaG91bGQgZ2VuZXJhbGx5IHVzZSBwb29saW5nIHRvIHJlZHVjZSB0aGUgZnJlcXVlbmN5IG9mIGdhcmJhZ2VcbiAqIGNvbGxlY3Rpb24uIFRoZSBzeXN0ZW0gc2hvdWxkIGNoZWNrIGBpc1BlcnNpc3RlbnRgIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZVxuICogZXZlbnQgc2hvdWxkIGJlIHJlbGVhc2VkIGludG8gdGhlIHBvb2wgYWZ0ZXIgYmVpbmcgZGlzcGF0Y2hlZC4gVXNlcnMgdGhhdFxuICogbmVlZCBhIHBlcnNpc3RlZCBldmVudCBzaG91bGQgaW52b2tlIGBwZXJzaXN0YC5cbiAqXG4gKiBTeW50aGV0aWMgZXZlbnRzIChhbmQgc3ViY2xhc3NlcykgaW1wbGVtZW50IHRoZSBET00gTGV2ZWwgMyBFdmVudHMgQVBJIGJ5XG4gKiBub3JtYWxpemluZyBicm93c2VyIHF1aXJrcy4gU3ViY2xhc3NlcyBkbyBub3QgbmVjZXNzYXJpbHkgaGF2ZSB0byBpbXBsZW1lbnQgYVxuICogRE9NIGludGVyZmFjZTsgY3VzdG9tIGFwcGxpY2F0aW9uLXNwZWNpZmljIGV2ZW50cyBjYW4gYWxzbyBzdWJjbGFzcyB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7Kn0gdGFyZ2V0SW5zdCBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IG5hdGl2ZUV2ZW50VGFyZ2V0IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNFdmVudChkaXNwYXRjaENvbmZpZywgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHtcbiAgICAvLyB0aGVzZSBoYXZlIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICBkZWxldGUgdGhpcy5uYXRpdmVFdmVudDtcbiAgICBkZWxldGUgdGhpcy5wcmV2ZW50RGVmYXVsdDtcbiAgICBkZWxldGUgdGhpcy5zdG9wUHJvcGFnYXRpb247XG4gIH1cblxuICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gZGlzcGF0Y2hDb25maWc7XG4gIHRoaXMuX3RhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB7XG4gICAgICBkZWxldGUgdGhpc1twcm9wTmFtZV07IC8vIHRoaXMgaGFzIGEgZ2V0dGVyL3NldHRlciBmb3Igd2FybmluZ3NcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6ZSA9IEludGVyZmFjZVtwcm9wTmFtZV07XG4gICAgaWYgKG5vcm1hbGl6ZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBub3JtYWxpemUobmF0aXZlRXZlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICd0YXJnZXQnKSB7XG4gICAgICAgIHRoaXMudGFyZ2V0ID0gbmF0aXZlRXZlbnRUYXJnZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IG5hdGl2ZUV2ZW50W3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZGVmYXVsdFByZXZlbnRlZCA9IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgIT0gbnVsbCA/IG5hdGl2ZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgOiBuYXRpdmVFdmVudC5yZXR1cm5WYWx1ZSA9PT0gZmFsc2U7XG4gIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgdGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbiQxLnRoYXRSZXR1cm5zRmFsc2U7XG4gIH1cbiAgdGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IGVtcHR5RnVuY3Rpb24kMS50aGF0UmV0dXJuc0ZhbHNlO1xuICByZXR1cm4gdGhpcztcbn1cblxuX2Fzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcbiAgcHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSB0cnVlO1xuICAgIHZhciBldmVudCA9IHRoaXMubmF0aXZlRXZlbnQ7XG4gICAgaWYgKCFldmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChldmVudC5wcmV2ZW50RGVmYXVsdCkge1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBldmVudC5yZXR1cm5WYWx1ZSAhPT0gJ3Vua25vd24nKSB7XG4gICAgICBldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24kMS50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZXZlbnQuY2FuY2VsQnViYmxlICE9PSAndW5rbm93bicpIHtcbiAgICAgIC8vIFRoZSBDaGFuZ2VFdmVudFBsdWdpbiByZWdpc3RlcnMgYSBcInByb3BlcnR5Y2hhbmdlXCIgZXZlbnQgZm9yXG4gICAgICAvLyBJRS4gVGhpcyBldmVudCBkb2VzIG5vdCBzdXBwb3J0IGJ1YmJsaW5nIG9yIGNhbmNlbGxpbmcsIGFuZFxuICAgICAgLy8gYW55IHJlZmVyZW5jZXMgdG8gY2FuY2VsQnViYmxlIHRocm93IFwiTWVtYmVyIG5vdCBmb3VuZFwiLiAgQVxuICAgICAgLy8gdHlwZW9mIGNoZWNrIG9mIFwidW5rbm93blwiIGNpcmN1bXZlbnRzIHRoaXMgaXNzdWUgKGFuZCBpcyBhbHNvXG4gICAgICAvLyBJRSBzcGVjaWZpYykuXG4gICAgICBldmVudC5jYW5jZWxCdWJibGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBXZSByZWxlYXNlIGFsbCBkaXNwYXRjaGVkIGBTeW50aGV0aWNFdmVudGBzIGFmdGVyIGVhY2ggZXZlbnQgbG9vcCwgYWRkaW5nXG4gICAqIHRoZW0gYmFjayBpbnRvIHRoZSBwb29sLiBUaGlzIGFsbG93cyBhIHdheSB0byBob2xkIG9udG8gYSByZWZlcmVuY2UgdGhhdFxuICAgKiB3b24ndCBiZSBhZGRlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqL1xuICBwZXJzaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pc1BlcnNpc3RlbnQgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNUcnVlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhpcyBldmVudCBzaG91bGQgYmUgcmVsZWFzZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoaXMgc2hvdWxkIG5vdCBiZSByZWxlYXNlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKi9cbiAgaXNQZXJzaXN0ZW50OiBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgcHJvcE5hbWUsIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIEludGVyZmFjZVtwcm9wTmFtZV0pKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpc1tzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllc1tpXV0gPSBudWxsO1xuICAgIH1cbiAgICB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ25hdGl2ZUV2ZW50JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignbmF0aXZlRXZlbnQnLCBudWxsKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3ByZXZlbnREZWZhdWx0JywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbigncHJldmVudERlZmF1bHQnLCBlbXB0eUZ1bmN0aW9uJDEpKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnc3RvcFByb3BhZ2F0aW9uJywgZ2V0UG9vbGVkV2FybmluZ1Byb3BlcnR5RGVmaW5pdGlvbignc3RvcFByb3BhZ2F0aW9uJywgZW1wdHlGdW5jdGlvbiQxKSk7XG4gICAgfVxuICB9XG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIEUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgRS5wcm90b3R5cGUgPSBTdXBlci5wcm90b3R5cGU7XG4gIHZhciBwcm90b3R5cGUgPSBuZXcgRSgpO1xuXG4gIF9hc3NpZ24ocHJvdG90eXBlLCBDbGFzcy5wcm90b3R5cGUpO1xuICBDbGFzcy5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gIENsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENsYXNzO1xuXG4gIENsYXNzLkludGVyZmFjZSA9IF9hc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuICBhZGRFdmVudFBvb2xpbmdUbyhDbGFzcyk7XG59O1xuXG4vKiogUHJveHlpbmcgYWZ0ZXIgZXZlcnl0aGluZyBzZXQgb24gU3ludGhldGljRXZlbnRcbiAqIHRvIHJlc29sdmUgUHJveHkgaXNzdWUgb24gc29tZSBXZWJLaXQgYnJvd3NlcnNcbiAqIGluIHdoaWNoIHNvbWUgRXZlbnQgcHJvcGVydGllcyBhcmUgc2V0IHRvIHVuZGVmaW5lZCAoR0gjMTAwMTApXG4gKi9cbntcbiAgaWYgKGlzUHJveHlTdXBwb3J0ZWQpIHtcbiAgICAvKmVzbGludC1kaXNhYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gICAgU3ludGhldGljRXZlbnQgPSBuZXcgUHJveHkoU3ludGhldGljRXZlbnQsIHtcbiAgICAgIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRhcmdldCwgYXJncykge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBseSh0YXJnZXQsIE9iamVjdC5jcmVhdGUodGFyZ2V0LnByb3RvdHlwZSksIGFyZ3MpO1xuICAgICAgfSxcbiAgICAgIGFwcGx5OiBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHRoYXQsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm94eShjb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmdzKSwge1xuICAgICAgICAgIHNldDogZnVuY3Rpb24gKHRhcmdldCwgcHJvcCwgdmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9wICE9PSAnaXNQZXJzaXN0ZW50JyAmJiAhdGFyZ2V0LmNvbnN0cnVjdG9yLkludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSAmJiBzaG91bGRCZVJlbGVhc2VkUHJvcGVydGllcy5pbmRleE9mKHByb3ApID09PSAtMSkge1xuICAgICAgICAgICAgICB3YXJuaW5nKGRpZFdhcm5Gb3JBZGRlZE5ld1Byb3BlcnR5IHx8IHRhcmdldC5pc1BlcnNpc3RlbnQoKSwgXCJUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdSdyZSBcIiArIFwic2VlaW5nIHRoaXMsIHlvdSdyZSBhZGRpbmcgYSBuZXcgcHJvcGVydHkgaW4gdGhlIHN5bnRoZXRpYyBldmVudCBvYmplY3QuIFwiICsgJ1RoZSBwcm9wZXJ0eSBpcyBuZXZlciByZWxlYXNlZC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpO1xuICAgICAgICAgICAgICBkaWRXYXJuRm9yQWRkZWROZXdQcm9wZXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXRbcHJvcF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLyplc2xpbnQtZW5hYmxlIG5vLWZ1bmMtYXNzaWduICovXG4gIH1cbn1cblxuYWRkRXZlbnRQb29saW5nVG8oU3ludGhldGljRXZlbnQpO1xuXG4vKipcbiAqIEhlbHBlciB0byBudWxsaWZ5IHN5bnRoZXRpY0V2ZW50IGluc3RhbmNlIHByb3BlcnRpZXMgd2hlbiBkZXN0cnVjdGluZ1xuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wTmFtZVxuICogQHBhcmFtIHs/b2JqZWN0fSBnZXRWYWxcbiAqIEByZXR1cm4ge29iamVjdH0gZGVmaW5lUHJvcGVydHkgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGdldFBvb2xlZFdhcm5pbmdQcm9wZXJ0eURlZmluaXRpb24ocHJvcE5hbWUsIGdldFZhbCkge1xuICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBnZXRWYWwgPT09ICdmdW5jdGlvbic7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHNldDogc2V0LFxuICAgIGdldDogZ2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gc2V0KHZhbCkge1xuICAgIHZhciBhY3Rpb24gPSBpc0Z1bmN0aW9uID8gJ3NldHRpbmcgdGhlIG1ldGhvZCcgOiAnc2V0dGluZyB0aGUgcHJvcGVydHknO1xuICAgIHdhcm4oYWN0aW9uLCAnVGhpcyBpcyBlZmZlY3RpdmVseSBhIG5vLW9wJyk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldCgpIHtcbiAgICB2YXIgYWN0aW9uID0gaXNGdW5jdGlvbiA/ICdhY2Nlc3NpbmcgdGhlIG1ldGhvZCcgOiAnYWNjZXNzaW5nIHRoZSBwcm9wZXJ0eSc7XG4gICAgdmFyIHJlc3VsdCA9IGlzRnVuY3Rpb24gPyAnVGhpcyBpcyBhIG5vLW9wIGZ1bmN0aW9uJyA6ICdUaGlzIGlzIHNldCB0byBudWxsJztcbiAgICB3YXJuKGFjdGlvbiwgcmVzdWx0KTtcbiAgICByZXR1cm4gZ2V0VmFsO1xuICB9XG5cbiAgZnVuY3Rpb24gd2FybihhY3Rpb24sIHJlc3VsdCkge1xuICAgIHZhciB3YXJuaW5nQ29uZGl0aW9uID0gZmFsc2U7XG4gICAgd2FybmluZyh3YXJuaW5nQ29uZGl0aW9uLCBcIlRoaXMgc3ludGhldGljIGV2ZW50IGlzIHJldXNlZCBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBcIiArIFwieW91J3JlICVzIGAlc2Agb24gYSByZWxlYXNlZC9udWxsaWZpZWQgc3ludGhldGljIGV2ZW50LiAlcy4gXCIgKyAnSWYgeW91IG11c3Qga2VlcCB0aGUgb3JpZ2luYWwgc3ludGhldGljIGV2ZW50IGFyb3VuZCwgdXNlIGV2ZW50LnBlcnNpc3QoKS4gJyArICdTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGFjdGlvbiwgcHJvcE5hbWUsIHJlc3VsdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UG9vbGVkRXZlbnQoZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KSB7XG4gIHZhciBFdmVudENvbnN0cnVjdG9yID0gdGhpcztcbiAgaWYgKEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sLnBvcCgpO1xuICAgIEV2ZW50Q29uc3RydWN0b3IuY2FsbChpbnN0YW5jZSwgZGlzcGF0Y2hDb25maWcsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVJbnN0KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH1cbiAgcmV0dXJuIG5ldyBFdmVudENvbnN0cnVjdG9yKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlSW5zdCk7XG59XG5cbmZ1bmN0aW9uIHJlbGVhc2VQb29sZWRFdmVudChldmVudCkge1xuICB2YXIgRXZlbnRDb25zdHJ1Y3RvciA9IHRoaXM7XG4gICEoZXZlbnQgaW5zdGFuY2VvZiBFdmVudENvbnN0cnVjdG9yKSA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGV2ZW50IGluc3RhbmNlICBpbnRvIGEgcG9vbCBvZiBhIGRpZmZlcmVudCB0eXBlLicpIDogdm9pZCAwO1xuICBldmVudC5kZXN0cnVjdG9yKCk7XG4gIGlmIChFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5sZW5ndGggPCBFVkVOVF9QT09MX1NJWkUpIHtcbiAgICBFdmVudENvbnN0cnVjdG9yLmV2ZW50UG9vbC5wdXNoKGV2ZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhZGRFdmVudFBvb2xpbmdUbyhFdmVudENvbnN0cnVjdG9yKSB7XG4gIEV2ZW50Q29uc3RydWN0b3IuZXZlbnRQb29sID0gW107XG4gIEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkID0gZ2V0UG9vbGVkRXZlbnQ7XG4gIEV2ZW50Q29uc3RydWN0b3IucmVsZWFzZSA9IHJlbGVhc2VQb29sZWRFdmVudDtcbn1cblxudmFyIFN5bnRoZXRpY0V2ZW50JDEgPSBTeW50aGV0aWNFdmVudDtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljQ29tcG9zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDEzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDEzMTEwNVxuICogICAgICAvI2V2ZW50cy1pbnB1dGV2ZW50c1xuICovXG52YXIgSW5wdXRFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YTogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY0lucHV0RXZlbnQsIElucHV0RXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgRU5EX0tFWUNPREVTID0gWzksIDEzLCAyNywgMzJdOyAvLyBUYWIsIFJldHVybiwgRXNjLCBTcGFjZVxudmFyIFNUQVJUX0tFWUNPREUgPSAyMjk7XG5cbnZhciBjYW5Vc2VDb21wb3NpdGlvbkV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdDb21wb3NpdGlvbkV2ZW50JyBpbiB3aW5kb3c7XG5cbnZhciBkb2N1bWVudE1vZGUgPSBudWxsO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkge1xuICBkb2N1bWVudE1vZGUgPSBkb2N1bWVudC5kb2N1bWVudE1vZGU7XG59XG5cbi8vIFdlYmtpdCBvZmZlcnMgYSB2ZXJ5IHVzZWZ1bCBgdGV4dElucHV0YCBldmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvXG4vLyBkaXJlY3RseSByZXByZXNlbnQgYGJlZm9yZUlucHV0YC4gVGhlIElFIGB0ZXh0aW5wdXRgIGV2ZW50IGlzIG5vdCBhc1xuLy8gdXNlZnVsLCBzbyB3ZSBkb24ndCB1c2UgaXQuXG52YXIgY2FuVXNlVGV4dElucHV0RXZlbnQgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ1RleHRFdmVudCcgaW4gd2luZG93ICYmICFkb2N1bWVudE1vZGUgJiYgIWlzUHJlc3RvKCk7XG5cbi8vIEluIElFOSssIHdlIGhhdmUgYWNjZXNzIHRvIGNvbXBvc2l0aW9uIGV2ZW50cywgYnV0IHRoZSBkYXRhIHN1cHBsaWVkXG4vLyBieSB0aGUgbmF0aXZlIGNvbXBvc2l0aW9uZW5kIGV2ZW50IG1heSBiZSBpbmNvcnJlY3QuIEphcGFuZXNlIGlkZW9ncmFwaGljXG4vLyBzcGFjZXMsIGZvciBpbnN0YW5jZSAoXFx1MzAwMCkgYXJlIG5vdCByZWNvcmRlZCBjb3JyZWN0bHkuXG52YXIgdXNlRmFsbGJhY2tDb21wb3NpdGlvbkRhdGEgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgKCFjYW5Vc2VDb21wb3NpdGlvbkV2ZW50IHx8IGRvY3VtZW50TW9kZSAmJiBkb2N1bWVudE1vZGUgPiA4ICYmIGRvY3VtZW50TW9kZSA8PSAxMSk7XG5cbi8qKlxuICogT3BlcmEgPD0gMTIgaW5jbHVkZXMgVGV4dEV2ZW50IGluIHdpbmRvdywgYnV0IGRvZXMgbm90IGZpcmVcbiAqIHRleHQgaW5wdXQgZXZlbnRzLiBSZWx5IG9uIGtleXByZXNzIGluc3RlYWQuXG4gKi9cbmZ1bmN0aW9uIGlzUHJlc3RvKCkge1xuICB2YXIgb3BlcmEgPSB3aW5kb3cub3BlcmE7XG4gIHJldHVybiB0eXBlb2Ygb3BlcmEgPT09ICdvYmplY3QnICYmIHR5cGVvZiBvcGVyYS52ZXJzaW9uID09PSAnZnVuY3Rpb24nICYmIHBhcnNlSW50KG9wZXJhLnZlcnNpb24oKSwgMTApIDw9IDEyO1xufVxuXG52YXIgU1BBQ0VCQVJfQ09ERSA9IDMyO1xudmFyIFNQQUNFQkFSX0NIQVIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKFNQQUNFQkFSX0NPREUpO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQmVmb3JlSW5wdXQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkJlZm9yZUlucHV0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BDb21wb3NpdGlvbkVuZCcsICd0b3BLZXlQcmVzcycsICd0b3BUZXh0SW5wdXQnLCAndG9wUGFzdGUnXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiAnb25Db21wb3NpdGlvbkVuZCcsXG4gICAgICBjYXB0dXJlZDogJ29uQ29tcG9zaXRpb25FbmRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25FbmQnLCAndG9wS2V5RG93bicsICd0b3BLZXlQcmVzcycsICd0b3BLZXlVcCcsICd0b3BNb3VzZURvd24nXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnQnLFxuICAgICAgY2FwdHVyZWQ6ICdvbkNvbXBvc2l0aW9uU3RhcnRDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ29tcG9zaXRpb25TdGFydCcsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvbkNvbXBvc2l0aW9uVXBkYXRlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25Db21wb3NpdGlvblVwZGF0ZUNhcHR1cmUnXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wQmx1cicsICd0b3BDb21wb3NpdGlvblVwZGF0ZScsICd0b3BLZXlEb3duJywgJ3RvcEtleVByZXNzJywgJ3RvcEtleVVwJywgJ3RvcE1vdXNlRG93biddXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25TdGFydCc6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uRW5kJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgJ3RvcENvbXBvc2l0aW9uVXBkYXRlJzpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJyAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gc3RhdHVzLCBpZiBhbnkuXG52YXIgaXNDb21wb3NpbmcgPSBmYWxzZTtcblxuLyoqXG4gKiBAcmV0dXJuIHs/b2JqZWN0fSBBIFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RDb21wb3NpdGlvbkV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHZhciBldmVudFR5cGU7XG4gIHZhciBmYWxsYmFja0RhdGE7XG5cbiAgaWYgKGNhblVzZUNvbXBvc2l0aW9uRXZlbnQpIHtcbiAgICBldmVudFR5cGUgPSBnZXRDb21wb3NpdGlvbkV2ZW50VHlwZSh0b3BMZXZlbFR5cGUpO1xuICB9IGVsc2UgaWYgKCFpc0NvbXBvc2luZykge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWlzQ29tcG9zaW5nICYmIGV2ZW50VHlwZSA9PT0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0KSB7XG4gICAgICBpc0NvbXBvc2luZyA9IGluaXRpYWxpemUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIH0gZWxzZSBpZiAoZXZlbnRUeXBlID09PSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kKSB7XG4gICAgICBpZiAoaXNDb21wb3NpbmcpIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gZ2V0RGF0YSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcblxuICBpZiAoZmFsbGJhY2tEYXRhKSB7XG4gICAgLy8gSW5qZWN0IGRhdGEgZ2VuZXJhdGVkIGZyb20gZmFsbGJhY2sgcGF0aCBpbnRvIHRoZSBzeW50aGV0aWMgZXZlbnQuXG4gICAgLy8gVGhpcyBtYXRjaGVzIHRoZSBwcm9wZXJ0eSBvZiBuYXRpdmUgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZS5cbiAgICBldmVudC5kYXRhID0gZmFsbGJhY2tEYXRhO1xuICB9IGVsc2Uge1xuICAgIHZhciBjdXN0b21EYXRhID0gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgaWYgKGN1c3RvbURhdGEgIT09IG51bGwpIHtcbiAgICAgIGV2ZW50LmRhdGEgPSBjdXN0b21EYXRhO1xuICAgIH1cbiAgfVxuXG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtUb3BMZXZlbFR5cGVzfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHs/c3RyaW5nfSBUaGUgc3RyaW5nIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpIHtcbiAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICBjYXNlICd0b3BDb21wb3NpdGlvbkVuZCc6XG4gICAgICByZXR1cm4gZ2V0RGF0YUZyb21DdXN0b21FdmVudChuYXRpdmVFdmVudCk7XG4gICAgY2FzZSAndG9wS2V5UHJlc3MnOlxuICAgICAgLyoqXG4gICAgICAgKiBJZiBuYXRpdmUgYHRleHRJbnB1dGAgZXZlbnRzIGFyZSBhdmFpbGFibGUsIG91ciBnb2FsIGlzIHRvIG1ha2VcbiAgICAgICAqIHVzZSBvZiB0aGVtLiBIb3dldmVyLCB0aGVyZSBpcyBhIHNwZWNpYWwgY2FzZTogdGhlIHNwYWNlYmFyIGtleS5cbiAgICAgICAqIEluIFdlYmtpdCwgcHJldmVudGluZyBkZWZhdWx0IG9uIGEgc3BhY2ViYXIgYHRleHRJbnB1dGAgZXZlbnRcbiAgICAgICAqIGNhbmNlbHMgY2hhcmFjdGVyIGluc2VydGlvbiwgYnV0IGl0ICphbHNvKiBjYXVzZXMgdGhlIGJyb3dzZXJcbiAgICAgICAqIHRvIGZhbGwgYmFjayB0byBpdHMgZGVmYXVsdCBzcGFjZWJhciBiZWhhdmlvciBvZiBzY3JvbGxpbmcgdGhlXG4gICAgICAgKiBwYWdlLlxuICAgICAgICpcbiAgICAgICAqIFRyYWNraW5nIGF0OlxuICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM1NTEwM1xuICAgICAgICpcbiAgICAgICAqIFRvIGF2b2lkIHRoaXMgaXNzdWUsIHVzZSB0aGUga2V5cHJlc3MgZXZlbnQgYXMgaWYgbm8gYHRleHRJbnB1dGBcbiAgICAgICAqIGV2ZW50IGlzIGF2YWlsYWJsZS5cbiAgICAgICAqL1xuICAgICAgdmFyIHdoaWNoID0gbmF0aXZlRXZlbnQud2hpY2g7XG4gICAgICBpZiAod2hpY2ggIT09IFNQQUNFQkFSX0NPREUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIGhhc1NwYWNlS2V5cHJlc3MgPSB0cnVlO1xuICAgICAgcmV0dXJuIFNQQUNFQkFSX0NIQVI7XG5cbiAgICBjYXNlICd0b3BUZXh0SW5wdXQnOlxuICAgICAgLy8gUmVjb3JkIHRoZSBjaGFyYWN0ZXJzIHRvIGJlIGFkZGVkIHRvIHRoZSBET00uXG4gICAgICB2YXIgY2hhcnMgPSBuYXRpdmVFdmVudC5kYXRhO1xuXG4gICAgICAvLyBJZiBpdCdzIGEgc3BhY2ViYXIgY2hhcmFjdGVyLCBhc3N1bWUgdGhhdCB3ZSBoYXZlIGFscmVhZHkgaGFuZGxlZFxuICAgICAgLy8gaXQgYXQgdGhlIGtleXByZXNzIGxldmVsIGFuZCBiYWlsIGltbWVkaWF0ZWx5LiBBbmRyb2lkIENocm9tZVxuICAgICAgLy8gZG9lc24ndCBnaXZlIHVzIGtleWNvZGVzLCBzbyB3ZSBuZWVkIHRvIGJsYWNrbGlzdCBpdC5cbiAgICAgIGlmIChjaGFycyA9PT0gU1BBQ0VCQVJfQ0hBUiAmJiBoYXNTcGFjZUtleXByZXNzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY2hhcnM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gRm9yIG90aGVyIG5hdGl2ZSBldmVudCB0eXBlcywgZG8gbm90aGluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRm9yIGJyb3dzZXJzIHRoYXQgZG8gbm90IHByb3ZpZGUgdGhlIGB0ZXh0SW5wdXRgIGV2ZW50LCBleHRyYWN0IHRoZVxuICogYXBwcm9wcmlhdGUgc3RyaW5nIHRvIHVzZSBmb3IgU3ludGhldGljSW5wdXRFdmVudC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBCcm93c2VyRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICAvLyBJZiBjb21wb3NpdGlvbiBldmVudCBpcyBhdmFpbGFibGUsIHdlIGV4dHJhY3QgYSBzdHJpbmcgb25seSBhdFxuICAvLyBjb21wb3NpdGlvbmV2ZW50LCBvdGhlcndpc2UgZXh0cmFjdCBpdCBhdCBmYWxsYmFjayBldmVudHMuXG4gIGlmIChpc0NvbXBvc2luZykge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BDb21wb3NpdGlvbkVuZCcgfHwgIWNhblVzZUNvbXBvc2l0aW9uRXZlbnQgJiYgaXNGYWxsYmFja0NvbXBvc2l0aW9uRW5kKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQpKSB7XG4gICAgICB2YXIgY2hhcnMgPSBnZXREYXRhKCk7XG4gICAgICByZXNldCgpO1xuICAgICAgaXNDb21wb3NpbmcgPSBmYWxzZTtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgJ3RvcFBhc3RlJzpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmICghaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIC8vIElFIGZpcmVzIHRoZSBga2V5cHJlc3NgIGV2ZW50IHdoZW4gYSB1c2VyIHR5cGVzIGFuIGVtb2ppIHZpYVxuICAgICAgICAvLyBUb3VjaCBrZXlib2FyZCBvZiBXaW5kb3dzLiAgSW4gc3VjaCBhIGNhc2UsIHRoZSBgY2hhcmAgcHJvcGVydHlcbiAgICAgICAgLy8gaG9sZHMgYW4gZW1vamkgY2hhcmFjdGVyIGxpa2UgYFxcdUQ4M0RcXHVERTBBYC4gIEJlY2F1c2UgaXRzIGxlbmd0aFxuICAgICAgICAvLyBpcyAyLCB0aGUgcHJvcGVydHkgYHdoaWNoYCBkb2VzIG5vdCByZXByZXNlbnQgYW4gZW1vamkgY29ycmVjdGx5LlxuICAgICAgICAvLyBJbiBzdWNoIGEgY2FzZSwgd2UgZGlyZWN0bHkgcmV0dXJuIHRoZSBgY2hhcmAgcHJvcGVydHkgaW5zdGVhZCBvZlxuICAgICAgICAvLyB1c2luZyBgd2hpY2hgLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuY2hhciAmJiBuYXRpdmVFdmVudC5jaGFyLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlRXZlbnQuY2hhcjtcbiAgICAgICAgfSBlbHNlIGlmIChuYXRpdmVFdmVudC53aGljaCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAndG9wQ29tcG9zaXRpb25FbmQnOlxuICAgICAgcmV0dXJuIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID8gbnVsbCA6IG5hdGl2ZUV2ZW50LmRhdGE7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRXh0cmFjdCBhIFN5bnRoZXRpY0lucHV0RXZlbnQgZm9yIGBiZWZvcmVJbnB1dGAsIGJhc2VkIG9uIGVpdGhlciBuYXRpdmVcbiAqIGB0ZXh0SW5wdXRgIG9yIGZhbGxiYWNrIGJlaGF2aW9yLlxuICpcbiAqIEByZXR1cm4gez9vYmplY3R9IEEgU3ludGhldGljSW5wdXRFdmVudC5cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdEJlZm9yZUlucHV0RXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuXG4vKipcbiAqIENyZWF0ZSBhbiBgb25CZWZvcmVJbnB1dGAgZXZlbnQgdG8gbWF0Y2hcbiAqIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMTMxMTA1LyNldmVudHMtaW5wdXRldmVudHMuXG4gKlxuICogVGhpcyBldmVudCBwbHVnaW4gaXMgYmFzZWQgb24gdGhlIG5hdGl2ZSBgdGV4dElucHV0YCBldmVudFxuICogYXZhaWxhYmxlIGluIENocm9tZSwgU2FmYXJpLCBPcGVyYSwgYW5kIElFLiBUaGlzIGV2ZW50IGZpcmVzIGFmdGVyXG4gKiBgb25LZXlQcmVzc2AgYW5kIGBvbkNvbXBvc2l0aW9uRW5kYCwgYnV0IGJlZm9yZSBgb25JbnB1dGAuXG4gKlxuICogYGJlZm9yZUlucHV0YCBpcyBzcGVjJ2QgYnV0IG5vdCBpbXBsZW1lbnRlZCBpbiBhbnkgYnJvd3NlcnMsIGFuZFxuICogdGhlIGBpbnB1dGAgZXZlbnQgZG9lcyBub3QgcHJvdmlkZSBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIGFib3V0IHdoYXQgaGFzXG4gKiBhY3R1YWxseSBiZWVuIGFkZGVkLCBjb250cmFyeSB0byB0aGUgc3BlYy4gVGh1cywgYHRleHRJbnB1dGAgaXMgdGhlIGJlc3RcbiAqIGF2YWlsYWJsZSBldmVudCB0byBpZGVudGlmeSB0aGUgY2hhcmFjdGVycyB0aGF0IGhhdmUgYWN0dWFsbHkgYmVlbiBpbnNlcnRlZFxuICogaW50byB0aGUgdGFyZ2V0IG5vZGUuXG4gKlxuICogVGhpcyBwbHVnaW4gaXMgYWxzbyByZXNwb25zaWJsZSBmb3IgZW1pdHRpbmcgYGNvbXBvc2l0aW9uYCBldmVudHMsIHRodXNcbiAqIGFsbG93aW5nIHVzIHRvIHNoYXJlIGNvbXBvc2l0aW9uIGZhbGxiYWNrIGNvZGUgZm9yIGJvdGggYGJlZm9yZUlucHV0YCBhbmRcbiAqIGBjb21wb3NpdGlvbmAgZXZlbnQgdHlwZXMuXG4gKi9cbnZhciBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luID0ge1xuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIGV4dHJhY3RFdmVudHM6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHJldHVybiBbZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCldO1xuICB9XG59O1xuXG4vLyBVc2UgdG8gcmVzdG9yZSBjb250cm9sbGVkIHN0YXRlIGFmdGVyIGEgY2hhbmdlIGV2ZW50IGhhcyBmaXJlZC5cblxudmFyIGZpYmVySG9zdENvbXBvbmVudCA9IG51bGw7XG5cbnZhciBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIGluamVjdEZpYmVyQ29udHJvbGxlZEhvc3RDb21wb25lbnQ6IGZ1bmN0aW9uIChob3N0Q29tcG9uZW50SW1wbCkge1xuICAgIC8vIFRoZSBmaWJlciBpbXBsZW1lbnRhdGlvbiBkb2Vzbid0IHVzZSBkeW5hbWljIGRpc3BhdGNoIHNvIHdlIG5lZWQgdG9cbiAgICAvLyBpbmplY3QgdGhlIGltcGxlbWVudGF0aW9uLlxuICAgIGZpYmVySG9zdENvbXBvbmVudCA9IGhvc3RDb21wb25lbnRJbXBsO1xuICB9XG59O1xuXG52YXIgcmVzdG9yZVRhcmdldCA9IG51bGw7XG52YXIgcmVzdG9yZVF1ZXVlID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlT2ZUYXJnZXQodGFyZ2V0KSB7XG4gIC8vIFdlIHBlcmZvcm0gdGhpcyB0cmFuc2xhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBldmVudCBsb29wIHNvIHRoYXQgd2VcbiAgLy8gYWx3YXlzIHJlY2VpdmUgdGhlIGNvcnJlY3QgZmliZXIgaGVyZVxuICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEluc3RhbmNlRnJvbU5vZGUodGFyZ2V0KTtcbiAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgLy8gVW5tb3VudGVkXG4gICAgcmV0dXJuO1xuICB9XG4gICEoZmliZXJIb3N0Q29tcG9uZW50ICYmIHR5cGVvZiBmaWJlckhvc3RDb21wb25lbnQucmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykgPyBpbnZhcmlhbnQoZmFsc2UsICdGaWJlciBuZWVkcyB0byBiZSBpbmplY3RlZCB0byBoYW5kbGUgYSBmaWJlciB0YXJnZXQgZm9yIGNvbnRyb2xsZWQgZXZlbnRzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICB2YXIgcHJvcHMgPSBnZXRGaWJlckN1cnJlbnRQcm9wc0Zyb21Ob2RlKGludGVybmFsSW5zdGFuY2Uuc3RhdGVOb2RlKTtcbiAgZmliZXJIb3N0Q29tcG9uZW50LnJlc3RvcmVDb250cm9sbGVkU3RhdGUoaW50ZXJuYWxJbnN0YW5jZS5zdGF0ZU5vZGUsIGludGVybmFsSW5zdGFuY2UudHlwZSwgcHJvcHMpO1xufVxuXG52YXIgaW5qZWN0aW9uJDMgPSBSZWFjdENvbnRyb2xsZWRDb21wb25lbnRJbmplY3Rpb247XG5cbmZ1bmN0aW9uIGVucXVldWVTdGF0ZVJlc3RvcmUodGFyZ2V0KSB7XG4gIGlmIChyZXN0b3JlVGFyZ2V0KSB7XG4gICAgaWYgKHJlc3RvcmVRdWV1ZSkge1xuICAgICAgcmVzdG9yZVF1ZXVlLnB1c2godGFyZ2V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzdG9yZVF1ZXVlID0gW3RhcmdldF07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlc3RvcmVUYXJnZXQgPSB0YXJnZXQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVN0YXRlSWZOZWVkZWQoKSB7XG4gIGlmICghcmVzdG9yZVRhcmdldCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgdGFyZ2V0ID0gcmVzdG9yZVRhcmdldDtcbiAgdmFyIHF1ZXVlZFRhcmdldHMgPSByZXN0b3JlUXVldWU7XG4gIHJlc3RvcmVUYXJnZXQgPSBudWxsO1xuICByZXN0b3JlUXVldWUgPSBudWxsO1xuXG4gIHJlc3RvcmVTdGF0ZU9mVGFyZ2V0KHRhcmdldCk7XG4gIGlmIChxdWV1ZWRUYXJnZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZWRUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN0b3JlU3RhdGVPZlRhcmdldChxdWV1ZWRUYXJnZXRzW2ldKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q29udHJvbGxlZENvbXBvbmVudCA9IE9iamVjdC5mcmVlemUoe1xuXHRpbmplY3Rpb246IGluamVjdGlvbiQzLFxuXHRlbnF1ZXVlU3RhdGVSZXN0b3JlOiBlbnF1ZXVlU3RhdGVSZXN0b3JlLFxuXHRyZXN0b3JlU3RhdGVJZk5lZWRlZDogcmVzdG9yZVN0YXRlSWZOZWVkZWRcbn0pO1xuXG4vLyBVc2VkIGFzIGEgd2F5IHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMgd2hlbiB3ZSBkb24ndCBoYXZlIGEgcmVmZXJlbmNlIHRvXG4vLyB0aGUgcmVuZGVyZXIuIFN1Y2ggYXMgd2hlbiB3ZSdyZSBkaXNwYXRjaGluZyBldmVudHMgb3IgaWYgdGhpcmQgcGFydHlcbi8vIGxpYnJhcmllcyBuZWVkIHRvIGNhbGwgYmF0Y2hlZFVwZGF0ZXMuIEV2ZW50dWFsbHksIHRoaXMgQVBJIHdpbGwgZ28gYXdheSB3aGVuXG4vLyBldmVyeXRoaW5nIGlzIGJhdGNoZWQgYnkgZGVmYXVsdC4gV2UnbGwgdGhlbiBoYXZlIGEgc2ltaWxhciBBUEkgdG8gb3B0LW91dCBvZlxuLy8gc2NoZWR1bGVkIHdvcmsgYW5kIGluc3RlYWQgZG8gc3luY2hyb25vdXMgd29yay5cblxuLy8gRGVmYXVsdHNcbnZhciBmaWJlckJhdGNoZWRVcGRhdGVzID0gZnVuY3Rpb24gKGZuLCBib29ra2VlcGluZykge1xuICByZXR1cm4gZm4oYm9va2tlZXBpbmcpO1xufTtcblxudmFyIGlzTmVzdGluZ0JhdGNoZWQgPSBmYWxzZTtcbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZykge1xuICBpZiAoaXNOZXN0aW5nQmF0Y2hlZCkge1xuICAgIC8vIElmIHdlIGFyZSBjdXJyZW50bHkgaW5zaWRlIGFub3RoZXIgYmF0Y2gsIHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdFxuICAgIC8vIGZ1bGx5IGNvbXBsZXRlcyBiZWZvcmUgcmVzdG9yaW5nIHN0YXRlLiBUaGVyZWZvcmUsIHdlIGFkZCB0aGUgdGFyZ2V0IHRvXG4gICAgLy8gYSBxdWV1ZSBvZiB3b3JrLlxuICAgIHJldHVybiBmaWJlckJhdGNoZWRVcGRhdGVzKGZuLCBib29ra2VlcGluZyk7XG4gIH1cbiAgaXNOZXN0aW5nQmF0Y2hlZCA9IHRydWU7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZpYmVyQmF0Y2hlZFVwZGF0ZXMoZm4sIGJvb2trZWVwaW5nKTtcbiAgfSBmaW5hbGx5IHtcbiAgICAvLyBIZXJlIHdlIHdhaXQgdW50aWwgYWxsIHVwZGF0ZXMgaGF2ZSBwcm9wYWdhdGVkLCB3aGljaCBpcyBpbXBvcnRhbnRcbiAgICAvLyB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTY5OFxuICAgIC8vIFRoZW4gd2UgcmVzdG9yZSBzdGF0ZSBvZiBhbnkgY29udHJvbGxlZCBjb21wb25lbnQuXG4gICAgaXNOZXN0aW5nQmF0Y2hlZCA9IGZhbHNlO1xuICAgIHJlc3RvcmVTdGF0ZUlmTmVlZGVkKCk7XG4gIH1cbn1cblxudmFyIFJlYWN0R2VuZXJpY0JhdGNoaW5nSW5qZWN0aW9uID0ge1xuICBpbmplY3RGaWJlckJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoX2JhdGNoZWRVcGRhdGVzKSB7XG4gICAgZmliZXJCYXRjaGVkVXBkYXRlcyA9IF9iYXRjaGVkVXBkYXRlcztcbiAgfVxufTtcblxudmFyIGluamVjdGlvbiQ0ID0gUmVhY3RHZW5lcmljQmF0Y2hpbmdJbmplY3Rpb247XG5cbi8qKlxuICogQHNlZSBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS90aGUtaW5wdXQtZWxlbWVudC5odG1sI2lucHV0LXR5cGUtYXR0ci1zdW1tYXJ5XG4gKi9cbnZhciBzdXBwb3J0ZWRJbnB1dFR5cGVzID0ge1xuICBjb2xvcjogdHJ1ZSxcbiAgZGF0ZTogdHJ1ZSxcbiAgZGF0ZXRpbWU6IHRydWUsXG4gICdkYXRldGltZS1sb2NhbCc6IHRydWUsXG4gIGVtYWlsOiB0cnVlLFxuICBtb250aDogdHJ1ZSxcbiAgbnVtYmVyOiB0cnVlLFxuICBwYXNzd29yZDogdHJ1ZSxcbiAgcmFuZ2U6IHRydWUsXG4gIHNlYXJjaDogdHJ1ZSxcbiAgdGVsOiB0cnVlLFxuICB0ZXh0OiB0cnVlLFxuICB0aW1lOiB0cnVlLFxuICB1cmw6IHRydWUsXG4gIHdlZWs6IHRydWVcbn07XG5cbmZ1bmN0aW9uIGlzVGV4dElucHV0RWxlbWVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnaW5wdXQnKSB7XG4gICAgcmV0dXJuICEhc3VwcG9ydGVkSW5wdXRUeXBlc1tlbGVtLnR5cGVdO1xuICB9XG5cbiAgaWYgKG5vZGVOYW1lID09PSAndGV4dGFyZWEnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogSFRNTCBub2RlVHlwZSB2YWx1ZXMgdGhhdCByZXByZXNlbnQgdGhlIHR5cGUgb2YgdGhlIG5vZGVcbiAqL1xuXG52YXIgRUxFTUVOVF9OT0RFID0gMTtcbnZhciBURVhUX05PREUgPSAzO1xudmFyIENPTU1FTlRfTk9ERSA9IDg7XG52YXIgRE9DVU1FTlRfTk9ERSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERSA9IDExO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuXG4gIC8vIE5vcm1hbGl6ZSBTVkcgPHVzZT4gZWxlbWVudCBldmVudHMgIzQ5NjNcbiAgaWYgKHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudCkge1xuICAgIHRhcmdldCA9IHRhcmdldC5jb3JyZXNwb25kaW5nVXNlRWxlbWVudDtcbiAgfVxuXG4gIC8vIFNhZmFyaSBtYXkgZmlyZSBldmVudHMgb24gdGV4dCBub2RlcyAoTm9kZS5URVhUX05PREUgaXMgMykuXG4gIC8vIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9qcy9ldmVudHNfcHJvcGVydGllcy5odG1sXG4gIHJldHVybiB0YXJnZXQubm9kZVR5cGUgPT09IFRFWFRfTk9ERSA/IHRhcmdldC5wYXJlbnROb2RlIDogdGFyZ2V0O1xufVxuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IGV2ZW50TmFtZSBpbiBkb2N1bWVudDtcblxuICBpZiAoIWlzU3VwcG9ydGVkKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG4gICAgaXNTdXBwb3J0ZWQgPSB0eXBlb2YgZWxlbWVudFtldmVudE5hbWVdID09PSAnZnVuY3Rpb24nO1xuICB9XG5cbiAgaWYgKCFpc1N1cHBvcnRlZCAmJiB1c2VIYXNGZWF0dXJlICYmIGV2ZW50TmFtZVN1ZmZpeCA9PT0gJ3doZWVsJykge1xuICAgIC8vIFRoaXMgaXMgdGhlIG9ubHkgd2F5IHRvIHRlc3Qgc3VwcG9ydCBmb3IgdGhlIGB3aGVlbGAgZXZlbnQgaW4gSUU5Ky5cbiAgICBpc1N1cHBvcnRlZCA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ0V2ZW50cy53aGVlbCcsICczLjAnKTtcbiAgfVxuXG4gIHJldHVybiBpc1N1cHBvcnRlZDtcbn1cblxuZnVuY3Rpb24gaXNDaGVja2FibGUoZWxlbSkge1xuICB2YXIgdHlwZSA9IGVsZW0udHlwZTtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIG5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgJiYgKHR5cGUgPT09ICdjaGVja2JveCcgfHwgdHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRyYWNrZXIobm9kZSkge1xuICByZXR1cm4gbm9kZS5fdmFsdWVUcmFja2VyO1xufVxuXG5mdW5jdGlvbiBkZXRhY2hUcmFja2VyKG5vZGUpIHtcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVGcm9tTm9kZShub2RlKSB7XG4gIHZhciB2YWx1ZSA9ICcnO1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBpZiAoaXNDaGVja2FibGUobm9kZSkpIHtcbiAgICB2YWx1ZSA9IG5vZGUuY2hlY2tlZCA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gIH0gZWxzZSB7XG4gICAgdmFsdWUgPSBub2RlLnZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB0cmFja1ZhbHVlT25Ob2RlKG5vZGUpIHtcbiAgdmFyIHZhbHVlRmllbGQgPSBpc0NoZWNrYWJsZShub2RlKSA/ICdjaGVja2VkJyA6ICd2YWx1ZSc7XG4gIHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihub2RlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgdmFsdWVGaWVsZCk7XG5cbiAgdmFyIGN1cnJlbnRWYWx1ZSA9ICcnICsgbm9kZVt2YWx1ZUZpZWxkXTtcblxuICAvLyBpZiBzb21lb25lIGhhcyBhbHJlYWR5IGRlZmluZWQgYSB2YWx1ZSBvciBTYWZhcmksIHRoZW4gYmFpbFxuICAvLyBhbmQgZG9uJ3QgdHJhY2sgdmFsdWUgd2lsbCBjYXVzZSBvdmVyIHJlcG9ydGluZyBvZiBjaGFuZ2VzLFxuICAvLyBidXQgaXQncyBiZXR0ZXIgdGhlbiBhIGhhcmQgZmFpbHVyZVxuICAvLyAobmVlZGVkIGZvciBjZXJ0YWluIHRlc3RzIHRoYXQgc3B5T24gaW5wdXQgdmFsdWVzIGFuZCBTYWZhcmkpXG4gIGlmIChub2RlLmhhc093blByb3BlcnR5KHZhbHVlRmllbGQpIHx8IHR5cGVvZiBkZXNjcmlwdG9yLmdldCAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZGVzY3JpcHRvci5zZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobm9kZSwgdmFsdWVGaWVsZCwge1xuICAgIGVudW1lcmFibGU6IGRlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRvci5nZXQuY2FsbCh0aGlzKTtcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBjdXJyZW50VmFsdWUgPSAnJyArIHZhbHVlO1xuICAgICAgZGVzY3JpcHRvci5zZXQuY2FsbCh0aGlzLCB2YWx1ZSk7XG4gICAgfVxuICB9KTtcblxuICB2YXIgdHJhY2tlciA9IHtcbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZTtcbiAgICB9LFxuICAgIHNldFZhbHVlOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGN1cnJlbnRWYWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfSxcbiAgICBzdG9wVHJhY2tpbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGRldGFjaFRyYWNrZXIobm9kZSk7XG4gICAgICBkZWxldGUgbm9kZVt2YWx1ZUZpZWxkXTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFja2VyO1xufVxuXG5mdW5jdGlvbiB0cmFjayhub2RlKSB7XG4gIGlmIChnZXRUcmFja2VyKG5vZGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gVE9ETzogT25jZSBpdCdzIGp1c3QgRmliZXIgd2UgY2FuIG1vdmUgdGhpcyB0byBub2RlLl93cmFwcGVyU3RhdGVcbiAgbm9kZS5fdmFsdWVUcmFja2VyID0gdHJhY2tWYWx1ZU9uTm9kZShub2RlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVmFsdWVJZkNoYW5nZWQobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdHJhY2tlciA9IGdldFRyYWNrZXIobm9kZSk7XG4gIC8vIGlmIHRoZXJlIGlzIG5vIHRyYWNrZXIgYXQgdGhpcyBwb2ludCBpdCdzIHVubGlrZWx5XG4gIC8vIHRoYXQgdHJ5aW5nIGFnYWluIHdpbGwgc3VjY2VlZFxuICBpZiAoIXRyYWNrZXIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBsYXN0VmFsdWUgPSB0cmFja2VyLmdldFZhbHVlKCk7XG4gIHZhciBuZXh0VmFsdWUgPSBnZXRWYWx1ZUZyb21Ob2RlKG5vZGUpO1xuICBpZiAobmV4dFZhbHVlICE9PSBsYXN0VmFsdWUpIHtcbiAgICB0cmFja2VyLnNldFZhbHVlKG5leHRWYWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgZXZlbnRUeXBlcyQxID0ge1xuICBjaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDogJ29uQ2hhbmdlJyxcbiAgICAgIGNhcHR1cmVkOiAnb25DaGFuZ2VDYXB0dXJlJ1xuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcEJsdXInLCAndG9wQ2hhbmdlJywgJ3RvcENsaWNrJywgJ3RvcEZvY3VzJywgJ3RvcElucHV0JywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxuZnVuY3Rpb24gY3JlYXRlQW5kQWNjdW11bGF0ZUNoYW5nZUV2ZW50KGluc3QsIG5hdGl2ZUV2ZW50LCB0YXJnZXQpIHtcbiAgdmFyIGV2ZW50ID0gU3ludGhldGljRXZlbnQkMS5nZXRQb29sZWQoZXZlbnRUeXBlcyQxLmNoYW5nZSwgaW5zdCwgbmF0aXZlRXZlbnQsIHRhcmdldCk7XG4gIGV2ZW50LnR5cGUgPSAnY2hhbmdlJztcbiAgLy8gRmxhZyB0aGlzIGV2ZW50IGxvb3AgYXMgbmVlZGluZyBzdGF0ZSByZXN0b3JlLlxuICBlbnF1ZXVlU3RhdGVSZXN0b3JlKHRhcmdldCk7XG4gIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG5mdW5jdGlvbiBtYW51YWxEaXNwYXRjaENoYW5nZUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBldmVudCA9IGNyZWF0ZUFuZEFjY3VtdWxhdGVDaGFuZ2VFdmVudChhY3RpdmVFbGVtZW50SW5zdCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIGJhdGNoZWRVcGRhdGVzKHJ1bkV2ZW50SW5CYXRjaCwgZXZlbnQpO1xufVxuXG5mdW5jdGlvbiBydW5FdmVudEluQmF0Y2goZXZlbnQpIHtcbiAgZW5xdWV1ZUV2ZW50cyhldmVudCk7XG4gIHByb2Nlc3NFdmVudFF1ZXVlKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpIHtcbiAgdmFyIHRhcmdldE5vZGUgPSBnZXROb2RlRnJvbUluc3RhbmNlJDEodGFyZ2V0SW5zdCk7XG4gIGlmICh1cGRhdGVWYWx1ZUlmQ2hhbmdlZCh0YXJnZXROb2RlKSkge1xuICAgIHJldHVybiB0YXJnZXRJbnN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gdGFyZ2V0SW5zdDtcbiAgfVxufVxuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgaW5wdXRgIGV2ZW50XG4gKi9cbnZhciBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgLy8gSUU5IGNsYWltcyB0byBzdXBwb3J0IHRoZSBpbnB1dCBldmVudCBidXQgZmFpbHMgdG8gdHJpZ2dlciBpdCB3aGVuXG4gIC8vIGRlbGV0aW5nIHRleHQsIHNvIHdlIGlnbm9yZSBpdHMgaW5wdXQgZXZlbnRzLlxuICBpc0lucHV0RXZlbnRTdXBwb3J0ZWQgPSBpc0V2ZW50U3VwcG9ydGVkKCdpbnB1dCcpICYmICghZG9jdW1lbnQuZG9jdW1lbnRNb2RlIHx8IGRvY3VtZW50LmRvY3VtZW50TW9kZSA+IDkpO1xufVxuXG4vKipcbiAqIChGb3IgSUUgPD05KSBTdGFydHMgdHJhY2tpbmcgcHJvcGVydHljaGFuZ2UgZXZlbnRzIG9uIHRoZSBwYXNzZWQtaW4gZWxlbWVudFxuICogYW5kIG92ZXJyaWRlIHRoZSB2YWx1ZSBwcm9wZXJ0eSBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB1c2VyIGV2ZW50cyBmcm9tXG4gKiB2YWx1ZSBjaGFuZ2VzIGluIEpTLlxuICovXG5mdW5jdGlvbiBzdGFydFdhdGNoaW5nRm9yVmFsdWVDaGFuZ2UodGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJbnN0ID0gdGFyZ2V0SW5zdDtcbiAgYWN0aXZlRWxlbWVudC5hdHRhY2hFdmVudCgnb25wcm9wZXJ0eWNoYW5nZScsIGhhbmRsZVByb3BlcnR5Q2hhbmdlKTtcbn1cblxuLyoqXG4gKiAoRm9yIElFIDw9OSkgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29ucHJvcGVydHljaGFuZ2UnLCBoYW5kbGVQcm9wZXJ0eUNoYW5nZSk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SW5zdCA9IG51bGw7XG59XG5cbi8qKlxuICogKEZvciBJRSA8PTkpIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpKSB7XG4gICAgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9ySW5wdXRFdmVudFBvbHlmaWxsKHRvcExldmVsVHlwZSwgdGFyZ2V0LCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BGb2N1cycpIHtcbiAgICAvLyBJbiBJRTksIHByb3BlcnR5Y2hhbmdlIGZpcmVzIGZvciBtb3N0IGlucHV0IGV2ZW50cyBidXQgaXMgYnVnZ3kgYW5kXG4gICAgLy8gZG9lc24ndCBmaXJlIHdoZW4gdGV4dCBpcyBkZWxldGVkLCBidXQgY29udmVuaWVudGx5LCBzZWxlY3Rpb25jaGFuZ2VcbiAgICAvLyBhcHBlYXJzIHRvIGZpcmUgaW4gYWxsIG9mIHRoZSByZW1haW5pbmcgY2FzZXMgc28gd2UgY2F0Y2ggdGhvc2UgYW5kXG4gICAgLy8gZm9yd2FyZCB0aGUgZXZlbnQgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgLy8gSW4gZWl0aGVyIGNhc2UsIHdlIGRvbid0IHdhbnQgdG8gY2FsbCB0aGUgZXZlbnQgaGFuZGxlciBpZiB0aGUgdmFsdWVcbiAgICAvLyBpcyBjaGFuZ2VkIGZyb20gSlMgc28gd2UgcmVkZWZpbmUgYSBzZXR0ZXIgZm9yIGAudmFsdWVgIHRoYXQgdXBkYXRlc1xuICAgIC8vIG91ciBhY3RpdmVFbGVtZW50VmFsdWUgdmFyaWFibGUsIGFsbG93aW5nIHVzIHRvIGlnbm9yZSB0aG9zZSBjaGFuZ2VzXG4gICAgLy9cbiAgICAvLyBzdG9wV2F0Y2hpbmcoKSBzaG91bGQgYmUgYSBub29wIGhlcmUgYnV0IHdlIGNhbGwgaXQganVzdCBpbiBjYXNlIHdlXG4gICAgLy8gbWlzc2VkIGEgYmx1ciBldmVudCBzb21laG93LlxuICAgIHN0b3BXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKCk7XG4gICAgc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SW5zdCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQmx1cicpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGwodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0KSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BTZWxlY3Rpb25DaGFuZ2UnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcEtleVVwJyB8fCB0b3BMZXZlbFR5cGUgPT09ICd0b3BLZXlEb3duJykge1xuICAgIC8vIE9uIHRoZSBzZWxlY3Rpb25jaGFuZ2UgZXZlbnQsIHRoZSB0YXJnZXQgaXMganVzdCBkb2N1bWVudCB3aGljaCBpc24ndFxuICAgIC8vIGhlbHBmdWwgZm9yIHVzIHNvIGp1c3QgY2hlY2sgYWN0aXZlRWxlbWVudCBpbnN0ZWFkLlxuICAgIC8vXG4gICAgLy8gOTklIG9mIHRoZSB0aW1lLCBrZXlkb3duIGFuZCBrZXl1cCBhcmVuJ3QgbmVjZXNzYXJ5LiBJRTggZmFpbHMgdG8gZmlyZVxuICAgIC8vIHByb3BlcnR5Y2hhbmdlIG9uIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhZnRlciBzZXR0aW5nIGB2YWx1ZWAgZnJvbSBhXG4gICAgLy8gc2NyaXB0IGFuZCBmaXJlcyBvbmx5IGtleWRvd24sIGtleXByZXNzLCBrZXl1cC4gQ2F0Y2hpbmcga2V5dXAgdXN1YWxseVxuICAgIC8vIGdldHMgaXQgYW5kIGNhdGNoaW5nIGtleWRvd24gbGV0cyB1cyBmaXJlIGFuIGV2ZW50IGZvciB0aGUgZmlyc3RcbiAgICAvLyBrZXlzdHJva2UgaWYgdXNlciBkb2VzIGEga2V5IHJlcGVhdCAoaXQnbGwgYmUgYSBsaXR0bGUgZGVsYXllZDogcmlnaHRcbiAgICAvLyBiZWZvcmUgdGhlIHNlY29uZCBrZXlzdHJva2UpLiBPdGhlciBpbnB1dCBtZXRob2RzIChlLmcuLCBwYXN0ZSkgc2VlbSB0b1xuICAgIC8vIGZpcmUgc2VsZWN0aW9uY2hhbmdlIG5vcm1hbGx5LlxuICAgIHJldHVybiBnZXRJbnN0SWZWYWx1ZUNoYW5nZWQoYWN0aXZlRWxlbWVudEluc3QpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBjbGlja2AgZXZlbnRcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ2xpY2tFdmVudChlbGVtKSB7XG4gIC8vIFVzZSB0aGUgYGNsaWNrYCBldmVudCB0byBkZXRlY3QgY2hhbmdlcyB0byBjaGVja2JveCBhbmQgcmFkaW8gaW5wdXRzLlxuICAvLyBUaGlzIGFwcHJvYWNoIHdvcmtzIGFjcm9zcyBhbGwgYnJvd3NlcnMsIHdoZXJlYXMgYGNoYW5nZWAgZG9lcyBub3QgZmlyZVxuICAvLyB1bnRpbCBgYmx1cmAgaW4gSUU4LlxuICB2YXIgbm9kZU5hbWUgPSBlbGVtLm5vZGVOYW1lO1xuICByZXR1cm4gbm9kZU5hbWUgJiYgbm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldEluc3RGb3JDbGlja0V2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wQ2xpY2snKSB7XG4gICAgcmV0dXJuIGdldEluc3RJZlZhbHVlQ2hhbmdlZCh0YXJnZXRJbnN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJbnN0Rm9ySW5wdXRPckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wSW5wdXQnIHx8IHRvcExldmVsVHlwZSA9PT0gJ3RvcENoYW5nZScpIHtcbiAgICByZXR1cm4gZ2V0SW5zdElmVmFsdWVDaGFuZ2VkKHRhcmdldEluc3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZUNvbnRyb2xsZWRJbnB1dEJsdXIoaW5zdCwgbm9kZSkge1xuICAvLyBUT0RPOiBJbiBJRSwgaW5zdCBpcyBvY2Nhc2lvbmFsbHkgbnVsbC4gV2h5P1xuICBpZiAoaW5zdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gRmliZXIgYW5kIFJlYWN0RE9NIGtlZXAgd3JhcHBlciBzdGF0ZSBpbiBzZXBhcmF0ZSBwbGFjZXNcbiAgdmFyIHN0YXRlID0gaW5zdC5fd3JhcHBlclN0YXRlIHx8IG5vZGUuX3dyYXBwZXJTdGF0ZTtcblxuICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5jb250cm9sbGVkIHx8IG5vZGUudHlwZSAhPT0gJ251bWJlcicpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBjb250cm9sbGVkLCBhc3NpZ24gdGhlIHZhbHVlIGF0dHJpYnV0ZSB0byB0aGUgY3VycmVudCB2YWx1ZSBvbiBibHVyXG4gIHZhciB2YWx1ZSA9ICcnICsgbm9kZS52YWx1ZTtcbiAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKCd2YWx1ZScpICE9PSB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlKCd2YWx1ZScsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMSxcblxuICBfaXNJbnB1dEV2ZW50U3VwcG9ydGVkOiBpc0lucHV0RXZlbnRTdXBwb3J0ZWQsXG5cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgdmFyIGdldFRhcmdldEluc3RGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRhcmdldE5vZGUpKSB7XG4gICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JDaGFuZ2VFdmVudDtcbiAgICB9IGVsc2UgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0YXJnZXROb2RlKSkge1xuICAgICAgaWYgKGlzSW5wdXRFdmVudFN1cHBvcnRlZCkge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dE9yQ2hhbmdlRXZlbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBnZXRUYXJnZXRJbnN0RnVuYyA9IGdldFRhcmdldEluc3RGb3JJbnB1dEV2ZW50UG9seWZpbGw7XG4gICAgICAgIGhhbmRsZUV2ZW50RnVuYyA9IGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRQb2x5ZmlsbDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHNob3VsZFVzZUNsaWNrRXZlbnQodGFyZ2V0Tm9kZSkpIHtcbiAgICAgIGdldFRhcmdldEluc3RGdW5jID0gZ2V0VGFyZ2V0SW5zdEZvckNsaWNrRXZlbnQ7XG4gICAgfVxuXG4gICAgaWYgKGdldFRhcmdldEluc3RGdW5jKSB7XG4gICAgICB2YXIgaW5zdCA9IGdldFRhcmdldEluc3RGdW5jKHRvcExldmVsVHlwZSwgdGFyZ2V0SW5zdCk7XG4gICAgICBpZiAoaW5zdCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBjcmVhdGVBbmRBY2N1bXVsYXRlQ2hhbmdlRXZlbnQoaW5zdCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgcmV0dXJuIGV2ZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYW5kbGVFdmVudEZ1bmMpIHtcbiAgICAgIGhhbmRsZUV2ZW50RnVuYyh0b3BMZXZlbFR5cGUsIHRhcmdldE5vZGUsIHRhcmdldEluc3QpO1xuICAgIH1cblxuICAgIC8vIFdoZW4gYmx1cnJpbmcsIHNldCB0aGUgdmFsdWUgYXR0cmlidXRlIGZvciBudW1iZXIgaW5wdXRzXG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICBoYW5kbGVDb250cm9sbGVkSW5wdXRCbHVyKHRhcmdldEluc3QsIHRhcmdldE5vZGUpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERPTUV2ZW50UGx1Z2luT3JkZXIgPSBbJ1Jlc3BvbmRlckV2ZW50UGx1Z2luJywgJ1NpbXBsZUV2ZW50UGx1Z2luJywgJ1RhcEV2ZW50UGx1Z2luJywgJ0VudGVyTGVhdmVFdmVudFBsdWdpbicsICdDaGFuZ2VFdmVudFBsdWdpbicsICdTZWxlY3RFdmVudFBsdWdpbicsICdCZWZvcmVJbnB1dEV2ZW50UGx1Z2luJ107XG5cbi8qKlxuICogQGludGVyZmFjZSBVSUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIFVJRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHZpZXc6IG51bGwsXG4gIGRldGFpbDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1VJRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY0V2ZW50JDEuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50JDEuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgQWx0OiAnYWx0S2V5JyxcbiAgQ29udHJvbDogJ2N0cmxLZXknLFxuICBNZXRhOiAnbWV0YUtleScsXG4gIFNoaWZ0OiAnc2hpZnRLZXknXG59O1xuXG4vLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGdldE1vZGlmaWVyU3RhdGUgc28gd2Ugc2ltcGx5IG1hcCBpdCB0byB0aGUgb25seVxuLy8gbW9kaWZpZXIga2V5cyBleHBvc2VkIGJ5IHRoZSBldmVudCBpdHNlbGYsIGRvZXMgbm90IHN1cHBvcnQgTG9jay1rZXlzLlxuLy8gQ3VycmVudGx5LCBhbGwgbWFqb3IgYnJvd3NlcnMgZXhjZXB0IENocm9tZSBzZWVtcyB0byBzdXBwb3J0IExvY2sta2V5cy5cbmZ1bmN0aW9uIG1vZGlmaWVyU3RhdGVHZXR0ZXIoa2V5QXJnKSB7XG4gIHZhciBzeW50aGV0aWNFdmVudCA9IHRoaXM7XG4gIHZhciBuYXRpdmVFdmVudCA9IHN5bnRoZXRpY0V2ZW50Lm5hdGl2ZUV2ZW50O1xuICBpZiAobmF0aXZlRXZlbnQuZ2V0TW9kaWZpZXJTdGF0ZSkge1xuICAgIHJldHVybiBuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKGtleUFyZyk7XG4gIH1cbiAgdmFyIGtleVByb3AgPSBtb2RpZmllcktleVRvUHJvcFtrZXlBcmddO1xuICByZXR1cm4ga2V5UHJvcCA/ICEhbmF0aXZlRXZlbnRba2V5UHJvcF0gOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZ2V0RXZlbnRNb2RpZmllclN0YXRlKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiBtb2RpZmllclN0YXRlR2V0dGVyO1xufVxuXG4vKipcbiAqIEBpbnRlcmZhY2UgTW91c2VFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBNb3VzZUV2ZW50SW50ZXJmYWNlID0ge1xuICBzY3JlZW5YOiBudWxsLFxuICBzY3JlZW5ZOiBudWxsLFxuICBjbGllbnRYOiBudWxsLFxuICBjbGllbnRZOiBudWxsLFxuICBwYWdlWDogbnVsbCxcbiAgcGFnZVk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBudWxsLFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY01vdXNlRXZlbnQsIE1vdXNlRXZlbnRJbnRlcmZhY2UpO1xuXG52YXIgZXZlbnRUeXBlcyQyID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZTogJ29uTW91c2VFbnRlcicsXG4gICAgZGVwZW5kZW5jaWVzOiBbJ3RvcE1vdXNlT3V0JywgJ3RvcE1vdXNlT3ZlciddXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiAnb25Nb3VzZUxlYXZlJyxcbiAgICBkZXBlbmRlbmNpZXM6IFsndG9wTW91c2VPdXQnLCAndG9wTW91c2VPdmVyJ11cbiAgfVxufTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyQyLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICBpZiAodG9wTGV2ZWxUeXBlID09PSAndG9wTW91c2VPdmVyJyAmJiAobmF0aXZlRXZlbnQucmVsYXRlZFRhcmdldCB8fCBuYXRpdmVFdmVudC5mcm9tRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodG9wTGV2ZWxUeXBlICE9PSAndG9wTW91c2VPdXQnICYmIHRvcExldmVsVHlwZSAhPT0gJ3RvcE1vdXNlT3ZlcicpIHtcbiAgICAgIC8vIE11c3Qgbm90IGJlIGEgbW91c2UgaW4gb3IgbW91c2Ugb3V0IC0gaWdub3JpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgd2luO1xuICAgIGlmIChuYXRpdmVFdmVudFRhcmdldC53aW5kb3cgPT09IG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgICAvLyBgbmF0aXZlRXZlbnRUYXJnZXRgIGlzIHByb2JhYmx5IGEgd2luZG93IG9iamVjdC5cbiAgICAgIHdpbiA9IG5hdGl2ZUV2ZW50VGFyZ2V0O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBGaWd1cmUgb3V0IHdoeSBgb3duZXJEb2N1bWVudGAgaXMgc29tZXRpbWVzIHVuZGVmaW5lZCBpbiBJRTguXG4gICAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQub3duZXJEb2N1bWVudDtcbiAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgd2luID0gZG9jLmRlZmF1bHRWaWV3IHx8IGRvYy5wYXJlbnRXaW5kb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3aW4gPSB3aW5kb3c7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGZyb207XG4gICAgdmFyIHRvO1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09ICd0b3BNb3VzZU91dCcpIHtcbiAgICAgIGZyb20gPSB0YXJnZXRJbnN0O1xuICAgICAgdmFyIHJlbGF0ZWQgPSBuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudDtcbiAgICAgIHRvID0gcmVsYXRlZCA/IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJlbGF0ZWQpIDogbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTW92aW5nIHRvIGEgbm9kZSBmcm9tIG91dHNpZGUgdGhlIHdpbmRvdy5cbiAgICAgIGZyb20gPSBudWxsO1xuICAgICAgdG8gPSB0YXJnZXRJbnN0O1xuICAgIH1cblxuICAgIGlmIChmcm9tID09PSB0bykge1xuICAgICAgLy8gTm90aGluZyBwZXJ0YWlucyB0byBvdXIgbWFuYWdlZCBjb21wb25lbnRzLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGZyb21Ob2RlID0gZnJvbSA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKGZyb20pO1xuICAgIHZhciB0b05vZGUgPSB0byA9PSBudWxsID8gd2luIDogZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRvKTtcblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUxlYXZlLCBmcm9tLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbU5vZGU7XG4gICAgbGVhdmUucmVsYXRlZFRhcmdldCA9IHRvTm9kZTtcblxuICAgIHZhciBlbnRlciA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMi5tb3VzZUVudGVyLCB0bywgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICBlbnRlci50eXBlID0gJ21vdXNlZW50ZXInO1xuICAgIGVudGVyLnRhcmdldCA9IHRvTm9kZTtcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbU5vZGU7XG5cbiAgICBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXMobGVhdmUsIGVudGVyLCBmcm9tLCB0byk7XG5cbiAgICByZXR1cm4gW2xlYXZlLCBlbnRlcl07XG4gIH1cbn07XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKlxuICogTm90ZSB0aGF0IHRoaXMgbW9kdWxlIGlzIGN1cnJlbnRseSBzaGFyZWQgYW5kIGFzc3VtZWQgdG8gYmUgc3RhdGVsZXNzLlxuICogSWYgdGhpcyBiZWNvbWVzIGFuIGFjdHVhbCBNYXAsIHRoYXQgd2lsbCBicmVhay5cbiAqL1xuXG4vKipcbiAqIFRoaXMgQVBJIHNob3VsZCBiZSBjYWxsZWQgYGRlbGV0ZWAgYnV0IHdlJ2QgaGF2ZSB0byBtYWtlIHN1cmUgdG8gYWx3YXlzXG4gKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICogc3VwcG9ydGVkIHdlIGNhbiByZW5hbWUgaXQuXG4gKi9cblxuXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxGaWJlcjtcbn1cblxuZnVuY3Rpb24gaGFzKGtleSkge1xuICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsRmliZXIgIT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFsRmliZXIgPSB2YWx1ZTtcbn1cblxudmFyIFJlYWN0SW50ZXJuYWxzID0gUmVhY3QuX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IFJlYWN0SW50ZXJuYWxzLlJlYWN0Q3VycmVudE93bmVyO1xudmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB7XG4gIHZhciB0eXBlID0gZmliZXIudHlwZTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBEb24ndCBjaGFuZ2UgdGhlc2UgdHdvIHZhbHVlczpcbnZhciBOb0VmZmVjdCA9IDA7IC8vICAgICAgICAgICAwYjAwMDAwMDAwXG52YXIgUGVyZm9ybWVkV29yayA9IDE7IC8vICAgICAgMGIwMDAwMDAwMVxuXG4vLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cbnZhciBQbGFjZW1lbnQgPSAyOyAvLyAgICAgICAgICAwYjAwMDAwMDEwXG52YXIgVXBkYXRlID0gNDsgLy8gICAgICAgICAgICAgMGIwMDAwMDEwMFxudmFyIFBsYWNlbWVudEFuZFVwZGF0ZSA9IDY7IC8vIDBiMDAwMDAxMTBcbnZhciBEZWxldGlvbiA9IDg7IC8vICAgICAgICAgICAwYjAwMDAxMDAwXG52YXIgQ29udGVudFJlc2V0ID0gMTY7IC8vICAgICAgMGIwMDAxMDAwMFxudmFyIENhbGxiYWNrID0gMzI7IC8vICAgICAgICAgIDBiMDAxMDAwMDBcbnZhciBFcnIgPSA2NDsgLy8gICAgICAgICAgICAgICAwYjAxMDAwMDAwXG52YXIgUmVmID0gMTI4OyAvLyAgICAgICAgICAgICAgMGIxMDAwMDAwMFxuXG52YXIgTU9VTlRJTkcgPSAxO1xudmFyIE1PVU5URUQgPSAyO1xudmFyIFVOTU9VTlRFRCA9IDM7XG5cbmZ1bmN0aW9uIGlzRmliZXJNb3VudGVkSW1wbChmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgIHJldHVybiBNT1VOVElORztcbiAgICB9XG4gICAgd2hpbGUgKG5vZGVbJ3JldHVybiddKSB7XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBpZiAoKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSAhPT0gTm9FZmZlY3QpIHtcbiAgICAgICAgcmV0dXJuIE1PVU5USU5HO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZVsncmV0dXJuJ10pIHtcbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIFRPRE86IENoZWNrIGlmIHRoaXMgd2FzIGEgbmVzdGVkIEhvc3RSb290IHdoZW4gdXNlZCB3aXRoXG4gICAgLy8gcmVuZGVyQ29udGFpbmVySW50b1N1YnRyZWUuXG4gICAgcmV0dXJuIE1PVU5URUQ7XG4gIH1cbiAgLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuICByZXR1cm4gVU5NT1VOVEVEO1xufVxuXG5mdW5jdGlvbiBpc0ZpYmVyTW91bnRlZChmaWJlcikge1xuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gaXNNb3VudGVkKGNvbXBvbmVudCkge1xuICB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuICAgICAgd2FybmluZyhpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIsICclcyBpcyBhY2Nlc3NpbmcgaXNNb3VudGVkIGluc2lkZSBpdHMgcmVuZGVyKCkgZnVuY3Rpb24uICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lKG93bmVyRmliZXIpIHx8ICdBIGNvbXBvbmVudCcpO1xuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRDtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gICEoaXNGaWJlck1vdW50ZWRJbXBsKGZpYmVyKSA9PT0gTU9VTlRFRCkgPyBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJykgOiB2b2lkIDA7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBzdGF0ZSA9IGlzRmliZXJNb3VudGVkSW1wbChmaWJlcik7XG4gICAgIShzdGF0ZSAhPT0gVU5NT1VOVEVEKSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgICBpZiAoc3RhdGUgPT09IE1PVU5USU5HKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYVsncmV0dXJuJ107XG4gICAgdmFyIHBhcmVudEIgPSBwYXJlbnRBID8gcGFyZW50QS5hbHRlcm5hdGUgOiBudWxsO1xuICAgIGlmICghcGFyZW50QSB8fCAhcGFyZW50Qikge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoaWxkID09PSBiKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEIgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gYWx0ZXJuYXRlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICAgIC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGFbJ3JldHVybiddICE9PSBiWydyZXR1cm4nXSkge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcbiAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYSkge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgYiA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAvLyBTZWFyY2ggcGFyZW50IEIncyBjaGlsZCBzZXRcbiAgICAgICAgX2NoaWxkID0gcGFyZW50Qi5jaGlsZDtcbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgICFkaWRGaW5kQ2hpbGQgPyBpbnZhcmlhbnQoZmFsc2UsICdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShhLmFsdGVybmF0ZSA9PT0gYikgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXR1cm4gZmliZXJzIHNob3VsZCBhbHdheXMgYmUgZWFjaCBvdGhlcnNcXCcgYWx0ZXJuYXRlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgfVxuICAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG4gICEoYS50YWcgPT09IEhvc3RSb290KSA/IGludmFyaWFudChmYWxzZSwgJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKSA6IHZvaWQgMDtcbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9XG4gIC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXIocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHMocGFyZW50KSB7XG4gIHZhciBjdXJyZW50UGFyZW50ID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgocGFyZW50KTtcbiAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgbm9kZSA9IGN1cnJlbnRQYXJlbnQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICYmIG5vZGUudGFnICE9PSBIb3N0UG9ydGFsKSB7XG4gICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gY3VycmVudFBhcmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHdoaWxlICghbm9kZS5zaWJsaW5nKSB7XG4gICAgICBpZiAoIW5vZGVbJ3JldHVybiddIHx8IG5vZGVbJ3JldHVybiddID09PSBjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgIH1cbiAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxuICAvLyBGbG93IG5lZWRzIHRoZSByZXR1cm4gbnVsbCBoZXJlLCBidXQgRVNMaW50IGNvbXBsYWlucyBhYm91dCBpdC5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgQ0FMTEJBQ0tfQk9PS0tFRVBJTkdfUE9PTF9TSVpFID0gMTA7XG52YXIgY2FsbGJhY2tCb29ra2VlcGluZ1Bvb2wgPSBbXTtcblxuLyoqXG4gKiBGaW5kIHRoZSBkZWVwZXN0IFJlYWN0IGNvbXBvbmVudCBjb21wbGV0ZWx5IGNvbnRhaW5pbmcgdGhlIHJvb3Qgb2YgdGhlXG4gKiBwYXNzZWQtaW4gaW5zdGFuY2UgKGZvciB1c2Ugd2hlbiBlbnRpcmUgUmVhY3QgdHJlZXMgYXJlIG5lc3RlZCB3aXRoaW4gZWFjaFxuICogb3RoZXIpLiBJZiBSZWFjdCB0cmVlcyBhcmUgbm90IG5lc3RlZCwgcmV0dXJucyBudWxsLlxuICovXG5mdW5jdGlvbiBmaW5kUm9vdENvbnRhaW5lck5vZGUoaW5zdCkge1xuICAvLyBUT0RPOiBJdCBtYXkgYmUgYSBnb29kIGlkZWEgdG8gY2FjaGUgdGhpcyB0byBwcmV2ZW50IHVubmVjZXNzYXJ5IERPTVxuICAvLyB0cmF2ZXJzYWwsIGJ1dCBjYWNoaW5nIGlzIGRpZmZpY3VsdCB0byBkbyBjb3JyZWN0bHkgd2l0aG91dCB1c2luZyBhXG4gIC8vIG11dGF0aW9uIG9ic2VydmVyIHRvIGxpc3RlbiBmb3IgYWxsIERPTSBjaGFuZ2VzLlxuICB3aGlsZSAoaW5zdFsncmV0dXJuJ10pIHtcbiAgICBpbnN0ID0gaW5zdFsncmV0dXJuJ107XG4gIH1cbiAgaWYgKGluc3QudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB3ZSdyZSBpbiBhIGRldGFjaGVkIHRyZWUuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGluc3Quc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG59XG5cbi8vIFVzZWQgdG8gc3RvcmUgYW5jZXN0b3IgaGllcmFyY2h5IGluIHRvcCBsZXZlbCBjYWxsYmFja1xuZnVuY3Rpb24gZ2V0VG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nKHRvcExldmVsVHlwZSwgbmF0aXZlRXZlbnQsIHRhcmdldEluc3QpIHtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnBvcCgpO1xuICAgIGluc3RhbmNlLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICAgIGluc3RhbmNlLnRhcmdldEluc3QgPSB0YXJnZXRJbnN0O1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHRvcExldmVsVHlwZTogdG9wTGV2ZWxUeXBlLFxuICAgIG5hdGl2ZUV2ZW50OiBuYXRpdmVFdmVudCxcbiAgICB0YXJnZXRJbnN0OiB0YXJnZXRJbnN0LFxuICAgIGFuY2VzdG9yczogW11cbiAgfTtcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyhpbnN0YW5jZSkge1xuICBpbnN0YW5jZS50b3BMZXZlbFR5cGUgPSBudWxsO1xuICBpbnN0YW5jZS5uYXRpdmVFdmVudCA9IG51bGw7XG4gIGluc3RhbmNlLnRhcmdldEluc3QgPSBudWxsO1xuICBpbnN0YW5jZS5hbmNlc3RvcnMubGVuZ3RoID0gMDtcbiAgaWYgKGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLmxlbmd0aCA8IENBTExCQUNLX0JPT0tLRUVQSU5HX1BPT0xfU0laRSkge1xuICAgIGNhbGxiYWNrQm9va2tlZXBpbmdQb29sLnB1c2goaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRvcExldmVsSW1wbChib29rS2VlcGluZykge1xuICB2YXIgdGFyZ2V0SW5zdCA9IGJvb2tLZWVwaW5nLnRhcmdldEluc3Q7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRhcmdldEluc3Q7XG4gIGRvIHtcbiAgICBpZiAoIWFuY2VzdG9yKSB7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgdmFyIHJvb3QgPSBmaW5kUm9vdENvbnRhaW5lck5vZGUoYW5jZXN0b3IpO1xuICAgIGlmICghcm9vdCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGJvb2tLZWVwaW5nLmFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICBhbmNlc3RvciA9IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlKHJvb3QpO1xuICB9IHdoaWxlIChhbmNlc3Rvcik7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBib29rS2VlcGluZy5hbmNlc3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB0YXJnZXRJbnN0ID0gYm9va0tlZXBpbmcuYW5jZXN0b3JzW2ldO1xuICAgIF9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIFRPRE86IGNhbiB3ZSBzdG9wIGV4cG9ydGluZyB0aGVzZT9cbnZhciBfZW5hYmxlZCA9IHRydWU7XG52YXIgX2hhbmRsZVRvcExldmVsID0gdm9pZCAwO1xuXG5mdW5jdGlvbiBzZXRIYW5kbGVUb3BMZXZlbChoYW5kbGVUb3BMZXZlbCkge1xuICBfaGFuZGxlVG9wTGV2ZWwgPSBoYW5kbGVUb3BMZXZlbDtcbn1cblxuZnVuY3Rpb24gc2V0RW5hYmxlZChlbmFibGVkKSB7XG4gIF9lbmFibGVkID0gISFlbmFibGVkO1xufVxuXG5mdW5jdGlvbiBpc0VuYWJsZWQoKSB7XG4gIHJldHVybiBfZW5hYmxlZDtcbn1cblxuLyoqXG4gKiBUcmFwcyB0b3AtbGV2ZWwgZXZlbnRzIGJ5IHVzaW5nIGV2ZW50IGJ1YmJsaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgZWxlbWVudCkge1xuICBpZiAoIWVsZW1lbnQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBkaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG59XG5cbi8qKlxuICogVHJhcHMgYSB0b3AtbGV2ZWwgZXZlbnQgYnkgdXNpbmcgZXZlbnQgY2FwdHVyaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEJyb3dzZXJFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge3N0cmluZ30gaGFuZGxlckJhc2VOYW1lIEV2ZW50IG5hbWUgKGUuZy4gXCJjbGlja1wiKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBlbGVtZW50IEVsZW1lbnQgb24gd2hpY2ggdG8gYXR0YWNoIGxpc3RlbmVyLlxuICogQHJldHVybiB7P29iamVjdH0gQW4gb2JqZWN0IHdpdGggYSByZW1vdmUgZnVuY3Rpb24gd2hpY2ggd2lsbCBmb3JjZWZ1bGx5XG4gKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGVsZW1lbnQpIHtcbiAgaWYgKCFlbGVtZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIGRpc3BhdGNoRXZlbnQuYmluZChudWxsLCB0b3BMZXZlbFR5cGUpKTtcbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hFdmVudCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIGlmICghX2VuYWJsZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgbmF0aXZlRXZlbnRUYXJnZXQgPSBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCk7XG4gIHZhciB0YXJnZXRJbnN0ID0gZ2V0Q2xvc2VzdEluc3RhbmNlRnJvbU5vZGUobmF0aXZlRXZlbnRUYXJnZXQpO1xuICBpZiAodGFyZ2V0SW5zdCAhPT0gbnVsbCAmJiB0eXBlb2YgdGFyZ2V0SW5zdC50YWcgPT09ICdudW1iZXInICYmICFpc0ZpYmVyTW91bnRlZCh0YXJnZXRJbnN0KSkge1xuICAgIC8vIElmIHdlIGdldCBhbiBldmVudCAoZXg6IGltZyBvbmxvYWQpIGJlZm9yZSBjb21taXR0aW5nIHRoYXRcbiAgICAvLyBjb21wb25lbnQncyBtb3VudCwgaWdub3JlIGl0IGZvciBub3cgKHRoYXQgaXMsIHRyZWF0IGl0IGFzIGlmIGl0IHdhcyBhblxuICAgIC8vIGV2ZW50IG9uIGEgbm9uLVJlYWN0IHRyZWUpLiBXZSBtaWdodCBhbHNvIGNvbnNpZGVyIHF1ZXVlaW5nIGV2ZW50cyBhbmRcbiAgICAvLyBkaXNwYXRjaGluZyB0aGVtIGFmdGVyIHRoZSBtb3VudC5cbiAgICB0YXJnZXRJbnN0ID0gbnVsbDtcbiAgfVxuXG4gIHZhciBib29rS2VlcGluZyA9IGdldFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50LCB0YXJnZXRJbnN0KTtcblxuICB0cnkge1xuICAgIC8vIEV2ZW50IHF1ZXVlIGJlaW5nIHByb2Nlc3NlZCBpbiB0aGUgc2FtZSBjeWNsZSBhbGxvd3NcbiAgICAvLyBgcHJldmVudERlZmF1bHRgLlxuICAgIGJhdGNoZWRVcGRhdGVzKGhhbmRsZVRvcExldmVsSW1wbCwgYm9va0tlZXBpbmcpO1xuICB9IGZpbmFsbHkge1xuICAgIHJlbGVhc2VUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcoYm9va0tlZXBpbmcpO1xuICB9XG59XG5cbnZhciBSZWFjdERPTUV2ZW50TGlzdGVuZXIgPSBPYmplY3QuZnJlZXplKHtcblx0Z2V0IF9lbmFibGVkICgpIHsgcmV0dXJuIF9lbmFibGVkOyB9LFxuXHRnZXQgX2hhbmRsZVRvcExldmVsICgpIHsgcmV0dXJuIF9oYW5kbGVUb3BMZXZlbDsgfSxcblx0c2V0SGFuZGxlVG9wTGV2ZWw6IHNldEhhbmRsZVRvcExldmVsLFxuXHRzZXRFbmFibGVkOiBzZXRFbmFibGVkLFxuXHRpc0VuYWJsZWQ6IGlzRW5hYmxlZCxcblx0dHJhcEJ1YmJsZWRFdmVudDogdHJhcEJ1YmJsZWRFdmVudCxcblx0dHJhcENhcHR1cmVkRXZlbnQ6IHRyYXBDYXB0dXJlZEV2ZW50LFxuXHRkaXNwYXRjaEV2ZW50OiBkaXNwYXRjaEV2ZW50XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBhIG1hcHBpbmcgb2Ygc3RhbmRhcmQgdmVuZG9yIHByZWZpeGVzIHVzaW5nIHRoZSBkZWZpbmVkIHN0eWxlIHByb3BlcnR5IGFuZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVByb3BcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG1ha2VQcmVmaXhNYXAoc3R5bGVQcm9wLCBldmVudE5hbWUpIHtcbiAgdmFyIHByZWZpeGVzID0ge307XG5cbiAgcHJlZml4ZXNbc3R5bGVQcm9wLnRvTG93ZXJDYXNlKCldID0gZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHByZWZpeGVzWydXZWJraXQnICsgc3R5bGVQcm9wXSA9ICd3ZWJraXQnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTW96JyArIHN0eWxlUHJvcF0gPSAnbW96JyArIGV2ZW50TmFtZTtcbiAgcHJlZml4ZXNbJ21zJyArIHN0eWxlUHJvcF0gPSAnTVMnICsgZXZlbnROYW1lO1xuICBwcmVmaXhlc1snTycgKyBzdHlsZVByb3BdID0gJ28nICsgZXZlbnROYW1lLnRvTG93ZXJDYXNlKCk7XG5cbiAgcmV0dXJuIHByZWZpeGVzO1xufVxuXG4vKipcbiAqIEEgbGlzdCBvZiBldmVudCBuYW1lcyB0byBhIGNvbmZpZ3VyYWJsZSBsaXN0IG9mIHZlbmRvciBwcmVmaXhlcy5cbiAqL1xudmFyIHZlbmRvclByZWZpeGVzID0ge1xuICBhbmltYXRpb25lbmQ6IG1ha2VQcmVmaXhNYXAoJ0FuaW1hdGlvbicsICdBbmltYXRpb25FbmQnKSxcbiAgYW5pbWF0aW9uaXRlcmF0aW9uOiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uSXRlcmF0aW9uJyksXG4gIGFuaW1hdGlvbnN0YXJ0OiBtYWtlUHJlZml4TWFwKCdBbmltYXRpb24nLCAnQW5pbWF0aW9uU3RhcnQnKSxcbiAgdHJhbnNpdGlvbmVuZDogbWFrZVByZWZpeE1hcCgnVHJhbnNpdGlvbicsICdUcmFuc2l0aW9uRW5kJylcbn07XG5cbi8qKlxuICogRXZlbnQgbmFtZXMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBkZXRlY3RlZCBhbmQgcHJlZml4ZWQgKGlmIGFwcGxpY2FibGUpLlxuICovXG52YXIgcHJlZml4ZWRFdmVudE5hbWVzID0ge307XG5cbi8qKlxuICogRWxlbWVudCB0byBjaGVjayBmb3IgcHJlZml4ZXMgb24uXG4gKi9cbnZhciBzdHlsZSA9IHt9O1xuXG4vKipcbiAqIEJvb3RzdHJhcCBpZiBhIERPTSBleGlzdHMuXG4gKi9cbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcblxuICAvLyBPbiBzb21lIHBsYXRmb3JtcywgaW4gcGFydGljdWxhciBzb21lIHJlbGVhc2VzIG9mIEFuZHJvaWQgNC54LFxuICAvLyB0aGUgdW4tcHJlZml4ZWQgXCJhbmltYXRpb25cIiBhbmQgXCJ0cmFuc2l0aW9uXCIgcHJvcGVydGllcyBhcmUgZGVmaW5lZCBvbiB0aGVcbiAgLy8gc3R5bGUgb2JqZWN0IGJ1dCB0aGUgZXZlbnRzIHRoYXQgZmlyZSB3aWxsIHN0aWxsIGJlIHByZWZpeGVkLCBzbyB3ZSBuZWVkXG4gIC8vIHRvIGNoZWNrIGlmIHRoZSB1bi1wcmVmaXhlZCBldmVudHMgYXJlIHVzYWJsZSwgYW5kIGlmIG5vdCByZW1vdmUgdGhlbSBmcm9tIHRoZSBtYXAuXG4gIGlmICghKCdBbmltYXRpb25FdmVudCcgaW4gd2luZG93KSkge1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25lbmQuYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25pdGVyYXRpb24uYW5pbWF0aW9uO1xuICAgIGRlbGV0ZSB2ZW5kb3JQcmVmaXhlcy5hbmltYXRpb25zdGFydC5hbmltYXRpb247XG4gIH1cblxuICAvLyBTYW1lIGFzIGFib3ZlXG4gIGlmICghKCdUcmFuc2l0aW9uRXZlbnQnIGluIHdpbmRvdykpIHtcbiAgICBkZWxldGUgdmVuZG9yUHJlZml4ZXMudHJhbnNpdGlvbmVuZC50cmFuc2l0aW9uO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZGV0ZXJtaW5lIHRoZSBjb3JyZWN0IHZlbmRvciBwcmVmaXhlZCBldmVudCBuYW1lLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldFZlbmRvclByZWZpeGVkRXZlbnROYW1lKGV2ZW50TmFtZSkge1xuICBpZiAocHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gcHJlZml4ZWRFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gIH0gZWxzZSBpZiAoIXZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV0pIHtcbiAgICByZXR1cm4gZXZlbnROYW1lO1xuICB9XG5cbiAgdmFyIHByZWZpeE1hcCA9IHZlbmRvclByZWZpeGVzW2V2ZW50TmFtZV07XG5cbiAgZm9yICh2YXIgc3R5bGVQcm9wIGluIHByZWZpeE1hcCkge1xuICAgIGlmIChwcmVmaXhNYXAuaGFzT3duUHJvcGVydHkoc3R5bGVQcm9wKSAmJiBzdHlsZVByb3AgaW4gc3R5bGUpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHByZWZpeE1hcFtzdHlsZVByb3BdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICpcbiAqIEZvciBldmVudHMgbGlrZSAnc3VibWl0JyB3aGljaCBkb24ndCBjb25zaXN0ZW50bHkgYnViYmxlICh3aGljaCB3ZVxuICogdHJhcCBhdCBhIGxvd2VyIG5vZGUgdGhhbiBgZG9jdW1lbnRgKSwgYmluZGluZyBhdCBgZG9jdW1lbnRgIHdvdWxkXG4gKiBjYXVzZSBkdXBsaWNhdGUgZXZlbnRzIHNvIHdlIGRvbid0IGluY2x1ZGUgdGhlbSBoZXJlLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyQxID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQW5pbWF0aW9uRW5kOiBnZXRWZW5kb3JQcmVmaXhlZEV2ZW50TmFtZSgnYW5pbWF0aW9uZW5kJykgfHwgJ2FuaW1hdGlvbmVuZCcsXG4gIHRvcEFuaW1hdGlvbkl0ZXJhdGlvbjogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbml0ZXJhdGlvbicpIHx8ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICB0b3BBbmltYXRpb25TdGFydDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ2FuaW1hdGlvbnN0YXJ0JykgfHwgJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgdG9wQmx1cjogJ2JsdXInLFxuICB0b3BDYW5jZWw6ICdjYW5jZWwnLFxuICB0b3BDYW5QbGF5OiAnY2FucGxheScsXG4gIHRvcENhblBsYXlUaHJvdWdoOiAnY2FucGxheXRocm91Z2gnLFxuICB0b3BDaGFuZ2U6ICdjaGFuZ2UnLFxuICB0b3BDbGljazogJ2NsaWNrJyxcbiAgdG9wQ2xvc2U6ICdjbG9zZScsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZDogJ2xvYWQnLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogJ2xvYWRlZG1ldGFkYXRhJyxcbiAgdG9wTG9hZFN0YXJ0OiAnbG9hZHN0YXJ0JyxcbiAgdG9wTW91c2VEb3duOiAnbW91c2Vkb3duJyxcbiAgdG9wTW91c2VNb3ZlOiAnbW91c2Vtb3ZlJyxcbiAgdG9wTW91c2VPdXQ6ICdtb3VzZW91dCcsXG4gIHRvcE1vdXNlT3ZlcjogJ21vdXNlb3ZlcicsXG4gIHRvcE1vdXNlVXA6ICdtb3VzZXVwJyxcbiAgdG9wUGFzdGU6ICdwYXN0ZScsXG4gIHRvcFBhdXNlOiAncGF1c2UnLFxuICB0b3BQbGF5OiAncGxheScsXG4gIHRvcFBsYXlpbmc6ICdwbGF5aW5nJyxcbiAgdG9wUHJvZ3Jlc3M6ICdwcm9ncmVzcycsXG4gIHRvcFJhdGVDaGFuZ2U6ICdyYXRlY2hhbmdlJyxcbiAgdG9wU2Nyb2xsOiAnc2Nyb2xsJyxcbiAgdG9wU2Vla2VkOiAnc2Vla2VkJyxcbiAgdG9wU2Vla2luZzogJ3NlZWtpbmcnLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6ICdzZWxlY3Rpb25jaGFuZ2UnLFxuICB0b3BTdGFsbGVkOiAnc3RhbGxlZCcsXG4gIHRvcFN1c3BlbmQ6ICdzdXNwZW5kJyxcbiAgdG9wVGV4dElucHV0OiAndGV4dElucHV0JyxcbiAgdG9wVGltZVVwZGF0ZTogJ3RpbWV1cGRhdGUnLFxuICB0b3BUb2dnbGU6ICd0b2dnbGUnLFxuICB0b3BUb3VjaENhbmNlbDogJ3RvdWNoY2FuY2VsJyxcbiAgdG9wVG91Y2hFbmQ6ICd0b3VjaGVuZCcsXG4gIHRvcFRvdWNoTW92ZTogJ3RvdWNobW92ZScsXG4gIHRvcFRvdWNoU3RhcnQ6ICd0b3VjaHN0YXJ0JyxcbiAgdG9wVHJhbnNpdGlvbkVuZDogZ2V0VmVuZG9yUHJlZml4ZWRFdmVudE5hbWUoJ3RyYW5zaXRpb25lbmQnKSB8fCAndHJhbnNpdGlvbmVuZCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbnZhciBCcm93c2VyRXZlbnRDb25zdGFudHMgPSB7XG4gIHRvcExldmVsVHlwZXM6IHRvcExldmVsVHlwZXMkMVxufTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIGVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgcHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG4vKipcbiAqIFN0cmVhbXMgYSBmaXJlZCB0b3AtbGV2ZWwgZXZlbnQgdG8gYEV2ZW50UGx1Z2luSHViYCB3aGVyZSBwbHVnaW5zIGhhdmUgdGhlXG4gKiBvcHBvcnR1bml0eSB0byBjcmVhdGUgYFJlYWN0RXZlbnRgcyB0byBiZSBkaXNwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVUb3BMZXZlbCh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICB2YXIgZXZlbnRzID0gZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRhcmdldEluc3QsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG59XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gQnJvd3NlckV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdERPTUV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnRcbiAqICAgIHBsdWdnYWJsZSBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW5cbiAqICAgIHRocmVhZC5cbiAqXG4gKiAgLSBXZSBub3JtYWxpemUgYW5kIGRlLWR1cGxpY2F0ZSBldmVudHMgdG8gYWNjb3VudCBmb3IgYnJvd3NlciBxdWlya3MuIFRoaXNcbiAqICAgIG1heSBiZSBkb25lIGluIHRoZSB3b3JrZXIgdGhyZWFkLlxuICpcbiAqICAtIEZvcndhcmQgdGhlc2UgbmF0aXZlIGV2ZW50cyAod2l0aCB0aGUgYXNzb2NpYXRlZCB0b3AtbGV2ZWwgdHlwZSB1c2VkIHRvXG4gKiAgICB0cmFwIGl0KSB0byBgRXZlbnRQbHVnaW5IdWJgLCB3aGljaCBpbiB0dXJuIHdpbGwgYXNrIHBsdWdpbnMgaWYgdGhleSB3YW50XG4gKiAgICB0byBleHRyYWN0IGFueSBzeW50aGV0aWMgZXZlbnRzLlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHdpbGwgdGhlbiBwcm9jZXNzIGVhY2ggZXZlbnQgYnkgYW5ub3RhdGluZyB0aGVtIHdpdGhcbiAqICAgIFwiZGlzcGF0Y2hlc1wiLCBhIHNlcXVlbmNlIG9mIGxpc3RlbmVycyBhbmQgSURzIHRoYXQgY2FyZSBhYm91dCB0aGF0IGV2ZW50LlxuICpcbiAqICAtIFRoZSBgRXZlbnRQbHVnaW5IdWJgIHRoZW4gZGlzcGF0Y2hlcyB0aGUgZXZlbnRzLlxuICpcbiAqIE92ZXJ2aWV3IG9mIFJlYWN0IGFuZCB0aGUgZXZlbnQgc3lzdGVtOlxuICpcbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgICAgRE9NICAgICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqICAgICAgIHwgICAgICAgICAgIC5cbiAqICAgICAgIHYgICAgICAgICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC5cbiAqIHwgUmVhY3RFdmVudCB8ICAgIC5cbiAqIHwgIExpc3RlbmVyICB8ICAgIC5cbiAqICstLS0tLS0tLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICstLS0tLS0tLSt8U2ltcGxlRXZlbnR8XG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgfCAgICAgICAgIHxQbHVnaW4gICAgIHxcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICB2ICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58RXZlbnRQbHVnaW5IdWJ8ICAgICAgICAgICAgICAgICAgICB8ICAgIEV2ZW50ICAgfFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8IFByb3BhZ2F0b3JzfFxuICogfCBSZWFjdEV2ZW50IHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICB8VGFwRXZlbnQgICB8ICB8LS0tLS0tLS0tLS0tfFxuICogfCAgRW1pdHRlciAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8PC0tLSt8UGx1Z2luICAgICB8ICB8b3RoZXIgcGx1Z2lufFxuICogfCAgICAgICAgICAgIHwgICAgLiAgICB8ICAgICAgICAgICAgICB8ICAgICArLS0tLS0tLS0tLS0rICB8ICB1dGlsaXRpZXMgfFxuICogfCAgICAgKy0tLS0tLS0tLS0tLi0tLT58ICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tK1xuICogfCAgICAgfCAgICAgIHwgICAgLiAgICArLS0tLS0tLS0tLS0tLS0rXG4gKiArLS0tLS18LS0tLS0tKyAgICAuICAgICAgICAgICAgICAgIF4gICAgICAgICstLS0tLS0tLS0tLStcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICAgfCAgICAgICAgfEVudGVyL0xlYXZlfFxuICogICAgICAgKyAgICAgICAgICAgLiAgICAgICAgICAgICAgICArLS0tLS0tLSt8UGx1Z2luICAgICB8XG4gKiArLS0tLS0tLS0tLS0tLSsgICAuICAgICAgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLStcbiAqIHwgYXBwbGljYXRpb24gfCAgIC5cbiAqIHwtLS0tLS0tLS0tLS0tfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqIHwgICAgICAgICAgICAgfCAgIC5cbiAqICstLS0tLS0tLS0tLS0tKyAgIC5cbiAqICAgICAgICAgICAgICAgICAgIC5cbiAqICAgIFJlYWN0IENvcmUgICAgIC4gIEdlbmVyYWwgUHVycG9zZSBFdmVudCBQbHVnaW4gU3lzdGVtXG4gKi9cblxudmFyIGFscmVhZHlMaXN0ZW5pbmdUbyA9IHt9O1xudmFyIHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciA9IDA7XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArICgnJyArIE1hdGgucmFuZG9tKCkpLnNsaWNlKDIpO1xuXG5mdW5jdGlvbiBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KSB7XG4gIC8vIEluIElFOCwgYG1vdW50QXRgIGlzIGEgaG9zdCBvYmplY3QgYW5kIGRvZXNuJ3QgaGF2ZSBgaGFzT3duUHJvcGVydHlgXG4gIC8vIGRpcmVjdGx5LlxuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3VudEF0LCB0b3BMaXN0ZW5lcnNJREtleSkpIHtcbiAgICBtb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XSA9IHJlYWN0VG9wTGlzdGVuZXJzQ291bnRlcisrO1xuICAgIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV0gPSB7fTtcbiAgfVxuICByZXR1cm4gYWxyZWFkeUxpc3RlbmluZ1RvW21vdW50QXRbdG9wTGlzdGVuZXJzSURLZXldXTtcbn1cblxuLyoqXG4gKiBXZSBsaXN0ZW4gZm9yIGJ1YmJsZWQgdG91Y2ggZXZlbnRzIG9uIHRoZSBkb2N1bWVudCBvYmplY3QuXG4gKlxuICogRmlyZWZveCB2OC4wMSAoYW5kIHBvc3NpYmx5IG90aGVycykgZXhoaWJpdGVkIHN0cmFuZ2UgYmVoYXZpb3Igd2hlblxuICogbW91bnRpbmcgYG9ubW91c2Vtb3ZlYCBldmVudHMgYXQgc29tZSBub2RlIHRoYXQgd2FzIG5vdCB0aGUgZG9jdW1lbnRcbiAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gKiBjb250YWluZWQgd2l0aGluIHRoYXQgbW91bnQgcG9pbnQgKGZvciBleGFtcGxlIG9uIHRoZSBiYWNrZ3JvdW5kKSB0aGVcbiAqIHRvcC1sZXZlbCBsaXN0ZW5lcnMgZm9yIGBvbm1vdXNlbW92ZWAgd29uJ3QgYmUgY2FsbGVkLiBIb3dldmVyLCBpZiB5b3VcbiAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gKiBjYXRjaCBhbGwgYG1vdXNlbW92ZWBzLiBUaGlzIGFsb25nIHdpdGggaU9TIHF1aXJrcywganVzdGlmaWVzIHJlc3RyaWN0aW5nXG4gKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIHRvIHRoZSBkb2N1bWVudCBvYmplY3Qgb25seSwgYXQgbGVhc3QgZm9yIHRoZXNlXG4gKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gKlxuICogQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxMC8wOS9jbGlja19ldmVudF9kZWwuaHRtbFxuICpcbiAqIEFsc28sIGBrZXl1cGAvYGtleXByZXNzYC9ga2V5ZG93bmAgZG8gbm90IGJ1YmJsZSB0byB0aGUgd2luZG93IG9uIElFLCBidXRcbiAqIHRoZXkgYnViYmxlIHRvIGRvY3VtZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZW50RG9jdW1lbnRIYW5kbGUgRG9jdW1lbnQgd2hpY2ggb3ducyB0aGUgY29udGFpbmVyXG4gKi9cbmZ1bmN0aW9uIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGNvbnRlbnREb2N1bWVudEhhbmRsZSkge1xuICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgdmFyIGlzTGlzdGVuaW5nID0gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCk7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSByZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcFdoZWVsJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnd2hlZWwnKSkge1xuICAgICAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFdoZWVsJywgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNFdmVudFN1cHBvcnRlZCgnbW91c2V3aGVlbCcpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wV2hlZWwnLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEZpcmVmb3ggbmVlZHMgdG8gY2FwdHVyZSBhIGRpZmZlcmVudCBtb3VzZSBzY3JvbGwgZXZlbnQuXG4gICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BXaGVlbCcsICdET01Nb3VzZVNjcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BTY3JvbGwnKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BTY3JvbGwnLCAnc2Nyb2xsJywgbW91bnRBdCk7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BGb2N1cycgfHwgZGVwZW5kZW5jeSA9PT0gJ3RvcEJsdXInKSB7XG4gICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BGb2N1cycsICdmb2N1cycsIG1vdW50QXQpO1xuICAgICAgICB0cmFwQ2FwdHVyZWRFdmVudCgndG9wQmx1cicsICdibHVyJywgbW91bnRBdCk7XG5cbiAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGJsdXIgYW5kIGZvY3VzIGV2ZW50IGxpc3RlbmVycyBhcmUgb25seSBhdHRhY2hlZCBvbmNlXG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcEJsdXIgPSB0cnVlO1xuICAgICAgICBpc0xpc3RlbmluZy50b3BGb2N1cyA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGRlcGVuZGVuY3kgPT09ICd0b3BDYW5jZWwnKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdjYW5jZWwnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDYW5jZWwnLCAnY2FuY2VsJywgbW91bnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgaXNMaXN0ZW5pbmcudG9wQ2FuY2VsID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gJ3RvcENsb3NlJykge1xuICAgICAgICBpZiAoaXNFdmVudFN1cHBvcnRlZCgnY2xvc2UnLCB0cnVlKSkge1xuICAgICAgICAgIHRyYXBDYXB0dXJlZEV2ZW50KCd0b3BDbG9zZScsICdjbG9zZScsIG1vdW50QXQpO1xuICAgICAgICB9XG4gICAgICAgIGlzTGlzdGVuaW5nLnRvcENsb3NlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlcy5oYXNPd25Qcm9wZXJ0eShkZXBlbmRlbmN5KSkge1xuICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGRlcGVuZGVuY3ksIHRvcExldmVsVHlwZXNbZGVwZW5kZW5jeV0sIG1vdW50QXQpO1xuICAgICAgfVxuXG4gICAgICBpc0xpc3RlbmluZ1tkZXBlbmRlbmN5XSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMocmVnaXN0cmF0aW9uTmFtZSwgbW91bnRBdCkge1xuICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmNpZXNbaV07XG4gICAgaWYgKCEoaXNMaXN0ZW5pbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkgJiYgaXNMaXN0ZW5pbmdbZGVwZW5kZW5jeV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdpdmVuIGFueSBub2RlIHJldHVybiB0aGUgZmlyc3QgbGVhZiBub2RlIHdpdGhvdXQgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRMZWFmTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlICYmIG5vZGUuZmlyc3RDaGlsZCkge1xuICAgIG5vZGUgPSBub2RlLmZpcnN0Q2hpbGQ7XG4gIH1cbiAgcmV0dXJuIG5vZGU7XG59XG5cbi8qKlxuICogR2V0IHRoZSBuZXh0IHNpYmxpbmcgd2l0aGluIGEgY29udGFpbmVyLiBUaGlzIHdpbGwgd2FsayB1cCB0aGVcbiAqIERPTSBpZiBhIG5vZGUncyBzaWJsaW5ncyBoYXZlIGJlZW4gZXhoYXVzdGVkLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7P0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9XG4gKi9cbmZ1bmN0aW9uIGdldFNpYmxpbmdOb2RlKG5vZGUpIHtcbiAgd2hpbGUgKG5vZGUpIHtcbiAgICBpZiAobm9kZS5uZXh0U2libGluZykge1xuICAgICAgcmV0dXJuIG5vZGUubmV4dFNpYmxpbmc7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlLnBhcmVudE5vZGU7XG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgb2JqZWN0IGRlc2NyaWJpbmcgdGhlIG5vZGVzIHdoaWNoIGNvbnRhaW4gY2hhcmFjdGVycyBhdCBvZmZzZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSByb290XG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0KHJvb3QsIG9mZnNldCkge1xuICB2YXIgbm9kZSA9IGdldExlYWZOb2RlKHJvb3QpO1xuICB2YXIgbm9kZVN0YXJ0ID0gMDtcbiAgdmFyIG5vZGVFbmQgPSAwO1xuXG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkge1xuICAgICAgbm9kZUVuZCA9IG5vZGVTdGFydCArIG5vZGUudGV4dENvbnRlbnQubGVuZ3RoO1xuXG4gICAgICBpZiAobm9kZVN0YXJ0IDw9IG9mZnNldCAmJiBub2RlRW5kID49IG9mZnNldCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5vZGU6IG5vZGUsXG4gICAgICAgICAgb2Zmc2V0OiBvZmZzZXQgLSBub2RlU3RhcnRcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgbm9kZVN0YXJ0ID0gbm9kZUVuZDtcbiAgICB9XG5cbiAgICBub2RlID0gZ2V0TGVhZk5vZGUoZ2V0U2libGluZ05vZGUobm9kZSkpO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBvdXRlck5vZGVcbiAqIEByZXR1cm4gez9vYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldE9mZnNldHMob3V0ZXJOb2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUkJDEgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgLy8gSW4gRmlyZWZveCwgYW5jaG9yTm9kZSBhbmQgZm9jdXNOb2RlIGNhbiBiZSBcImFub255bW91cyBkaXZzXCIsIGUuZy4gdGhlXG4gIC8vIHVwL2Rvd24gYnV0dG9ucyBvbiBhbiA8aW5wdXQgdHlwZT1cIm51bWJlclwiPi4gQW5vbnltb3VzIGRpdnMgZG8gbm90IHNlZW0gdG9cbiAgLy8gZXhwb3NlIHByb3BlcnRpZXMsIHRyaWdnZXJpbmcgYSBcIlBlcm1pc3Npb24gZGVuaWVkIGVycm9yXCIgaWYgYW55IG9mIGl0c1xuICAvLyBwcm9wZXJ0aWVzIGFyZSBhY2Nlc3NlZC4gVGhlIG9ubHkgc2VlbWluZ2x5IHBvc3NpYmxlIHdheSB0byBhdm9pZCBlcnJvcmluZ1xuICAvLyBpcyB0byBhY2Nlc3MgYSBwcm9wZXJ0eSB0aGF0IHR5cGljYWxseSB3b3JrcyBmb3Igbm9uLWFub255bW91cyBkaXZzIGFuZFxuICAvLyBjYXRjaCBhbnkgZXJyb3IgdGhhdCBtYXkgb3RoZXJ3aXNlIGFyaXNlLiBTZWVcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjA4NDI3XG4gIHRyeSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLWV4cHJlc3Npb25zICovXG4gICAgYW5jaG9yTm9kZS5ub2RlVHlwZTtcbiAgICBmb2N1c05vZGUkJDEubm9kZVR5cGU7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUkJDEsIGZvY3VzT2Zmc2V0KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHtzdGFydCwgZW5kfSB3aGVyZSBgc3RhcnRgIGlzIHRoZSBjaGFyYWN0ZXIvY29kZXBvaW50IGluZGV4IG9mXG4gKiAoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0KSB3aXRoaW4gdGhlIHRleHRDb250ZW50IG9mIGBvdXRlck5vZGVgLCBhbmRcbiAqIGBlbmRgIGlzIHRoZSBpbmRleCBvZiAoZm9jdXNOb2RlLCBmb2N1c09mZnNldCkuXG4gKlxuICogUmV0dXJucyBudWxsIGlmIHlvdSBwYXNzIGluIGdhcmJhZ2UgaW5wdXQgYnV0IHdlIHNob3VsZCBwcm9iYWJseSBqdXN0IGNyYXNoLlxuICpcbiAqIEV4cG9ydGVkIG9ubHkgZm9yIHRlc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIGdldE1vZGVybk9mZnNldHNGcm9tUG9pbnRzKG91dGVyTm9kZSwgYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUkJDEsIGZvY3VzT2Zmc2V0KSB7XG4gIHZhciBsZW5ndGggPSAwO1xuICB2YXIgc3RhcnQgPSAtMTtcbiAgdmFyIGVuZCA9IC0xO1xuICB2YXIgaW5kZXhXaXRoaW5BbmNob3IgPSAwO1xuICB2YXIgaW5kZXhXaXRoaW5Gb2N1cyA9IDA7XG4gIHZhciBub2RlID0gb3V0ZXJOb2RlO1xuICB2YXIgcGFyZW50Tm9kZSA9IG51bGw7XG5cbiAgb3V0ZXI6IHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIG5leHQgPSBudWxsO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlID09PSBhbmNob3JOb2RlICYmIChhbmNob3JPZmZzZXQgPT09IDAgfHwgbm9kZS5ub2RlVHlwZSA9PT0gVEVYVF9OT0RFKSkge1xuICAgICAgICBzdGFydCA9IGxlbmd0aCArIGFuY2hvck9mZnNldDtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmb2N1c05vZGUkJDEgJiYgKGZvY3VzT2Zmc2V0ID09PSAwIHx8IG5vZGUubm9kZVR5cGUgPT09IFRFWFRfTk9ERSkpIHtcbiAgICAgICAgZW5kID0gbGVuZ3RoICsgZm9jdXNPZmZzZXQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbGVuZ3RoICs9IG5vZGUubm9kZVZhbHVlLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdENoaWxkKSA9PT0gbnVsbCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgZmlyc3QgY2hpbGQgYG5leHRgLlxuICAgICAgcGFyZW50Tm9kZSA9IG5vZGU7XG4gICAgICBub2RlID0gbmV4dDtcbiAgICB9XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUgPT09IG91dGVyTm9kZSkge1xuICAgICAgICAvLyBJZiBgb3V0ZXJOb2RlYCBoYXMgY2hpbGRyZW4sIHRoaXMgaXMgYWx3YXlzIHRoZSBzZWNvbmQgdGltZSB2aXNpdGluZ1xuICAgICAgICAvLyBpdC4gSWYgaXQgaGFzIG5vIGNoaWxkcmVuLCB0aGlzIGlzIHN0aWxsIHRoZSBmaXJzdCBsb29wLCBhbmQgdGhlIG9ubHlcbiAgICAgICAgLy8gdmFsaWQgc2VsZWN0aW9uIGlzIGFuY2hvck5vZGUgYW5kIGZvY3VzTm9kZSBib3RoIGVxdWFsIHRvIHRoaXMgbm9kZVxuICAgICAgICAvLyBhbmQgYm90aCBvZmZzZXRzIDAsIGluIHdoaWNoIGNhc2Ugd2Ugd2lsbCBoYXZlIGhhbmRsZWQgYWJvdmUuXG4gICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGFuY2hvck5vZGUgJiYgKytpbmRleFdpdGhpbkFuY2hvciA9PT0gYW5jaG9yT2Zmc2V0KSB7XG4gICAgICAgIHN0YXJ0ID0gbGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudE5vZGUgPT09IGZvY3VzTm9kZSQkMSAmJiArK2luZGV4V2l0aGluRm9jdXMgPT09IGZvY3VzT2Zmc2V0KSB7XG4gICAgICAgIGVuZCA9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmICgobmV4dCA9IG5vZGUubmV4dFNpYmxpbmcpICE9PSBudWxsKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgbm9kZSA9IHBhcmVudE5vZGU7XG4gICAgICBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIE1vdmluZyBmcm9tIGBub2RlYCB0byBpdHMgbmV4dCBzaWJsaW5nIGBuZXh0YC5cbiAgICBub2RlID0gbmV4dDtcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kID09PSAtMSkge1xuICAgIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbi4gKFdvdWxkIGhhcHBlbiBpZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFyZW4ndFxuICAgIC8vIGFjdHVhbGx5IGluc2lkZSB0aGUgcGFzc2VkLWluIG5vZGUuKVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxuLyoqXG4gKiBJbiBtb2Rlcm4gbm9uLUlFIGJyb3dzZXJzLCB3ZSBjYW4gc3VwcG9ydCBib3RoIGZvcndhcmQgYW5kIGJhY2t3YXJkXG4gKiBzZWxlY3Rpb25zLlxuICpcbiAqIE5vdGU6IElFMTArIHN1cHBvcnRzIHRoZSBTZWxlY3Rpb24gb2JqZWN0LCBidXQgaXQgZG9lcyBub3Qgc3VwcG9ydFxuICogdGhlIGBleHRlbmRgIG1ldGhvZCwgd2hpY2ggbWVhbnMgdGhhdCBldmVuIGluIG1vZGVybiBJRSwgaXQncyBub3QgcG9zc2libGVcbiAqIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IG9mZnNldHMuZW5kID09PSB1bmRlZmluZWQgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICBpZiAoc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDEgJiYgc2VsZWN0aW9uLmFuY2hvck5vZGUgPT09IHN0YXJ0TWFya2VyLm5vZGUgJiYgc2VsZWN0aW9uLmFuY2hvck9mZnNldCA9PT0gc3RhcnRNYXJrZXIub2Zmc2V0ICYmIHNlbGVjdGlvbi5mb2N1c05vZGUgPT09IGVuZE1hcmtlci5ub2RlICYmIHNlbGVjdGlvbi5mb2N1c09mZnNldCA9PT0gZW5kTWFya2VyLm9mZnNldCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0luRG9jdW1lbnQobm9kZSkge1xuICByZXR1cm4gY29udGFpbnNOb2RlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgbm9kZSk7XG59XG5cbi8qKlxuICogQFJlYWN0SW5wdXRTZWxlY3Rpb246IFJlYWN0IGlucHV0IHNlbGVjdGlvbiBtb2R1bGUuIEJhc2VkIG9uIFNlbGVjdGlvbi5qcyxcbiAqIGJ1dCBtb2RpZmllZCB0byBiZSBzdWl0YWJsZSBmb3IgcmVhY3QgYW5kIGhhcyBhIGNvdXBsZSBvZiBidWcgZml4ZXMgKGRvZXNuJ3RcbiAqIGFzc3VtZSBidXR0b25zIGhhdmUgcmFuZ2Ugc2VsZWN0aW9ucyBhbGxvd2VkKS5cbiAqIElucHV0IHNlbGVjdGlvbiBtb2R1bGUgZm9yIFJlYWN0LlxuICovXG5cbmZ1bmN0aW9uIGhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyhlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBub2RlTmFtZSAmJiAobm9kZU5hbWUgPT09ICdpbnB1dCcgJiYgZWxlbS50eXBlID09PSAndGV4dCcgfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScgfHwgZWxlbS5jb250ZW50RWRpdGFibGUgPT09ICd0cnVlJyk7XG59XG5cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkluZm9ybWF0aW9uKCkge1xuICB2YXIgZm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gIHJldHVybiB7XG4gICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgIHNlbGVjdGlvblJhbmdlOiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMoZm9jdXNlZEVsZW0pID8gZ2V0U2VsZWN0aW9uJDEoZm9jdXNlZEVsZW0pIDogbnVsbFxuICB9O1xufVxuXG4vKipcbiAqIEByZXN0b3JlU2VsZWN0aW9uOiBJZiBhbnkgc2VsZWN0aW9uIGluZm9ybWF0aW9uIHdhcyBwb3RlbnRpYWxseSBsb3N0LFxuICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gKiBub2RlcyBhbmQgcGxhY2UgdGhlbSBiYWNrIGluLCByZXN1bHRpbmcgaW4gZm9jdXMgYmVpbmcgbG9zdC5cbiAqL1xuZnVuY3Rpb24gcmVzdG9yZVNlbGVjdGlvbihwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uKSB7XG4gIHZhciBjdXJGb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICB2YXIgcHJpb3JTZWxlY3Rpb25SYW5nZSA9IHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24uc2VsZWN0aW9uUmFuZ2U7XG4gIGlmIChjdXJGb2N1c2VkRWxlbSAhPT0gcHJpb3JGb2N1c2VkRWxlbSAmJiBpc0luRG9jdW1lbnQocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICBpZiAoaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBzZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgfVxuXG4gICAgLy8gRm9jdXNpbmcgYSBub2RlIGNhbiBjaGFuZ2UgdGhlIHNjcm9sbCBwb3NpdGlvbiwgd2hpY2ggaXMgdW5kZXNpcmFibGVcbiAgICB2YXIgYW5jZXN0b3JzID0gW107XG4gICAgdmFyIGFuY2VzdG9yID0gcHJpb3JGb2N1c2VkRWxlbTtcbiAgICB3aGlsZSAoYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnROb2RlKSB7XG4gICAgICBpZiAoYW5jZXN0b3Iubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSkge1xuICAgICAgICBhbmNlc3RvcnMucHVzaCh7XG4gICAgICAgICAgZWxlbWVudDogYW5jZXN0b3IsXG4gICAgICAgICAgbGVmdDogYW5jZXN0b3Iuc2Nyb2xsTGVmdCxcbiAgICAgICAgICB0b3A6IGFuY2VzdG9yLnNjcm9sbFRvcFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFuY2VzdG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGluZm8gPSBhbmNlc3RvcnNbaV07XG4gICAgICBpbmZvLmVsZW1lbnQuc2Nyb2xsTGVmdCA9IGluZm8ubGVmdDtcbiAgICAgIGluZm8uZWxlbWVudC5zY3JvbGxUb3AgPSBpbmZvLnRvcDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAqIGNvbnRlbnRFZGl0YWJsZSBub2RlLlxuICogLUBpbnB1dDogTG9vayB1cCBzZWxlY3Rpb24gYm91bmRzIG9mIHRoaXMgaW5wdXRcbiAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24kMShpbnB1dCkge1xuICB2YXIgc2VsZWN0aW9uID0gdm9pZCAwO1xuXG4gIGlmICgnc2VsZWN0aW9uU3RhcnQnIGluIGlucHV0KSB7XG4gICAgLy8gTW9kZXJuIGJyb3dzZXIgd2l0aCBpbnB1dCBvciB0ZXh0YXJlYS5cbiAgICBzZWxlY3Rpb24gPSB7XG4gICAgICBzdGFydDogaW5wdXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IGlucHV0LnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgc2VsZWN0aW9uID0gZ2V0T2Zmc2V0cyhpbnB1dCk7XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xufVxuXG4vKipcbiAqIEBzZXRTZWxlY3Rpb246IFNldHMgdGhlIHNlbGVjdGlvbiBib3VuZHMgb2YgYSB0ZXh0YXJlYSBvciBpbnB1dCBhbmQgZm9jdXNlc1xuICogdGhlIGlucHV0LlxuICogLUBpbnB1dCAgICAgU2V0IHNlbGVjdGlvbiBib3VuZHMgb2YgdGhpcyBpbnB1dCBvciB0ZXh0YXJlYVxuICogLUBvZmZzZXRzICAgT2JqZWN0IG9mIHNhbWUgZm9ybSB0aGF0IGlzIHJldHVybmVkIGZyb20gZ2V0KlxuICovXG5mdW5jdGlvbiBzZXRTZWxlY3Rpb24oaW5wdXQsIG9mZnNldHMpIHtcbiAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydCxcbiAgICAgIGVuZCA9IG9mZnNldHMuZW5kO1xuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHN0YXJ0O1xuICB9XG5cbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICBpbnB1dC5zZWxlY3Rpb25TdGFydCA9IHN0YXJ0O1xuICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgfSBlbHNlIHtcbiAgICBzZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgfVxufVxuXG52YXIgc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8PSAxMTtcblxudmFyIGV2ZW50VHlwZXMkMyA9IHtcbiAgc2VsZWN0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6ICdvblNlbGVjdCcsXG4gICAgICBjYXB0dXJlZDogJ29uU2VsZWN0Q2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogWyd0b3BCbHVyJywgJ3RvcENvbnRleHRNZW51JywgJ3RvcEZvY3VzJywgJ3RvcEtleURvd24nLCAndG9wS2V5VXAnLCAndG9wTW91c2VEb3duJywgJ3RvcE1vdXNlVXAnLCAndG9wU2VsZWN0aW9uQ2hhbmdlJ11cbiAgfVxufTtcblxudmFyIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudEluc3QkMSA9IG51bGw7XG52YXIgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG52YXIgbW91c2VEb3duID0gZmFsc2U7XG5cbi8qKlxuICogR2V0IGFuIG9iamVjdCB3aGljaCBpcyBhIHVuaXF1ZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXG4gKlxuICogVGhlIHJldHVybiB2YWx1ZSB3aWxsIG5vdCBiZSBjb25zaXN0ZW50IGFjcm9zcyBub2RlcyBvciBicm93c2VycywgYnV0XG4gKiB0d28gaWRlbnRpY2FsIHNlbGVjdGlvbnMgb24gdGhlIHNhbWUgbm9kZSB3aWxsIHJldHVybiBpZGVudGljYWwgb2JqZWN0cy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0U2VsZWN0aW9uKG5vZGUpIHtcbiAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gbm9kZSAmJiBoYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMobm9kZSkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhcnQ6IG5vZGUuc2VsZWN0aW9uU3RhcnQsXG4gICAgICBlbmQ6IG5vZGUuc2VsZWN0aW9uRW5kXG4gICAgfTtcbiAgfSBlbHNlIGlmICh3aW5kb3cuZ2V0U2VsZWN0aW9uKSB7XG4gICAgdmFyIHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yTm9kZTogc2VsZWN0aW9uLmFuY2hvck5vZGUsXG4gICAgICBhbmNob3JPZmZzZXQ6IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQsXG4gICAgICBmb2N1c05vZGU6IHNlbGVjdGlvbi5mb2N1c05vZGUsXG4gICAgICBmb2N1c09mZnNldDogc2VsZWN0aW9uLmZvY3VzT2Zmc2V0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCQxID09IG51bGwgfHwgYWN0aXZlRWxlbWVudCQxICE9PSBnZXRBY3RpdmVFbGVtZW50KCkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIE9ubHkgZmlyZSB3aGVuIHNlbGVjdGlvbiBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgdmFyIGN1cnJlbnRTZWxlY3Rpb24gPSBnZXRTZWxlY3Rpb24oYWN0aXZlRWxlbWVudCQxKTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50JDEuZ2V0UG9vbGVkKGV2ZW50VHlwZXMkMy5zZWxlY3QsIGFjdGl2ZUVsZW1lbnRJbnN0JDEsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgICBzeW50aGV0aWNFdmVudC50eXBlID0gJ3NlbGVjdCc7XG4gICAgc3ludGhldGljRXZlbnQudGFyZ2V0ID0gYWN0aXZlRWxlbWVudCQxO1xuXG4gICAgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhzeW50aGV0aWNFdmVudCk7XG5cbiAgICByZXR1cm4gc3ludGhldGljRXZlbnQ7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBUaGlzIHBsdWdpbiBjcmVhdGVzIGFuIGBvblNlbGVjdGAgZXZlbnQgdGhhdCBub3JtYWxpemVzIHNlbGVjdCBldmVudHNcbiAqIGFjcm9zcyBmb3JtIGVsZW1lbnRzLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIGNvbnRlbnRFZGl0YWJsZVxuICpcbiAqIFRoaXMgZGlmZmVycyBmcm9tIG5hdGl2ZSBicm93c2VyIGltcGxlbWVudGF0aW9ucyBpbiB0aGUgZm9sbG93aW5nIHdheXM6XG4gKiAtIEZpcmVzIG9uIGNvbnRlbnRFZGl0YWJsZSBmaWVsZHMgYXMgd2VsbCBhcyBpbnB1dHMuXG4gKiAtIEZpcmVzIGZvciBjb2xsYXBzZWQgc2VsZWN0aW9uLlxuICogLSBGaXJlcyBhZnRlciB1c2VyIGlucHV0LlxuICovXG52YXIgU2VsZWN0RXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkMyxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZG9jID0gbmF0aXZlRXZlbnRUYXJnZXQud2luZG93ID09PSBuYXRpdmVFdmVudFRhcmdldCA/IG5hdGl2ZUV2ZW50VGFyZ2V0LmRvY3VtZW50IDogbmF0aXZlRXZlbnRUYXJnZXQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyBuYXRpdmVFdmVudFRhcmdldCA6IG5hdGl2ZUV2ZW50VGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVHJhY2sgd2hldGhlciBhbGwgbGlzdGVuZXJzIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4gICAgLy8gbm90IGV4dHJhY3QgZXZlbnRzLiBTZWUgIzM2MzkuXG4gICAgaWYgKCFkb2MgfHwgIWlzTGlzdGVuaW5nVG9BbGxEZXBlbmRlbmNpZXMoJ29uU2VsZWN0JywgZG9jKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldE5vZGUgPSB0YXJnZXRJbnN0ID8gZ2V0Tm9kZUZyb21JbnN0YW5jZSQxKHRhcmdldEluc3QpIDogd2luZG93O1xuXG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIC8vIFRyYWNrIHRoZSBpbnB1dCBub2RlIHRoYXQgaGFzIGZvY3VzLlxuICAgICAgY2FzZSAndG9wRm9jdXMnOlxuICAgICAgICBpZiAoaXNUZXh0SW5wdXRFbGVtZW50KHRhcmdldE5vZGUpIHx8IHRhcmdldE5vZGUuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50JDEgPSB0YXJnZXROb2RlO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSB0YXJnZXRJbnN0O1xuICAgICAgICAgIGxhc3RTZWxlY3Rpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQmx1cic6XG4gICAgICAgIGFjdGl2ZUVsZW1lbnQkMSA9IG51bGw7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRJbnN0JDEgPSBudWxsO1xuICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSAndG9wTW91c2VEb3duJzpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BDb250ZXh0TWVudSc6XG4gICAgICBjYXNlICd0b3BNb3VzZVVwJzpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgLy8gQ2hyb21lIGFuZCBJRSBmaXJlIG5vbi1zdGFuZGFyZCBldmVudCB3aGVuIHNlbGVjdGlvbiBpcyBjaGFuZ2VkIChhbmRcbiAgICAgIC8vIHNvbWV0aW1lcyB3aGVuIGl0IGhhc24ndCkuIElFJ3MgZXZlbnQgZmlyZXMgb3V0IG9mIG9yZGVyIHdpdGggcmVzcGVjdFxuICAgICAgLy8gdG8ga2V5IGFuZCBpbnB1dCBldmVudHMgb24gZGVsZXRpb24sIHNvIHdlIGRpc2NhcmQgaXQuXG4gICAgICAvL1xuICAgICAgLy8gRmlyZWZveCBkb2Vzbid0IHN1cHBvcnQgc2VsZWN0aW9uY2hhbmdlLCBzbyBjaGVjayBzZWxlY3Rpb24gc3RhdHVzXG4gICAgICAvLyBhZnRlciBlYWNoIGtleSBlbnRyeS4gVGhlIHNlbGVjdGlvbiBjaGFuZ2VzIGFmdGVyIGtleWRvd24gYW5kIGJlZm9yZVxuICAgICAgLy8ga2V5dXAsIGJ1dCB3ZSBjaGVjayBvbiBrZXlkb3duIGFzIHdlbGwgaW4gdGhlIGNhc2Ugb2YgaG9sZGluZyBkb3duIGFcbiAgICAgIC8vIGtleSwgd2hlbiBtdWx0aXBsZSBrZXlkb3duIGV2ZW50cyBhcmUgZmlyZWQgYnV0IG9ubHkgb25lIGtleXVwIGlzLlxuICAgICAgLy8gVGhpcyBpcyBhbHNvIG91ciBhcHByb2FjaCBmb3IgSUUgaGFuZGxpbmcsIGZvciB0aGUgcmVhc29uIGFib3ZlLlxuICAgICAgY2FzZSAndG9wU2VsZWN0aW9uQ2hhbmdlJzpcbiAgICAgICAgaWYgKHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAvLyBmYWxscyB0aHJvdWdoXG4gICAgICBjYXNlICd0b3BLZXlEb3duJzpcbiAgICAgIGNhc2UgJ3RvcEtleVVwJzpcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdFNlbGVjdEV2ZW50KG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQGludGVyZmFjZSBFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLWFuaW1hdGlvbnMvI0FuaW1hdGlvbkV2ZW50LWludGVyZmFjZVxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQW5pbWF0aW9uRXZlbnRcbiAqL1xudmFyIEFuaW1hdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBhbmltYXRpb25OYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNBbmltYXRpb25FdmVudCwgQW5pbWF0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvY2xpcGJvYXJkLWFwaXMvXG4gKi9cbnZhciBDbGlwYm9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAgY2xpcGJvYXJkRGF0YTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdjbGlwYm9hcmREYXRhJyBpbiBldmVudCA/IGV2ZW50LmNsaXBib2FyZERhdGEgOiB3aW5kb3cuY2xpcGJvYXJkRGF0YTtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNFdmVudCQxLmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudCQxLmF1Z21lbnRDbGFzcyhTeW50aGV0aWNDbGlwYm9hcmRFdmVudCwgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRm9jdXNFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBGb2N1c0V2ZW50SW50ZXJmYWNlID0ge1xuICByZWxhdGVkVGFyZ2V0OiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNGb2N1c0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBvZiBkZXByZWNhdGVkIEhUTUw1IGBrZXlgIHZhbHVlc1xuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIG5vcm1hbGl6ZUtleSA9IHtcbiAgRXNjOiAnRXNjYXBlJyxcbiAgU3BhY2ViYXI6ICcgJyxcbiAgTGVmdDogJ0Fycm93TGVmdCcsXG4gIFVwOiAnQXJyb3dVcCcsXG4gIFJpZ2h0OiAnQXJyb3dSaWdodCcsXG4gIERvd246ICdBcnJvd0Rvd24nLFxuICBEZWw6ICdEZWxldGUnLFxuICBXaW46ICdPUycsXG4gIE1lbnU6ICdDb250ZXh0TWVudScsXG4gIEFwcHM6ICdDb250ZXh0TWVudScsXG4gIFNjcm9sbDogJ1Njcm9sbExvY2snLFxuICBNb3pQcmludGFibGVLZXk6ICdVbmlkZW50aWZpZWQnXG59O1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbGVnYWN5IGBrZXlDb2RlYCB0byBIVE1MNSBga2V5YFxuICogT25seSBzcGVjaWFsIGtleXMgc3VwcG9ydGVkLCBhbGwgb3RoZXJzIGRlcGVuZCBvbiBrZXlib2FyZCBsYXlvdXQgb3IgYnJvd3NlclxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvS2V5Ym9hcmRFdmVudCNLZXlfbmFtZXNcbiAqL1xudmFyIHRyYW5zbGF0ZVRvS2V5ID0ge1xuICAnOCc6ICdCYWNrc3BhY2UnLFxuICAnOSc6ICdUYWInLFxuICAnMTInOiAnQ2xlYXInLFxuICAnMTMnOiAnRW50ZXInLFxuICAnMTYnOiAnU2hpZnQnLFxuICAnMTcnOiAnQ29udHJvbCcsXG4gICcxOCc6ICdBbHQnLFxuICAnMTknOiAnUGF1c2UnLFxuICAnMjAnOiAnQ2Fwc0xvY2snLFxuICAnMjcnOiAnRXNjYXBlJyxcbiAgJzMyJzogJyAnLFxuICAnMzMnOiAnUGFnZVVwJyxcbiAgJzM0JzogJ1BhZ2VEb3duJyxcbiAgJzM1JzogJ0VuZCcsXG4gICczNic6ICdIb21lJyxcbiAgJzM3JzogJ0Fycm93TGVmdCcsXG4gICczOCc6ICdBcnJvd1VwJyxcbiAgJzM5JzogJ0Fycm93UmlnaHQnLFxuICAnNDAnOiAnQXJyb3dEb3duJyxcbiAgJzQ1JzogJ0luc2VydCcsXG4gICc0Nic6ICdEZWxldGUnLFxuICAnMTEyJzogJ0YxJyxcbiAgJzExMyc6ICdGMicsXG4gICcxMTQnOiAnRjMnLFxuICAnMTE1JzogJ0Y0JyxcbiAgJzExNic6ICdGNScsXG4gICcxMTcnOiAnRjYnLFxuICAnMTE4JzogJ0Y3JyxcbiAgJzExOSc6ICdGOCcsXG4gICcxMjAnOiAnRjknLFxuICAnMTIxJzogJ0YxMCcsXG4gICcxMjInOiAnRjExJyxcbiAgJzEyMyc6ICdGMTInLFxuICAnMTQ0JzogJ051bUxvY2snLFxuICAnMTQ1JzogJ1Njcm9sbExvY2snLFxuICAnMjI0JzogJ01ldGEnXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBga2V5YCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRLZXkobmF0aXZlRXZlbnQpIHtcbiAgaWYgKG5hdGl2ZUV2ZW50LmtleSkge1xuICAgIC8vIE5vcm1hbGl6ZSBpbmNvbnNpc3RlbnQgdmFsdWVzIHJlcG9ydGVkIGJ5IGJyb3dzZXJzIGR1ZSB0b1xuICAgIC8vIGltcGxlbWVudGF0aW9ucyBvZiBhIHdvcmtpbmcgZHJhZnQgc3BlY2lmaWNhdGlvbi5cblxuICAgIC8vIEZpcmVGb3ggaW1wbGVtZW50cyBga2V5YCBidXQgcmV0dXJucyBgTW96UHJpbnRhYmxlS2V5YCBmb3IgYWxsXG4gICAgLy8gcHJpbnRhYmxlIGNoYXJhY3RlcnMgKG5vcm1hbGl6ZWQgdG8gYFVuaWRlbnRpZmllZGApLCBpZ25vcmUgaXQuXG4gICAgdmFyIGtleSA9IG5vcm1hbGl6ZUtleVtuYXRpdmVFdmVudC5rZXldIHx8IG5hdGl2ZUV2ZW50LmtleTtcbiAgICBpZiAoa2V5ICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9XG4gIH1cblxuICAvLyBCcm93c2VyIGRvZXMgbm90IGltcGxlbWVudCBga2V5YCwgcG9seWZpbGwgYXMgbXVjaCBvZiBpdCBhcyB3ZSBjYW4uXG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgdmFyIGNoYXJDb2RlID0gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCk7XG5cbiAgICAvLyBUaGUgZW50ZXIta2V5IGlzIHRlY2huaWNhbGx5IGJvdGggcHJpbnRhYmxlIGFuZCBub24tcHJpbnRhYmxlIGFuZCBjYW5cbiAgICAvLyB0aHVzIGJlIGNhcHR1cmVkIGJ5IGBrZXlwcmVzc2AsIG5vIG90aGVyIG5vbi1wcmludGFibGUga2V5IHNob3VsZC5cbiAgICByZXR1cm4gY2hhckNvZGUgPT09IDEzID8gJ0VudGVyJyA6IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpO1xuICB9XG4gIGlmIChuYXRpdmVFdmVudC50eXBlID09PSAna2V5ZG93bicgfHwgbmF0aXZlRXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgIC8vIFdoaWxlIHVzZXIga2V5Ym9hcmQgbGF5b3V0IGRldGVybWluZXMgdGhlIGFjdHVhbCBtZWFuaW5nIG9mIGVhY2hcbiAgICAvLyBga2V5Q29kZWAgdmFsdWUsIGFsbW9zdCBhbGwgZnVuY3Rpb24ga2V5cyBoYXZlIGEgdW5pdmVyc2FsIHZhbHVlLlxuICAgIHJldHVybiB0cmFuc2xhdGVUb0tleVtuYXRpdmVFdmVudC5rZXlDb2RlXSB8fCAnVW5pZGVudGlmaWVkJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQGludGVyZmFjZSBLZXlib2FyZEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGtleTogZ2V0RXZlbnRLZXksXG4gIGxvY2F0aW9uOiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICByZXBlYXQ6IG51bGwsXG4gIGxvY2FsZTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlLFxuICAvLyBMZWdhY3kgSW50ZXJmYWNlXG4gIGNoYXJDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgY2hhckNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlQcmVzcyBldmVudCBhbmQgcmVwcmVzZW50cyB0aGUgdmFsdWUgb2ZcbiAgICAvLyB0aGUgYWN0dWFsIHByaW50YWJsZSBjaGFyYWN0ZXIuXG5cbiAgICAvLyBLZXlQcmVzcyBpcyBkZXByZWNhdGVkLCBidXQgaXRzIHJlcGxhY2VtZW50IGlzIG5vdCB5ZXQgZmluYWwgYW5kIG5vdFxuICAgIC8vIGltcGxlbWVudGVkIGluIGFueSBtYWpvciBicm93c2VyLiBPbmx5IEtleVByZXNzIGhhcyBjaGFyQ29kZS5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSxcbiAga2V5Q29kZTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYGtleUNvZGVgIGlzIHRoZSByZXN1bHQgb2YgYSBLZXlEb3duL1VwIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHBoeXNpY2FsIGtleWJvYXJkIGtleS5cblxuICAgIC8vIFRoZSBhY3R1YWwgbWVhbmluZyBvZiB0aGUgdmFsdWUgZGVwZW5kcyBvbiB0aGUgdXNlcnMnIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHdoaWNoIGNhbm5vdCBiZSBkZXRlY3RlZC4gQXNzdW1pbmcgdGhhdCBpdCBpcyBhIFVTIGtleWJvYXJkIGxheW91dFxuICAgIC8vIHByb3ZpZGVzIGEgc3VycHJpc2luZ2x5IGFjY3VyYXRlIG1hcHBpbmcgZm9yIFVTIGFuZCBFdXJvcGVhbiB1c2Vycy5cbiAgICAvLyBEdWUgdG8gdGhpcywgaXQgaXMgbGVmdCB0byB0aGUgdXNlciB0byBpbXBsZW1lbnQgYXQgdGhpcyB0aW1lLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICB3aGljaDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gYHdoaWNoYCBpcyBhbiBhbGlhcyBmb3IgZWl0aGVyIGBrZXlDb2RlYCBvciBgY2hhckNvZGVgIGRlcGVuZGluZyBvbiB0aGVcbiAgICAvLyB0eXBlIG9mIHRoZSBldmVudC5cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleXByZXNzJykge1xuICAgICAgcmV0dXJuIGdldEV2ZW50Q2hhckNvZGUoZXZlbnQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2tleWRvd24nIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcpIHtcbiAgICAgIHJldHVybiBldmVudC5rZXlDb2RlO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljS2V5Ym9hcmRFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljS2V5Ym9hcmRFdmVudCwgS2V5Ym9hcmRFdmVudEludGVyZmFjZSk7XG5cbi8qKlxuICogQGludGVyZmFjZSBEcmFnRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRHJhZ0V2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhVHJhbnNmZXI6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0RyYWdFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHJldHVybiBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNUb3VjaEV2ZW50LCBUb3VjaEV2ZW50SW50ZXJmYWNlKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMDkvV0QtY3NzMy10cmFuc2l0aW9ucy0yMDA5MDMyMC8jdHJhbnNpdGlvbi1ldmVudHMtXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9UcmFuc2l0aW9uRXZlbnRcbiAqL1xudmFyIFRyYW5zaXRpb25FdmVudEludGVyZmFjZSA9IHtcbiAgcHJvcGVydHlOYW1lOiBudWxsLFxuICBlbGFwc2VkVGltZTogbnVsbCxcbiAgcHNldWRvRWxlbWVudDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1RyYW5zaXRpb25FdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICByZXR1cm4gU3ludGhldGljRXZlbnQkMS5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQkMS5hdWdtZW50Q2xhc3MoU3ludGhldGljVHJhbnNpdGlvbkV2ZW50LCBUcmFuc2l0aW9uRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgV2hlZWxFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi9ET00tTGV2ZWwtMy1FdmVudHMvXG4gKi9cbnZhciBXaGVlbEV2ZW50SW50ZXJmYWNlID0ge1xuICBkZWx0YVg6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnZGVsdGFYJyBpbiBldmVudCA/IGV2ZW50LmRlbHRhWCA6IC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDogLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFZYCBmb3IgV2Via2l0IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhWScgaW4gZXZlbnQgPyAtZXZlbnQud2hlZWxEZWx0YVkgOiAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YWAgZm9yIElFPDkgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGEnIGluIGV2ZW50ID8gLWV2ZW50LndoZWVsRGVsdGEgOiAwO1xuICB9LFxuICBkZWx0YVo6IG51bGwsXG5cbiAgLy8gQnJvd3NlcnMgd2l0aG91dCBcImRlbHRhTW9kZVwiIGlzIHJlcG9ydGluZyBpbiByYXcgd2hlZWwgZGVsdGEgd2hlcmUgb25lXG4gIC8vIG5vdGNoIG9uIHRoZSBzY3JvbGwgaXMgYWx3YXlzICsvLSAxMjAsIHJvdWdobHkgZXF1aXZhbGVudCB0byBwaXhlbHMuXG4gIC8vIEEgZ29vZCBhcHByb3hpbWF0aW9uIG9mIERPTV9ERUxUQV9MSU5FICgxKSBpcyA1JSBvZiB2aWV3cG9ydCBzaXplIG9yXG4gIC8vIH40MCBwaXhlbHMsIGZvciBET01fREVMVEFfU0NSRUVOICgyKSBpdCBpcyA4Ny41JSBvZiB2aWV3cG9ydCBzaXplLlxuICBkZWx0YU1vZGU6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY01vdXNlRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY1doZWVsRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgcmV0dXJuIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG4vKipcbiAqIFR1cm5zXG4gKiBbJ2Fib3J0JywgLi4uXVxuICogaW50b1xuICogZXZlbnRUeXBlcyA9IHtcbiAqICAgJ2Fib3J0Jzoge1xuICogICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gKiAgICAgICBidWJibGVkOiAnb25BYm9ydCcsXG4gKiAgICAgICBjYXB0dXJlZDogJ29uQWJvcnRDYXB0dXJlJyxcbiAqICAgICB9LFxuICogICAgIGRlcGVuZGVuY2llczogWyd0b3BBYm9ydCddLFxuICogICB9LFxuICogICAuLi5cbiAqIH07XG4gKiB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWcgPSB7XG4gKiAgICd0b3BBYm9ydCc6IHsgc2FtZUNvbmZpZyB9XG4gKiB9O1xuICovXG52YXIgZXZlbnRUeXBlcyQ0ID0ge307XG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge307XG5bJ2Fib3J0JywgJ2FuaW1hdGlvbkVuZCcsICdhbmltYXRpb25JdGVyYXRpb24nLCAnYW5pbWF0aW9uU3RhcnQnLCAnYmx1cicsICdjYW5jZWwnLCAnY2FuUGxheScsICdjYW5QbGF5VGhyb3VnaCcsICdjbGljaycsICdjbG9zZScsICdjb250ZXh0TWVudScsICdjb3B5JywgJ2N1dCcsICdkb3VibGVDbGljaycsICdkcmFnJywgJ2RyYWdFbmQnLCAnZHJhZ0VudGVyJywgJ2RyYWdFeGl0JywgJ2RyYWdMZWF2ZScsICdkcmFnT3ZlcicsICdkcmFnU3RhcnQnLCAnZHJvcCcsICdkdXJhdGlvbkNoYW5nZScsICdlbXB0aWVkJywgJ2VuY3J5cHRlZCcsICdlbmRlZCcsICdlcnJvcicsICdmb2N1cycsICdpbnB1dCcsICdpbnZhbGlkJywgJ2tleURvd24nLCAna2V5UHJlc3MnLCAna2V5VXAnLCAnbG9hZCcsICdsb2FkZWREYXRhJywgJ2xvYWRlZE1ldGFkYXRhJywgJ2xvYWRTdGFydCcsICdtb3VzZURvd24nLCAnbW91c2VNb3ZlJywgJ21vdXNlT3V0JywgJ21vdXNlT3ZlcicsICdtb3VzZVVwJywgJ3Bhc3RlJywgJ3BhdXNlJywgJ3BsYXknLCAncGxheWluZycsICdwcm9ncmVzcycsICdyYXRlQ2hhbmdlJywgJ3Jlc2V0JywgJ3Njcm9sbCcsICdzZWVrZWQnLCAnc2Vla2luZycsICdzdGFsbGVkJywgJ3N1Ym1pdCcsICdzdXNwZW5kJywgJ3RpbWVVcGRhdGUnLCAndG9nZ2xlJywgJ3RvdWNoQ2FuY2VsJywgJ3RvdWNoRW5kJywgJ3RvdWNoTW92ZScsICd0b3VjaFN0YXJ0JywgJ3RyYW5zaXRpb25FbmQnLCAndm9sdW1lQ2hhbmdlJywgJ3dhaXRpbmcnLCAnd2hlZWwnXS5mb3JFYWNoKGZ1bmN0aW9uIChldmVudCkge1xuICB2YXIgY2FwaXRhbGl6ZWRFdmVudCA9IGV2ZW50WzBdLnRvVXBwZXJDYXNlKCkgKyBldmVudC5zbGljZSgxKTtcbiAgdmFyIG9uRXZlbnQgPSAnb24nICsgY2FwaXRhbGl6ZWRFdmVudDtcbiAgdmFyIHRvcEV2ZW50ID0gJ3RvcCcgKyBjYXBpdGFsaXplZEV2ZW50O1xuXG4gIHZhciB0eXBlID0ge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBvbkV2ZW50LFxuICAgICAgY2FwdHVyZWQ6IG9uRXZlbnQgKyAnQ2FwdHVyZSdcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcEV2ZW50XVxuICB9O1xuICBldmVudFR5cGVzJDRbZXZlbnRdID0gdHlwZTtcbiAgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnW3RvcEV2ZW50XSA9IHR5cGU7XG59KTtcblxuLy8gT25seSB1c2VkIGluIERFViBmb3IgZXhoYXVzdGl2ZW5lc3MgdmFsaWRhdGlvbi5cbnZhciBrbm93bkhUTUxUb3BMZXZlbFR5cGVzID0gWyd0b3BBYm9ydCcsICd0b3BDYW5jZWwnLCAndG9wQ2FuUGxheScsICd0b3BDYW5QbGF5VGhyb3VnaCcsICd0b3BDbG9zZScsICd0b3BEdXJhdGlvbkNoYW5nZScsICd0b3BFbXB0aWVkJywgJ3RvcEVuY3J5cHRlZCcsICd0b3BFbmRlZCcsICd0b3BFcnJvcicsICd0b3BJbnB1dCcsICd0b3BJbnZhbGlkJywgJ3RvcExvYWQnLCAndG9wTG9hZGVkRGF0YScsICd0b3BMb2FkZWRNZXRhZGF0YScsICd0b3BMb2FkU3RhcnQnLCAndG9wUGF1c2UnLCAndG9wUGxheScsICd0b3BQbGF5aW5nJywgJ3RvcFByb2dyZXNzJywgJ3RvcFJhdGVDaGFuZ2UnLCAndG9wUmVzZXQnLCAndG9wU2Vla2VkJywgJ3RvcFNlZWtpbmcnLCAndG9wU3RhbGxlZCcsICd0b3BTdWJtaXQnLCAndG9wU3VzcGVuZCcsICd0b3BUaW1lVXBkYXRlJywgJ3RvcFRvZ2dsZScsICd0b3BWb2x1bWVDaGFuZ2UnLCAndG9wV2FpdGluZyddO1xuXG52YXIgU2ltcGxlRXZlbnRQbHVnaW4gPSB7XG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMkNCxcblxuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZGlzcGF0Y2hDb25maWcgPSB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdG9wTGV2ZWxUeXBlXTtcbiAgICBpZiAoIWRpc3BhdGNoQ29uZmlnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdmFyIEV2ZW50Q29uc3RydWN0b3I7XG4gICAgc3dpdGNoICh0b3BMZXZlbFR5cGUpIHtcbiAgICAgIGNhc2UgJ3RvcEtleVByZXNzJzpcbiAgICAgICAgLy8gRmlyZWZveCBjcmVhdGVzIGEga2V5cHJlc3MgZXZlbnQgZm9yIGZ1bmN0aW9uIGtleXMgdG9vLiBUaGlzIHJlbW92ZXNcbiAgICAgICAgLy8gdGhlIHVud2FudGVkIGtleXByZXNzIGV2ZW50cy4gRW50ZXIgaXMgaG93ZXZlciBib3RoIHByaW50YWJsZSBhbmRcbiAgICAgICAgLy8gbm9uLXByaW50YWJsZS4gT25lIHdvdWxkIGV4cGVjdCBUYWIgdG8gYmUgYXMgd2VsbCAoYnV0IGl0IGlzbid0KS5cbiAgICAgICAgaWYgKGdldEV2ZW50Q2hhckNvZGUobmF0aXZlRXZlbnQpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcEtleURvd24nOlxuICAgICAgY2FzZSAndG9wS2V5VXAnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljS2V5Ym9hcmRFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BCbHVyJzpcbiAgICAgIGNhc2UgJ3RvcEZvY3VzJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0ZvY3VzRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ2xpY2snOlxuICAgICAgICAvLyBGaXJlZm94IGNyZWF0ZXMgYSBjbGljayBldmVudCBvbiByaWdodCBtb3VzZSBjbGlja3MuIFRoaXMgcmVtb3ZlcyB0aGVcbiAgICAgICAgLy8gdW53YW50ZWQgY2xpY2sgZXZlbnRzLlxuICAgICAgICBpZiAobmF0aXZlRXZlbnQuYnV0dG9uID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICAgIGNhc2UgJ3RvcERvdWJsZUNsaWNrJzpcbiAgICAgIGNhc2UgJ3RvcE1vdXNlRG93bic6XG4gICAgICBjYXNlICd0b3BNb3VzZU1vdmUnOlxuICAgICAgY2FzZSAndG9wTW91c2VVcCc6XG4gICAgICAvLyBUT0RPOiBEaXNhYmxlZCBlbGVtZW50cyBzaG91bGQgbm90IHJlc3BvbmQgdG8gbW91c2UgZXZlbnRzXG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBjYXNlICd0b3BNb3VzZU91dCc6XG4gICAgICBjYXNlICd0b3BNb3VzZU92ZXInOlxuICAgICAgY2FzZSAndG9wQ29udGV4dE1lbnUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljTW91c2VFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BEcmFnJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFbmQnOlxuICAgICAgY2FzZSAndG9wRHJhZ0VudGVyJzpcbiAgICAgIGNhc2UgJ3RvcERyYWdFeGl0JzpcbiAgICAgIGNhc2UgJ3RvcERyYWdMZWF2ZSc6XG4gICAgICBjYXNlICd0b3BEcmFnT3Zlcic6XG4gICAgICBjYXNlICd0b3BEcmFnU3RhcnQnOlxuICAgICAgY2FzZSAndG9wRHJvcCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNEcmFnRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wVG91Y2hDYW5jZWwnOlxuICAgICAgY2FzZSAndG9wVG91Y2hFbmQnOlxuICAgICAgY2FzZSAndG9wVG91Y2hNb3ZlJzpcbiAgICAgIGNhc2UgJ3RvcFRvdWNoU3RhcnQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVG91Y2hFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0b3BBbmltYXRpb25FbmQnOlxuICAgICAgY2FzZSAndG9wQW5pbWF0aW9uSXRlcmF0aW9uJzpcbiAgICAgIGNhc2UgJ3RvcEFuaW1hdGlvblN0YXJ0JzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0FuaW1hdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFRyYW5zaXRpb25FbmQnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljVHJhbnNpdGlvbkV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFNjcm9sbCc6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RvcFdoZWVsJzpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndG9wQ29weSc6XG4gICAgICBjYXNlICd0b3BDdXQnOlxuICAgICAgY2FzZSAndG9wUGFzdGUnOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAge1xuICAgICAgICAgIGlmIChrbm93bkhUTUxUb3BMZXZlbFR5cGVzLmluZGV4T2YodG9wTGV2ZWxUeXBlKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuIFRoaXMgd2FybmluZyAnICsgJ2lzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsIHRvcExldmVsVHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQkMTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHZhciBldmVudCA9IEV2ZW50Q29uc3RydWN0b3IuZ2V0UG9vbGVkKGRpc3BhdGNoQ29uZmlnLCB0YXJnZXRJbnN0LCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICAgIHJldHVybiBldmVudDtcbiAgfVxufTtcblxuc2V0SGFuZGxlVG9wTGV2ZWwoaGFuZGxlVG9wTGV2ZWwpO1xuXG4vKipcbiAqIEluamVjdCBtb2R1bGVzIGZvciByZXNvbHZpbmcgRE9NIGhpZXJhcmNoeSBhbmQgcGx1Z2luIG9yZGVyaW5nLlxuICovXG5pbmplY3Rpb24kMS5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERPTUV2ZW50UGx1Z2luT3JkZXIpO1xuaW5qZWN0aW9uJDIuaW5qZWN0Q29tcG9uZW50VHJlZShSZWFjdERPTUNvbXBvbmVudFRyZWUpO1xuXG4vKipcbiAqIFNvbWUgaW1wb3J0YW50IGV2ZW50IHBsdWdpbnMgaW5jbHVkZWQgYnkgZGVmYXVsdCAod2l0aG91dCBoYXZpbmcgdG8gcmVxdWlyZVxuICogdGhlbSkuXG4gKi9cbmluamVjdGlvbiQxLmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZSh7XG4gIFNpbXBsZUV2ZW50UGx1Z2luOiBTaW1wbGVFdmVudFBsdWdpbixcbiAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gIENoYW5nZUV2ZW50UGx1Z2luOiBDaGFuZ2VFdmVudFBsdWdpbixcbiAgU2VsZWN0RXZlbnRQbHVnaW46IFNlbGVjdEV2ZW50UGx1Z2luLFxuICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG59KTtcblxudmFyIGVuYWJsZUFzeW5jU3VidHJlZUFQSSA9IHRydWU7XG52YXIgZW5hYmxlQXN5bmNTY2hlZHVsaW5nQnlEZWZhdWx0SW5SZWFjdERPTSA9IGZhbHNlO1xuLy8gRXhwb3J0cyBSZWFjdC5GcmFnbWVudFxudmFyIGVuYWJsZVJlYWN0RnJhZ21lbnQgPSBmYWxzZTtcbi8vIEV4cG9ydHMgUmVhY3RET00uY3JlYXRlUm9vdFxudmFyIGVuYWJsZUNyZWF0ZVJvb3QgPSBmYWxzZTtcbnZhciBlbmFibGVVc2VyVGltaW5nQVBJID0gdHJ1ZTtcblxuLy8gTXV0YXRpbmcgbW9kZSAoUmVhY3QgRE9NLCBSZWFjdCBBUlQsIFJlYWN0IE5hdGl2ZSk6XG52YXIgZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyID0gdHJ1ZTtcbi8vIEV4cGVyaW1lbnRhbCBub29wIG1vZGUgKGN1cnJlbnRseSB1bnVzZWQpOlxudmFyIGVuYWJsZU5vb3BSZWNvbmNpbGVyID0gZmFsc2U7XG4vLyBFeHBlcmltZW50YWwgcGVyc2lzdGVudCBtb2RlIChDUyk6XG52YXIgZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgPSBmYWxzZTtcblxuLy8gT25seSB1c2VkIGluIHd3dyBidWlsZHMuXG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG5cbntcbiAgdmFyIGZpYmVyU3RhY2sgPSBbXTtcbn1cblxudmFyIGluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcihkZWZhdWx0VmFsdWUpIHtcbiAgcmV0dXJuIHtcbiAgICBjdXJyZW50OiBkZWZhdWx0VmFsdWVcbiAgfTtcbn1cblxuXG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcblxuICB2YWx1ZVN0YWNrW2luZGV4XSA9IGN1cnNvci5jdXJyZW50O1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IGZpYmVyO1xuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gcmVzZXQkMSgpIHtcbiAgd2hpbGUgKGluZGV4ID4gLTEpIHtcbiAgICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAgICB7XG4gICAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gICAgfVxuXG4gICAgaW5kZXgtLTtcbiAgfVxufVxuXG52YXIgZGVzY3JpYmVDb21wb25lbnRGcmFtZSA9IGZ1bmN0aW9uIChuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSkge1xuICByZXR1cm4gJ1xcbiAgICBpbiAnICsgKG5hbWUgfHwgJ1Vua25vd24nKSArIChzb3VyY2UgPyAnIChhdCAnICsgc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKSArICc6JyArIHNvdXJjZS5saW5lTnVtYmVyICsgJyknIDogb3duZXJOYW1lID8gJyAoY3JlYXRlZCBieSAnICsgb3duZXJOYW1lICsgJyknIDogJycpO1xufTtcblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICAgIHZhciBzb3VyY2UgPSBmaWJlci5fZGVidWdTb3VyY2U7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpO1xuICAgICAgdmFyIG93bmVyTmFtZSA9IG51bGw7XG4gICAgICBpZiAob3duZXIpIHtcbiAgICAgICAgb3duZXJOYW1lID0gZ2V0Q29tcG9uZW50TmFtZShvd25lcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzY3JpYmVDb21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyTmFtZSk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGNhbiBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgd29yay1pbi1wcm9ncmVzcyBmaWJlciBhbmRcbi8vIG9ubHkgZHVyaW5nIGJlZ2luIG9yIGNvbXBsZXRlIHBoYXNlLiBEbyBub3QgY2FsbCBpdCB1bmRlciBhbnkgb3RoZXJcbi8vIGNpcmN1bXN0YW5jZXMuXG5mdW5jdGlvbiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciBpbmZvID0gJyc7XG4gIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG4gIGRvIHtcbiAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG4gICAgLy8gT3RoZXJ3aXNlIHRoaXMgcmV0dXJuIHBvaW50ZXIgbWlnaHQgcG9pbnQgdG8gdGhlIHdyb25nIHRyZWU6XG4gICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICB9IHdoaWxlIChub2RlKTtcbiAgcmV0dXJuIGluZm87XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgb3duZXIgPSBmaWJlci5fZGVidWdPd25lcjtcbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgdHlwZW9mIG93bmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUob3duZXIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSgpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudDtcbiAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuICAgIHJldHVybiBnZXRTdGFja0FkZGVuZHVtQnlXb3JrSW5Qcm9ncmVzc0ZpYmVyKGZpYmVyKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ID0gbnVsbDtcbiAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldEN1cnJlbnRTdGFjayA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIuY3VycmVudCA9IGZpYmVyO1xuICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnBoYXNlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gc2V0Q3VycmVudFBoYXNlKHBoYXNlKSB7XG4gIFJlYWN0RGVidWdDdXJyZW50RmliZXIucGhhc2UgPSBwaGFzZTtcbn1cblxudmFyIFJlYWN0RGVidWdDdXJyZW50RmliZXIgPSB7XG4gIGN1cnJlbnQ6IG51bGwsXG4gIHBoYXNlOiBudWxsLFxuICByZXNldEN1cnJlbnRGaWJlcjogcmVzZXRDdXJyZW50RmliZXIsXG4gIHNldEN1cnJlbnRGaWJlcjogc2V0Q3VycmVudEZpYmVyLFxuICBzZXRDdXJyZW50UGhhc2U6IHNldEN1cnJlbnRQaGFzZSxcbiAgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lOiBnZXRDdXJyZW50RmliZXJPd25lck5hbWUsXG4gIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW06IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW1cbn07XG5cbi8vIFByZWZpeCBtZWFzdXJlbWVudHMgc28gdGhhdCBpdCdzIHBvc3NpYmxlIHRvIGZpbHRlciB0aGVtLlxuLy8gTG9uZ2VyIHByZWZpeGVzIGFyZSBoYXJkIHRvIHJlYWQgaW4gRGV2VG9vbHMuXG52YXIgcmVhY3RFbW9qaSA9ICdcXHUyNjlCJztcbnZhciB3YXJuaW5nRW1vamkgPSAnXFx1MjZENCc7XG52YXIgc3VwcG9ydHNVc2VyVGltaW5nID0gdHlwZW9mIHBlcmZvcm1hbmNlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UubWVhc3VyZSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcGVyZm9ybWFuY2UuY2xlYXJNZWFzdXJlcyA9PT0gJ2Z1bmN0aW9uJztcblxuLy8gS2VlcCB0cmFjayBvZiBjdXJyZW50IGZpYmVyIHNvIHRoYXQgd2Uga25vdyB0aGUgcGF0aCB0byB1bndpbmQgb24gcGF1c2UuXG4vLyBUT0RPOiB0aGlzIGxvb2tzIHRoZSBzYW1lIGFzIG5leHRVbml0T2ZXb3JrIGluIHNjaGVkdWxlci4gQ2FuIHdlIHVuaWZ5IHRoZW0/XG52YXIgY3VycmVudEZpYmVyID0gbnVsbDtcbi8vIElmIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgdXNlciBjb2RlLCB3aGljaCBmaWJlciBhbmQgbWV0aG9kIGlzIGl0P1xuLy8gUmV1c2luZyBgY3VycmVudEZpYmVyYCB3b3VsZCBiZSBjb25mdXNpbmcgZm9yIHRoaXMgYmVjYXVzZSB1c2VyIGNvZGUgZmliZXJcbi8vIGNhbiBjaGFuZ2UgZHVyaW5nIGNvbW1pdCBwaGFzZSB0b28sIGJ1dCB3ZSBkb24ndCBuZWVkIHRvIHVud2luZCBpdCAoc2luY2Vcbi8vIGxpZmVjeWNsZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSBkb24ndCByZXNlbWJsZSBhIHRyZWUpLlxudmFyIGN1cnJlbnRQaGFzZSA9IG51bGw7XG52YXIgY3VycmVudFBoYXNlRmliZXIgPSBudWxsO1xuLy8gRGlkIGxpZmVjeWNsZSBob29rIHNjaGVkdWxlIGFuIHVwZGF0ZT8gVGhpcyBpcyBvZnRlbiBhIHBlcmZvcm1hbmNlIHByb2JsZW0sXG4vLyBzbyB3ZSB3aWxsIGtlZXAgdHJhY2sgb2YgaXQsIGFuZCBpbmNsdWRlIGl0IGluIHRoZSByZXBvcnQuXG4vLyBUcmFjayBjb21taXRzIGNhdXNlZCBieSBjYXNjYWRpbmcgdXBkYXRlcy5cbnZhciBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbnZhciBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRQaGFzZSA9IGZhbHNlO1xudmFyIGNvbW1pdENvdW50SW5DdXJyZW50V29ya0xvb3AgPSAwO1xudmFyIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbi8vIER1cmluZyBjb21taXRzLCB3ZSBvbmx5IHNob3cgYSBtZWFzdXJlbWVudCBvbmNlIHBlciBtZXRob2QgbmFtZVxuLy8gdG8gYXZvaWQgc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIHdpdGggbWVhc3VyZW1lbnQgb3ZlcmhlYWQuXG52YXIgbGFiZWxzSW5DdXJyZW50Q29tbWl0ID0gbmV3IFNldCgpO1xuXG52YXIgZm9ybWF0TWFya05hbWUgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcmV0dXJuIHJlYWN0RW1vamkgKyAnICcgKyBtYXJrTmFtZTtcbn07XG5cbnZhciBmb3JtYXRMYWJlbCA9IGZ1bmN0aW9uIChsYWJlbCwgd2FybmluZyQkMSkge1xuICB2YXIgcHJlZml4ID0gd2FybmluZyQkMSA/IHdhcm5pbmdFbW9qaSArICcgJyA6IHJlYWN0RW1vamkgKyAnICc7XG4gIHZhciBzdWZmaXggPSB3YXJuaW5nJCQxID8gJyBXYXJuaW5nOiAnICsgd2FybmluZyQkMSA6ICcnO1xuICByZXR1cm4gJycgKyBwcmVmaXggKyBsYWJlbCArIHN1ZmZpeDtcbn07XG5cbnZhciBiZWdpbk1hcmsgPSBmdW5jdGlvbiAobWFya05hbWUpIHtcbiAgcGVyZm9ybWFuY2UubWFyayhmb3JtYXRNYXJrTmFtZShtYXJrTmFtZSkpO1xufTtcblxudmFyIGNsZWFyTWFyayA9IGZ1bmN0aW9uIChtYXJrTmFtZSkge1xuICBwZXJmb3JtYW5jZS5jbGVhck1hcmtzKGZvcm1hdE1hcmtOYW1lKG1hcmtOYW1lKSk7XG59O1xuXG52YXIgZW5kTWFyayA9IGZ1bmN0aW9uIChsYWJlbCwgbWFya05hbWUsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGZvcm1hdHRlZE1hcmtOYW1lID0gZm9ybWF0TWFya05hbWUobWFya05hbWUpO1xuICB2YXIgZm9ybWF0dGVkTGFiZWwgPSBmb3JtYXRMYWJlbChsYWJlbCwgd2FybmluZyQkMSk7XG4gIHRyeSB7XG4gICAgcGVyZm9ybWFuY2UubWVhc3VyZShmb3JtYXR0ZWRMYWJlbCwgZm9ybWF0dGVkTWFya05hbWUpO1xuICB9IGNhdGNoIChlcnIpIHt9XG4gIC8vIElmIHByZXZpb3VzIG1hcmsgd2FzIG1pc3NpbmcgZm9yIHNvbWUgcmVhc29uLCB0aGlzIHdpbGwgdGhyb3cuXG4gIC8vIFRoaXMgY291bGQgb25seSBoYXBwZW4gaWYgUmVhY3QgY3Jhc2hlZCBpbiBhbiB1bmV4cGVjdGVkIHBsYWNlIGVhcmxpZXIuXG4gIC8vIERvbid0IHBpbGUgb24gd2l0aCBtb3JlIGVycm9ycy5cblxuICAvLyBDbGVhciBtYXJrcyBpbW1lZGlhdGVseSB0byBhdm9pZCBncm93aW5nIGJ1ZmZlci5cbiAgcGVyZm9ybWFuY2UuY2xlYXJNYXJrcyhmb3JtYXR0ZWRNYXJrTmFtZSk7XG4gIHBlcmZvcm1hbmNlLmNsZWFyTWVhc3VyZXMoZm9ybWF0dGVkTGFiZWwpO1xufTtcblxudmFyIGdldEZpYmVyTWFya05hbWUgPSBmdW5jdGlvbiAobGFiZWwsIGRlYnVnSUQpIHtcbiAgcmV0dXJuIGxhYmVsICsgJyAoIycgKyBkZWJ1Z0lEICsgJyknO1xufTtcblxudmFyIGdldEZpYmVyTGFiZWwgPSBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSkge1xuICBpZiAocGhhc2UgPT09IG51bGwpIHtcbiAgICAvLyBUaGVzZSBhcmUgY29tcG9zaXRlIGNvbXBvbmVudCB0b3RhbCB0aW1lIG1lYXN1cmVtZW50cy5cbiAgICByZXR1cm4gY29tcG9uZW50TmFtZSArICcgWycgKyAoaXNNb3VudGVkID8gJ3VwZGF0ZScgOiAnbW91bnQnKSArICddJztcbiAgfSBlbHNlIHtcbiAgICAvLyBDb21wb3NpdGUgY29tcG9uZW50IG1ldGhvZHMuXG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgKyAnLicgKyBwaGFzZTtcbiAgfVxufTtcblxudmFyIGJlZ2luRmliZXJNYXJrID0gZnVuY3Rpb24gKGZpYmVyLCBwaGFzZSkge1xuICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcbiAgdmFyIGRlYnVnSUQgPSBmaWJlci5fZGVidWdJRDtcbiAgdmFyIGlzTW91bnRlZCA9IGZpYmVyLmFsdGVybmF0ZSAhPT0gbnVsbDtcbiAgdmFyIGxhYmVsID0gZ2V0RmliZXJMYWJlbChjb21wb25lbnROYW1lLCBpc01vdW50ZWQsIHBoYXNlKTtcblxuICBpZiAoaXNDb21taXR0aW5nICYmIGxhYmVsc0luQ3VycmVudENvbW1pdC5oYXMobGFiZWwpKSB7XG4gICAgLy8gRHVyaW5nIHRoZSBjb21taXQgcGhhc2UsIHdlIGRvbid0IHNob3cgZHVwbGljYXRlIGxhYmVscyBiZWNhdXNlXG4gICAgLy8gdGhlcmUgaXMgYSBmaXhlZCBvdmVyaGVhZCBmb3IgZXZlcnkgbWVhc3VyZW1lbnQsIGFuZCB3ZSBkb24ndFxuICAgIC8vIHdhbnQgdG8gc3RyZXRjaCB0aGUgY29tbWl0IHBoYXNlIGJleW9uZCBuZWNlc3NhcnkuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGxhYmVsc0luQ3VycmVudENvbW1pdC5hZGQobGFiZWwpO1xuXG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBiZWdpbk1hcmsobWFya05hbWUpO1xuICByZXR1cm4gdHJ1ZTtcbn07XG5cbnZhciBjbGVhckZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBjbGVhck1hcmsobWFya05hbWUpO1xufTtcblxudmFyIGVuZEZpYmVyTWFyayA9IGZ1bmN0aW9uIChmaWJlciwgcGhhc2UsIHdhcm5pbmckJDEpIHtcbiAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKGZpYmVyKSB8fCAnVW5rbm93bic7XG4gIHZhciBkZWJ1Z0lEID0gZmliZXIuX2RlYnVnSUQ7XG4gIHZhciBpc01vdW50ZWQgPSBmaWJlci5hbHRlcm5hdGUgIT09IG51bGw7XG4gIHZhciBsYWJlbCA9IGdldEZpYmVyTGFiZWwoY29tcG9uZW50TmFtZSwgaXNNb3VudGVkLCBwaGFzZSk7XG4gIHZhciBtYXJrTmFtZSA9IGdldEZpYmVyTWFya05hbWUobGFiZWwsIGRlYnVnSUQpO1xuICBlbmRNYXJrKGxhYmVsLCBtYXJrTmFtZSwgd2FybmluZyQkMSk7XG59O1xuXG52YXIgc2hvdWxkSWdub3JlRmliZXIgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgLy8gSG9zdCBjb21wb25lbnRzIHNob3VsZCBiZSBza2lwcGVkIGluIHRoZSB0aW1lbGluZS5cbiAgLy8gV2UgY291bGQgY2hlY2sgdHlwZW9mIGZpYmVyLnR5cGUsIGJ1dCBkb2VzIHRoaXMgd29yayB3aXRoIFJOP1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgUmV0dXJuQ29tcG9uZW50OlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG52YXIgY2xlYXJQZW5kaW5nUGhhc2VNZWFzdXJlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKGN1cnJlbnRQaGFzZSAhPT0gbnVsbCAmJiBjdXJyZW50UGhhc2VGaWJlciAhPT0gbnVsbCkge1xuICAgIGNsZWFyRmliZXJNYXJrKGN1cnJlbnRQaGFzZUZpYmVyLCBjdXJyZW50UGhhc2UpO1xuICB9XG4gIGN1cnJlbnRQaGFzZUZpYmVyID0gbnVsbDtcbiAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50UGhhc2UgPSBmYWxzZTtcbn07XG5cbnZhciBwYXVzZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gU3RvcHMgYWxsIGN1cnJlbnRseSBhY3RpdmUgbWVhc3VyZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gYmUgcmVzdW1lZFxuICAvLyBpZiB3ZSBjb250aW51ZSBpbiBhIGxhdGVyIGRlZmVycmVkIGxvb3AgZnJvbSB0aGUgc2FtZSB1bml0IG9mIHdvcmsuXG4gIHZhciBmaWJlciA9IGN1cnJlbnRGaWJlcjtcbiAgd2hpbGUgKGZpYmVyKSB7XG4gICAgaWYgKGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICBlbmRGaWJlck1hcmsoZmliZXIsIG51bGwsIG51bGwpO1xuICAgIH1cbiAgICBmaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVyc1JlY3Vyc2l2ZWx5ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIGlmIChmaWJlclsncmV0dXJuJ10gIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShmaWJlclsncmV0dXJuJ10pO1xuICB9XG4gIGlmIChmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgIGJlZ2luRmliZXJNYXJrKGZpYmVyLCBudWxsKTtcbiAgfVxufTtcblxudmFyIHJlc3VtZVRpbWVycyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gUmVzdW1lcyBhbGwgbWVhc3VyZW1lbnRzIHRoYXQgd2VyZSBhY3RpdmUgZHVyaW5nIHRoZSBsYXN0IGRlZmVycmVkIGxvb3AuXG4gIGlmIChjdXJyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICByZXN1bWVUaW1lcnNSZWN1cnNpdmVseShjdXJyZW50RmliZXIpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWNvcmRFZmZlY3QoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQrKztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRTY2hlZHVsZVVwZGF0ZSgpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZSAhPT0gJ2NvbXBvbmVudFdpbGxNb3VudCcgJiYgY3VycmVudFBoYXNlICE9PSAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycpIHtcbiAgICAgIGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIHRoaXMgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlmICghYmVnaW5GaWJlck1hcmsoZmliZXIsIG51bGwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gUmVtZW1iZXIgd2Ugc2hvdWxkbid0IGNvbXBsZXRlIG1lYXN1cmVtZW50IGZvciB0aGlzIGZpYmVyLlxuICAgIC8vIE90aGVyd2lzZSBmbGFtZWNoYXJ0IHdpbGwgYmUgZGVlcCBldmVuIGZvciBzbWFsbCB1cGRhdGVzLlxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgY2xlYXJGaWJlck1hcmsoZmliZXIsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrVGltZXIoZmliZXIpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZyB8fCBzaG91bGRJZ25vcmVGaWJlcihmaWJlcikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgd2UgcGF1c2UsIGl0cyBwYXJlbnQgaXMgdGhlIGZpYmVyIHRvIHVud2luZCBmcm9tLlxuICAgIGN1cnJlbnRGaWJlciA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICBpZiAoIWZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZpYmVyLl9kZWJ1Z0lzQ3VycmVudGx5VGltaW5nID0gZmFsc2U7XG4gICAgZW5kRmliZXJNYXJrKGZpYmVyLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wRmFpbGVkV29ya1RpbWVyKGZpYmVyKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcgfHwgc2hvdWxkSWdub3JlRmliZXIoZmliZXIpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIElmIHdlIHBhdXNlLCBpdHMgcGFyZW50IGlzIHRoZSBmaWJlciB0byB1bndpbmQgZnJvbS5cbiAgICBjdXJyZW50RmliZXIgPSBmaWJlclsncmV0dXJuJ107XG4gICAgaWYgKCFmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmaWJlci5fZGVidWdJc0N1cnJlbnRseVRpbWluZyA9IGZhbHNlO1xuICAgIHZhciB3YXJuaW5nJCQxID0gJ0FuIGVycm9yIHdhcyB0aHJvd24gaW5zaWRlIHRoaXMgZXJyb3IgYm91bmRhcnknO1xuICAgIGVuZEZpYmVyTWFyayhmaWJlciwgbnVsbCwgd2FybmluZyQkMSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRQaGFzZVRpbWVyKGZpYmVyLCBwaGFzZSkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNsZWFyUGVuZGluZ1BoYXNlTWVhc3VyZW1lbnQoKTtcbiAgICBpZiAoIWJlZ2luRmliZXJNYXJrKGZpYmVyLCBwaGFzZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlRmliZXIgPSBmaWJlcjtcbiAgICBjdXJyZW50UGhhc2UgPSBwaGFzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUGhhc2VUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoY3VycmVudFBoYXNlICE9PSBudWxsICYmIGN1cnJlbnRQaGFzZUZpYmVyICE9PSBudWxsKSB7XG4gICAgICB2YXIgd2FybmluZyQkMSA9IGhhc1NjaGVkdWxlZFVwZGF0ZUluQ3VycmVudFBoYXNlID8gJ1NjaGVkdWxlZCBhIGNhc2NhZGluZyB1cGRhdGUnIDogbnVsbDtcbiAgICAgIGVuZEZpYmVyTWFyayhjdXJyZW50UGhhc2VGaWJlciwgY3VycmVudFBoYXNlLCB3YXJuaW5nJCQxKTtcbiAgICB9XG4gICAgY3VycmVudFBoYXNlID0gbnVsbDtcbiAgICBjdXJyZW50UGhhc2VGaWJlciA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgY3VycmVudEZpYmVyID0gbmV4dFVuaXRPZldvcms7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gVGhpcyBpcyB0b3AgbGV2ZWwgY2FsbC5cbiAgICAvLyBBbnkgb3RoZXIgbWVhc3VyZW1lbnRzIGFyZSBwZXJmb3JtZWQgd2l0aGluLlxuICAgIGJlZ2luTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJyk7XG4gICAgLy8gUmVzdW1lIGFueSBtZWFzdXJlbWVudHMgdGhhdCB3ZXJlIGluIHByb2dyZXNzIGR1cmluZyB0aGUgbGFzdCBsb29wLlxuICAgIHJlc3VtZVRpbWVycygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BXb3JrTG9vcFRpbWVyKGludGVycnVwdGVkQnkpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgd2FybmluZyQkMSA9IG51bGw7XG4gICAgaWYgKGludGVycnVwdGVkQnkgIT09IG51bGwpIHtcbiAgICAgIGlmIChpbnRlcnJ1cHRlZEJ5LnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgd2FybmluZyQkMSA9ICdBIHRvcC1sZXZlbCB1cGRhdGUgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoaW50ZXJydXB0ZWRCeSkgfHwgJ1Vua25vd24nO1xuICAgICAgICB3YXJuaW5nJCQxID0gJ0FuIHVwZGF0ZSB0byAnICsgY29tcG9uZW50TmFtZSArICcgaW50ZXJydXB0ZWQgdGhlIHByZXZpb3VzIHJlbmRlcic7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMSkge1xuICAgICAgd2FybmluZyQkMSA9ICdUaGVyZSB3ZXJlIGNhc2NhZGluZyB1cGRhdGVzJztcbiAgICB9XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCA9IDA7XG4gICAgLy8gUGF1c2UgYW55IG1lYXN1cmVtZW50cyB1bnRpbCB0aGUgbmV4dCBsb29wLlxuICAgIHBhdXNlVGltZXJzKCk7XG4gICAgZW5kTWFyaygnKFJlYWN0IFRyZWUgUmVjb25jaWxpYXRpb24pJywgJyhSZWFjdCBUcmVlIFJlY29uY2lsaWF0aW9uKScsIHdhcm5pbmckJDEpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0Q29tbWl0VGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNDb21taXR0aW5nID0gdHJ1ZTtcbiAgICBoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQgPSBmYWxzZTtcbiAgICBsYWJlbHNJbkN1cnJlbnRDb21taXQuY2xlYXIoKTtcbiAgICBiZWdpbk1hcmsoJyhDb21taXR0aW5nIENoYW5nZXMpJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RvcENvbW1pdFRpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmckJDEgPSBudWxsO1xuICAgIGlmIChoYXNTY2hlZHVsZWRVcGRhdGVJbkN1cnJlbnRDb21taXQpIHtcbiAgICAgIHdhcm5pbmckJDEgPSAnTGlmZWN5Y2xlIGhvb2sgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHVwZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChjb21taXRDb3VudEluQ3VycmVudFdvcmtMb29wID4gMCkge1xuICAgICAgd2FybmluZyQkMSA9ICdDYXVzZWQgYnkgYSBjYXNjYWRpbmcgdXBkYXRlIGluIGVhcmxpZXIgY29tbWl0JztcbiAgICB9XG4gICAgaGFzU2NoZWR1bGVkVXBkYXRlSW5DdXJyZW50Q29tbWl0ID0gZmFsc2U7XG4gICAgY29tbWl0Q291bnRJbkN1cnJlbnRXb3JrTG9vcCsrO1xuICAgIGlzQ29tbWl0dGluZyA9IGZhbHNlO1xuICAgIGxhYmVsc0luQ3VycmVudENvbW1pdC5jbGVhcigpO1xuXG4gICAgZW5kTWFyaygnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCAnKENvbW1pdHRpbmcgQ2hhbmdlcyknLCB3YXJuaW5nJCQxKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKSB7XG4gIGlmIChlbmFibGVVc2VyVGltaW5nQVBJKSB7XG4gICAgaWYgKCFzdXBwb3J0c1VzZXJUaW1pbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWZmZWN0Q291bnRJbkN1cnJlbnRDb21taXQgPSAwO1xuICAgIGJlZ2luTWFyaygnKENvbW1pdHRpbmcgSG9zdCBFZmZlY3RzKScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BDb21taXRIb3N0RWZmZWN0c1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ29tbWl0dGluZyBIb3N0IEVmZmVjdHM6ICcgKyBjb3VudCArICcgVG90YWwpJywgJyhDb21taXR0aW5nIEhvc3QgRWZmZWN0cyknLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpIHtcbiAgaWYgKGVuYWJsZVVzZXJUaW1pbmdBUEkpIHtcbiAgICBpZiAoIXN1cHBvcnRzVXNlclRpbWluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlZmZlY3RDb3VudEluQ3VycmVudENvbW1pdCA9IDA7XG4gICAgYmVnaW5NYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kcyknKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCkge1xuICBpZiAoZW5hYmxlVXNlclRpbWluZ0FQSSkge1xuICAgIGlmICghc3VwcG9ydHNVc2VyVGltaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBjb3VudCA9IGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0O1xuICAgIGVmZmVjdENvdW50SW5DdXJyZW50Q29tbWl0ID0gMDtcbiAgICBlbmRNYXJrKCcoQ2FsbGluZyBMaWZlY3ljbGUgTWV0aG9kczogJyArIGNvdW50ICsgJyBUb3RhbCknLCAnKENhbGxpbmcgTGlmZWN5Y2xlIE1ldGhvZHMpJywgbnVsbCk7XG4gIH1cbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0ID0ge307XG59XG5cbi8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKGVtcHR5T2JqZWN0KTtcbi8vIEEgY3Vyc29yIHRvIGEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIGNvbnRleHQgaGFzIGNoYW5nZWQuXG52YXIgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihmYWxzZSk7XG4vLyBLZWVwIHRyYWNrIG9mIHRoZSBwcmV2aW91cyBjb250ZXh0IG9iamVjdCB0aGF0IHdhcyBvbiB0aGUgc3RhY2suXG4vLyBXZSB1c2UgdGhpcyB0byBnZXQgYWNjZXNzIHRvIHRoZSBwYXJlbnQgY29udGV4dCBhZnRlciB3ZSBoYXZlIGFscmVhZHlcbi8vIHB1c2hlZCB0aGUgbmV4dCBjb250ZXh0IHByb3ZpZGVyLCBhbmQgbm93IG5lZWQgdG8gbWVyZ2UgdGhlaXIgY29udGV4dHMuXG52YXIgcHJldmlvdXNDb250ZXh0ID0gZW1wdHlPYmplY3Q7XG5cbmZ1bmN0aW9uIGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgaGFzT3duQ29udGV4dCA9IGlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgaWYgKGhhc093bkNvbnRleHQpIHtcbiAgICAvLyBJZiB0aGUgZmliZXIgaXMgYSBjb250ZXh0IHByb3ZpZGVyIGl0c2VsZiwgd2hlbiB3ZSByZWFkIGl0cyBjb250ZXh0XG4gICAgLy8gd2UgaGF2ZSBhbHJlYWR5IHB1c2hlZCBpdHMgb3duIGNoaWxkIGNvbnRleHQgb24gdGhlIHN0YWNrLiBBIGNvbnRleHRcbiAgICAvLyBwcm92aWRlciBzaG91bGQgbm90IFwic2VlXCIgaXRzIG93biBjaGlsZCBjb250ZXh0LiBUaGVyZWZvcmUgd2UgcmVhZCB0aGVcbiAgICAvLyBwcmV2aW91cyAocGFyZW50KSBjb250ZXh0IGluc3RlYWQgZm9yIGEgY29udGV4dCBwcm92aWRlci5cbiAgICByZXR1cm4gcHJldmlvdXNDb250ZXh0O1xuICB9XG4gIHJldHVybiBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbn1cblxuZnVuY3Rpb24gY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIG1hc2tlZENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1hc2tlZENoaWxkQ29udGV4dCA9IG1hc2tlZENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCkge1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBjb250ZXh0VHlwZXMgPSB0eXBlLmNvbnRleHRUeXBlcztcbiAgaWYgKCFjb250ZXh0VHlwZXMpIHtcbiAgICByZXR1cm4gZW1wdHlPYmplY3Q7XG4gIH1cblxuICAvLyBBdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyB1bm1hc2tlZCBjb250ZXh0IGhhcyBjaGFuZ2VkLlxuICAvLyBGYWlsaW5nIHRvIGRvIHRoaXMgd2lsbCByZXN1bHQgaW4gdW5uZWNlc3NhcnkgY2FsbHMgdG8gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5cbiAgLy8gVGhpcyBtYXkgdHJpZ2dlciBpbmZpbml0ZSBsb29wcyBpZiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGNhbGxzIHNldFN0YXRlLlxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGlmIChpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZFVubWFza2VkQ2hpbGRDb250ZXh0ID09PSB1bm1hc2tlZENvbnRleHQpIHtcbiAgICByZXR1cm4gaW5zdGFuY2UuX19yZWFjdEludGVybmFsTWVtb2l6ZWRNYXNrZWRDaGlsZENvbnRleHQ7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHt9O1xuICBmb3IgKHZhciBrZXkgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgY29udGV4dFtrZXldID0gdW5tYXNrZWRDb250ZXh0W2tleV07XG4gIH1cblxuICB7XG4gICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG4gICAgY2hlY2tQcm9wVHlwZXMoY29udGV4dFR5cGVzLCBjb250ZXh0LCAnY29udGV4dCcsIG5hbWUsIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICAvLyBDYWNoZSB1bm1hc2tlZCBjb250ZXh0IHNvIHdlIGNhbiBhdm9pZCByZWNyZWF0aW5nIG1hc2tlZCBjb250ZXh0IHVubGVzcyBuZWNlc3NhcnkuXG4gIC8vIENvbnRleHQgaXMgY3JlYXRlZCBiZWZvcmUgdGhlIGNsYXNzIGNvbXBvbmVudCBpcyBpbnN0YW50aWF0ZWQgc28gY2hlY2sgZm9yIGluc3RhbmNlLlxuICBpZiAoaW5zdGFuY2UpIHtcbiAgICBjYWNoZUNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCwgY29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gaGFzQ29udGV4dENoYW5nZWQoKSB7XG4gIHJldHVybiBkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dENvbnN1bWVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50ICYmIGZpYmVyLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgIT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dFByb3ZpZGVyKGZpYmVyKSB7XG4gIGlmICghaXNDb250ZXh0UHJvdmlkZXIoZmliZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BUb3BMZXZlbENvbnRleHRPYmplY3QoZmliZXIpIHtcbiAgcG9wKGRpZFBlcmZvcm1Xb3JrU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KGZpYmVyLCBjb250ZXh0LCBkaWRDaGFuZ2UpIHtcbiAgIShjb250ZXh0U3RhY2tDdXJzb3IuY3Vyc29yID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVW5leHBlY3RlZCBjb250ZXh0IGZvdW5kIG9uIHN0YWNrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBjb250ZXh0LCBmaWJlcik7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgY2hpbGRDb250ZXh0VHlwZXMgPSBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzO1xuXG4gIC8vIFRPRE8gKGJ2YXVnaG4pIFJlcGxhY2UgdGhpcyBiZWhhdmlvciB3aXRoIGFuIGludmFyaWFudCgpIGluIHRoZSBmdXR1cmUuXG4gIC8vIEl0IGhhcyBvbmx5IGJlZW4gYWRkZWQgaW4gRmliZXIgdG8gbWF0Y2ggdGhlICh1bmludGVudGlvbmFsKSBiZWhhdmlvciBpbiBTdGFjay5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgIT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCF3YXJuZWRBYm91dE1pc3NpbmdHZXRDaGlsZENvbnRleHRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgd2FybmVkQWJvdXRNaXNzaW5nR2V0Q2hpbGRDb250ZXh0W2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzLmNoaWxkQ29udGV4dFR5cGVzIGlzIHNwZWNpZmllZCBidXQgdGhlcmUgaXMgbm8gZ2V0Q2hpbGRDb250ZXh0KCkgbWV0aG9kICcgKyAnb24gdGhlIGluc3RhbmNlLiBZb3UgY2FuIGVpdGhlciBkZWZpbmUgZ2V0Q2hpbGRDb250ZXh0KCkgb24gJXMgb3IgcmVtb3ZlICcgKyAnY2hpbGRDb250ZXh0VHlwZXMgZnJvbSBpdC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cblxuICB2YXIgY2hpbGRDb250ZXh0ID0gdm9pZCAwO1xuICB7XG4gICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ2dldENoaWxkQ29udGV4dCcpO1xuICB9XG4gIHN0YXJ0UGhhc2VUaW1lcihmaWJlciwgJ2dldENoaWxkQ29udGV4dCcpO1xuICBjaGlsZENvbnRleHQgPSBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQoKTtcbiAgc3RvcFBoYXNlVGltZXIoKTtcbiAge1xuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudFBoYXNlKG51bGwpO1xuICB9XG4gIGZvciAodmFyIGNvbnRleHRLZXkgaW4gY2hpbGRDb250ZXh0KSB7XG4gICAgIShjb250ZXh0S2V5IGluIGNoaWxkQ29udGV4dFR5cGVzKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBrZXkgXCIlc1wiIGlzIG5vdCBkZWZpbmVkIGluIGNoaWxkQ29udGV4dFR5cGVzLicsIGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdVbmtub3duJywgY29udGV4dEtleSkgOiB2b2lkIDA7XG4gIH1cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZShmaWJlcikgfHwgJ1Vua25vd24nO1xuICAgIGNoZWNrUHJvcFR5cGVzKGNoaWxkQ29udGV4dFR5cGVzLCBjaGlsZENvbnRleHQsICdjaGlsZCBjb250ZXh0JywgbmFtZSxcbiAgICAvLyBJbiBwcmFjdGljZSwgdGhlcmUgaXMgb25lIGNhc2UgaW4gd2hpY2ggd2Ugd29uJ3QgZ2V0IGEgc3RhY2suIEl0J3Mgd2hlblxuICAgIC8vIHNvbWVib2R5IGNhbGxzIHVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKCkgYW5kIHdlIHByb2Nlc3NcbiAgICAvLyBjb250ZXh0IGZyb20gdGhlIHBhcmVudCBjb21wb25lbnQgaW5zdGFuY2UuIFRoZSBzdGFjayB3aWxsIGJlIG1pc3NpbmdcbiAgICAvLyBiZWNhdXNlIGl0J3Mgb3V0c2lkZSBvZiB0aGUgcmVjb25jaWxpYXRpb24sIGFuZCBzbyB0aGUgcG9pbnRlciBoYXMgbm90XG4gICAgLy8gYmVlbiBzZXQuIFRoaXMgaXMgcmFyZSBhbmQgZG9lc24ndCBtYXR0ZXIuIFdlJ2xsIGFsc28gcmVtb3ZlIHRoYXQgQVBJLlxuICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSk7XG4gIH1cblxuICByZXR1cm4gX2Fzc2lnbih7fSwgcGFyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoIWlzQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gV2UgcHVzaCB0aGUgY29udGV4dCBhcyBlYXJseSBhcyBwb3NzaWJsZSB0byBlbnN1cmUgc3RhY2sgaW50ZWdyaXR5LlxuICAvLyBJZiB0aGUgaW5zdGFuY2UgZG9lcyBub3QgZXhpc3QgeWV0LCB3ZSB3aWxsIHB1c2ggbnVsbCBhdCBmaXJzdCxcbiAgLy8gYW5kIHJlcGxhY2UgaXQgb24gdGhlIHN0YWNrIGxhdGVyIHdoZW4gaW52YWxpZGF0aW5nIHRoZSBjb250ZXh0LlxuICB2YXIgbWVtb2l6ZWRNZXJnZWRDaGlsZENvbnRleHQgPSBpbnN0YW5jZSAmJiBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dCB8fCBlbXB0eU9iamVjdDtcblxuICAvLyBSZW1lbWJlciB0aGUgcGFyZW50IGNvbnRleHQgc28gd2UgY2FuIG1lcmdlIHdpdGggaXQgbGF0ZXIuXG4gIC8vIEluaGVyaXQgdGhlIHBhcmVudCdzIGRpZC1wZXJmb3JtLXdvcmsgdmFsdWUgdG8gYXZvaWQgaW5hZHZlcnRlbnRseSBibG9ja2luZyB1cGRhdGVzLlxuICBwcmV2aW91c0NvbnRleHQgPSBjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGRpZENoYW5nZSkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICFpbnN0YW5jZSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGhhdmUgYW4gaW5zdGFuY2UgYnkgdGhpcyBwb2ludC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICBpZiAoZGlkQ2hhbmdlKSB7XG4gICAgLy8gTWVyZ2UgcGFyZW50IGFuZCBvd24gY29udGV4dC5cbiAgICAvLyBTa2lwIHRoaXMgaWYgd2UncmUgbm90IHVwZGF0aW5nIGR1ZSB0byBzQ1UuXG4gICAgLy8gVGhpcyBhdm9pZHMgdW5uZWNlc3NhcmlseSByZWNvbXB1dGluZyBtZW1vaXplZCB2YWx1ZXMuXG4gICAgdmFyIG1lcmdlZENvbnRleHQgPSBwcm9jZXNzQ2hpbGRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2aW91c0NvbnRleHQpO1xuICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbE1lbW9pemVkTWVyZ2VkQ2hpbGRDb250ZXh0ID0gbWVyZ2VkQ29udGV4dDtcblxuICAgIC8vIFJlcGxhY2UgdGhlIG9sZCAob3IgZW1wdHkpIGNvbnRleHQgd2l0aCB0aGUgbmV3IG9uZS5cbiAgICAvLyBJdCBpcyBpbXBvcnRhbnQgdG8gdW53aW5kIHRoZSBjb250ZXh0IGluIHRoZSByZXZlcnNlIG9yZGVyLlxuICAgIHBvcChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIC8vIE5vdyBwdXNoIHRoZSBuZXcgY29udGV4dCBhbmQgbWFyayB0aGF0IGl0IGhhcyBjaGFuZ2VkLlxuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBtZXJnZWRDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaChkaWRQZXJmb3JtV29ya1N0YWNrQ3Vyc29yLCBkaWRDaGFuZ2UsIHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIHtcbiAgICBwb3AoZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHB1c2goZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvciwgZGlkQ2hhbmdlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDb250ZXh0KCkge1xuICBwcmV2aW91c0NvbnRleHQgPSBlbXB0eU9iamVjdDtcbiAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBlbXB0eU9iamVjdDtcbiAgZGlkUGVyZm9ybVdvcmtTdGFja0N1cnNvci5jdXJyZW50ID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKSB7XG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIG9ubHkgdXNlZCB3aXRoIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOyBub3Qgc3VyZSBpZiBpdFxuICAvLyBtYWtlcyBzZW5zZSBlbHNld2hlcmVcbiAgIShpc0ZpYmVyTW91bnRlZChmaWJlcikgJiYgZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBzdWJ0cmVlIHBhcmVudCB0byBiZSBhIG1vdW50ZWQgY2xhc3MgY29tcG9uZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gIHZhciBub2RlID0gZmliZXI7XG4gIHdoaWxlIChub2RlLnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlLnN0YXRlTm9kZS5fX3JlYWN0SW50ZXJuYWxNZW1vaXplZE1lcmdlZENoaWxkQ29udGV4dDtcbiAgICB9XG4gICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICFwYXJlbnQgPyBpbnZhcmlhbnQoZmFsc2UsICdGb3VuZCB1bmV4cGVjdGVkIGRldGFjaGVkIHN1YnRyZWUgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gIH1cbiAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlLmNvbnRleHQ7XG59XG5cbnZhciBOb1dvcmsgPSAwOyAvLyBUT0RPOiBVc2UgYW4gb3BhcXVlIHR5cGUgb25jZSBFU0xpbnQgZXQgYWwgc3VwcG9ydCB0aGUgc3ludGF4XG5cbnZhciBTeW5jID0gMTtcbnZhciBOZXZlciA9IDIxNDc0ODM2NDc7IC8vIE1heCBpbnQzMjogTWF0aC5wb3coMiwgMzEpIC0gMVxuXG52YXIgVU5JVF9TSVpFID0gMTA7XG52YXIgTUFHSUNfTlVNQkVSX09GRlNFVCA9IDI7XG5cbi8vIDEgdW5pdCBvZiBleHBpcmF0aW9uIHRpbWUgcmVwcmVzZW50cyAxMG1zLlxuZnVuY3Rpb24gbXNUb0V4cGlyYXRpb25UaW1lKG1zKSB7XG4gIC8vIEFsd2F5cyBhZGQgYW4gb2Zmc2V0IHNvIHRoYXQgd2UgZG9uJ3QgY2xhc2ggd2l0aCB0aGUgbWFnaWMgbnVtYmVyIGZvciBOb1dvcmsuXG4gIHJldHVybiAobXMgLyBVTklUX1NJWkUgfCAwKSArIE1BR0lDX05VTUJFUl9PRkZTRVQ7XG59XG5cbmZ1bmN0aW9uIGNlaWxpbmcobnVtLCBwcmVjaXNpb24pIHtcbiAgcmV0dXJuICgobnVtIC8gcHJlY2lzaW9uIHwgMCkgKyAxKSAqIHByZWNpc2lvbjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25Jbk1zLCBidWNrZXRTaXplTXMpIHtcbiAgcmV0dXJuIGNlaWxpbmcoY3VycmVudFRpbWUgKyBleHBpcmF0aW9uSW5NcyAvIFVOSVRfU0laRSwgYnVja2V0U2l6ZU1zIC8gVU5JVF9TSVpFKTtcbn1cblxudmFyIE5vQ29udGV4dCA9IDA7XG52YXIgQXN5bmNVcGRhdGVzID0gMTtcblxue1xuICB2YXIgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG4gICAgbmV3IE1hcChbW25vbkV4dGVuc2libGVPYmplY3QsIG51bGxdXSk7XG4gICAgbmV3IFNldChbbm9uRXh0ZW5zaWJsZU9iamVjdF0pO1xuICAgIC8qIGVzbGludC1lbmFibGUgbm8tbmV3ICovXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGFib3V0IGJhZCBwb2x5ZmlsbHNcbiAgICBoYXNCYWRNYXBQb2x5ZmlsbCA9IHRydWU7XG4gIH1cbn1cblxuLy8gQSBGaWJlciBpcyB3b3JrIG9uIGEgQ29tcG9uZW50IHRoYXQgbmVlZHMgdG8gYmUgZG9uZSBvciB3YXMgZG9uZS4gVGhlcmUgY2FuXG4vLyBiZSBtb3JlIHRoYW4gb25lIHBlciBjb21wb25lbnQuXG5cblxue1xuICB2YXIgZGVidWdDb3VudGVyID0gMTtcbn1cblxuZnVuY3Rpb24gRmliZXJOb2RlKHRhZywga2V5LCBpbnRlcm5hbENvbnRleHRUYWcpIHtcbiAgLy8gSW5zdGFuY2VcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMua2V5ID0ga2V5O1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAgLy8gRmliZXJcbiAgdGhpc1sncmV0dXJuJ10gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG5cbiAgdGhpcy5yZWYgPSBudWxsO1xuXG4gIHRoaXMucGVuZGluZ1Byb3BzID0gbnVsbDtcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG5cbiAgdGhpcy5pbnRlcm5hbENvbnRleHRUYWcgPSBpbnRlcm5hbENvbnRleHRUYWc7XG5cbiAgLy8gRWZmZWN0c1xuICB0aGlzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICB0aGlzLm5leHRFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZmlyc3RFZmZlY3QgPSBudWxsO1xuICB0aGlzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gIHRoaXMuZXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG5cbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICB0aGlzLl9kZWJ1Z0lEID0gZGVidWdDb3VudGVyKys7XG4gICAgdGhpcy5fZGVidWdTb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnT3duZXIgPSBudWxsO1xuICAgIHRoaXMuX2RlYnVnSXNDdXJyZW50bHlUaW1pbmcgPSBmYWxzZTtcbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG52YXIgY3JlYXRlRmliZXIgPSBmdW5jdGlvbiAodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZykge1xuICAvLyAkRmxvd0ZpeE1lOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHJldHVybiAhIShDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbi8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5mdW5jdGlvbiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBjdXJyZW50LmtleSwgY3VycmVudC5pbnRlcm5hbENvbnRleHRUYWcpO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0lEID0gY3VycmVudC5fZGVidWdJRDtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z1NvdXJjZSA9IGN1cnJlbnQuX2RlYnVnU291cmNlO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgPSBjdXJyZW50Ll9kZWJ1Z093bmVyO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuXG4gICAgLy8gVGhlIGVmZmVjdCBsaXN0IGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCA9IG51bGw7XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgLy8gVGhlc2Ugd2lsbCBiZSBvdmVycmlkZGVuIGR1cmluZyB0aGUgcGFyZW50J3MgcmVjb25jaWxpYXRpb25cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIoKSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBOb0NvbnRleHQpO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgb3duZXIgPSBudWxsO1xuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IHZvaWQgMDtcbiAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGUsXG4gICAgICBrZXkgPSBlbGVtZW50LmtleTtcblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICBmaWJlciA9IHNob3VsZENvbnN0cnVjdCh0eXBlKSA/IGNyZWF0ZUZpYmVyKENsYXNzQ29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZykgOiBjcmVhdGVGaWJlcihJbmRldGVybWluYXRlQ29tcG9uZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gICAgZmliZXIudHlwZSA9IHR5cGU7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RDb21wb25lbnQsIGtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgICBmaWJlci50eXBlID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAvLyBDdXJyZW50bHkgYXNzdW1lZCB0byBiZSBhIGNvbnRpbnVhdGlvbiBhbmQgdGhlcmVmb3JlIGlzIGEgZmliZXIgYWxyZWFkeS5cbiAgICAvLyBUT0RPOiBUaGUgeWllbGQgc3lzdGVtIGlzIGN1cnJlbnRseSBicm9rZW4gZm9yIHVwZGF0ZXMgaW4gc29tZSBjYXNlcy5cbiAgICAvLyBUaGUgcmVpZmllZCB5aWVsZCBzdG9yZXMgYSBmaWJlciwgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZmliZXIgdGhhdCBpcztcbiAgICAvLyB0aGUgY3VycmVudCBvciBhIHdvcmtJblByb2dyZXNzPyBXaGVuIHRoZSBjb250aW51YXRpb24gZ2V0cyByZW5kZXJlZCBoZXJlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyBpZiB3ZSBjYW4gcmV1c2UgdGhhdCBmaWJlciBvciBpZiB3ZSBuZWVkIHRvIGNsb25lIGl0LlxuICAgIC8vIFRoZXJlIGlzIHByb2JhYmx5IGEgY2xldmVyIHdheSB0byByZXN0cnVjdHVyZSB0aGlzLlxuICAgIGZpYmVyID0gdHlwZTtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB9IGVsc2Uge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAge1xuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbi5cIjtcbiAgICAgIH1cbiAgICAgIHZhciBvd25lck5hbWUgPSBvd25lciA/IGdldENvbXBvbmVudE5hbWUob3duZXIpIDogbnVsbDtcbiAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhcmlhbnQoZmFsc2UsICdFbGVtZW50IHR5cGUgaXMgaW52YWxpZDogZXhwZWN0ZWQgYSBzdHJpbmcgKGZvciBidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZSA9PSBudWxsID8gdHlwZSA6IHR5cGVvZiB0eXBlLCBpbmZvKTtcbiAgfVxuXG4gIHtcbiAgICBmaWJlci5fZGVidWdTb3VyY2UgPSBlbGVtZW50Ll9zb3VyY2U7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEZyYWdtZW50LCBrZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGVsZW1lbnRzO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgbnVsbCwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gY29udGVudDtcbiAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Ib3N0SW5zdGFuY2VGb3JEZWxldGlvbigpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdENvbXBvbmVudCwgbnVsbCwgTm9Db250ZXh0KTtcbiAgZmliZXIudHlwZSA9ICdERUxFVEVEJztcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoQ2FsbENvbXBvbmVudCwgY2FsbC5rZXksIGludGVybmFsQ29udGV4dFRhZyk7XG4gIGZpYmVyLnR5cGUgPSBjYWxsLmhhbmRsZXI7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNhbGw7XG4gIGZpYmVyLmV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWU7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUmV0dXJuKHJldHVybk5vZGUsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUmV0dXJuQ29tcG9uZW50LCBudWxsLCBpbnRlcm5hbENvbnRleHRUYWcpO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIGludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFBvcnRhbCwgcG9ydGFsLmtleSwgaW50ZXJuYWxDb250ZXh0VGFnKTtcbiAgZmliZXIucGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuIHx8IFtdO1xuICBmaWJlci5leHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLCAvLyBVc2VkIGJ5IHBlcnNpc3RlbnQgdXBkYXRlc1xuICAgIGltcGxlbWVudGF0aW9uOiBwb3J0YWwuaW1wbGVtZW50YXRpb25cbiAgfTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlclJvb3QoY29udGFpbmVySW5mbywgaHlkcmF0ZSkge1xuICAvLyBDeWNsaWMgY29uc3RydWN0aW9uLiBUaGlzIGNoZWF0cyB0aGUgdHlwZSBzeXN0ZW0gcmlnaHQgbm93IGJlY2F1c2VcbiAgLy8gc3RhdGVOb2RlIGlzIGFueS5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIoKTtcbiAgdmFyIHJvb3QgPSB7XG4gICAgY3VycmVudDogdW5pbml0aWFsaXplZEZpYmVyLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lOiBOb1dvcmssXG4gICAgaXNSZWFkeUZvckNvbW1pdDogZmFsc2UsXG4gICAgZmluaXNoZWRXb3JrOiBudWxsLFxuICAgIGNvbnRleHQ6IG51bGwsXG4gICAgcGVuZGluZ0NvbnRleHQ6IG51bGwsXG4gICAgaHlkcmF0ZTogaHlkcmF0ZSxcbiAgICBuZXh0U2NoZWR1bGVkUm9vdDogbnVsbFxuICB9O1xuICB1bmluaXRpYWxpemVkRmliZXIuc3RhdGVOb2RlID0gcm9vdDtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbnZhciBvbkNvbW1pdEZpYmVyUm9vdCA9IG51bGw7XG52YXIgb25Db21taXRGaWJlclVubW91bnQgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGNhdGNoRXJyb3JzKGZuKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhcmcpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKHRydWUgJiYgIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBob29rID0gX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fO1xuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgfVxuICAgIC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIHJlbmRlcmVySUQgPSBob29rLmluamVjdChpbnRlcm5hbHMpO1xuICAgIC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG4gICAgb25Db21taXRGaWJlclJvb3QgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAocm9vdCkge1xuICAgICAgcmV0dXJuIGhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCk7XG4gICAgfSk7XG4gICAgb25Db21taXRGaWJlclVubW91bnQgPSBjYXRjaEVycm9ycyhmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgIHJldHVybiBob29rLm9uQ29tbWl0RmliZXJVbm1vdW50KHJlbmRlcmVySUQsIGZpYmVyKTtcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgLy8gQ2F0Y2ggYWxsIGVycm9ycyBiZWNhdXNlIGl0IGlzIHVuc2FmZSB0byB0aHJvdyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gICAge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IERldlRvb2xzIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfVxuICAvLyBEZXZUb29scyBleGlzdHNcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIG9uQ29tbWl0Um9vdChyb290KSB7XG4gIGlmICh0eXBlb2Ygb25Db21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICBvbkNvbW1pdEZpYmVyUm9vdChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbkNvbW1pdFVubW91bnQoZmliZXIpIHtcbiAgaWYgKHR5cGVvZiBvbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIG9uQ29tbWl0RmliZXJVbm1vdW50KGZpYmVyKTtcbiAgfVxufVxuXG57XG4gIHZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG59XG5cbi8vIENhbGxiYWNrcyBhcmUgbm90IHZhbGlkYXRlZCB1bnRpbCBpbnZvY2F0aW9uXG5cblxuLy8gU2luZ2x5IGxpbmtlZC1saXN0IG9mIHVwZGF0ZXMuIFdoZW4gYW4gdXBkYXRlIGlzIHNjaGVkdWxlZCwgaXQgaXMgYWRkZWQgdG9cbi8vIHRoZSBxdWV1ZSBvZiB0aGUgY3VycmVudCBmaWJlciBhbmQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuIFRoZSB0d28gcXVldWVzXG4vLyBhcmUgc2VwYXJhdGUgYnV0IHRoZXkgc2hhcmUgYSBwZXJzaXN0ZW50IHN0cnVjdHVyZS5cbi8vXG4vLyBEdXJpbmcgcmVjb25jaWxpYXRpb24sIHVwZGF0ZXMgYXJlIHJlbW92ZWQgZnJvbSB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlcixcbi8vIGJ1dCB0aGV5IHJlbWFpbiBvbiB0aGUgY3VycmVudCBmaWJlci4gVGhhdCBlbnN1cmVzIHRoYXQgaWYgYSB3b3JrLWluLXByb2dyZXNzXG4vLyBpcyBhYm9ydGVkLCB0aGUgYWJvcnRlZCB1cGRhdGVzIGFyZSByZWNvdmVyZWQgYnkgY2xvbmluZyBmcm9tIGN1cnJlbnQuXG4vL1xuLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgYWx3YXlzIGEgc3Vic2V0IG9mIHRoZSBjdXJyZW50IHF1ZXVlLlxuLy9cbi8vIFdoZW4gdGhlIHRyZWUgaXMgY29tbWl0dGVkLCB0aGUgd29yay1pbi1wcm9ncmVzcyBiZWNvbWVzIHRoZSBjdXJyZW50LlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZVF1ZXVlKGJhc2VTdGF0ZSkge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBiYXNlU3RhdGUsXG4gICAgZXhwaXJhdGlvblRpbWU6IE5vV29yayxcbiAgICBmaXJzdDogbnVsbCxcbiAgICBsYXN0OiBudWxsLFxuICAgIGNhbGxiYWNrTGlzdDogbnVsbCxcbiAgICBoYXNGb3JjZVVwZGF0ZTogZmFsc2UsXG4gICAgaXNJbml0aWFsaXplZDogZmFsc2VcbiAgfTtcbiAge1xuICAgIHF1ZXVlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBxdWV1ZTtcbn1cblxuZnVuY3Rpb24gaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gQXBwZW5kIHRoZSB1cGRhdGUgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAgaWYgKHF1ZXVlLmxhc3QgPT09IG51bGwpIHtcbiAgICAvLyBRdWV1ZSBpcyBlbXB0eVxuICAgIHF1ZXVlLmZpcnN0ID0gcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBxdWV1ZS5sYXN0Lm5leHQgPSB1cGRhdGU7XG4gICAgcXVldWUubGFzdCA9IHVwZGF0ZTtcbiAgfVxuICBpZiAocXVldWUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBxdWV1ZS5leHBpcmF0aW9uVGltZSA+IHVwZGF0ZS5leHBpcmF0aW9uVGltZSkge1xuICAgIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydFVwZGF0ZUludG9GaWJlcihmaWJlciwgdXBkYXRlKSB7XG4gIC8vIFdlJ2xsIGhhdmUgYXQgbGVhc3Qgb25lIGFuZCBhdCBtb3N0IHR3byBkaXN0aW5jdCB1cGRhdGUgcXVldWVzLlxuICB2YXIgYWx0ZXJuYXRlRmliZXIgPSBmaWJlci5hbHRlcm5hdGU7XG4gIHZhciBxdWV1ZTEgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHF1ZXVlMSA9PT0gbnVsbCkge1xuICAgIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gICAgLy8gSXQgZGVwZW5kcyBvbiB3aGljaCBmaWJlciBpcyB0aGUgbmV4dCBjdXJyZW50LiBJbml0aWFsaXplIHdpdGggYW4gZW1wdHlcbiAgICAvLyBiYXNlIHN0YXRlLCB0aGVuIHNldCB0byB0aGUgbWVtb2l6ZWRTdGF0ZSB3aGVuIHJlbmRlcmluZy4gTm90IHN1cGVyXG4gICAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICAgIHF1ZXVlMSA9IGZpYmVyLnVwZGF0ZVF1ZXVlID0gY3JlYXRlVXBkYXRlUXVldWUobnVsbCk7XG4gIH1cblxuICB2YXIgcXVldWUyID0gdm9pZCAwO1xuICBpZiAoYWx0ZXJuYXRlRmliZXIgIT09IG51bGwpIHtcbiAgICBxdWV1ZTIgPSBhbHRlcm5hdGVGaWJlci51cGRhdGVRdWV1ZTtcbiAgICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgICBxdWV1ZTIgPSBhbHRlcm5hdGVGaWJlci51cGRhdGVRdWV1ZSA9IGNyZWF0ZVVwZGF0ZVF1ZXVlKG51bGwpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBxdWV1ZTIgPSBudWxsO1xuICB9XG4gIHF1ZXVlMiA9IHF1ZXVlMiAhPT0gcXVldWUxID8gcXVldWUyIDogbnVsbDtcblxuICAvLyBXYXJuIGlmIGFuIHVwZGF0ZSBpcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYW4gdXBkYXRlciBmdW5jdGlvbi5cbiAge1xuICAgIGlmICgocXVldWUxLmlzUHJvY2Vzc2luZyB8fCBxdWV1ZTIgIT09IG51bGwgJiYgcXVldWUyLmlzUHJvY2Vzc2luZykgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suJyk7XG4gICAgICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHF1ZXVlLCBhZGQgdGhlIHVwZGF0ZSB0byB0aGF0IHF1ZXVlIGFuZCBleGl0LlxuICBpZiAocXVldWUyID09PSBudWxsKSB7XG4gICAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBJZiBlaXRoZXIgcXVldWUgaXMgZW1wdHksIHdlIG5lZWQgdG8gYWRkIHRvIGJvdGggcXVldWVzLlxuICBpZiAocXVldWUxLmxhc3QgPT09IG51bGwgfHwgcXVldWUyLmxhc3QgPT09IG51bGwpIHtcbiAgICBpbnNlcnRVcGRhdGVJbnRvUXVldWUocXVldWUxLCB1cGRhdGUpO1xuICAgIGluc2VydFVwZGF0ZUludG9RdWV1ZShxdWV1ZTIsIHVwZGF0ZSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gSWYgYm90aCBsaXN0cyBhcmUgbm90IGVtcHR5LCB0aGUgbGFzdCB1cGRhdGUgaXMgdGhlIHNhbWUgZm9yIGJvdGggbGlzdHNcbiAgLy8gYmVjYXVzZSBvZiBzdHJ1Y3R1cmFsIHNoYXJpbmcuIFNvLCB3ZSBzaG91bGQgb25seSBhcHBlbmQgdG8gb25lIG9mXG4gIC8vIHRoZSBsaXN0cy5cbiAgaW5zZXJ0VXBkYXRlSW50b1F1ZXVlKHF1ZXVlMSwgdXBkYXRlKTtcbiAgLy8gQnV0IHdlIHN0aWxsIG5lZWQgdG8gdXBkYXRlIHRoZSBgbGFzdGAgcG9pbnRlciBvZiBxdWV1ZTIuXG4gIHF1ZXVlMi5sYXN0ID0gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRVcGRhdGVFeHBpcmF0aW9uVGltZShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBDbGFzc0NvbXBvbmVudCAmJiBmaWJlci50YWcgIT09IEhvc3RSb290KSB7XG4gICAgcmV0dXJuIE5vV29yaztcbiAgfVxuICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIE5vV29yaztcbiAgfVxuICByZXR1cm4gdXBkYXRlUXVldWUuZXhwaXJhdGlvblRpbWU7XG59XG5cbmZ1bmN0aW9uIGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBwcmV2U3RhdGUsIHByb3BzKSB7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSB1cGRhdGUucGFydGlhbFN0YXRlO1xuICBpZiAodHlwZW9mIHBhcnRpYWxTdGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB1cGRhdGVGbiA9IHBhcnRpYWxTdGF0ZTtcbiAgICByZXR1cm4gdXBkYXRlRm4uY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBwcm9wcyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnRpYWxTdGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudXBkYXRlUXVldWUgPT09IHF1ZXVlKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjcmVhdGUgYSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlLCBieSBjbG9uaW5nIHRoZSBjdXJyZW50IHF1ZXVlLlxuICAgIHZhciBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZXhwaXJhdGlvblRpbWU6IGN1cnJlbnRRdWV1ZS5leHBpcmF0aW9uVGltZSxcbiAgICAgIGZpcnN0OiBjdXJyZW50UXVldWUuZmlyc3QsXG4gICAgICBsYXN0OiBjdXJyZW50UXVldWUubGFzdCxcbiAgICAgIGlzSW5pdGlhbGl6ZWQ6IGN1cnJlbnRRdWV1ZS5pc0luaXRpYWxpemVkLFxuICAgICAgLy8gVGhlc2UgZmllbGRzIGFyZSBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB0aGV5IHdlcmUgYWxyZWFkeSBjb21taXR0ZWQuXG4gICAgICAvLyBSZXNldCB0aGVtLlxuICAgICAgY2FsbGJhY2tMaXN0OiBudWxsLFxuICAgICAgaGFzRm9yY2VVcGRhdGU6IGZhbHNlXG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICAvLyBTZXQgdGhpcyBmbGFnIHNvIHdlIGNhbiB3YXJuIGlmIHNldFN0YXRlIGlzIGNhbGxlZCBpbnNpZGUgdGhlIHVwZGF0ZVxuICAgIC8vIGZ1bmN0aW9uIG9mIGFub3RoZXIgc2V0U3RhdGUuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFJlc2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLiBJZiB3ZSBza2lwIG92ZXIgYW55IHVwZGF0ZXMsIHdlJ2xsXG4gIC8vIGluY3JlYXNlIHRoaXMgYWNjb3JkaW5nbHkuXG4gIHF1ZXVlLmV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRPRE86IFdlIGRvbid0IGtub3cgd2hhdCB0aGUgYmFzZSBzdGF0ZSB3aWxsIGJlIHVudGlsIHdlIGJlZ2luIHdvcmsuXG4gIC8vIEl0IGRlcGVuZHMgb24gd2hpY2ggZmliZXIgaXMgdGhlIG5leHQgY3VycmVudC4gSW5pdGlhbGl6ZSB3aXRoIGFuIGVtcHR5XG4gIC8vIGJhc2Ugc3RhdGUsIHRoZW4gc2V0IHRvIHRoZSBtZW1vaXplZFN0YXRlIHdoZW4gcmVuZGVyaW5nLiBOb3Qgc3VwZXJcbiAgLy8gaGFwcHkgd2l0aCB0aGlzIGFwcHJvYWNoLlxuICB2YXIgc3RhdGUgPSB2b2lkIDA7XG4gIGlmIChxdWV1ZS5pc0luaXRpYWxpemVkKSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgIHF1ZXVlLmlzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG4gIHZhciBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgdmFyIHVwZGF0ZSA9IHF1ZXVlLmZpcnN0O1xuICB2YXIgZGlkU2tpcCA9IGZhbHNlO1xuICB3aGlsZSAodXBkYXRlICE9PSBudWxsKSB7XG4gICAgdmFyIHVwZGF0ZUV4cGlyYXRpb25UaW1lID0gdXBkYXRlLmV4cGlyYXRpb25UaW1lO1xuICAgIGlmICh1cGRhdGVFeHBpcmF0aW9uVGltZSA+IHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIG5vdCBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuIFNraXAgaXQuXG4gICAgICB2YXIgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBxdWV1ZS5leHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID4gdXBkYXRlRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lLlxuICAgICAgICBxdWV1ZS5leHBpcmF0aW9uVGltZSA9IHVwZGF0ZUV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgICAgaWYgKCFkaWRTa2lwKSB7XG4gICAgICAgIGRpZFNraXAgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5iYXNlU3RhdGUgPSBzdGF0ZTtcbiAgICAgIH1cbiAgICAgIC8vIENvbnRpbnVlIHRvIHRoZSBuZXh0IHVwZGF0ZS5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG5cbiAgICAvLyBJZiBubyBwcmV2aW91cyB1cGRhdGVzIHdlcmUgc2tpcHBlZCwgZHJvcCB0aGlzIHVwZGF0ZSBmcm9tIHRoZSBxdWV1ZSBieVxuICAgIC8vIGFkdmFuY2luZyB0aGUgaGVhZCBvZiB0aGUgbGlzdC5cbiAgICBpZiAoIWRpZFNraXApIHtcbiAgICAgIHF1ZXVlLmZpcnN0ID0gdXBkYXRlLm5leHQ7XG4gICAgICBpZiAocXVldWUuZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgcXVldWUubGFzdCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvY2VzcyB0aGUgdXBkYXRlXG4gICAgdmFyIF9wYXJ0aWFsU3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHVwZGF0ZS5pc1JlcGxhY2UpIHtcbiAgICAgIHN0YXRlID0gZ2V0U3RhdGVGcm9tVXBkYXRlKHVwZGF0ZSwgaW5zdGFuY2UsIHN0YXRlLCBwcm9wcyk7XG4gICAgICBkb250TXV0YXRlUHJldlN0YXRlID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgX3BhcnRpYWxTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh1cGRhdGUsIGluc3RhbmNlLCBzdGF0ZSwgcHJvcHMpO1xuICAgICAgaWYgKF9wYXJ0aWFsU3RhdGUpIHtcbiAgICAgICAgaWYgKGRvbnRNdXRhdGVQcmV2U3RhdGUpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lOiBJZGsgaG93IHRvIHR5cGUgdGhpcyBwcm9wZXJseS5cbiAgICAgICAgICBzdGF0ZSA9IF9hc3NpZ24oe30sIHN0YXRlLCBfcGFydGlhbFN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdGF0ZSA9IF9hc3NpZ24oc3RhdGUsIF9wYXJ0aWFsU3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIGRvbnRNdXRhdGVQcmV2U3RhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHVwZGF0ZS5pc0ZvcmNlZCkge1xuICAgICAgcXVldWUuaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodXBkYXRlLmNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAvLyBBcHBlbmQgdG8gbGlzdCBvZiBjYWxsYmFja3MuXG4gICAgICB2YXIgX2NhbGxiYWNrTGlzdCA9IHF1ZXVlLmNhbGxiYWNrTGlzdDtcbiAgICAgIGlmIChfY2FsbGJhY2tMaXN0ID09PSBudWxsKSB7XG4gICAgICAgIF9jYWxsYmFja0xpc3QgPSBxdWV1ZS5jYWxsYmFja0xpc3QgPSBbXTtcbiAgICAgIH1cbiAgICAgIF9jYWxsYmFja0xpc3QucHVzaCh1cGRhdGUpO1xuICAgIH1cbiAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgfVxuXG4gIGlmIChxdWV1ZS5jYWxsYmFja0xpc3QgIT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gQ2FsbGJhY2s7XG4gIH0gZWxzZSBpZiAocXVldWUuZmlyc3QgPT09IG51bGwgJiYgIXF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSB7XG4gICAgLy8gVGhlIHF1ZXVlIGlzIGVtcHR5LiBXZSBjYW4gcmVzZXQgaXQuXG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFkaWRTa2lwKSB7XG4gICAgZGlkU2tpcCA9IHRydWU7XG4gICAgcXVldWUuYmFzZVN0YXRlID0gc3RhdGU7XG4gIH1cblxuICB7XG4gICAgLy8gTm8gbG9uZ2VyIHByb2Nlc3NpbmcuXG4gICAgcXVldWUuaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gc3RhdGU7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyhxdWV1ZSwgY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2tMaXN0ID0gcXVldWUuY2FsbGJhY2tMaXN0O1xuICBpZiAoY2FsbGJhY2tMaXN0ID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIFNldCB0aGUgbGlzdCB0byBudWxsIHRvIG1ha2Ugc3VyZSB0aGV5IGRvbid0IGdldCBjYWxsZWQgbW9yZSB0aGFuIG9uY2UuXG4gIHF1ZXVlLmNhbGxiYWNrTGlzdCA9IG51bGw7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHVwZGF0ZSA9IGNhbGxiYWNrTGlzdFtpXTtcbiAgICB2YXIgX2NhbGxiYWNrID0gdXBkYXRlLmNhbGxiYWNrO1xuICAgIC8vIFRoaXMgdXBkYXRlIG1pZ2h0IGJlIHByb2Nlc3NlZCBhZ2Fpbi4gQ2xlYXIgdGhlIGNhbGxiYWNrIHNvIGl0J3Mgb25seVxuICAgIC8vIGNhbGxlZCBvbmNlLlxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IG51bGw7XG4gICAgISh0eXBlb2YgX2NhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcycsIF9jYWxsYmFjaykgOiB2b2lkIDA7XG4gICAgX2NhbGxiYWNrLmNhbGwoY29udGV4dCk7XG4gIH1cbn1cblxudmFyIGZha2VJbnRlcm5hbEluc3RhbmNlID0ge307XG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IHt9O1xuXG4gIHZhciB3YXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FsbGJhY2ssIGNhbGxlck5hbWUpIHtcbiAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJyVzKC4uLik6IEV4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsZXJOYW1lLCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy8gVGhpcyBpcyBzbyBncm9zcyBidXQgaXQncyBhdCBsZWFzdCBub24tY3JpdGljYWwgYW5kIGNhbiBiZSByZW1vdmVkIGlmXG4gIC8vIGl0IGNhdXNlcyBwcm9ibGVtcy4gVGhpcyBpcyBtZWFudCB0byBnaXZlIGEgbmljZXIgZXJyb3IgbWVzc2FnZSBmb3JcbiAgLy8gUmVhY3RET00xNS51bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihyZWFjdERPTTE2Q29tcG9uZW50LFxuICAvLyAuLi4pKSB3aGljaCBvdGhlcndpc2UgdGhyb3dzIGEgXCJfcHJvY2Vzc0NoaWxkQ29udGV4dCBpcyBub3QgYSBmdW5jdGlvblwiXG4gIC8vIGV4Y2VwdGlvbi5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSBtZWFucyB5b3UgaGF2ZSBtdWx0aXBsZSBjb3BpZXMgb2YgUmVhY3QgYW5kIGFyZSBhdHRlbXB0aW5nIHRvIG5lc3QgYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzblxcJ3Qgc3VwcG9ydGVkLiBUcnkgdG8gbWFrZSBzdXJlIHlvdSBoYXZlIG9ubHkgb25lIGNvcHkgb2YgUmVhY3QgKGFuZCBpZGVhbGx5LCBzd2l0Y2ggdG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxudmFyIFJlYWN0RmliZXJDbGFzc0NvbXBvbmVudCA9IGZ1bmN0aW9uIChzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsIG1lbW9pemVQcm9wcywgbWVtb2l6ZVN0YXRlKSB7XG4gIC8vIENsYXNzIGNvbXBvbmVudCBzdGF0ZSB1cGRhdGVyXG4gIHZhciB1cGRhdGVyID0ge1xuICAgIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICAgIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3RhbmNlLCBwYXJ0aWFsU3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmliZXIgPSBnZXQoaW5zdGFuY2UpO1xuICAgICAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2ssICdzZXRTdGF0ZScpO1xuICAgICAgfVxuICAgICAgdmFyIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihmaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgICBleHBpcmF0aW9uVGltZTogZXhwaXJhdGlvblRpbWUsXG4gICAgICAgIHBhcnRpYWxTdGF0ZTogcGFydGlhbFN0YXRlLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSxcbiAgICBlbnF1ZXVlUmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAoaW5zdGFuY2UsIHN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgdmFyIGZpYmVyID0gZ2V0KGluc3RhbmNlKTtcbiAgICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrLCAncmVwbGFjZVN0YXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBzdGF0ZSxcbiAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICBpc1JlcGxhY2U6IHRydWUsXG4gICAgICAgIGlzRm9yY2VkOiBmYWxzZSxcbiAgICAgICAgbmV4dENhbGxiYWNrOiBudWxsLFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaW5zZXJ0VXBkYXRlSW50b0ZpYmVyKGZpYmVyLCB1cGRhdGUpO1xuICAgICAgc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfSxcbiAgICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAgIHZhciBmaWJlciA9IGdldChpbnN0YW5jZSk7XG4gICAgICBjYWxsYmFjayA9IGNhbGxiYWNrID09PSB1bmRlZmluZWQgPyBudWxsIDogY2FsbGJhY2s7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaywgJ2ZvcmNlVXBkYXRlJyk7XG4gICAgICB9XG4gICAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyKGZpYmVyKTtcbiAgICAgIHZhciB1cGRhdGUgPSB7XG4gICAgICAgIGV4cGlyYXRpb25UaW1lOiBleHBpcmF0aW9uVGltZSxcbiAgICAgICAgcGFydGlhbFN0YXRlOiBudWxsLFxuICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICAgIGlzRm9yY2VkOiB0cnVlLFxuICAgICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICAgIG5leHQ6IG51bGxcbiAgICAgIH07XG4gICAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoZmliZXIsIHVwZGF0ZSk7XG4gICAgICBzY2hlZHVsZVdvcmsoZmliZXIsIGV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXdDb250ZXh0KSB7XG4gICAgaWYgKG9sZFByb3BzID09PSBudWxsIHx8IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlLmhhc0ZvcmNlVXBkYXRlKSB7XG4gICAgICAvLyBJZiB0aGUgd29ya0luUHJvZ3Jlc3MgYWxyZWFkeSBoYXMgYW4gVXBkYXRlIGVmZmVjdCwgcmV0dXJuIHRydWVcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScpO1xuICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgICAge1xuICAgICAgICB3YXJuaW5nKHNob3VsZFVwZGF0ZSAhPT0gdW5kZWZpbmVkLCAnJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcykgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQpIHtcbiAgICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIHJlbmRlclByZXNlbnQgPSBpbnN0YW5jZS5yZW5kZXI7XG5cbiAgICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlIHJldHVybmVkIGNvbXBvbmVudCAnICsgJ2luc3RhbmNlOiB5b3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIGRlZmluZSBgcmVuZGVyYC4nLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbm9HZXRJbml0aWFsU3RhdGVPbkVTNiA9ICFpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgfHwgaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkIHx8IGluc3RhbmNlLnN0YXRlO1xuICAgICAgd2FybmluZyhub0dldEluaXRpYWxTdGF0ZU9uRVM2LCAnZ2V0SW5pdGlhbFN0YXRlIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBkZWZpbmUgYSBzdGF0ZSBwcm9wZXJ0eSBpbnN0ZWFkPycsIG5hbWUpO1xuICAgICAgdmFyIG5vR2V0RGVmYXVsdFByb3BzT25FUzYgPSAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzIHx8IGluc3RhbmNlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZDtcbiAgICAgIHdhcm5pbmcobm9HZXREZWZhdWx0UHJvcHNPbkVTNiwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgdmFyIG5vSW5zdGFuY2VQcm9wVHlwZXMgPSAhaW5zdGFuY2UucHJvcFR5cGVzO1xuICAgICAgd2FybmluZyhub0luc3RhbmNlUHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB2YXIgbm9JbnN0YW5jZUNvbnRleHRUeXBlcyA9ICFpbnN0YW5jZS5jb250ZXh0VHlwZXM7XG4gICAgICB3YXJuaW5nKG5vSW5zdGFuY2VDb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIHZhciBub0NvbXBvbmVudFNob3VsZFVwZGF0ZSA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50U2hvdWxkVXBkYXRlLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgICBpZiAodHlwZS5wcm90b3R5cGUgJiYgdHlwZS5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkuICcgKyAnc2hvdWxkQ29tcG9uZW50VXBkYXRlIHNob3VsZCBub3QgYmUgdXNlZCB3aGVuIGV4dGVuZGluZyBSZWFjdC5QdXJlQ29tcG9uZW50LiAnICsgJ1BsZWFzZSBleHRlbmQgUmVhY3QuQ29tcG9uZW50IGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSBpcyB1c2VkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRVbm1vdW50ID0gdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgIT09ICdmdW5jdGlvbic7XG4gICAgICB3YXJuaW5nKG5vQ29tcG9uZW50RGlkVW5tb3VudCwgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgbmFtZSk7XG4gICAgICB2YXIgbm9Db21wb25lbnREaWRSZWNlaXZlUHJvcHMgPSB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudERpZFJlY2VpdmVQcm9wcywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgICAgdmFyIG5vQ29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nO1xuICAgICAgd2FybmluZyhub0NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgICAgdmFyIGhhc011dGF0ZWRQcm9wcyA9IGluc3RhbmNlLnByb3BzICE9PSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICB3YXJuaW5nKGluc3RhbmNlLnByb3BzID09PSB1bmRlZmluZWQgfHwgIWhhc011dGF0ZWRQcm9wcywgJyVzKC4uLik6IFdoZW4gY2FsbGluZyBzdXBlcigpIGluIGAlc2AsIG1ha2Ugc3VyZSB0byBwYXNzICcgKyBcInVwIHRoZSBzYW1lIHByb3BzIHRoYXQgeW91ciBjb21wb25lbnQncyBjb25zdHJ1Y3RvciB3YXMgcGFzc2VkLlwiLCBuYW1lLCBuYW1lKTtcbiAgICAgIHZhciBub0luc3RhbmNlRGVmYXVsdFByb3BzID0gIWluc3RhbmNlLmRlZmF1bHRQcm9wcztcbiAgICAgIHdhcm5pbmcobm9JbnN0YW5jZURlZmF1bHRQcm9wcywgJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuICAgIGlmIChzdGF0ZSAmJiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KHN0YXRlKSkpIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICEodHlwZW9mIHdvcmtJblByb2dyZXNzLnR5cGUuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IGludmFyaWFudChmYWxzZSwgJyVzLmdldENoaWxkQ29udGV4dCgpOiBjaGlsZENvbnRleHRUeXBlcyBtdXN0IGJlIGRlZmluZWQgaW4gb3JkZXIgdG8gdXNlIGdldENoaWxkQ29udGV4dCgpLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKSA6IHZvaWQgMDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgaW5zdGFuY2UucHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgICBpbnN0YW5jZS51cGRhdGVyID0gdXBkYXRlcjtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcbiAgICAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG4gICAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAge1xuICAgICAgaW5zdGFuY2UuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSA9IGZha2VJbnRlcm5hbEluc3RhbmNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHByb3BzKSB7XG4gICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZWVkc0NvbnRleHQgPSBpc0NvbnRleHRDb25zdW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgdmFyIGNvbnRleHQgPSBuZWVkc0NvbnRleHQgPyBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQpIDogZW1wdHlPYmplY3Q7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpO1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuICAgIC8vIFJlYWN0RmliZXJDb250ZXh0IHVzdWFsbHkgdXBkYXRlcyB0aGlzIGNhY2hlIGJ1dCBjYW4ndCBmb3IgbmV3bHktY3JlYXRlZCBpbnN0YW5jZXMuXG4gICAgaWYgKG5lZWRzQ29udGV4dCkge1xuICAgICAgY2FjaGVDb250ZXh0KHdvcmtJblByb2dyZXNzLCB1bm1hc2tlZENvbnRleHQsIGNvbnRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gICAgc3RhcnRQaGFzZVRpbWVyKHdvcmtJblByb2dyZXNzLCAnY29tcG9uZW50V2lsbE1vdW50Jyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG5cbiAgICBzdG9wUGhhc2VUaW1lcigpO1xuXG4gICAgaWYgKG9sZFN0YXRlICE9PSBpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAge1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWUod29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgIH1cbiAgICAgIHVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcbiAgICBzdGFydFBoYXNlVGltZXIod29ya0luUHJvZ3Jlc3MsICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyk7XG4gICAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgc3RvcFBoYXNlVGltZXIoKTtcblxuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50JztcbiAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB1cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgICB9XG4gIH1cblxuICAvLyBJbnZva2VzIHRoZSBtb3VudCBsaWZlLWN5Y2xlcyBvbiBhIHByZXZpb3VzbHkgbmV2ZXIgcmVuZGVyZWQgaW5zdGFuY2UuXG4gIGZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIHtcbiAgICAgIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHZhciBzdGF0ZSA9IGluc3RhbmNlLnN0YXRlIHx8IG51bGw7XG5cbiAgICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgIXByb3BzID8gaW52YXJpYW50KGZhbHNlLCAnVGhlcmUgbXVzdCBiZSBwZW5kaW5nIHByb3BzIGZvciBhbiBpbml0aWFsIG1vdW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuXG4gICAgdmFyIHVubWFza2VkQ29udGV4dCA9IGdldFVubWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpbnN0YW5jZS5wcm9wcyA9IHByb3BzO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlO1xuICAgIGluc3RhbmNlLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgd29ya0luUHJvZ3Jlc3MudHlwZSAhPSBudWxsICYmIHdvcmtJblByb2dyZXNzLnR5cGUucHJvdG90eXBlICE9IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudHlwZS5wcm90b3R5cGUudW5zdGFibGVfaXNBc3luY1JlYWN0Q29tcG9uZW50ID09PSB0cnVlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5pbnRlcm5hbENvbnRleHRUYWcgfD0gQXN5bmNVcGRhdGVzO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgICAvLyBJZiB3ZSBoYWQgYWRkaXRpb25hbCBzdGF0ZSB1cGRhdGVzIGR1cmluZyB0aGlzIGxpZmUtY3ljbGUsIGxldCdzXG4gICAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgaW5zdGFuY2Uuc3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSwgcHJvcHMsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICB9XG4gIH1cblxuICAvLyBDYWxsZWQgb24gYSBwcmVleGlzdGluZyBjbGFzcyBpbnN0YW5jZS4gUmV0dXJucyBmYWxzZSBpZiBhIHJlc3VtZWQgcmVuZGVyXG4gIC8vIGNvdWxkIGJlIHJldXNlZC5cbiAgLy8gZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKFxuICAvLyAgIHdvcmtJblByb2dyZXNzOiBGaWJlcixcbiAgLy8gICBwcmlvcml0eUxldmVsOiBQcmlvcml0eUxldmVsLFxuICAvLyApOiBib29sZWFuIHtcbiAgLy8gICBjb25zdCBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgLy8gICByZXNldElucHV0UG9pbnRlcnMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcblxuICAvLyAgIGxldCBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIC8vICAgbGV0IG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAvLyAgIGlmICghbmV3UHJvcHMpIHtcbiAgLy8gICAgIC8vIElmIHRoZXJlIGlzbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAvLyAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gIC8vICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIC8vICAgICBpbnZhcmlhbnQoXG4gIC8vICAgICAgIG5ld1Byb3BzICE9IG51bGwsXG4gIC8vICAgICAgICdUaGVyZSBzaG91bGQgYWx3YXlzIGJlIHBlbmRpbmcgb3IgbWVtb2l6ZWQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgJyArXG4gIC8vICAgICAgICAgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicsXG4gIC8vICAgICApO1xuICAvLyAgIH1cbiAgLy8gICBjb25zdCBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAvLyAgIGNvbnN0IG5ld0NvbnRleHQgPSBnZXRNYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCBuZXdVbm1hc2tlZENvbnRleHQpO1xuXG4gIC8vICAgY29uc3Qgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIC8vICAgY29uc3Qgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiZcbiAgLy8gICAgIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV3Q29udGV4dClcbiAgLy8gICApIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgIG5ld1Byb3BzLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUgYmVmb3JlIGNhbGxpbmcgc2hvdWxkQ29tcG9uZW50VXBkYXRlXG4gIC8vICAgY29uc3QgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgLy8gICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgIG5ld1N0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgdXBkYXRlUXVldWUsXG4gIC8vICAgICAgIGluc3RhbmNlLFxuICAvLyAgICAgICBuZXdTdGF0ZSxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHByaW9yaXR5TGV2ZWwsXG4gIC8vICAgICApO1xuICAvLyAgIH1cblxuICAvLyAgIC8vIFRPRE86IFNob3VsZCB3ZSBkZWFsIHdpdGggYSBzZXRTdGF0ZSB0aGF0IGhhcHBlbmVkIGFmdGVyIHRoZSBsYXN0XG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50IGFuZCBiZWZvcmUgdGhpcyBjb21wb25lbnRXaWxsTW91bnQ/IFByb2JhYmx5XG4gIC8vICAgLy8gdW5zdXBwb3J0ZWQgYW55d2F5LlxuXG4gIC8vICAgaWYgKFxuICAvLyAgICAgIWNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKFxuICAvLyAgICAgICB3b3JrSW5Qcm9ncmVzcyxcbiAgLy8gICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyxcbiAgLy8gICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUsXG4gIC8vICAgICAgIG5ld1N0YXRlLFxuICAvLyAgICAgICBuZXdDb250ZXh0LFxuICAvLyAgICAgKVxuICAvLyAgICkge1xuICAvLyAgICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyAgICAgLy8gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LlxuICAvLyAgICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIC8vICAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcbiAgLy8gICAgIHJldHVybiBmYWxzZTtcbiAgLy8gICB9XG5cbiAgLy8gICAvLyBVcGRhdGUgdGhlIGlucHV0IHBvaW50ZXJzIG5vdyBzbyB0aGF0IHRoZXkgYXJlIGNvcnJlY3Qgd2hlbiB3ZSBjYWxsXG4gIC8vICAgLy8gY29tcG9uZW50V2lsbE1vdW50XG4gIC8vICAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgLy8gICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICAvLyAgIGluc3RhbmNlLmNvbnRleHQgPSBuZXdDb250ZXh0O1xuXG4gIC8vICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgLy8gICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudCBtYXkgaGF2ZSBjYWxsZWQgc2V0U3RhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgLy8gICAgIGNvbnN0IG5ld1VwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIC8vICAgICBpZiAobmV3VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgLy8gICAgICAgbmV3U3RhdGUgPSBwcm9jZXNzVXBkYXRlUXVldWUoXG4gIC8vICAgICAgICAgd29ya0luUHJvZ3Jlc3MsXG4gIC8vICAgICAgICAgbmV3VXBkYXRlUXVldWUsXG4gIC8vICAgICAgICAgaW5zdGFuY2UsXG4gIC8vICAgICAgICAgbmV3U3RhdGUsXG4gIC8vICAgICAgICAgbmV3UHJvcHMsXG4gIC8vICAgICAgICAgcHJpb3JpdHlMZXZlbCxcbiAgLy8gICAgICAgKTtcbiAgLy8gICAgIH1cbiAgLy8gICB9XG5cbiAgLy8gICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gVXBkYXRlO1xuICAvLyAgIH1cblxuICAvLyAgIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG5cbiAgLy8gICByZXR1cm4gdHJ1ZTtcbiAgLy8gfVxuXG4gIC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIHJlc2V0SW5wdXRQb2ludGVycyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuXG4gICAgdmFyIG9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlbid0IGFueSBuZXcgcHJvcHMsIHRoZW4gd2UnbGwgcmV1c2UgdGhlIG1lbW9pemVkIHByb3BzLlxuICAgICAgLy8gVGhpcyBjb3VsZCBiZSBmcm9tIGFscmVhZHkgY29tcGxldGVkIHdvcmsuXG4gICAgICBuZXdQcm9wcyA9IG9sZFByb3BzO1xuICAgICAgIShuZXdQcm9wcyAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIHNob3VsZCBhbHdheXMgYmUgcGVuZGluZyBvciBtZW1vaXplZCBwcm9wcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB9XG4gICAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICAgIHZhciBuZXdVbm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBuZXdDb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgbmV3VW5tYXNrZWRDb250ZXh0KTtcblxuICAgIC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgICAvLyBldmVyIHRoZSBwcmV2aW91c2x5IGF0dGVtcHRlZCB0byByZW5kZXIgLSBub3QgdGhlIFwiY3VycmVudFwiLiBIb3dldmVyLFxuICAgIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXdDb250ZXh0KSkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV3Q29udGV4dCk7XG4gICAgfVxuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV4dCBzdGF0ZSB1c2luZyB0aGUgbWVtb2l6ZWQgc3RhdGUgYW5kIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAvLyBUT0RPOiBQcmV2aW91cyBzdGF0ZSBjYW4gYmUgbnVsbC5cbiAgICB2YXIgbmV3U3RhdGUgPSB2b2lkIDA7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBuZXdTdGF0ZSA9IHByb2Nlc3NVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUsIGluc3RhbmNlLCBuZXdQcm9wcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdTdGF0ZSA9IG9sZFN0YXRlO1xuICAgIH1cblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMgJiYgb2xkU3RhdGUgPT09IG5ld1N0YXRlICYmICFoYXNDb250ZXh0Q2hhbmdlZCgpICYmICEod29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUuaGFzRm9yY2VVcGRhdGUpKSB7XG4gICAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpZiAob2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuXG4gICAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHN0YXJ0UGhhc2VUaW1lcih3b3JrSW5Qcm9ncmVzcywgJ2NvbXBvbmVudFdpbGxVcGRhdGUnKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5ld0NvbnRleHQpO1xuICAgICAgICBzdG9wUGhhc2VUaW1lcigpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgICAgLy8gbWVtb2l6ZWQgcHJvcHMvc3RhdGUgdG8gaW5kaWNhdGUgdGhhdCB0aGlzIHdvcmsgY2FuIGJlIHJldXNlZC5cbiAgICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMpO1xuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBuZXdTdGF0ZSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAgIC8vIGlmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5zIGZhbHNlLlxuICAgIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gbmV3Q29udGV4dDtcblxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGFkb3B0Q2xhc3NJbnN0YW5jZTogYWRvcHRDbGFzc0luc3RhbmNlLFxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2U6IGNvbnN0cnVjdENsYXNzSW5zdGFuY2UsXG4gICAgbW91bnRDbGFzc0luc3RhbmNlOiBtb3VudENsYXNzSW5zdGFuY2UsXG4gICAgLy8gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlLFxuICAgIHVwZGF0ZUNsYXNzSW5zdGFuY2U6IHVwZGF0ZUNsYXNzSW5zdGFuY2VcbiAgfTtcbn07XG5cbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIHNwZWNpYWwgUmVhY3QgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5wb3J0YWwnKSB8fCAweGVhY2E7XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLFxuLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cblxue1xuICB2YXIgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICAvKipcbiAgICogV2FybiBpZiB0aGVyZSdzIG5vIGtleSBleHBsaWNpdGx5IHNldCBvbiBkeW5hbWljIGFycmF5cyBvZiBjaGlsZHJlbiBvclxuICAgKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAgICogdXBkYXRlcy5cbiAgICovXG4gIHZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgdmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyA9IHt9O1xuXG4gIHZhciB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgISh0eXBlb2YgY2hpbGQuX3N0b3JlID09PSAnb2JqZWN0JykgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdCBDb21wb25lbnQgaW4gd2FybkZvck1pc3NpbmdLZXkgc2hvdWxkIGhhdmUgYSBfc3RvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgY2hpbGQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG5cbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICdFYWNoIGNoaWxkIGluIGFuIGFycmF5IG9yIGl0ZXJhdG9yIHNob3VsZCBoYXZlIGEgdW5pcXVlICcgKyAnXCJrZXlcIiBwcm9wLiBTZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC13YXJuaW5nLWtleXMgZm9yICcgKyAnbW9yZSBpbmZvcm1hdGlvbi4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7XG5cbiAgICB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSAnICsgJ1wia2V5XCIgcHJvcC4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1rZXlzIGZvciAnICsgJ21vcmUgaW5mb3JtYXRpb24uJXMnLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSk7XG4gIH07XG59XG5cbnZhciBpc0FycmF5JDEgPSBBcnJheS5pc0FycmF5O1xuXG52YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuIElmIHRoZXJlIGlzIG5vIG5hdGl2ZSBTeW1ib2xcbi8vIG5vciBwb2x5ZmlsbCwgdGhlbiBhIHBsYWluIG51bWJlciBpcyB1c2VkIGZvciBwZXJmb3JtYW5jZS5cbnZhciBSRUFDVF9FTEVNRU5UX1RZUEU7XG52YXIgUkVBQ1RfQ0FMTF9UWVBFO1xudmFyIFJFQUNUX1JFVFVSTl9UWVBFO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEU7XG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2xbJ2ZvciddKSB7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LmVsZW1lbnQnKTtcbiAgUkVBQ1RfQ0FMTF9UWVBFID0gU3ltYm9sWydmb3InXSgncmVhY3QuY2FsbCcpO1xuICBSRUFDVF9SRVRVUk5fVFlQRSA9IFN5bWJvbFsnZm9yJ10oJ3JlYWN0LnJldHVybicpO1xuICBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sWydmb3InXSgncmVhY3QuZnJhZ21lbnQnKTtcbn0gZWxzZSB7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbiAgUkVBQ1RfQ0FMTF9UWVBFID0gMHhlYWM4O1xuICBSRUFDVF9SRVRVUk5fVFlQRSA9IDB4ZWFjOTtcbiAgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IDB4ZWFjYjtcbn1cblxuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBpdGVyYXRvckZuID0gSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcbiAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvZXJjZVJlZihjdXJyZW50LCBlbGVtZW50KSB7XG4gIHZhciBtaXhlZFJlZiA9IGVsZW1lbnQucmVmO1xuICBpZiAobWl4ZWRSZWYgIT09IG51bGwgJiYgdHlwZW9mIG1peGVkUmVmICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGVsZW1lbnQuX293bmVyKSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBpbnN0ID0gdm9pZCAwO1xuICAgICAgaWYgKG93bmVyKSB7XG4gICAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICAgICEob3duZXJGaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSA/IGludmFyaWFudChmYWxzZSwgJ1N0YXRlbGVzcyBmdW5jdGlvbiBjb21wb25lbnRzIGNhbm5vdCBoYXZlIHJlZnMuJykgOiB2b2lkIDA7XG4gICAgICAgIGluc3QgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcbiAgICAgIH1cbiAgICAgICFpbnN0ID8gaW52YXJpYW50KGZhbHNlLCAnTWlzc2luZyBvd25lciBmb3Igc3RyaW5nIHJlZiAlcy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgICB2YXIgc3RyaW5nUmVmID0gJycgKyBtaXhlZFJlZjtcbiAgICAgIC8vIENoZWNrIGlmIHByZXZpb3VzIHN0cmluZyByZWYgbWF0Y2hlcyBuZXcgc3RyaW5nIHJlZlxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwgJiYgY3VycmVudC5yZWYuX3N0cmluZ1JlZiA9PT0gc3RyaW5nUmVmKSB7XG4gICAgICAgIHJldHVybiBjdXJyZW50LnJlZjtcbiAgICAgIH1cbiAgICAgIHZhciByZWYgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGRlbGV0ZSByZWZzW3N0cmluZ1JlZl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmc1tzdHJpbmdSZWZdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWYuX3N0cmluZ1JlZiA9IHN0cmluZ1JlZjtcbiAgICAgIHJldHVybiByZWY7XG4gICAgfSBlbHNlIHtcbiAgICAgICEodHlwZW9mIG1peGVkUmVmID09PSAnc3RyaW5nJykgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZy4nKSA6IHZvaWQgMDtcbiAgICAgICFlbGVtZW50Ll9vd25lciA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgcmVmIHdhcyBzcGVjaWZpZWQgYXMgYSBzdHJpbmcgKCVzKSBidXQgbm8gb3duZXIgd2FzIHNldC4gWW91IG1heSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQuIChkZXRhaWxzOiBodHRwczovL2ZiLm1lL3JlYWN0LXJlZnMtbXVzdC1oYXZlLW93bmVyKS4nLCBtaXhlZFJlZikgOiB2b2lkIDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaXhlZFJlZjtcbn1cblxuZnVuY3Rpb24gdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCkge1xuICBpZiAocmV0dXJuRmliZXIudHlwZSAhPT0gJ3RleHRhcmVhJykge1xuICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuICAgIHtcbiAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nICsgKGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbiAgICB9XG4gICAgaW52YXJpYW50KGZhbHNlLCAnT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiAlcykuJXMnLCBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBuZXdDaGlsZCwgYWRkZW5kdW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkZ1bmN0aW9uVHlwZSgpIHtcbiAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiBhIENvbXBvbmVudCBpbnN0ZWFkIG9mIDxDb21wb25lbnQgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuJyArIChnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDEoKSB8fCAnJyk7XG5cbiAgaWYgKG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgIHJldHVybjtcbiAgfVxuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbY3VycmVudENvbXBvbmVudEVycm9ySW5mb10gPSB0cnVlO1xuXG4gIHdhcm5pbmcoZmFsc2UsICdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuIGEgQ29tcG9uZW50IGluc3RlYWQgb2YgPENvbXBvbmVudCAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpIHx8ICcnKTtcbn1cblxuLy8gVGhpcyB3cmFwcGVyIGZ1bmN0aW9uIGV4aXN0cyBiZWNhdXNlIEkgZXhwZWN0IHRvIGNsb25lIHRoZSBjb2RlIGluIGVhY2ggcGF0aFxuLy8gdG8gYmUgYWJsZSB0byBvcHRpbWl6ZSBlYWNoIHBhdGggaW5kaXZpZHVhbGx5IGJ5IGJyYW5jaGluZyBlYXJseS4gVGhpcyBuZWVkc1xuLy8gYSBjb21waWxlciBvciB3ZSBjYW4gZG8gaXQgbWFudWFsbHkuIEhlbHBlcnMgdGhhdCBkb24ndCBuZWVkIHRoaXMgYnJhbmNoaW5nXG4vLyBsaXZlIG91dHNpZGUgb2YgdGhpcyBmdW5jdGlvbi5cbmZ1bmN0aW9uIENoaWxkUmVjb25jaWxlcihzaG91bGRDbG9uZSwgc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICBmdW5jdGlvbiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFzaG91bGRDbG9uZSkge1xuICAgICAgLy8gV2hlbiB3ZSdyZSByZWNvbmNpbGluZyBpbiBwbGFjZSB3ZSBoYXZlIGEgd29yayBpbiBwcm9ncmVzcyBjb3B5LiBXZVxuICAgICAgLy8gYWN0dWFsbHkgd2FudCB0aGUgY3VycmVudCBjb3B5LiBJZiB0aGVyZSBpcyBubyBjdXJyZW50IGNvcHksIHRoZW4gd2VcbiAgICAgIC8vIGRvbid0IG5lZWQgdG8gdHJhY2sgZGVsZXRpb24gc2lkZS1lZmZlY3RzLlxuICAgICAgaWYgKGNoaWxkVG9EZWxldGUuYWx0ZXJuYXRlID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNoaWxkVG9EZWxldGUgPSBjaGlsZFRvRGVsZXRlLmFsdGVybmF0ZTtcbiAgICB9XG4gICAgLy8gRGVsZXRpb25zIGFyZSBhZGRlZCBpbiByZXZlcnNlZCBvcmRlciBzbyB3ZSBhZGQgaXQgdG8gdGhlIGZyb250LlxuICAgIC8vIEF0IHRoaXMgcG9pbnQsIHRoZSByZXR1cm4gZmliZXIncyBlZmZlY3QgbGlzdCBpcyBlbXB0eSBleGNlcHQgZm9yXG4gICAgLy8gZGVsZXRpb25zLCBzbyB3ZSBjYW4ganVzdCBhcHBlbmQgdGhlIGRlbGV0aW9uIHRvIHRoZSBsaXN0LiBUaGUgcmVtYWluaW5nXG4gICAgLy8gZWZmZWN0cyBhcmVuJ3QgYWRkZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBPbmNlIHdlIGltcGxlbWVudFxuICAgIC8vIHJlc3VtaW5nLCB0aGlzIG1heSBub3QgYmUgdHJ1ZS5cbiAgICB2YXIgbGFzdCA9IHJldHVybkZpYmVyLmxhc3RFZmZlY3Q7XG4gICAgaWYgKGxhc3QgIT09IG51bGwpIHtcbiAgICAgIGxhc3QubmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGRUb0RlbGV0ZTtcbiAgICB9XG4gICAgY2hpbGRUb0RlbGV0ZS5uZXh0RWZmZWN0ID0gbnVsbDtcbiAgICBjaGlsZFRvRGVsZXRlLmVmZmVjdFRhZyA9IERlbGV0aW9uO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cbiAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIC8vIEFkZCB0aGUgcmVtYWluaW5nIGNoaWxkcmVuIHRvIGEgdGVtcG9yYXJ5IG1hcCBzbyB0aGF0IHdlIGNhbiBmaW5kIHRoZW0gYnlcbiAgICAvLyBrZXlzIHF1aWNrbHkuIEltcGxpY2l0IChudWxsKSBrZXlzIGdldCBhZGRlZCB0byB0aGlzIHNldCB3aXRoIHRoZWlyIGluZGV4XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZXhpc3RpbmdDaGlsZHJlbjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVzZUZpYmVyKGZpYmVyLCBwZW5kaW5nUHJvcHMsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIGlmIChzaG91bGRDbG9uZSkge1xuICAgICAgdmFyIGNsb25lID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoZmliZXIsIHBlbmRpbmdQcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2xvbmUuaW5kZXggPSAwO1xuICAgICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFdlIG92ZXJyaWRlIHRoZSBleHBpcmF0aW9uIHRpbWUgZXZlbiBpZiBpdCBpcyBlYXJsaWVyLCBiZWNhdXNlIGlmXG4gICAgICAvLyB3ZSdyZSByZWNvbmNpbGluZyBhdCBhIGxhdGVyIHRpbWUgdGhhdCBtZWFucyB0aGF0IHRoaXMgd2FzXG4gICAgICAvLyBkb3duLXByaW9yaXRpemVkLlxuICAgICAgZmliZXIuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGZpYmVyLmVmZmVjdFRhZyA9IE5vRWZmZWN0O1xuICAgICAgZmliZXIuaW5kZXggPSAwO1xuICAgICAgZmliZXIuc2libGluZyA9IG51bGw7XG4gICAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gICAgICByZXR1cm4gZmliZXI7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnQgPSBuZXdGaWJlci5hbHRlcm5hdGU7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmVmZmVjdFRhZyA9IFBsYWNlbWVudDtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0ZpYmVyO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50LCBlbGVtZW50LCBleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZy5yZWYgPSBjb2VyY2VSZWYoY3VycmVudCwgZWxlbWVudCk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQucmVmID0gY29lcmNlUmVmKGN1cnJlbnQsIGVsZW1lbnQpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNhbGwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVE9ETzogU2hvdWxkIHRoaXMgYWxzbyBjb21wYXJlIGhhbmRsZXIgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG8gcmV1c2U/XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IENhbGxDb21wb25lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBNb3ZlIGJhc2VkIG9uIGluZGV4XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnQsIHJldHVybk5vZGUsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IFJldHVybkNvbXBvbmVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihyZXR1cm5Ob2RlLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNyZWF0ZWQudHlwZSA9IHJldHVybk5vZGUudmFsdWU7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nLnR5cGUgPSByZXR1cm5Ob2RlLnZhbHVlO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEhvc3RQb3J0YWwgfHwgY3VycmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyAhPT0gcG9ydGFsLmNvbnRhaW5lckluZm8gfHwgY3VycmVudC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gIT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgY3JlYXRlZFsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBleHBpcmF0aW9uVGltZSwga2V5KSB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC50YWcgIT09IEZyYWdtZW50KSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZnJhZ21lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIGtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGV4aXN0aW5nWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQoJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5yZWYgPSBjb2VyY2VSZWYobnVsbCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgICBfY3JlYXRlZDJbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfQ0FMTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21DYWxsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkM1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDM7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkNCA9IGNyZWF0ZUZpYmVyRnJvbVJldHVybihuZXdDaGlsZCwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgICBfY3JlYXRlZDQudHlwZSA9IG5ld0NoaWxkLnZhbHVlO1xuICAgICAgICAgICAgX2NyZWF0ZWQ0WydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQ1ID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIF9jcmVhdGVkNVsncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDU7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX2NyZWF0ZWQ2ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgICBfY3JlYXRlZDZbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBfY3JlYXRlZDY7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuXG4gICAgdmFyIGtleSA9IG9sZEZpYmVyICE9PSBudWxsID8gb2xkRmliZXIua2V5IDogbnVsbDtcblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIGlmIChuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW4sIGV4cGlyYXRpb25UaW1lLCBrZXkpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLy8gUmV0dXJucyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgICAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYVxuICAgICAgICAgICAgLy8geWllbGQuXG4gICAgICAgICAgICBpZiAoa2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZXR1cm4ocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUsIG51bGwpO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgJycgKyBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUZyYWdtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbiwgZXhwaXJhdGlvblRpbWUsIG5ld0NoaWxkLmtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9DQUxMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhbGwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1JFVFVSTl9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFJldHVybnMgZG9uJ3QgaGF2ZSBrZXlzLCBzbyB3ZSBuZWl0aGVyIGhhdmUgdG8gY2hlY2sgdGhlIG9sZCBub3JcbiAgICAgICAgICAgIC8vIG5ldyBub2RlIGZvciB0aGUga2V5LiBJZiBib3RoIGFyZSByZXR1cm5zLCB0aGV5IG1hdGNoLlxuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVJldHVybihyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXI0ID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheSQxKG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjUgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjUsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSwgbnVsbCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cykge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnIHx8IGNoaWxkID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBrbm93bktleXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCk7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoa25vd25LZXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICBrbm93bktleXMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAnRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4lcycsIGtleSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQxKCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGhzIGVuZHMgc2luY2Ugd2VcbiAgICAvLyBkb24ndCBoYXZlIGJhY2twb2ludGVycyBvbiBmaWJlcnMuIEknbSB0cnlpbmcgdG8gc2VlIGhvdyBmYXIgd2UgY2FuIGdldFxuICAgIC8vIHdpdGggdGhhdCBtb2RlbC4gSWYgaXQgZW5kcyB1cCBub3QgYmVpbmcgd29ydGggdGhlIHRyYWRlb2Zmcywgd2UgY2FuXG4gICAgLy8gYWRkIGl0IGxhdGVyLlxuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG5cbiAgICAvLyBJZiB5b3UgY2hhbmdlIHRoaXMgY29kZSwgYWxzbyB1cGRhdGUgcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcigpIHdoaWNoXG4gICAgLy8gdXNlcyB0aGUgc2FtZSBhbGdvcml0aG0uXG5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdDaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBuZXdDaGlsZHJlbltpXTtcbiAgICAgICAga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShjaGlsZCwga25vd25LZXlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuXG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cbiAgICAgIHZhciBuZXdGaWJlciA9IHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmICghX25ld0ZpYmVyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgIC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChfbmV3RmliZXIyKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlblsnZGVsZXRlJ10oX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgcmVjb25jaWxlQ2hpbGRyZW5BcnJheSgpLFxuICAgIC8vIGJ1dCB1c2luZyB0aGUgaXRlcmF0b3IgaW5zdGVhZC5cblxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcbiAgICAhKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICB7XG4gICAgICAvLyBXYXJuIGFib3V0IHVzaW5nIE1hcHMgYXMgY2hpbGRyZW5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBwb3NzaWJsZU1hcCA9IG5ld0NoaWxkcmVuSXRlcmFibGU7XG4gICAgICAgIGlmIChwb3NzaWJsZU1hcC5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgICAgd2FybmluZyhkaWRXYXJuQWJvdXRNYXBzLCAnVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMuIENvbnZlcnQgaXQgdG8gYSBzZXF1ZW5jZS9pdGVyYWJsZSBvZiBrZXllZCAnICsgJ1JlYWN0RWxlbWVudHMgaW5zdGVhZC4lcycsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIC8vIFdlJ2xsIGdldCBhIGRpZmZlcmVudCBpdGVyYXRvciBsYXRlciBmb3IgdGhlIG1haW4gcGFzcy5cbiAgICAgIHZhciBfbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgICBpZiAoX25ld0NoaWxkcmVuKSB7XG4gICAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuICAgICAgICB2YXIgX3N0ZXAgPSBfbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgICAgICBmb3IgKDsgIV9zdGVwLmRvbmU7IF9zdGVwID0gX25ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICAgIHZhciBjaGlsZCA9IF9zdGVwLnZhbHVlO1xuICAgICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG4gICAgIShuZXdDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0FuIGl0ZXJhYmxlIG9iamVjdCBwcm92aWRlZCBubyBpdGVyYXRvci4nKSA6IHZvaWQgMDtcblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG5cbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcblxuICAgIHZhciBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpO1xuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKCFvbGRGaWJlcikge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBNb3ZlIG91dCBvZiB0aGUgbG9vcC4gVGhpcyBvbmx5IGhhcHBlbnMgZm9yIHRoZSBmaXJzdCBydW4uXG4gICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBuZXdGaWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IERlZmVyIHNpYmxpbmdzIGlmIHdlJ3JlIG5vdCBhdCB0aGUgcmlnaHQgaW5kZXggZm9yIHRoaXMgc2xvdC5cbiAgICAgICAgLy8gSS5lLiBpZiB3ZSBoYWQgbnVsbCB2YWx1ZXMgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gZGVmZXIgdGhpc1xuICAgICAgICAvLyBmb3IgZWFjaCBudWxsIHZhbHVlLiBIb3dldmVyLCB3ZSBhbHNvIGRvbid0IHdhbnQgdG8gY2FsbCB1cGRhdGVTbG90XG4gICAgICAgIC8vIHdpdGggdGhlIHByZXZpb3VzIG9uZS5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gbmV3RmliZXI7XG4gICAgICB9XG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSkge1xuICAgICAgICB2YXIgX25ld0ZpYmVyMyA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBzdGVwLnZhbHVlLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIzLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyNCA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgc3RlcC52YWx1ZSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuWydkZWxldGUnXShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXI0LCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBleHBpcmF0aW9uVGltZSk7XG4gICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lKTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIGVsZW1lbnQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50ID8gZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIDogY2hpbGQudHlwZSA9PT0gZWxlbWVudC50eXBlKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgPyBlbGVtZW50LnByb3BzLmNoaWxkcmVuIDogZWxlbWVudC5wcm9wcywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICAgIGV4aXN0aW5nLnJlZiA9IGNvZXJjZVJlZihjaGlsZCwgZWxlbWVudCk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAge1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnU291cmNlID0gZWxlbWVudC5fc291cmNlO1xuICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgaWYgKGVsZW1lbnQudHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50LnByb3BzLmNoaWxkcmVuLCByZXR1cm5GaWJlci5pbnRlcm5hbENvbnRleHRUYWcsIGV4cGlyYXRpb25UaW1lLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDcgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgX2NyZWF0ZWQ3LnJlZiA9IGNvZXJjZVJlZihjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gX2NyZWF0ZWQ3O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUNhbGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBjYWxsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBDYWxsQ29tcG9uZW50KSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBjYWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21DYWxsKGNhbGwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVSZXR1cm4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZXR1cm5Ob2RlLCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB5aWVsZHMgc2luY2UgdGhleSdyZSBzdGF0ZWxlc3MuXG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgbnVsbCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBleGlzdGluZy50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICAgICAgZXhpc3RpbmdbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21SZXR1cm4ocmV0dXJuTm9kZSwgcmV0dXJuRmliZXIuaW50ZXJuYWxDb250ZXh0VGFnLCBleHBpcmF0aW9uVGltZSk7XG4gICAgY3JlYXRlZC50eXBlID0gcmV0dXJuTm9kZS52YWx1ZTtcbiAgICBjcmVhdGVkWydyZXR1cm4nXSA9IHJldHVybkZpYmVyO1xuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBrZXkgPSBwb3J0YWwua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10sIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgICBleGlzdGluZ1sncmV0dXJuJ10gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVBvcnRhbChwb3J0YWwsIHJldHVybkZpYmVyLmludGVybmFsQ29udGV4dFRhZywgZXhwaXJhdGlvblRpbWUpO1xuICAgIGNyZWF0ZWRbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgcmVjdXJzaXZlLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cblxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICBpZiAoZW5hYmxlUmVhY3RGcmFnbWVudCAmJiB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsKSB7XG4gICAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnByb3BzLmNoaWxkcmVuO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcbiAgICB2YXIgaXNPYmplY3QgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsO1xuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgZXhwaXJhdGlvblRpbWUpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX0NBTExfVFlQRTpcbiAgICAgICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVDYWxsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUkVUVVJOX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUmV0dXJuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGV4cGlyYXRpb25UaW1lKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCAnJyArIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSkpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5JDEobmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpKSB7XG4gICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgaWYgKGlzT2JqZWN0KSB7XG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gSWYgdGhlIG5ldyBjaGlsZCBpcyB1bmRlZmluZWQsIGFuZCB0aGUgcmV0dXJuIGZpYmVyIGlzIGEgY29tcG9zaXRlXG4gICAgICAvLyBjb21wb25lbnQsIHRocm93IGFuIGVycm9yLiBJZiBGaWJlciByZXR1cm4gdHlwZXMgYXJlIGRpc2FibGVkLFxuICAgICAgLy8gd2UgYWxyZWFkeSB0aHJldyBhYm92ZS5cbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5yZW5kZXIuX2lzTW9ja0Z1bmN0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHRvIHRoZSBuZXh0IGNhc2UsIHdoaWNoIGhhbmRsZXMgYm90aFxuICAgICAgICAvLyBmdW5jdGlvbnMgYW5kIGNsYXNzZXNcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lZCBuby1mYWxsdGhyb3VnaFxuICAgICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIENvbXBvbmVudCA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICclcyguLi4pOiBOb3RoaW5nIHdhcyByZXR1cm5lZCBmcm9tIHJlbmRlci4gVGhpcyB1c3VhbGx5IG1lYW5zIGEgcmV0dXJuIHN0YXRlbWVudCBpcyBtaXNzaW5nLiBPciwgdG8gcmVuZGVyIG5vdGhpbmcsIHJldHVybiBudWxsLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJlbWFpbmluZyBjYXNlcyBhcmUgYWxsIHRyZWF0ZWQgYXMgZW1wdHkuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IENoaWxkUmVjb25jaWxlcih0cnVlLCB0cnVlKTtcblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzSW5QbGFjZSA9IENoaWxkUmVjb25jaWxlcihmYWxzZSwgdHJ1ZSk7XG5cbnZhciBtb3VudENoaWxkRmliZXJzSW5QbGFjZSA9IENoaWxkUmVjb25jaWxlcihmYWxzZSwgZmFsc2UpO1xuXG5mdW5jdGlvbiBjbG9uZUNoaWxkRmliZXJzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICEoY3VycmVudCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gY3VycmVudC5jaGlsZCkgPyBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJykgOiB2b2lkIDA7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMsIGN1cnJlbnRDaGlsZC5leHBpcmF0aW9uVGltZSk7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbmV3Q2hpbGQ7XG5cbiAgbmV3Q2hpbGRbJ3JldHVybiddID0gd29ya0luUHJvZ3Jlc3M7XG4gIHdoaWxlIChjdXJyZW50Q2hpbGQuc2libGluZyAhPT0gbnVsbCkge1xuICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQuc2libGluZyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgY3VycmVudENoaWxkLnBlbmRpbmdQcm9wcywgY3VycmVudENoaWxkLmV4cGlyYXRpb25UaW1lKTtcbiAgICBuZXdDaGlsZFsncmV0dXJuJ10gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuICBuZXdDaGlsZC5zaWJsaW5nID0gbnVsbDtcbn1cblxue1xuICB2YXIgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzID0ge307XG59XG5cbnZhciBSZWFjdEZpYmVyQmVnaW5Xb3JrID0gZnVuY3Rpb24gKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQsIHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcikge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICB1c2VTeW5jU2NoZWR1bGluZyA9IGNvbmZpZy51c2VTeW5jU2NoZWR1bGluZyxcbiAgICAgIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWUgPSBjb25maWcuc2hvdWxkRGVwcmlvcml0aXplU3VidHJlZTtcbiAgdmFyIHB1c2hIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LnB1c2hIb3N0Q29udGV4dCxcbiAgICAgIHB1c2hIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucHVzaEhvc3RDb250YWluZXI7XG4gIHZhciBlbnRlckh5ZHJhdGlvblN0YXRlID0gaHlkcmF0aW9uQ29udGV4dC5lbnRlckh5ZHJhdGlvblN0YXRlLFxuICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSA9IGh5ZHJhdGlvbkNvbnRleHQucmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC50cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJDbGFzc0NvbXBvID0gUmVhY3RGaWJlckNsYXNzQ29tcG9uZW50KHNjaGVkdWxlV29yaywgY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlciwgbWVtb2l6ZVByb3BzLCBtZW1vaXplU3RhdGUpLFxuICAgICAgYWRvcHRDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLmFkb3B0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2UgPSBfUmVhY3RGaWJlckNsYXNzQ29tcG8uY29uc3RydWN0Q2xhc3NJbnN0YW5jZSxcbiAgICAgIG1vdW50Q2xhc3NJbnN0YW5jZSA9IF9SZWFjdEZpYmVyQ2xhc3NDb21wby5tb3VudENsYXNzSW5zdGFuY2UsXG4gICAgICB1cGRhdGVDbGFzc0luc3RhbmNlID0gX1JlYWN0RmliZXJDbGFzc0NvbXBvLnVwZGF0ZUNsYXNzSW5zdGFuY2U7XG5cbiAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgYW5kIHVzZSByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUgZGlyZWN0bHkuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW5BdEV4cGlyYXRpb25UaW1lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAgIC8vIHdvbid0IHVwZGF0ZSBpdHMgY2hpbGQgc2V0IGJ5IGFwcGx5aW5nIG1pbmltYWwgc2lkZS1lZmZlY3RzLiBJbnN0ZWFkLFxuICAgICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgfSBlbHNlIGlmIChjdXJyZW50LmNoaWxkID09PSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCkge1xuICAgICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgICAvLyB0aGUgY2xvbmUgYWxnb3JpdGhtIHRvIGNyZWF0ZSBhIGNvcHkgb2YgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuLlxuXG4gICAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgICAgLy8gbGV0J3MgdGhyb3cgaXQgb3V0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MuY2hpbGQsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiwgb24gdGhlIG90aGVyIGhhbmQsIGl0IGlzIGFscmVhZHkgdXNpbmcgYSBjbG9uZSwgdGhhdCBtZWFucyB3ZSd2ZVxuICAgICAgLy8gYWxyZWFkeSBiZWd1biBzb21lIHdvcmsgb24gdGhpcyB0cmVlIGFuZCB3ZSBjYW4gY29udGludWUgd2hlcmUgd2UgbGVmdFxuICAgICAgLy8gb2ZmIGJ5IHJlY29uY2lsaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIGNoaWxkcmVuLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0luUGxhY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwpIHtcbiAgICAgICAgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGlmIChyZWYgIT09IG51bGwgJiYgKCFjdXJyZW50IHx8IGN1cnJlbnQucmVmICE9PSByZWYpKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBSZWY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25hbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBmbiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgIHZhciBtZW1vaXplZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICBpZiAoaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgLy8gTm9ybWFsbHkgd2UgY2FuIGJhaWwgb3V0IG9uIHByb3BzIGVxdWFsaXR5IGJ1dCBpZiBjb250ZXh0IGhhcyBjaGFuZ2VkXG4gICAgICAvLyB3ZSBkb24ndCBkbyB0aGUgYmFpbG91dCBhbmQgd2UgaGF2ZSB0byByZXVzZSBleGlzdGluZyBwcm9wcyBpbnN0ZWFkLlxuICAgICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0UHJvcHMgPSBtZW1vaXplZFByb3BzO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmV4dFByb3BzID09PSBudWxsIHx8IG1lbW9pemVkUHJvcHMgPT09IG5leHRQcm9wcykge1xuICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBjb25zaWRlciBicmluZ2luZyBmbi5zaG91bGRDb21wb25lbnRVcGRhdGUoKSBiYWNrLlxuICAgICAgLy8gSXQgdXNlZCB0byBiZSBoZXJlLlxuICAgIH1cblxuICAgIHZhciB1bm1hc2tlZENvbnRleHQgPSBnZXRVbm1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgIHZhciBjb250ZXh0ID0gZ2V0TWFza2VkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgdW5tYXNrZWRDb250ZXh0KTtcblxuICAgIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgICB7XG4gICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZSgncmVuZGVyJyk7XG4gICAgICBuZXh0Q2hpbGRyZW4gPSBmbihuZXh0UHJvcHMsIGNvbnRleHQpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UobnVsbCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgIHZhciBoYXNDb250ZXh0ID0gcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gdm9pZCAwO1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSkge1xuICAgICAgICAvLyBJbiB0aGUgaW5pdGlhbCBwYXNzIHdlIG1pZ2h0IG5lZWQgdG8gY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICAgIHNob3VsZFVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdSZXN1bWluZyB3b3JrIG5vdCB5ZXQgaW1wbGVtZW50ZWQuJyk7XG4gICAgICAgIC8vIEluIGEgcmVzdW1lLCB3ZSdsbCBhbHJlYWR5IGhhdmUgYW4gaW5zdGFuY2Ugd2UgY2FuIHJldXNlLlxuICAgICAgICAvLyBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCk7XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0KSB7XG4gICAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICAgIGlmICghc2hvdWxkVXBkYXRlKSB7XG4gICAgICAvLyBDb250ZXh0IHByb3ZpZGVycyBzaG91bGQgZGVmZXIgdG8gc0NVIGZvciByZW5kZXJpbmdcbiAgICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICAgIGludmFsaWRhdGVDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIC8vIFJlcmVuZGVyXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSB2b2lkIDA7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50UGhhc2UoJ3JlbmRlcicpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRQaGFzZShudWxsKTtcbiAgICB9XG4gICAgLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBQZXJmb3JtZWRXb3JrO1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIC8vIE1lbW9pemUgcHJvcHMgYW5kIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cbiAgICBtZW1vaXplU3RhdGUod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnN0YXRlKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLnByb3BzKTtcblxuICAgIC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuICAgIGlmIChoYXNDb250ZXh0KSB7XG4gICAgICBpbnZhbGlkYXRlQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCB0cnVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgaWYgKHJvb3QucGVuZGluZ0NvbnRleHQpIHtcbiAgICAgIHB1c2hUb3BMZXZlbENvbnRleHRPYmplY3Qod29ya0luUHJvZ3Jlc3MsIHJvb3QucGVuZGluZ0NvbnRleHQsIHJvb3QucGVuZGluZ0NvbnRleHQgIT09IHJvb3QuY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChyb290LmNvbnRleHQpIHtcbiAgICAgIC8vIFNob3VsZCBhbHdheXMgYmUgc2V0XG4gICAgICBwdXNoVG9wTGV2ZWxDb250ZXh0T2JqZWN0KHdvcmtJblByb2dyZXNzLCByb290LmNvbnRleHQsIGZhbHNlKTtcbiAgICB9XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHJvb3QuY29udGFpbmVySW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHN0YXRlID0gcHJvY2Vzc1VwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVRdWV1ZSwgbnVsbCwgbnVsbCwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgaWYgKHByZXZTdGF0ZSA9PT0gc3RhdGUpIHtcbiAgICAgICAgLy8gSWYgdGhlIHN0YXRlIGlzIHRoZSBzYW1lIGFzIGJlZm9yZSwgdGhhdCdzIGEgYmFpbG91dCBiZWNhdXNlIHdlIGhhZFxuICAgICAgICAvLyBubyB3b3JrIHRoYXQgZXhwaXJlcyBhdCB0aGlzIHRpbWUuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50O1xuICAgICAgdmFyIHJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICBpZiAoKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkgJiYgcm9vdC5oeWRyYXRlICYmIGVudGVySHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGN1cnJlbnQgY2hpbGRyZW4gdGhpcyBtaWdodCBiZSB0aGUgZmlyc3QgcGFzcy5cbiAgICAgICAgLy8gV2UgYWx3YXlzIHRyeSB0byBoeWRyYXRlLiBJZiB0aGlzIGlzbid0IGEgaHlkcmF0aW9uIHBhc3MgdGhlcmUgd29uJ3RcbiAgICAgICAgLy8gYmUgYW55IGNoaWxkcmVuIHRvIGh5ZHJhdGUgd2hpY2ggaXMgZWZmZWN0aXZlbHkgdGhlIHNhbWUgdGhpbmcgYXNcbiAgICAgICAgLy8gbm90IGh5ZHJhdGluZy5cblxuICAgICAgICAvLyBUaGlzIGlzIGEgYml0IG9mIGEgaGFjay4gV2UgdHJhY2sgdGhlIGhvc3Qgcm9vdCBhcyBhIHBsYWNlbWVudCB0b1xuICAgICAgICAvLyBrbm93IHRoYXQgd2UncmUgY3VycmVudGx5IGluIGEgbW91bnRpbmcgc3RhdGUuIFRoYXQgd2F5IGlzTW91bnRlZFxuICAgICAgICAvLyB3b3JrcyBhcyBleHBlY3RlZC4gV2UgbXVzdCByZXNldCB0aGlzIGJlZm9yZSBjb21taXR0aW5nLlxuICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuXG4gICAgICAgIC8vIEVuc3VyZSB0aGF0IGNoaWxkcmVuIG1vdW50IGludG8gdGhpcyByb290IHdpdGhvdXQgdHJhY2tpbmdcbiAgICAgICAgLy8gc2lkZS1lZmZlY3RzLiBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBkb24ndCBzdG9yZSBQbGFjZW1lbnQgZWZmZWN0cyBvblxuICAgICAgICAvLyBub2RlcyB0aGF0IHdpbGwgYmUgaHlkcmF0ZWQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVyc0luUGxhY2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCBlbGVtZW50LCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UgcmVzZXQgaHlkcmF0aW9uIHN0YXRlIGluIGNhc2Ugd2UgYWJvcnRlZCBhbmQgcmVzdW1lZCBhbm90aGVyXG4gICAgICAgIC8vIHJvb3QuXG4gICAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgbWVtb2l6ZVN0YXRlKHdvcmtJblByb2dyZXNzLCBzdGF0ZSk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyB1cGRhdGUgcXVldWUsIHRoYXQncyBhIGJhaWxvdXQgYmVjYXVzZSB0aGUgcm9vdCBoYXMgbm8gcHJvcHMuXG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgdmFyIG1lbW9pemVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5leHRQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgbmV4dFByb3BzID0gbWVtb2l6ZWRQcm9wcztcbiAgICAgICEobmV4dFByb3BzICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgfVxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcblxuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcHMgPT09IG51bGwgfHwgbWVtb2l6ZWRQcm9wcyA9PT0gbmV4dFByb3BzKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgaXNEaXJlY3RUZXh0Q2hpbGQgPSBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBuZXh0UHJvcHMpO1xuXG4gICAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG4gICAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgICAgLy8gY2FzZS4gV2Ugd29uJ3QgaGFuZGxlIGl0IGFzIGEgcmVpZmllZCBjaGlsZC4gV2Ugd2lsbCBpbnN0ZWFkIGhhbmRsZVxuICAgICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGF2ZSBhY2Nlc3MgdG8gdGhpcyBwcm9wLiBUaGF0XG4gICAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHByZXZQcm9wcyAmJiBzaG91bGRTZXRUZXh0Q29udGVudCh0eXBlLCBwcmV2UHJvcHMpKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICAgIHdvcmtJblByb2dyZXNzLmVmZmVjdFRhZyB8PSBDb250ZW50UmVzZXQ7XG4gICAgfVxuXG4gICAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBDaGVjayB0aGUgaG9zdCBjb25maWcgdG8gc2VlIGlmIHRoZSBjaGlsZHJlbiBhcmUgb2Zmc2NyZWVuL2hpZGRlbi5cbiAgICBpZiAocmVuZGVyRXhwaXJhdGlvblRpbWUgIT09IE5ldmVyICYmICF1c2VTeW5jU2NoZWR1bGluZyAmJiBzaG91bGREZXByaW9yaXRpemVTdWJ0cmVlKHR5cGUsIG5leHRQcm9wcykpIHtcbiAgICAgIC8vIERvd24tcHJpb3JpdGl6ZSB0aGUgY2hpbGRyZW4uXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9IE5ldmVyO1xuICAgICAgLy8gQmFpbG91dCBhbmQgY29tZSBiYWNrIHRvIHRoaXMgZmliZXIgbGF0ZXIuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuKTtcbiAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcyk7XG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChuZXh0UHJvcHMgPT09IG51bGwpIHtcbiAgICAgIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfVxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKTtcbiAgICAvLyBOb3RoaW5nIHRvIGRvIGhlcmUuIFRoaXMgaXMgdGVybWluYWwuIFdlJ2xsIGRvIHRoZSBjb21wbGV0aW9uIHN0ZXBcbiAgICAvLyBpbW1lZGlhdGVseSBhZnRlci5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1vdW50SW5kZXRlcm1pbmF0ZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAhKGN1cnJlbnQgPT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIGhhdmUgbW91bnRlZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICB2YXIgZm4gPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgIHZhciBwcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgICB2YXIgdW5tYXNrZWRDb250ZXh0ID0gZ2V0VW5tYXNrZWRDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgY29udGV4dCA9IGdldE1hc2tlZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHVubWFza2VkQ29udGV4dCk7XG5cbiAgICB2YXIgdmFsdWU7XG5cbiAgICB7XG4gICAgICBpZiAoZm4ucHJvdG90eXBlICYmIHR5cGVvZiBmbi5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsIFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgdmFsdWUgPSBmbihwcm9wcywgY29udGV4dCk7XG4gICAgfVxuICAgIC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUGVyZm9ybWVkV29yaztcblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsICYmIHR5cGVvZiB2YWx1ZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFByb2NlZWQgdW5kZXIgdGhlIGFzc3VtcHRpb24gdGhhdCB0aGlzIGlzIGEgY2xhc3MgaW5zdGFuY2VcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAgICAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAgICAgLy8gV2Ugd2lsbCBpbnZhbGlkYXRlIHRoZSBjaGlsZCBjb250ZXh0IGluIGZpbmlzaENsYXNzQ29tcG9uZW50KCkgcmlnaHQgYWZ0ZXIgcmVuZGVyaW5nLlxuICAgICAgdmFyIGhhc0NvbnRleHQgPSBwdXNoQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGFkb3B0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgICAgbW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICByZXR1cm4gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHRydWUsIGhhc0NvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBQcm9jZWVkIHVuZGVyIHRoZSBhc3N1bXB0aW9uIHRoYXQgdGhpcyBpcyBhIGZ1bmN0aW9uYWwgY29tcG9uZW50XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbmFsQ29tcG9uZW50O1xuICAgICAge1xuICAgICAgICB2YXIgQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcblxuICAgICAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICAgICAgd2FybmluZyghQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzLCAnJXMoLi4uKTogY2hpbGRDb250ZXh0VHlwZXMgY2Fubm90IGJlIGRlZmluZWQgb24gYSBmdW5jdGlvbmFsIGNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5yZWYgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciBvd25lck5hbWUgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZSgpO1xuICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgd2FybmluZ0tleSA9IG93bmVyTmFtZSB8fCB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJRCB8fCAnJztcbiAgICAgICAgICB2YXIgZGVidWdTb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5fZGVidWdTb3VyY2U7XG4gICAgICAgICAgaWYgKGRlYnVnU291cmNlKSB7XG4gICAgICAgICAgICB3YXJuaW5nS2V5ID0gZGVidWdTb3VyY2UuZmlsZU5hbWUgKyAnOicgKyBkZWJ1Z1NvdXJjZS5saW5lTnVtYmVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXdhcm5lZEFib3V0U3RhdGVsZXNzUmVmc1t3YXJuaW5nS2V5XSkge1xuICAgICAgICAgICAgd2FybmVkQWJvdXRTdGF0ZWxlc3NSZWZzW3dhcm5pbmdLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHdhcm5pbmcoZmFsc2UsICdTdGF0ZWxlc3MgZnVuY3Rpb24gY29tcG9uZW50cyBjYW5ub3QgYmUgZ2l2ZW4gcmVmcy4gJyArICdBdHRlbXB0cyB0byBhY2Nlc3MgdGhpcyByZWYgd2lsbCBmYWlsLiVzJXMnLCBpbmZvLCBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdmFsdWUpO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBwcm9wcyk7XG4gICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICB2YXIgbmV4dENhbGwgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKGhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgIC8vIE5vcm1hbGx5IHdlIGNhbiBiYWlsIG91dCBvbiBwcm9wcyBlcXVhbGl0eSBidXQgaWYgY29udGV4dCBoYXMgY2hhbmdlZFxuICAgICAgLy8gd2UgZG9uJ3QgZG8gdGhlIGJhaWxvdXQgYW5kIHdlIGhhdmUgdG8gcmV1c2UgZXhpc3RpbmcgcHJvcHMgaW5zdGVhZC5cbiAgICAgIGlmIChuZXh0Q2FsbCA9PT0gbnVsbCkge1xuICAgICAgICBuZXh0Q2FsbCA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDYWxsICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2FsbCA9PT0gbnVsbCB8fCB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID09PSBuZXh0Q2FsbCkge1xuICAgICAgbmV4dENhbGwgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICAgICAgLy8gVE9ETzogV2hlbiBiYWlsaW5nIG91dCwgd2UgbWlnaHQgbmVlZCB0byByZXR1cm4gdGhlIHN0YXRlTm9kZSBpbnN0ZWFkXG4gICAgICAvLyBvZiB0aGUgY2hpbGQuIFRvIGNoZWNrIGl0IGZvciB3b3JrLlxuICAgICAgLy8gcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q2FsbC5jaGlsZHJlbjtcblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYSBmb3JrIG9mIHJlY29uY2lsZUNoaWxkcmVuQXRFeHBpcmF0aW9uVGltZSBidXQgdXNpbmdcbiAgICAvLyBzdGF0ZU5vZGUgdG8gc3RvcmUgdGhlIGNoaWxkLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBtb3VudENoaWxkRmliZXJzSW5QbGFjZSh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQuY2hpbGQgPT09IHdvcmtJblByb2dyZXNzLmNoaWxkKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIH1cblxuICAgIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dENhbGwpO1xuICAgIC8vIFRoaXMgZG9lc24ndCB0YWtlIGFyYml0cmFyeSB0aW1lIHNvIHdlIGNvdWxkIHN5bmNocm9ub3VzbHkganVzdCBiZWdpblxuICAgIC8vIGVhZ2VybHkgZG8gdGhlIHdvcmsgb2Ygd29ya0luUHJvZ3Jlc3MuY2hpbGQgYXMgYW4gb3B0aW1pemF0aW9uLlxuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgIGlmIChoYXNDb250ZXh0Q2hhbmdlZCgpKSB7XG4gICAgICAvLyBOb3JtYWxseSB3ZSBjYW4gYmFpbCBvdXQgb24gcHJvcHMgZXF1YWxpdHkgYnV0IGlmIGNvbnRleHQgaGFzIGNoYW5nZWRcbiAgICAgIC8vIHdlIGRvbid0IGRvIHRoZSBiYWlsb3V0IGFuZCB3ZSBoYXZlIHRvIHJldXNlIGV4aXN0aW5nIHByb3BzIGluc3RlYWQuXG4gICAgICBpZiAobmV4dENoaWxkcmVuID09PSBudWxsKSB7XG4gICAgICAgIG5leHRDaGlsZHJlbiA9IGN1cnJlbnQgJiYgY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAhKG5leHRDaGlsZHJlbiAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIHNob3VsZCBhbHdheXMgaGF2ZSBwZW5kaW5nIG9yIGN1cnJlbnQgcHJvcHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gPT09IG51bGwgfHwgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9PT0gbmV4dENoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgICAgLy8gYnV0IGF0IGNvbW1pdC4gVGhlcmVmb3JlIHdlIG5lZWQgdG8gdHJhY2sgaW5zZXJ0aW9ucyB3aGljaCB0aGUgbm9ybWFsXG4gICAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgICAgLy8gVE9ETzogQ29uc2lkZXIgdW5pZnlpbmcgdGhpcyB3aXRoIGhvdyB0aGUgcm9vdCB3b3Jrcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnNJblBsYWNlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBtZW1vaXplUHJvcHMod29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgICAgbWVtb2l6ZVByb3BzKHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4pO1xuICAgIH1cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICAvKlxuICBmdW5jdGlvbiByZXVzZUNoaWxkcmVuRWZmZWN0cyhyZXR1cm5GaWJlciA6IEZpYmVyLCBmaXJzdENoaWxkIDogRmliZXIpIHtcbiAgICBsZXQgY2hpbGQgPSBmaXJzdENoaWxkO1xuICAgIGRvIHtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBmaXJzdCBhbmQgbGFzdCBlZmZlY3Qgb2YgdGhlIHBhcmVudCBjb3JyZXNwb25kc1xuICAgICAgLy8gdG8gdGhlIGNoaWxkcmVuJ3MgZmlyc3QgYW5kIGxhc3QgZWZmZWN0LlxuICAgICAgaWYgKCFyZXR1cm5GaWJlci5maXJzdEVmZmVjdCkge1xuICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IGNoaWxkLmZpcnN0RWZmZWN0O1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QpIHtcbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZC5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gY2hpbGQubGFzdEVmZmVjdDtcbiAgICAgIH1cbiAgICB9IHdoaWxlIChjaGlsZCA9IGNoaWxkLnNpYmxpbmcpO1xuICB9XG4gICovXG5cbiAgZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIGNhbmNlbFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBiZSBhYmxlIHRvIGJhaWwgb3V0IGVhcmx5IGlmIHRoZSBjaGlsZHJlbiBoYXZlIG5vXG4gICAgLy8gbW9yZSB3b3JrIHRvIGRvLiBIb3dldmVyLCBzaW5jZSB3ZSBkb24ndCBoYXZlIGEgc2VwYXJhdGlvbiBvZiB0aGlzXG4gICAgLy8gRmliZXIncyBwcmlvcml0eSBhbmQgaXRzIGNoaWxkcmVuIHlldCAtIHdlIGRvbid0IGtub3cgd2l0aG91dCBkb2luZyBsb3RzXG4gICAgLy8gb2YgdGhlIHNhbWUgd29yayB3ZSBkbyBhbnl3YXkuIE9uY2Ugd2UgaGF2ZSB0aGF0IHNlcGFyYXRpb24gd2UgY2FuIGp1c3RcbiAgICAvLyBiYWlsIG91dCBoZXJlIGlmIHRoZSBjaGlsZHJlbiBoYXMgbm8gbW9yZSB3b3JrIGF0IHRoaXMgcHJpb3JpdHkgbGV2ZWwuXG4gICAgLy8gaWYgKHdvcmtJblByb2dyZXNzLnByaW9yaXR5T2ZDaGlsZHJlbiA8PSBwcmlvcml0eUxldmVsKSB7XG4gICAgLy8gICAvLyBJZiB0aGVyZSBhcmUgc2lkZS1lZmZlY3RzIGluIHRoZXNlIGNoaWxkcmVuIHRoYXQgaGF2ZSBub3QgeWV0IGJlZW5cbiAgICAvLyAgIC8vIGNvbW1pdHRlZCB3ZSBuZWVkIHRvIGVuc3VyZSB0aGF0IHRoZXkgZ2V0IHByb3Blcmx5IHRyYW5zZmVycmVkIHVwLlxuICAgIC8vICAgaWYgKGN1cnJlbnQgJiYgY3VycmVudC5jaGlsZCAhPT0gd29ya0luUHJvZ3Jlc3MuY2hpbGQpIHtcbiAgICAvLyAgICAgcmV1c2VDaGlsZHJlbkVmZmVjdHMod29ya0luUHJvZ3Jlc3MsIGNoaWxkKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIHJldHVybiBudWxsO1xuICAgIC8vIH1cblxuICAgIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgY2FuY2VsV29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IEhhbmRsZSBIb3N0Q29tcG9uZW50IHRhZ3MgaGVyZSBhcyB3ZWxsIGFuZCBjYWxsIHB1c2hIb3N0Q29udGV4dCgpP1xuICAgIC8vIFNlZSBQUiA4NTkwIGRpc2N1c3Npb24gZm9yIGNvbnRleHRcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgcHVzaENvbnRleHRQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgLy8gVE9ETzogV2hhdCBpZiB0aGlzIGlzIGN1cnJlbnRseSBpbiBwcm9ncmVzcz9cbiAgICAvLyBIb3cgY2FuIHRoYXQgaGFwcGVuPyBIb3cgaXMgdGhpcyBub3QgYmVpbmcgY2xvbmVkP1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gVE9ETzogRGVsZXRlIG1lbW9pemVQcm9wcy9TdGF0ZSBhbmQgbW92ZSB0byByZWNvbmNpbGUvYmFpbG91dCBpbnN0ZWFkXG4gIGZ1bmN0aW9uIG1lbW9pemVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgbmV4dFByb3BzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG5leHRQcm9wcztcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lbW9pemVTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAvLyBEb24ndCByZXNldCB0aGUgdXBkYXRlUXVldWUsIGluIGNhc2UgdGhlcmUgYXJlIHBlbmRpbmcgdXBkYXRlcy4gUmVzZXR0aW5nXG4gICAgLy8gaXMgaGFuZGxlZCBieSBwcm9jZXNzVXBkYXRlUXVldWUuXG4gIH1cblxuICBmdW5jdGlvbiBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgd29ya0luUHJvZ3Jlc3MuZXhwaXJhdGlvblRpbWUgPiByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkxvd1ByaW9yaXR5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBJbmRldGVybWluYXRlQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEZ1bmN0aW9uYWxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbmFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgY2FzZSBDYWxsSGFuZGxlclBoYXNlOlxuICAgICAgICAvLyBUaGlzIGlzIGEgcmVzdGFydC4gUmVzZXQgdGhlIHRhZyB0byB0aGUgaW5pdGlhbCBwaGFzZS5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgIC8vIEludGVudGlvbmFsbHkgZmFsbCB0aHJvdWdoIHNpbmNlIHRoaXMgaXMgbm93IHRoZSBzYW1lLlxuICAgICAgY2FzZSBDYWxsQ29tcG9uZW50OlxuICAgICAgICByZXR1cm4gdXBkYXRlQ2FsbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgICAgY2FzZSBSZXR1cm5Db21wb25lbnQ6XG4gICAgICAgIC8vIEEgcmV0dXJuIGNvbXBvbmVudCBpcyBqdXN0IGEgcGxhY2Vob2xkZXIsIHdlIGNhbiBqdXN0IHJ1biB0aHJvdWdoIHRoZVxuICAgICAgICAvLyBuZXh0IG9uZSBpbW1lZGlhdGVseS5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFB1c2ggY29udGV4dCBwcm92aWRlcnMgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIGNvbnRleHQgbWlzbWF0Y2guXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHB1c2hDb250ZXh0UHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgdHlwZSBvZiB3b3JrLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCBhbiBlcnJvciBlZmZlY3Qgc28gd2UgY2FuIGhhbmRsZSB0aGUgZXJyb3IgZHVyaW5nIHRoZSBjb21taXQgcGhhc2VcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gRXJyO1xuXG4gICAgLy8gVGhpcyBpcyBhIHdlaXJkIGNhc2Ugd2hlcmUgd2UgZG8gXCJyZXN1bWVcIiB3b3JrIOKAlCB3b3JrIHRoYXQgZmFpbGVkIG9uXG4gICAgLy8gb3VyIGZpcnN0IGF0dGVtcHQuIEJlY2F1c2Ugd2Ugbm8gbG9uZ2VyIGhhdmUgYSBub3Rpb24gb2YgXCJwcm9ncmVzc2VkXG4gICAgLy8gZGVsZXRpb25zLFwiIHJlc2V0IHRoZSBjaGlsZCB0byB0aGUgY3VycmVudCBjaGlsZCB0byBtYWtlIHN1cmUgd2UgZGVsZXRlXG4gICAgLy8gaXQgYWdhaW4uIFRPRE86IEZpbmQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLCBwZXJoYXBzIGR1cmluZyBhIG1vcmVcbiAgICAvLyBnZW5lcmFsIG92ZXJoYXVsIG9mIGVycm9yIGhhbmRsaW5nLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIH1cblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID4gcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25Mb3dQcmlvcml0eShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgYmFpbCBvdXQsIHdlJ3JlIGdvaW5nIGJlIHJlY29tcHV0aW5nIG91ciBjaGlsZHJlbiBzbyB3ZSBuZWVkXG4gICAgLy8gdG8gZHJvcCBvdXIgZWZmZWN0IGxpc3QuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmlyc3RFZmZlY3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3QgPSBudWxsO1xuXG4gICAgLy8gVW5tb3VudCB0aGUgY3VycmVudCBjaGlsZHJlbiBhcyBpZiB0aGUgY29tcG9uZW50IHJlbmRlcmVkIG51bGxcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgICByZWNvbmNpbGVDaGlsZHJlbkF0RXhwaXJhdGlvblRpbWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcztcbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJlZ2luV29yazogYmVnaW5Xb3JrLFxuICAgIGJlZ2luRmFpbGVkV29yazogYmVnaW5GYWlsZWRXb3JrXG4gIH07XG59O1xuXG52YXIgUmVhY3RGaWJlckNvbXBsZXRlV29yayA9IGZ1bmN0aW9uIChjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0KSB7XG4gIHZhciBjcmVhdGVJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVJbnN0YW5jZSxcbiAgICAgIGNyZWF0ZVRleHRJbnN0YW5jZSA9IGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBhcHBlbmRJbml0aWFsQ2hpbGQgPSBjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkLFxuICAgICAgZmluYWxpemVJbml0aWFsQ2hpbGRyZW4gPSBjb25maWcuZmluYWxpemVJbml0aWFsQ2hpbGRyZW4sXG4gICAgICBwcmVwYXJlVXBkYXRlID0gY29uZmlnLnByZXBhcmVVcGRhdGUsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuICB2YXIgZ2V0Um9vdEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5nZXRSb290SG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICBnZXRIb3N0Q29udGV4dCA9IGhvc3RDb250ZXh0LmdldEhvc3RDb250ZXh0LFxuICAgICAgcG9wSG9zdENvbnRhaW5lciA9IGhvc3RDb250ZXh0LnBvcEhvc3RDb250YWluZXI7XG4gIHZhciBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlID0gaHlkcmF0aW9uQ29udGV4dC5wcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlLFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb25Db250ZXh0LnByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlLFxuICAgICAgcG9wSHlkcmF0aW9uU3RhdGUgPSBoeWRyYXRpb25Db250ZXh0LnBvcEh5ZHJhdGlvblN0YXRlO1xuXG5cbiAgZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICAgIC8vIFRhZyB0aGUgZmliZXIgd2l0aCBhbiB1cGRhdGUgZWZmZWN0LiBUaGlzIHR1cm5zIGEgUGxhY2VtZW50IGludG9cbiAgICAvLyBhbiBVcGRhdGVBbmRQbGFjZW1lbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnIHw9IFVwZGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5lZmZlY3RUYWcgfD0gUmVmO1xuICB9XG5cbiAgZnVuY3Rpb24gYXBwZW5kQWxsUmV0dXJucyhyZXR1cm5zLCB3b3JrSW5Qcm9ncmVzcykge1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgIGlmIChub2RlKSB7XG4gICAgICBub2RlWydyZXR1cm4nXSA9IHdvcmtJblByb2dyZXNzO1xuICAgIH1cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdBIGNhbGwgY2Fubm90IGhhdmUgaG9zdCBjb21wb25lbnQgY2hpbGRyZW4uJyk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBSZXR1cm5Db21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJucy5wdXNoKG5vZGUudHlwZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBub2RlWydyZXR1cm4nXSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgIHZhciBjYWxsID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgICAhY2FsbCA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBiZSByZXNvbHZlZCBieSBub3cuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICAvLyBGaXJzdCBzdGVwIG9mIHRoZSBjYWxsIGhhcyBjb21wbGV0ZWQuIE5vdyB3ZSBuZWVkIHRvIGRvIHRoZSBzZWNvbmQuXG4gICAgLy8gVE9ETzogSXQgd291bGQgYmUgbmljZSB0byBoYXZlIGEgbXVsdGkgc3RhZ2UgY2FsbCByZXByZXNlbnRlZCBieSBhXG4gICAgLy8gc2luZ2xlIGNvbXBvbmVudCwgb3IgYXQgbGVhc3QgdGFpbCBjYWxsIG9wdGltaXplIG5lc3RlZCBvbmVzLiBDdXJyZW50bHlcbiAgICAvLyB0aGF0IHJlcXVpcmVzIGFkZGl0aW9uYWwgZmllbGRzIHRoYXQgd2UgZG9uJ3Qgd2FudCB0byBhZGQgdG8gdGhlIGZpYmVyLlxuICAgIC8vIFNvIHRoaXMgcmVxdWlyZXMgbmVzdGVkIGhhbmRsZXJzLlxuICAgIC8vIE5vdGU6IFRoaXMgZG9lc24ndCBtdXRhdGUgdGhlIGFsdGVybmF0ZSBub2RlLiBJIGRvbid0IHRoaW5rIGl0IG5lZWRzIHRvXG4gICAgLy8gc2luY2UgdGhpcyBzdGFnZSBpcyByZXNldCBmb3IgZXZlcnkgcGFzcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDYWxsSGFuZGxlclBoYXNlO1xuXG4gICAgLy8gQnVpbGQgdXAgdGhlIHJldHVybnMuXG4gICAgLy8gVE9ETzogQ29tcGFyZSB0aGlzIHRvIGEgZ2VuZXJhdG9yIG9yIG9wYXF1ZSBoZWxwZXJzIGxpa2UgQ2hpbGRyZW4uXG4gICAgdmFyIHJldHVybnMgPSBbXTtcbiAgICBhcHBlbmRBbGxSZXR1cm5zKHJldHVybnMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB2YXIgZm4gPSBjYWxsLmhhbmRsZXI7XG4gICAgdmFyIHByb3BzID0gY2FsbC5wcm9wcztcbiAgICB2YXIgbmV4dENoaWxkcmVuID0gZm4ocHJvcHMsIHJldHVybnMpO1xuXG4gICAgdmFyIGN1cnJlbnRGaXJzdENoaWxkID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuY2hpbGQgOiBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckV4cGlyYXRpb25UaW1lKTtcbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcG9ydGFsIGNoaWxkLCB0aGVuIHdlIGRvbid0IHdhbnQgdG8gdHJhdmVyc2VcbiAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAvLyB0aGUgcG9ydGFsIGRpcmVjdGx5LlxuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsIHx8IG5vZGVbJ3JldHVybiddID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGVIb3N0Q29udGFpbmVyID0gdm9pZCAwO1xuICB2YXIgdXBkYXRlSG9zdENvbXBvbmVudCA9IHZvaWQgMDtcbiAgdmFyIHVwZGF0ZUhvc3RUZXh0ID0gdm9pZCAwO1xuICBpZiAobXV0YXRpb24pIHtcbiAgICBpZiAoZW5hYmxlTXV0YXRpbmdSZWNvbmNpbGVyKSB7XG4gICAgICAvLyBNdXRhdGlvbiBtb2RlXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBUT0RPOiBUeXBlIHRoaXMgc3BlY2lmaWMgdG8gdGhpcyB0eXBlIG9mIGNvbXBvbmVudC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgICAgICAvLyBJZiB0aGUgdXBkYXRlIHBheWxvYWQgaW5kaWNhdGVzIHRoYXQgdGhlcmUgaXMgYSBjaGFuZ2Ugb3IgaWYgdGhlcmVcbiAgICAgICAgLy8gaXMgYSBuZXcgcmVmIHdlIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUuIEFsbCB0aGUgd29yayBpcyBkb25lIGluIGNvbW1pdFdvcmsuXG4gICAgICAgIGlmICh1cGRhdGVQYXlsb2FkKSB7XG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0VGV4dCA9IGZ1bmN0aW9uIChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTXV0YXRpbmcgcmVjb25jaWxlciBpcyBkaXNhYmxlZC4nKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIpIHtcbiAgICAgIC8vIFBlcnNpc3RlbnQgaG9zdCB0cmVlIG1vZGVcbiAgICAgIHZhciBjbG9uZUluc3RhbmNlID0gcGVyc2lzdGVuY2UuY2xvbmVJbnN0YW5jZSxcbiAgICAgICAgICBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0LFxuICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCA9IHBlcnNpc3RlbmNlLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldCxcbiAgICAgICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcblxuICAgICAgLy8gQW4gdW5mb3J0dW5hdGUgZm9yayBvZiBhcHBlbmRBbGxDaGlsZHJlbiBiZWNhdXNlIHdlIGhhdmUgdHdvIGRpZmZlcmVudCBwYXJlbnQgdHlwZXMuXG5cbiAgICAgIHZhciBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyID0gZnVuY3Rpb24gKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBjcmVhdGVkIGJ1dCB3ZSBuZWVkIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgICAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYSBwb3J0YWwgY2hpbGQsIHRoZW4gd2UgZG9uJ3Qgd2FudCB0byB0cmF2ZXJzZVxuICAgICAgICAgICAgLy8gZG93biBpdHMgY2hpbGRyZW4uIEluc3RlYWQsIHdlJ2xsIGdldCBpbnNlcnRpb25zIGZyb20gZWFjaCBjaGlsZCBpblxuICAgICAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBjaGlsZHJlblVuY2hhbmdlZCA9IHdvcmtJblByb2dyZXNzLmZpcnN0RWZmZWN0ID09PSBudWxsO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQpIHtcbiAgICAgICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgdmFyIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyKTtcbiAgICAgICAgICBpZiAoZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDtcbiAgICAgICAgICAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG4gICAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG4gICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAgICAgLy8gVGhpcyBndWFyYW50ZWVzIHRoYXQgd2UgY2FuIHJldXNlIGFsbCBvZiB0aGVtLlxuICAgICAgICB2YXIgY2hpbGRyZW5VbmNoYW5nZWQgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdCA9PT0gbnVsbDtcbiAgICAgICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgICAgICBpZiAoY2hpbGRyZW5VbmNoYW5nZWQgJiYgdXBkYXRlUGF5bG9hZCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHJlY3ljbGFibGVJbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCB3b3JrSW5Qcm9ncmVzcywgY2hpbGRyZW5VbmNoYW5nZWQsIHJlY3ljbGFibGVJbnN0YW5jZSk7XG4gICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKG5ld0luc3RhbmNlLCB0eXBlLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKSkge1xuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICAgIGlmIChjaGlsZHJlblVuY2hhbmdlZCkge1xuICAgICAgICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgaWYgKG9sZFRleHQgIT09IG5ld1RleHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAvLyBXZSdsbCBoYXZlIHRvIG1hcmsgaXQgYXMgaGF2aW5nIGFuIGVmZmVjdCwgZXZlbiB0aG91Z2ggd2Ugd29uJ3QgdXNlIHRoZSBlZmZlY3QgZm9yIGFueXRoaW5nLlxuICAgICAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdQZXJzaXN0ZW50IHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgLy8gTm8gaG9zdCBvcGVyYXRpb25zXG4gICAgICB1cGRhdGVIb3N0Q29udGFpbmVyID0gZnVuY3Rpb24gKHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgICB1cGRhdGVIb3N0Q29tcG9uZW50ID0gZnVuY3Rpb24gKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSkge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9O1xuICAgICAgdXBkYXRlSG9zdFRleHQgPSBmdW5jdGlvbiAoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgICAgICAgLy8gTm9vcFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTm9vcCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyRXhwaXJhdGlvblRpbWUpIHtcbiAgICAvLyBHZXQgdGhlIGxhdGVzdCBwcm9wcy5cbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgaWYgKG5ld1Byb3BzID09PSBudWxsKSB7XG4gICAgICBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gICAgfSBlbHNlIGlmICh3b3JrSW5Qcm9ncmVzcy5leHBpcmF0aW9uVGltZSAhPT0gTmV2ZXIgfHwgcmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5ldmVyKSB7XG4gICAgICAvLyBSZXNldCB0aGUgcGVuZGluZyBwcm9wcywgdW5sZXNzIHRoaXMgd2FzIGEgZG93bi1wcmlvcml0aXphdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gICAgfVxuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25hbENvbXBvbmVudDpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgYXJlIGxlYXZpbmcgdGhpcyBzdWJ0cmVlLCBzbyBwb3AgY29udGV4dCBpZiBhbnkuXG4gICAgICAgICAgcG9wQ29udGV4dFByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHBvcFRvcExldmVsQ29udGV4dE9iamVjdCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBmaWJlclJvb3QuY29udGV4dCA9IGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dDtcbiAgICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5jaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgICAgcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLy8gVGhpcyByZXNldHMgdGhlIGhhY2t5IHN0YXRlIHRvIGZpeCBpc01vdW50ZWQgYmVmb3JlIGNvbW1pdHRpbmcuXG4gICAgICAgICAgICAvLyBUT0RPOiBEZWxldGUgdGhpcyB3aGVuIHdlIGRlbGV0ZSBpc01vdW50ZWQgYW5kIGZpbmRET01Ob2RlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgdmFyIHJvb3RDb250YWluZXJJbnN0YW5jZSA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgICAgICAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgLy8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cbiAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGdldCB1cGRhdGVkIGJlY2F1c2Ugb25lIG9mIG91ciBjaGlsZHJlbiB1cGRhdGVkLCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gaGF2ZSBuZXdQcm9wcyBzbyB3ZSdsbCBoYXZlIHRvIHJldXNlIHRoZW0uXG4gICAgICAgICAgICAvLyBUT0RPOiBTcGxpdCB0aGUgdXBkYXRlIEFQSSBhcyBzZXBhcmF0ZSBmb3IgdGhlIHByb3BzIHZzLiBjaGlsZHJlbi5cbiAgICAgICAgICAgIC8vIEV2ZW4gYmV0dGVyIHdvdWxkIGJlIGlmIGNoaWxkcmVuIHdlcmVuJ3Qgc3BlY2lhbCBjYXNlZCBhdCBhbGwgdGhvLlxuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgdXBkYXRlUGF5bG9hZCA9IHByZXBhcmVVcGRhdGUoaW5zdGFuY2UsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQpO1xuXG4gICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50LnJlZiAhPT0gd29ya0luUHJvZ3Jlc3MucmVmKSB7XG4gICAgICAgICAgICAgIG1hcmtSZWYod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAgIC8vIFwic3RhY2tcIiBhcyB0aGUgcGFyZW50LiBUaGVuIGFwcGVuZCBjaGlsZHJlbiBhcyB3ZSBnbyBpbiBiZWdpbldvcmtcbiAgICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2Ugd2FudCB0byBhZGQgdGhlbiB0b3AtPmRvd24gb3JcbiAgICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cbiAgICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgICAvLyB0byBjb25zb2xpZGF0ZS5cbiAgICAgICAgICAgICAgaWYgKHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBjaGFuZ2VzIHRvIHRoZSBoeWRyYXRlZCBub2RlIG5lZWRzIHRvIGJlIGFwcGxpZWQgYXQgdGhlXG4gICAgICAgICAgICAgICAgLy8gY29tbWl0LXBoYXNlIHdlIG1hcmsgdGhpcyBhcyBzdWNoLlxuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gY3JlYXRlSW5zdGFuY2UodHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgX2N1cnJlbnRIb3N0Q29udGV4dCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICAgIC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG4gICAgICAgICAgICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihfaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MucmVmICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVmIG9uIGEgaG9zdCBub2RlIHdlIG5lZWQgdG8gc2NoZWR1bGUgYSBjYWxsYmFja1xuICAgICAgICAgICAgICBtYXJrUmVmKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuICAgICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgb2xkVGV4dCA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgICAgICAgICAgdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICEod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQyID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgICAgICAgIHZhciBfd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIGlmIChwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICBjYXNlIENhbGxDb21wb25lbnQ6XG4gICAgICAgIHJldHVybiBtb3ZlQ2FsbFRvSGFuZGxlclBoYXNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICBjYXNlIENhbGxIYW5kbGVyUGhhc2U6XG4gICAgICAgIC8vIFJlc2V0IHRoZSB0YWcgdG8gbm93IGJlIGEgZmlyc3QgcGhhc2UgY2FsbC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gQ2FsbENvbXBvbmVudDtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFJldHVybkNvbXBvbmVudDpcbiAgICAgICAgLy8gRG9lcyBub3RoaW5nLlxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgLy8gRXJyb3IgY2FzZXNcbiAgICAgIGNhc2UgSW5kZXRlcm1pbmF0ZUNvbXBvbmVudDpcbiAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnQW4gaW5kZXRlcm1pbmF0ZSBjb21wb25lbnQgc2hvdWxkIGhhdmUgYmVjb21lIGRldGVybWluYXRlIGJlZm9yZSBjb21wbGV0aW5nLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmtub3duIHVuaXQgb2Ygd29yayB0YWcuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wbGV0ZVdvcms6IGNvbXBsZXRlV29ya1xuICB9O1xufTtcblxudmFyIGludm9rZUd1YXJkZWRDYWxsYmFjayQyID0gUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjaztcbnZhciBoYXNDYXVnaHRFcnJvciQxID0gUmVhY3RFcnJvclV0aWxzLmhhc0NhdWdodEVycm9yO1xudmFyIGNsZWFyQ2F1Z2h0RXJyb3IkMSA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbnZhciBSZWFjdEZpYmVyQ29tbWl0V29yayA9IGZ1bmN0aW9uIChjb25maWcsIGNhcHR1cmVFcnJvcikge1xuICB2YXIgZ2V0UHVibGljSW5zdGFuY2UgPSBjb25maWcuZ2V0UHVibGljSW5zdGFuY2UsXG4gICAgICBtdXRhdGlvbiA9IGNvbmZpZy5tdXRhdGlvbixcbiAgICAgIHBlcnNpc3RlbmNlID0gY29uZmlnLnBlcnNpc3RlbmNlO1xuXG5cbiAgdmFyIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lciA9IGZ1bmN0aW9uIChjdXJyZW50LCBpbnN0YW5jZSkge1xuICAgIHN0YXJ0UGhhc2VUaW1lcihjdXJyZW50LCAnY29tcG9uZW50V2lsbFVubW91bnQnKTtcbiAgICBpbnN0YW5jZS5wcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gIH07XG5cbiAgLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cbiAgZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIGluc3RhbmNlKSB7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDIobnVsbCwgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyLCBudWxsLCBjdXJyZW50LCBpbnN0YW5jZSk7XG4gICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgIHZhciB1bm1vdW50RXJyb3IgPSBjbGVhckNhdWdodEVycm9yJDEoKTtcbiAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHVubW91bnRFcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQpIHtcbiAgICB2YXIgcmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMihudWxsLCByZWYsIG51bGwsIG51bGwpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IkMSgpKSB7XG4gICAgICAgICAgdmFyIHJlZkVycm9yID0gY2xlYXJDYXVnaHRFcnJvciQxKCk7XG4gICAgICAgICAgY2FwdHVyZUVycm9yKGN1cnJlbnQsIHJlZkVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3RhcnRQaGFzZVRpbWVyKGZpbmlzaGVkV29yaywgJ2NvbXBvbmVudERpZE1vdW50Jyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgICAgICAgICAgICBzdGFydFBoYXNlVGltZXIoZmluaXNoZWRXb3JrLCAnY29tcG9uZW50RGlkVXBkYXRlJyk7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgICAgIGluc3RhbmNlLnN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICAgIHN0b3BQaGFzZVRpbWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX3VwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgIGlmIChfdXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwgPyBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlIDogbnVsbDtcbiAgICAgICAgICAgIGNvbW1pdENhbGxiYWNrcyhfdXBkYXRlUXVldWUsIF9pbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgLy8gUmVuZGVyZXJzIG1heSBzY2hlZHVsZSB3b3JrIHRvIGJlIGRvbmUgYWZ0ZXIgaG9zdCBjb21wb25lbnRzIGFyZSBtb3VudGVkXG4gICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgICAgLy8gYWthIHdoZW4gdGhlcmUgaXMgbm8gY3VycmVudC9hbHRlcm5hdGUuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLmVmZmVjdFRhZyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgY29tbWl0TW91bnQoX2luc3RhbmNlMiwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gV2UgaGF2ZSBubyBsaWZlLWN5Y2xlcyBhc3NvY2lhdGVkIHdpdGggdGV4dC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbm8gbGlmZS1jeWNsZXMgYXNzb2NpYXRlZCB3aXRoIHBvcnRhbHMuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRBdHRhY2hSZWYoZmluaXNoZWRXb3JrKSB7XG4gICAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG4gICAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgcmVmKGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgcmVmKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXREZXRhY2hSZWYoY3VycmVudCkge1xuICAgIHZhciBjdXJyZW50UmVmID0gY3VycmVudC5yZWY7XG4gICAgaWYgKGN1cnJlbnRSZWYgIT09IG51bGwpIHtcbiAgICAgIGN1cnJlbnRSZWYobnVsbCk7XG4gICAgfVxuICB9XG5cbiAgLy8gVXNlci1vcmlnaW5hdGluZyBlcnJvcnMgKGxpZmVjeWNsZXMgYW5kIHJlZnMpIHNob3VsZCBub3QgaW50ZXJydXB0XG4gIC8vIGRlbGV0aW9uLCBzbyBkb24ndCBsZXQgdGhlbSB0aHJvdy4gSG9zdC1vcmlnaW5hdGluZyBlcnJvcnMgc2hvdWxkXG4gIC8vIGludGVycnVwdCBkZWxldGlvbiwgc28gaXQncyBva2F5XG4gIGZ1bmN0aW9uIGNvbW1pdFVubW91bnQoY3VycmVudCkge1xuICAgIGlmICh0eXBlb2Ygb25Db21taXRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvbkNvbW1pdFVubW91bnQoY3VycmVudCk7XG4gICAgfVxuXG4gICAgc3dpdGNoIChjdXJyZW50LnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgQ2FsbENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbW1pdE5lc3RlZFVubW91bnRzKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFRPRE86IHRoaXMgaXMgcmVjdXJzaXZlLlxuICAgICAgICAgIC8vIFdlIGFyZSBhbHNvIG5vdCB1c2luZyB0aGlzIHBhcmVudCBiZWNhdXNlXG4gICAgICAgICAgLy8gdGhlIHBvcnRhbCB3aWxsIGdldCBwdXNoZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgaWYgKGVuYWJsZU11dGF0aW5nUmVjb25jaWxlciAmJiBtdXRhdGlvbikge1xuICAgICAgICAgICAgdW5tb3VudEhvc3RDb21wb25lbnRzKGN1cnJlbnQpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZW5hYmxlUGVyc2lzdGVudFJlY29uY2lsZXIgJiYgcGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXROZXN0ZWRVbm1vdW50cyhyb290KSB7XG4gICAgLy8gV2hpbGUgd2UncmUgaW5zaWRlIGEgcmVtb3ZlZCBob3N0IG5vZGUgd2UgZG9uJ3Qgd2FudCB0byBjYWxsXG4gICAgLy8gcmVtb3ZlQ2hpbGQgb24gdGhlIGlubmVyIG5vZGVzIGJlY2F1c2UgdGhleSdyZSByZW1vdmVkIGJ5IHRoZSB0b3BcbiAgICAvLyBjYWxsIGFueXdheS4gV2UgYWxzbyB3YW50IHRvIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQgb24gYWxsXG4gICAgLy8gY29tcG9zaXRlcyBiZWZvcmUgdGhpcyBob3N0IG5vZGUgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0cmVlLiBUaGVyZWZvcmVcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGNvbW1pdFVubW91bnQobm9kZSk7XG4gICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHRoZXkgbWF5IGNvbnRhaW4gbW9yZSBjb21wb3NpdGUgb3IgaG9zdCBub2Rlcy5cbiAgICAgIC8vIFNraXAgcG9ydGFscyBiZWNhdXNlIGNvbW1pdFVubW91bnQoKSBjdXJyZW50bHkgdmlzaXRzIHRoZW0gcmVjdXJzaXZlbHkuXG4gICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCAmJiAoXG4gICAgICAvLyBJZiB3ZSB1c2UgbXV0YXRpb24gd2UgZHJpbGwgZG93biBpbnRvIHBvcnRhbHMgdXNpbmcgY29tbWl0VW5tb3VudCBhYm92ZS5cbiAgICAgIC8vIElmIHdlIGRvbid0IHVzZSBtdXRhdGlvbiB3ZSBkcmlsbCBkb3duIGludG8gcG9ydGFscyBoZXJlIGluc3RlYWQuXG4gICAgICAhbXV0YXRpb24gfHwgbm9kZS50YWcgIT09IEhvc3RQb3J0YWwpKSB7XG4gICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHJvb3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IHJvb3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgfVxuICAgICAgbm9kZS5zaWJsaW5nWydyZXR1cm4nXSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZXRhY2hGaWJlcihjdXJyZW50KSB7XG4gICAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXJzIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS4gSWRlYWxseSwgd2VcbiAgICAvLyBzaG91bGQgY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gICAgLy8gb25lIHNvIHdlJ2xsIHNldHRsZSBmb3IgR0M6aW5nIHRoZSBzdWJ0cmVlIG9mIHRoaXMgY2hpbGQuIFRoaXMgY2hpbGRcbiAgICAvLyBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAgIGN1cnJlbnRbJ3JldHVybiddID0gbnVsbDtcbiAgICBjdXJyZW50LmNoaWxkID0gbnVsbDtcbiAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUpIHtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlLmNoaWxkID0gbnVsbDtcbiAgICAgIGN1cnJlbnQuYWx0ZXJuYXRlWydyZXR1cm4nXSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFtdXRhdGlvbikge1xuICAgIHZhciBjb21taXRDb250YWluZXIgPSB2b2lkIDA7XG4gICAgaWYgKHBlcnNpc3RlbmNlKSB7XG4gICAgICB2YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gcGVyc2lzdGVuY2UucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuLFxuICAgICAgICAgIGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0ID0gcGVyc2lzdGVuY2UuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG5cbiAgICAgIHZhciBlbXB0eVBvcnRhbENvbnRhaW5lciA9IGZ1bmN0aW9uIChjdXJyZW50KSB7XG4gICAgICAgIHZhciBwb3J0YWwgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcblxuICAgICAgICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckluZm8pO1xuICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgZW1wdHlDaGlsZFNldCk7XG4gICAgICB9O1xuICAgICAgY29tbWl0Q29udGFpbmVyID0gZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge1xuICAgICAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcG9ydGFsT3JSb290ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbyxcbiAgICAgICAgICAgICAgICAgIF9wZW5kaW5nQ2hpbGRyZW4gPSBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGludmFyaWFudChmYWxzZSwgJ1RoaXMgdW5pdCBvZiB3b3JrIHRhZyBzaG91bGQgbm90IGhhdmUgc2lkZS1lZmZlY3RzLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRDb250YWluZXIgPSBmdW5jdGlvbiAoZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIC8vIE5vb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChlbmFibGVQZXJzaXN0ZW50UmVjb25jaWxlciB8fCBlbmFibGVOb29wUmVjb25jaWxlcikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdFBsYWNlbWVudDogZnVuY3Rpb24gKGZpbmlzaGVkV29yaykge30sXG4gICAgICAgIGNvbW1pdERlbGV0aW9uOiBmdW5jdGlvbiAoY3VycmVudCkge1xuICAgICAgICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMoY3VycmVudCk7XG4gICAgICAgICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gICAgICAgIH0sXG4gICAgICAgIGNvbW1pdFdvcms6IGZ1bmN0aW9uIChjdXJyZW50LCBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgICBjb21taXRDb250YWluZXIoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSxcblxuICAgICAgICBjb21taXRMaWZlQ3ljbGVzOiBjb21taXRMaWZlQ3ljbGVzLFxuICAgICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgICAgY29tbWl0RGV0YWNoUmVmOiBjb21taXREZXRhY2hSZWZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChwZXJzaXN0ZW5jZSkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnUGVyc2lzdGVudCByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdOb29wIHJlY29uY2lsZXIgaXMgZGlzYWJsZWQuJyk7XG4gICAgfVxuICB9XG4gIHZhciBjb21taXRNb3VudCA9IG11dGF0aW9uLmNvbW1pdE1vdW50LFxuICAgICAgY29tbWl0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VXBkYXRlLFxuICAgICAgcmVzZXRUZXh0Q29udGVudCA9IG11dGF0aW9uLnJlc2V0VGV4dENvbnRlbnQsXG4gICAgICBjb21taXRUZXh0VXBkYXRlID0gbXV0YXRpb24uY29tbWl0VGV4dFVwZGF0ZSxcbiAgICAgIGFwcGVuZENoaWxkID0gbXV0YXRpb24uYXBwZW5kQ2hpbGQsXG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gbXV0YXRpb24uYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcixcbiAgICAgIGluc2VydEJlZm9yZSA9IG11dGF0aW9uLmluc2VydEJlZm9yZSxcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gbXV0YXRpb24uaW5zZXJ0SW5Db250YWluZXJCZWZvcmUsXG4gICAgICByZW1vdmVDaGlsZCA9IG11dGF0aW9uLnJlbW92ZUNoaWxkLFxuICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyID0gbXV0YXRpb24ucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xuXG5cbiAgZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoaXNIb3N0UGFyZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICAgIH1cbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzSG9zdFBhcmVudChmaWJlcikge1xuICAgIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0U2libGluZyhmaWJlcikge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAgIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAgIC8vIHNlYXJjaCBwYXN0IHRoZW0uIFRoaXMgbGVhZHMgdG8gZXhwb25lbnRpYWwgc2VhcmNoIGZvciB0aGUgbmV4dCBzaWJsaW5nLlxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgc2libGluZ3M6IHdoaWxlICh0cnVlKSB7XG4gICAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlWydyZXR1cm4nXSA9PT0gbnVsbCB8fCBpc0hvc3RQYXJlbnQobm9kZVsncmV0dXJuJ10pKSB7XG4gICAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAgIC8vIFRyeSB0byBzZWFyY2ggZG93biB1bnRpbCB3ZSBmaW5kIG9uZS5cbiAgICAgICAgaWYgKG5vZGUuZWZmZWN0VGFnICYgUGxhY2VtZW50KSB7XG4gICAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG4gICAgICAgIGlmIChub2RlLmNoaWxkID09PSBudWxsIHx8IG5vZGUudGFnID09PSBIb3N0UG9ydGFsKSB7XG4gICAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuICAgICAgaWYgKCEobm9kZS5lZmZlY3RUYWcgJiBQbGFjZW1lbnQpKSB7XG4gICAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGluc2VydCBhbGwgaG9zdCBub2RlcyBpbnRvIHRoZSBwYXJlbnQuXG4gICAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG4gICAgdmFyIHBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgaXNDb250YWluZXIgPSB2b2lkIDA7XG4gICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICBpc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICBpc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICBwYXJlbnQgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgaXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0ludmFsaWQgaG9zdCBwYXJlbnQgZmliZXIuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICAgIGlmIChwYXJlbnRGaWJlci5lZmZlY3RUYWcgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgIHJlc2V0VGV4dENvbnRlbnQocGFyZW50KTtcbiAgICAgIC8vIENsZWFyIENvbnRlbnRSZXNldCBmcm9tIHRoZSBlZmZlY3QgdGFnXG4gICAgICBwYXJlbnRGaWJlci5lZmZlY3RUYWcgJj0gfkNvbnRlbnRSZXNldDtcbiAgICB9XG5cbiAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIG5vZGUuc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoaXNDb250YWluZXIpIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICAvLyBJZiB0aGUgaW5zZXJ0aW9uIGl0c2VsZiBpcyBhIHBvcnRhbCwgdGhlbiB3ZSBkb24ndCB3YW50IHRvIHRyYXZlcnNlXG4gICAgICAgIC8vIGRvd24gaXRzIGNoaWxkcmVuLiBJbnN0ZWFkLCB3ZSdsbCBnZXQgaW5zZXJ0aW9ucyBmcm9tIGVhY2ggY2hpbGQgaW5cbiAgICAgICAgLy8gdGhlIHBvcnRhbCBkaXJlY3RseS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkWydyZXR1cm4nXSA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgICBub2RlLnNpYmxpbmdbJ3JldHVybiddID0gbm9kZVsncmV0dXJuJ107XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVubW91bnRIb3N0Q29tcG9uZW50cyhjdXJyZW50KSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIHZhciBub2RlID0gY3VycmVudDtcblxuICAgIC8vIEVhY2ggaXRlcmF0aW9uLCBjdXJyZW50UGFyZW50IGlzIHBvcHVsYXRlZCB3aXRoIG5vZGUncyBob3N0IHBhcmVudCBpZiBub3RcbiAgICAvLyBjdXJyZW50UGFyZW50SXNWYWxpZC5cbiAgICB2YXIgY3VycmVudFBhcmVudElzVmFsaWQgPSBmYWxzZTtcbiAgICB2YXIgY3VycmVudFBhcmVudCA9IHZvaWQgMDtcbiAgICB2YXIgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdm9pZCAwO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICghY3VycmVudFBhcmVudElzVmFsaWQpIHtcbiAgICAgICAgdmFyIHBhcmVudCA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBmaW5kUGFyZW50OiB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICEocGFyZW50ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgICAgY3VycmVudFBhcmVudElzQ29udGFpbmVyID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFyZW50ID0gcGFyZW50WydyZXR1cm4nXTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50UGFyZW50SXNWYWxpZCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgY29tbWl0TmVzdGVkVW5tb3VudHMobm9kZSk7XG4gICAgICAgIC8vIEFmdGVyIGFsbCB0aGUgY2hpbGRyZW4gaGF2ZSB1bm1vdW50ZWQsIGl0IGlzIG5vdyBzYWZlIHRvIHJlbW92ZSB0aGVcbiAgICAgICAgLy8gbm9kZSBmcm9tIHRoZSB0cmVlLlxuICAgICAgICBpZiAoY3VycmVudFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGN1cnJlbnRQYXJlbnQsIG5vZGUuc3RhdGVOb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVDaGlsZChjdXJyZW50UGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG9uJ3QgdmlzaXQgY2hpbGRyZW4gYmVjYXVzZSB3ZSBhbHJlYWR5IHZpc2l0ZWQgdGhlbS5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgIC8vIFdlIHdpbGwgcmVhc3NpZ24gaXQgYmFjayB3aGVuIHdlIHBvcCB0aGUgcG9ydGFsIG9uIHRoZSB3YXkgdXAuXG4gICAgICAgIGN1cnJlbnRQYXJlbnQgPSBub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHBvcnRhbHMgbWlnaHQgY29udGFpbiBob3N0IGNvbXBvbmVudHMuXG4gICAgICAgIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgbm9kZS5jaGlsZFsncmV0dXJuJ10gPSBub2RlO1xuICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb21taXRVbm1vdW50KG5vZGUpO1xuICAgICAgICAvLyBWaXNpdCBjaGlsZHJlbiBiZWNhdXNlIHdlIG1heSBmaW5kIG1vcmUgaG9zdCBjb21wb25lbnRzIGJlbG93LlxuICAgICAgICBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5vZGUuY2hpbGRbJ3JldHVybiddID0gbm9kZTtcbiAgICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IGN1cnJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZVsncmV0dXJuJ10gPT09IG51bGwgfHwgbm9kZVsncmV0dXJuJ10gPT09IGN1cnJlbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVbJ3JldHVybiddO1xuICAgICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIG91dCBvZiB0aGUgcG9ydGFsLCB3ZSBuZWVkIHRvIHJlc3RvcmUgdGhlIHBhcmVudC5cbiAgICAgICAgICAvLyBTaW5jZSB3ZSBkb24ndCBrZWVwIGEgc3RhY2sgb2YgdGhlbSwgd2Ugd2lsbCBzZWFyY2ggZm9yIGl0LlxuICAgICAgICAgIGN1cnJlbnRQYXJlbnRJc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUuc2libGluZ1sncmV0dXJuJ10gPSBub2RlWydyZXR1cm4nXTtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RGVsZXRpb24oY3VycmVudCkge1xuICAgIC8vIFJlY3Vyc2l2ZWx5IGRlbGV0ZSBhbGwgaG9zdCBub2RlcyBmcm9tIHRoZSBwYXJlbnQuXG4gICAgLy8gRGV0YWNoIHJlZnMgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQoKSBvbiB0aGUgd2hvbGUgc3VidHJlZS5cbiAgICB1bm1vdW50SG9zdENvbXBvbmVudHMoY3VycmVudCk7XG4gICAgZGV0YWNoRmliZXIoY3VycmVudCk7XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRXb3JrKGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tbWl0IHRoZSB3b3JrIHByZXBhcmVkIGVhcmxpZXIuXG4gICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgIC8vIGFzIHRoZSBuZXdQcm9wcy4gVGhlIHVwZGF0ZVBheWxvYWQgd2lsbCBjb250YWluIHRoZSByZWFsIGNoYW5nZSBpblxuICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1Byb3BzO1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFR5cGUgdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHNwZWNpZmljIHRvIGhvc3QgY29tcG9uZW50cy5cbiAgICAgICAgICAgIHZhciB1cGRhdGVQYXlsb2FkID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgdXBkYXRlUGF5bG9hZCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAhKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnVGhpcyBzaG91bGQgaGF2ZSBhIHRleHQgbm9kZSBpbml0aWFsaXplZC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICB2YXIgdGV4dEluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAvLyB0aGlzIGNhc2UuXG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcbiAgICAgICAgICBjb21taXRUZXh0VXBkYXRlKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaW52YXJpYW50KGZhbHNlLCAnVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSZXNldFRleHRDb250ZW50KGN1cnJlbnQpIHtcbiAgICByZXNldFRleHRDb250ZW50KGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgfVxuXG4gIGlmIChlbmFibGVNdXRhdGluZ1JlY29uY2lsZXIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudDogY29tbWl0UmVzZXRUZXh0Q29udGVudCxcbiAgICAgIGNvbW1pdFBsYWNlbWVudDogY29tbWl0UGxhY2VtZW50LFxuICAgICAgY29tbWl0RGVsZXRpb246IGNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yazogY29tbWl0V29yayxcbiAgICAgIGNvbW1pdExpZmVDeWNsZXM6IGNvbW1pdExpZmVDeWNsZXMsXG4gICAgICBjb21taXRBdHRhY2hSZWY6IGNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZjogY29tbWl0RGV0YWNoUmVmXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpbnZhcmlhbnQoZmFsc2UsICdNdXRhdGluZyByZWNvbmNpbGVyIGlzIGRpc2FibGVkLicpO1xuICB9XG59O1xuXG52YXIgTk9fQ09OVEVYVCA9IHt9O1xuXG52YXIgUmVhY3RGaWJlckhvc3RDb250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9IGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0LFxuICAgICAgZ2V0Um9vdEhvc3RDb250ZXh0ID0gY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcblxuXG4gIHZhciBjb250ZXh0U3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTk9fQ09OVEVYVCk7XG4gIHZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOT19DT05URVhUKTtcbiAgdmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKE5PX0NPTlRFWFQpO1xuXG4gIGZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gICAgIShjICE9PSBOT19DT05URVhUKSA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICByZXR1cm4gYztcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICAgIHZhciByb290SW5zdGFuY2UgPSByZXF1aXJlZENvbnRleHQocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHB1c2hIb3N0Q29udGFpbmVyKGZpYmVyLCBuZXh0Um9vdEluc3RhbmNlKSB7XG4gICAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gICAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgICBwdXNoKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBuZXh0Um9vdEluc3RhbmNlLCBmaWJlcik7XG5cbiAgICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpO1xuXG4gICAgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAgIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuICAgIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvcEhvc3RDb250YWluZXIoZmliZXIpIHtcbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcmV0dXJuIGNvbnRleHQ7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoSG9zdENvbnRleHQoZmliZXIpIHtcbiAgICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICAgIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUsIHJvb3RJbnN0YW5jZSk7XG5cbiAgICAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cbiAgICBpZiAoY29udGV4dCA9PT0gbmV4dENvbnRleHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICAgIC8vIERvIG5vdCBwb3AgdW5sZXNzIHRoaXMgRmliZXIgcHJvdmlkZWQgdGhlIGN1cnJlbnQgY29udGV4dC5cbiAgICAvLyBwdXNoSG9zdENvbnRleHQoKSBvbmx5IHB1c2hlcyBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cbiAgICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gZmliZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gICAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEhvc3RDb250YWluZXIoKSB7XG4gICAgY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICAgIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQgPSBOT19DT05URVhUO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBnZXRIb3N0Q29udGV4dDogZ2V0SG9zdENvbnRleHQsXG4gICAgZ2V0Um9vdEhvc3RDb250YWluZXI6IGdldFJvb3RIb3N0Q29udGFpbmVyLFxuICAgIHBvcEhvc3RDb250YWluZXI6IHBvcEhvc3RDb250YWluZXIsXG4gICAgcG9wSG9zdENvbnRleHQ6IHBvcEhvc3RDb250ZXh0LFxuICAgIHB1c2hIb3N0Q29udGFpbmVyOiBwdXNoSG9zdENvbnRhaW5lcixcbiAgICBwdXNoSG9zdENvbnRleHQ6IHB1c2hIb3N0Q29udGV4dCxcbiAgICByZXNldEhvc3RDb250YWluZXI6IHJlc2V0SG9zdENvbnRhaW5lclxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0ID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICB2YXIgc2hvdWxkU2V0VGV4dENvbnRlbnQgPSBjb25maWcuc2hvdWxkU2V0VGV4dENvbnRlbnQsXG4gICAgICBoeWRyYXRpb24gPSBjb25maWcuaHlkcmF0aW9uO1xuXG4gIC8vIElmIHRoaXMgZG9lc24ndCBoYXZlIGh5ZHJhdGlvbiBtb2RlLlxuXG4gIGlmICghaHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSxcbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGU6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2U6IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSxcbiAgICAgIHBvcEh5ZHJhdGlvblN0YXRlOiBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICB2YXIgY2FuSHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmNhbkh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSxcbiAgICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9IGh5ZHJhdGlvbi5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcsXG4gICAgICBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9IGh5ZHJhdGlvbi5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCxcbiAgICAgIGh5ZHJhdGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5oeWRyYXRlSW5zdGFuY2UsXG4gICAgICBoeWRyYXRlVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmh5ZHJhdGVUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRDb250YWluZXJUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RNYXRjaEh5ZHJhdGVkVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2UsXG4gICAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90SHlkcmF0ZUNvbnRhaW5lckluc3RhbmNlLFxuICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEh5ZHJhdGVJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZSxcbiAgICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlID0gaHlkcmF0aW9uLmRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvbi5kaWROb3RGaW5kSHlkcmF0YWJsZUluc3RhbmNlLFxuICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSBoeWRyYXRpb24uZGlkTm90RmluZEh5ZHJhdGFibGVUZXh0SW5zdGFuY2U7XG5cbiAgLy8gVGhlIGRlZXBlc3QgRmliZXIgb24gdGhlIHN0YWNrIGludm9sdmVkIGluIGEgaHlkcmF0aW9uIGNvbnRleHQuXG4gIC8vIFRoaXMgbWF5IGhhdmUgYmVlbiBhbiBpbnNlcnRpb24gb3IgYSBoeWRyYXRpb24uXG5cbiAgdmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbiAgdmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICB2YXIgaXNIeWRyYXRpbmcgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBlbnRlckh5ZHJhdGlvblN0YXRlKGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKHBhcmVudEluc3RhbmNlKTtcbiAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZUh5ZHJhdGFibGVJbnN0YW5jZShyZXR1cm5GaWJlciwgaW5zdGFuY2UpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIGRpZE5vdEh5ZHJhdGVDb250YWluZXJJbnN0YW5jZShyZXR1cm5GaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbywgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlKHJldHVybkZpYmVyLnR5cGUsIHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHMsIHJldHVybkZpYmVyLnN0YXRlTm9kZSwgaW5zdGFuY2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3JlYXRlRmliZXJGcm9tSG9zdEluc3RhbmNlRm9yRGVsZXRpb24oKTtcbiAgICBjaGlsZFRvRGVsZXRlLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgIGNoaWxkVG9EZWxldGVbJ3JldHVybiddID0gcmV0dXJuRmliZXI7XG4gICAgY2hpbGRUb0RlbGV0ZS5lZmZlY3RUYWcgPSBEZWxldGlvbjtcblxuICAgIC8vIFRoaXMgbWlnaHQgc2VlbSBsaWtlIGl0IGJlbG9uZ3Mgb24gcHJvZ3Jlc3NlZEZpcnN0RGVsZXRpb24uIEhvd2V2ZXIsXG4gICAgLy8gdGhlc2UgY2hpbGRyZW4gYXJlIG5vdCBwYXJ0IG9mIHRoZSByZWNvbmNpbGlhdGlvbiBsaXN0IG9mIGNoaWxkcmVuLlxuICAgIC8vIEV2ZW4gaWYgd2UgYWJvcnQgYW5kIHJlcmVjb25jaWxlIHRoZSBjaGlsZHJlbiwgdGhhdCB3aWxsIHRyeSB0byBoeWRyYXRlXG4gICAgLy8gYWdhaW4gYW5kIHRoZSBub2RlcyBhcmUgc3RpbGwgaW4gdGhlIGhvc3QgdHJlZSBzbyB0aGVzZSB3aWxsIGJlXG4gICAgLy8gcmVjcmVhdGVkLlxuICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID0gcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShyZXR1cm5GaWJlciwgZmliZXIpIHtcbiAgICBmaWJlci5lZmZlY3RUYWcgfD0gUGxhY2VtZW50O1xuICAgIHtcbiAgICAgIHN3aXRjaCAocmV0dXJuRmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudENvbnRhaW5lciA9IHJldHVybkZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVDb250YWluZXJJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZUNvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhcmVudFR5cGUgPSByZXR1cm5GaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwYXJlbnRJbnN0YW5jZSA9IHJldHVybkZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICB2YXIgX3R5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgICAgIHZhciBfcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90eXBlLCBfcHJvcHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgICAgICAgICAgIHZhciBfdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICBkaWROb3RGaW5kSHlkcmF0YWJsZVRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIF90ZXh0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2FuSHlkcmF0ZShmaWJlciwgbmV4dEluc3RhbmNlKSB7XG4gICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgcmV0dXJuIGNhbkh5ZHJhdGVJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICAgICAgICAgIHJldHVybiBjYW5IeWRyYXRlVGV4dEluc3RhbmNlKG5leHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICAgIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG4gICAgaWYgKCFuZXh0SW5zdGFuY2UpIHtcbiAgICAgIC8vIE5vdGhpbmcgdG8gaHlkcmF0ZS4gTWFrZSBpdCBhbiBpbnNlcnRpb24uXG4gICAgICBpbnNlcnROb25IeWRyYXRlZEluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFjYW5IeWRyYXRlKGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgICAvLyBJZiB3ZSBjYW4ndCBoeWRyYXRlIHRoaXMgaW5zdGFuY2UgbGV0J3MgdHJ5IHRoZSBuZXh0IG9uZS5cbiAgICAgIC8vIFdlIHVzZSB0aGlzIGFzIGEgaGV1cmlzdGljLiBJdCdzIGJhc2VkIG9uIGludHVpdGlvbiBhbmQgbm90IGRhdGEgc28gaXRcbiAgICAgIC8vIG1pZ2h0IGJlIGZsYXdlZCBvciB1bm5lY2Vzc2FyeS5cbiAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIWNhbkh5ZHJhdGUoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gTm90aGluZyB0byBoeWRyYXRlLiBNYWtlIGl0IGFuIGluc2VydGlvbi5cbiAgICAgICAgaW5zZXJ0Tm9uSHlkcmF0ZWRJbnN0YW5jZShoeWRyYXRpb25QYXJlbnRGaWJlciwgZmliZXIpO1xuICAgICAgICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICAvLyBXZSBtYXRjaGVkIHRoZSBuZXh0IG9uZSwgd2UnbGwgbm93IGFzc3VtZSB0aGF0IHRoZSBmaXJzdCBvbmUgd2FzXG4gICAgICAvLyBzdXBlcmZsdW91cyBhbmQgd2UnbGwgZGVsZXRlIGl0LiBTaW5jZSB3ZSBjYW4ndCBlYWdlcmx5IGRlbGV0ZSBpdFxuICAgICAgLy8gd2UnbGwgaGF2ZSB0byBzY2hlZHVsZSBhIGRlbGV0aW9uLiBUbyBkbyB0aGF0LCB0aGlzIG5vZGUgbmVlZHMgYSBkdW1teVxuICAgICAgLy8gZmliZXIgYXNzb2NpYXRlZCB3aXRoIGl0LlxuICAgICAgZGVsZXRlSHlkcmF0YWJsZUluc3RhbmNlKGh5ZHJhdGlvblBhcmVudEZpYmVyLCBuZXh0SHlkcmF0YWJsZUluc3RhbmNlKTtcbiAgICB9XG4gICAgZmliZXIuc3RhdGVOb2RlID0gbmV4dEluc3RhbmNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKG5leHRJbnN0YW5jZSk7XG4gIH1cblxuICBmdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB1cGRhdGVQYXlsb2FkID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBmaWJlcik7XG4gICAgLy8gVE9ETzogVHlwZSB0aGlzIHNwZWNpZmljIHRvIHRoaXMgdHlwZSBvZiBjb21wb25lbnQuXG4gICAgZmliZXIudXBkYXRlUXVldWUgPSB1cGRhdGVQYXlsb2FkO1xuICAgIC8vIElmIHRoZSB1cGRhdGUgcGF5bG9hZCBpbmRpY2F0ZXMgdGhhdCB0aGVyZSBpcyBhIGNoYW5nZSBvciBpZiB0aGVyZVxuICAgIC8vIGlzIGEgbmV3IHJlZiB3ZSBtYXJrIHRoaXMgYXMgYW4gdXBkYXRlLlxuICAgIGlmICh1cGRhdGVQYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICAgIHZhciB0ZXh0Q29udGVudCA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIpO1xuICAgIHtcbiAgICAgIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAgICAgLy8gV2UgYXNzdW1lIHRoYXQgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UgaXMgY2FsbGVkIGluIGEgY29udGV4dCB3aGVyZSB0aGVcbiAgICAgICAgLy8gaHlkcmF0aW9uIHBhcmVudCBpcyB0aGUgcGFyZW50IGhvc3QgY29tcG9uZW50IG9mIHRoaXMgaG9zdCB0ZXh0LlxuICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcbiAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gcmV0dXJuRmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZENvbnRhaW5lclRleHRJbnN0YW5jZShwYXJlbnRDb250YWluZXIsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50VHlwZSA9IHJldHVybkZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudFByb3BzID0gcmV0dXJuRmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50SW5zdGFuY2UgPSByZXR1cm5GaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgZGlkTm90TWF0Y2hIeWRyYXRlZFRleHRJbnN0YW5jZShwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaG91bGRVcGRhdGU7XG4gIH1cblxuICBmdW5jdGlvbiBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKSB7XG4gICAgdmFyIHBhcmVudCA9IGZpYmVyWydyZXR1cm4nXTtcbiAgICB3aGlsZSAocGFyZW50ICE9PSBudWxsICYmIHBhcmVudC50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgcGFyZW50LnRhZyAhPT0gSG9zdFJvb3QpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudFsncmV0dXJuJ107XG4gICAgfVxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gcGFyZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgICBpZiAoZmliZXIgIT09IGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgICAvLyB0cmVlLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgICAgLy8gd2Ugd2VyZSBhbiBpbnNlcnRpb24gYW5kIG5vdyBuZWVkIHRvIHBvcCB1cCByZWVudGVyIGh5ZHJhdGlvbiBvZiBvdXJcbiAgICAgIC8vIHNpYmxpbmdzLlxuICAgICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS5cbiAgICAvLyBUT0RPOiBCZXR0ZXIgaGV1cmlzdGljLlxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQgfHwgdHlwZSAhPT0gJ2hlYWQnICYmIHR5cGUgIT09ICdib2R5JyAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpIHtcbiAgICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuICAgICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgICBkZWxldGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBoeWRyYXRpb25QYXJlbnRGaWJlciA/IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhmaWJlci5zdGF0ZU5vZGUpIDogbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIGlzSHlkcmF0aW5nID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVudGVySHlkcmF0aW9uU3RhdGU6IGVudGVySHlkcmF0aW9uU3RhdGUsXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZTogcmVzZXRIeWRyYXRpb25TdGF0ZSxcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZTogdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UsXG4gICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSxcbiAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZTogcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UsXG4gICAgcG9wSHlkcmF0aW9uU3RhdGU6IHBvcEh5ZHJhdGlvblN0YXRlXG4gIH07XG59O1xuXG4vLyBUaGlzIGxldHMgdXMgaG9vayBpbnRvIEZpYmVyIHRvIGRlYnVnIHdoYXQgaXQncyBkb2luZy5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC84MDMzLlxuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIEFQSSwgbm90IGV2ZW4gZm9yIFJlYWN0IERldlRvb2xzLlxuLy8gWW91IG1heSBvbmx5IGluamVjdCBhIGRlYnVnVG9vbCBpZiB5b3Ugd29yayBvbiBSZWFjdCBGaWJlciBpdHNlbGYuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbiA9IHtcbiAgZGVidWdUb29sOiBudWxsXG59O1xuXG52YXIgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xID0gUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbjtcblxudmFyIGRlZmF1bHRTaG93RGlhbG9nID0gZnVuY3Rpb24gKGNhcHR1cmVkRXJyb3IpIHtcbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgc2hvd0RpYWxvZyA9IGRlZmF1bHRTaG93RGlhbG9nO1xuXG5mdW5jdGlvbiBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpIHtcbiAgdmFyIGxvZ0Vycm9yID0gc2hvd0RpYWxvZyhjYXB0dXJlZEVycm9yKTtcblxuICAvLyBBbGxvdyBpbmplY3RlZCBzaG93RGlhbG9nKCkgdG8gcHJldmVudCBkZWZhdWx0IGNvbnNvbGUuZXJyb3IgbG9nZ2luZy5cbiAgLy8gVGhpcyBlbmFibGVzIHJlbmRlcmVycyBsaWtlIFJlYWN0TmF0aXZlIHRvIGJldHRlciBtYW5hZ2UgcmVkYm94IGJlaGF2aW9yLlxuICBpZiAobG9nRXJyb3IgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY2FwdHVyZWRFcnJvci5jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjayA9IGNhcHR1cmVkRXJyb3IuY29tcG9uZW50U3RhY2ssXG4gICAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5TmFtZSxcbiAgICAgICAgZXJyb3JCb3VuZGFyeUZvdW5kID0gY2FwdHVyZWRFcnJvci5lcnJvckJvdW5kYXJ5Rm91bmQsXG4gICAgICAgIHdpbGxSZXRyeSA9IGNhcHR1cmVkRXJyb3Iud2lsbFJldHJ5O1xuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPCcgKyBjb21wb25lbnROYW1lICsgJz4gY29tcG9uZW50OicgOiAnVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIG9uZSBvZiB5b3VyIFJlYWN0IGNvbXBvbmVudHM6JztcblxuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9IHZvaWQgMDtcbiAgICAvLyBlcnJvckJvdW5kYXJ5Rm91bmQgY2hlY2sgaXMgc3VmZmljaWVudDsgZXJyb3JCb3VuZGFyeU5hbWUgY2hlY2sgaXMgdG8gc2F0aXNmeSBGbG93LlxuICAgIGlmIChlcnJvckJvdW5kYXJ5Rm91bmQgJiYgZXJyb3JCb3VuZGFyeU5hbWUpIHtcbiAgICAgIGlmICh3aWxsUmV0cnkpIHtcbiAgICAgICAgZXJyb3JCb3VuZGFyeU1lc3NhZ2UgPSAnUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggJyArICgndXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgJyArIGVycm9yQm91bmRhcnlOYW1lICsgJy4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ1RoaXMgZXJyb3Igd2FzIGluaXRpYWxseSBoYW5kbGVkIGJ5IHRoZSBlcnJvciBib3VuZGFyeSAnICsgZXJyb3JCb3VuZGFyeU5hbWUgKyAnLlxcbicgKyAnUmVjcmVhdGluZyB0aGUgdHJlZSBmcm9tIHNjcmF0Y2ggZmFpbGVkIHNvIFJlYWN0IHdpbGwgdW5tb3VudCB0aGUgdHJlZS4nO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vZmIubWUvcmVhY3QtZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcbiAgICB9XG4gICAgdmFyIGNvbWJpbmVkTWVzc2FnZSA9ICcnICsgY29tcG9uZW50TmFtZU1lc3NhZ2UgKyBjb21wb25lbnRTdGFjayArICdcXG5cXG4nICsgKCcnICsgZXJyb3JCb3VuZGFyeU1lc3NhZ2UpO1xuXG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIHdlIHByb3ZpZGUgb3VyIG93biBtZXNzYWdlIHdpdGgganVzdCB0aGUgY29tcG9uZW50IHN0YWNrLlxuICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGhlIG9yaWdpbmFsIGVycm9yIG1lc3NhZ2UgYW5kIEpTIHN0YWNrIGJlY2F1c2UgdGhlIGJyb3dzZXJcbiAgICAvLyBoYXMgYWxyZWFkeSBwcmludGVkIGl0LiBFdmVuIGlmIHRoZSBhcHBsaWNhdGlvbiBzd2FsbG93cyB0aGUgZXJyb3IsIGl0IGlzIHN0aWxsXG4gICAgLy8gZGlzcGxheWVkIGJ5IHRoZSBicm93c2VyIHRoYW5rcyB0byB0aGUgREVWLW9ubHkgZmFrZSBldmVudCB0cmljayBpbiBSZWFjdEVycm9yVXRpbHMuXG4gICAgY29uc29sZS5lcnJvcihjb21iaW5lZE1lc3NhZ2UpO1xuICB9XG59XG5cbnZhciBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMSA9IFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2s7XG52YXIgaGFzQ2F1Z2h0RXJyb3IgPSBSZWFjdEVycm9yVXRpbHMuaGFzQ2F1Z2h0RXJyb3I7XG52YXIgY2xlYXJDYXVnaHRFcnJvciA9IFJlYWN0RXJyb3JVdGlscy5jbGVhckNhdWdodEVycm9yO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IGZhbHNlO1xuICB2YXIgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gZmFsc2U7XG4gIHZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnQgPSB7fTtcblxuICB2YXIgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmliZXIpIHx8ICdSZWFjdENsYXNzJztcbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yVW5tb3VudGVkQ29tcG9uZW50W2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHdhcm5pbmcoZmFsc2UsICdDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nICcgKyAnY29tcG9uZW50LiBUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCBzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCAnICsgJ29yIGZvcmNlVXBkYXRlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuIFRoaXMgaXMgYSBuby1vcC5cXG5cXG5QbGVhc2UgJyArICdjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjb21wb25lbnROYW1lKTtcbiAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JVbm1vdW50ZWRDb21wb25lbnRbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICB9O1xuXG4gIHZhciB3YXJuQWJvdXRJbnZhbGlkVXBkYXRlcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICAgIHN3aXRjaCAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSkge1xuICAgICAgY2FzZSAnZ2V0Q2hpbGRDb250ZXh0JzpcbiAgICAgICAgaWYgKGRpZFdhcm5TZXRTdGF0ZUNoaWxkQ29udGV4dCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnc2V0U3RhdGUoLi4uKTogQ2Fubm90IGNhbGwgc2V0U3RhdGUoKSBpbnNpZGUgZ2V0Q2hpbGRDb250ZXh0KCknKTtcbiAgICAgICAgZGlkV2FyblNldFN0YXRlQ2hpbGRDb250ZXh0ID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyZW5kZXInOlxuICAgICAgICBpZiAoZGlkV2FybkFib3V0U3RhdGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzIHdpdGhpbiAnICsgXCJgcmVuZGVyYCBvciBhbm90aGVyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIFwiICsgJ2JlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7IGNvbnN0cnVjdG9yIHNpZGUtZWZmZWN0cyBhcmUgJyArICdhbiBhbnRpLXBhdHRlcm4sIGJ1dCBjYW4gYmUgbW92ZWQgdG8gYGNvbXBvbmVudFdpbGxNb3VudGAuJyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFN0YXRlVHJhbnNpdGlvbiA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfTtcbn1cblxudmFyIFJlYWN0RmliZXJTY2hlZHVsZXIgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBob3N0Q29udGV4dCA9IFJlYWN0RmliZXJIb3N0Q29udGV4dChjb25maWcpO1xuICB2YXIgaHlkcmF0aW9uQ29udGV4dCA9IFJlYWN0RmliZXJIeWRyYXRpb25Db250ZXh0KGNvbmZpZyk7XG4gIHZhciBwb3BIb3N0Q29udGFpbmVyID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRhaW5lcixcbiAgICAgIHBvcEhvc3RDb250ZXh0ID0gaG9zdENvbnRleHQucG9wSG9zdENvbnRleHQsXG4gICAgICByZXNldEhvc3RDb250YWluZXIgPSBob3N0Q29udGV4dC5yZXNldEhvc3RDb250YWluZXI7XG5cbiAgdmFyIF9SZWFjdEZpYmVyQmVnaW5Xb3JrID0gUmVhY3RGaWJlckJlZ2luV29yayhjb25maWcsIGhvc3RDb250ZXh0LCBoeWRyYXRpb25Db250ZXh0LCBzY2hlZHVsZVdvcmssIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIpLFxuICAgICAgYmVnaW5Xb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5Xb3JrLFxuICAgICAgYmVnaW5GYWlsZWRXb3JrID0gX1JlYWN0RmliZXJCZWdpbldvcmsuYmVnaW5GYWlsZWRXb3JrO1xuXG4gIHZhciBfUmVhY3RGaWJlckNvbXBsZXRlV28gPSBSZWFjdEZpYmVyQ29tcGxldGVXb3JrKGNvbmZpZywgaG9zdENvbnRleHQsIGh5ZHJhdGlvbkNvbnRleHQpLFxuICAgICAgY29tcGxldGVXb3JrID0gX1JlYWN0RmliZXJDb21wbGV0ZVdvLmNvbXBsZXRlV29yaztcblxuICB2YXIgX1JlYWN0RmliZXJDb21taXRXb3JrID0gUmVhY3RGaWJlckNvbW1pdFdvcmsoY29uZmlnLCBjYXB0dXJlRXJyb3IpLFxuICAgICAgY29tbWl0UmVzZXRUZXh0Q29udGVudCA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRSZXNldFRleHRDb250ZW50LFxuICAgICAgY29tbWl0UGxhY2VtZW50ID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdFBsYWNlbWVudCxcbiAgICAgIGNvbW1pdERlbGV0aW9uID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdERlbGV0aW9uLFxuICAgICAgY29tbWl0V29yayA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRXb3JrLFxuICAgICAgY29tbWl0TGlmZUN5Y2xlcyA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXRMaWZlQ3ljbGVzLFxuICAgICAgY29tbWl0QXR0YWNoUmVmID0gX1JlYWN0RmliZXJDb21taXRXb3JrLmNvbW1pdEF0dGFjaFJlZixcbiAgICAgIGNvbW1pdERldGFjaFJlZiA9IF9SZWFjdEZpYmVyQ29tbWl0V29yay5jb21taXREZXRhY2hSZWY7XG5cbiAgdmFyIG5vdyA9IGNvbmZpZy5ub3csXG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2sgPSBjb25maWcuc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrLFxuICAgICAgdXNlU3luY1NjaGVkdWxpbmcgPSBjb25maWcudXNlU3luY1NjaGVkdWxpbmcsXG4gICAgICBwcmVwYXJlRm9yQ29tbWl0ID0gY29uZmlnLnByZXBhcmVGb3JDb21taXQsXG4gICAgICByZXNldEFmdGVyQ29tbWl0ID0gY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG5cbiAgLy8gUmVwcmVzZW50cyB0aGUgY3VycmVudCB0aW1lIGluIG1zLlxuXG4gIHZhciBzdGFydFRpbWUgPSBub3coKTtcbiAgdmFyIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZSgwKTtcblxuICAvLyBSZXByZXNlbnRzIHRoZSBleHBpcmF0aW9uIHRpbWUgdGhhdCBpbmNvbWluZyB1cGRhdGVzIHNob3VsZCB1c2UuIChJZiB0aGlzXG4gIC8vIGlzIE5vV29yaywgdXNlIHRoZSBkZWZhdWx0IHN0cmF0ZWd5OiBhc3luYyB1cGRhdGVzIGluIGFzeW5jIG1vZGUsIHN5bmNcbiAgLy8gdXBkYXRlcyBpbiBzeW5jIG1vZGUuKVxuICB2YXIgZXhwaXJhdGlvbkNvbnRleHQgPSBOb1dvcms7XG5cbiAgdmFyIGlzV29ya2luZyA9IGZhbHNlO1xuXG4gIC8vIFRoZSBuZXh0IHdvcmsgaW4gcHJvZ3Jlc3MgZmliZXIgdGhhdCB3ZSdyZSBjdXJyZW50bHkgd29ya2luZyBvbi5cbiAgdmFyIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgdmFyIG5leHRSb290ID0gbnVsbDtcbiAgLy8gVGhlIHRpbWUgYXQgd2hpY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZyB3b3JrLlxuICB2YXIgbmV4dFJlbmRlckV4cGlyYXRpb25UaW1lID0gTm9Xb3JrO1xuXG4gIC8vIFRoZSBuZXh0IGZpYmVyIHdpdGggYW4gZWZmZWN0IHRoYXQgd2UncmUgY3VycmVudGx5IGNvbW1pdHRpbmcuXG4gIHZhciBuZXh0RWZmZWN0ID0gbnVsbDtcblxuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGNhcHR1cmVkIGFuIGVycm9yIHRoYXQgbmVlZCB0byBiZSBoYW5kbGVkLlxuICAvLyBXb3JrIGlzIHJlbW92ZWQgZnJvbSB0aGlzIGNvbGxlY3Rpb24gYWZ0ZXIgY29tcG9uZW50RGlkQ2F0Y2ggaXMgY2FsbGVkLlxuICB2YXIgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGZpYmVycyBoYXZlIGZhaWxlZCBkdXJpbmcgdGhlIGN1cnJlbnQgYmF0Y2ggb2Ygd29yay5cbiAgLy8gVGhpcyBpcyBhIGRpZmZlcmVudCBzZXQgdGhhbiBjYXB0dXJlZEVycm9ycywgYmVjYXVzZSBpdCBpcyBub3QgcmVzZXQgdW50aWxcbiAgLy8gdGhlIGVuZCBvZiB0aGUgYmF0Y2guIFRoaXMgaXMgbmVlZGVkIHRvIHByb3BhZ2F0ZSBlcnJvcnMgY29ycmVjdGx5IGlmIGFcbiAgLy8gc3VidHJlZSBmYWlscyBtb3JlIHRoYW4gb25jZS5cbiAgdmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xuICAvLyBFcnJvciBib3VuZGFyaWVzIHRoYXQgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoZSBjdXJyZW50IGNvbW1pdC5cbiAgdmFyIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gIHZhciBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICB2YXIgZGlkRmF0YWwgPSBmYWxzZTtcblxuICB2YXIgaXNDb21taXR0aW5nID0gZmFsc2U7XG4gIHZhciBpc1VubW91bnRpbmcgPSBmYWxzZTtcblxuICAvLyBVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy5cbiAgdmFyIGludGVycnVwdGVkQnkgPSBudWxsO1xuXG4gIGZ1bmN0aW9uIHJlc2V0Q29udGV4dFN0YWNrKCkge1xuICAgIC8vIFJlc2V0IHRoZSBzdGFja1xuICAgIHJlc2V0JDEoKTtcbiAgICAvLyBSZXNldCB0aGUgY3Vyc29yc1xuICAgIHJlc2V0Q29udGV4dCgpO1xuICAgIHJlc2V0SG9zdENvbnRhaW5lcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0QWxsSG9zdEVmZmVjdHMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIobmV4dEVmZmVjdCk7XG4gICAgICB9XG4gICAgICByZWNvcmRFZmZlY3QoKTtcblxuICAgICAgdmFyIGVmZmVjdFRhZyA9IG5leHRFZmZlY3QuZWZmZWN0VGFnO1xuICAgICAgaWYgKGVmZmVjdFRhZyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICBjb21taXRSZXNldFRleHRDb250ZW50KG5leHRFZmZlY3QpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZWZmZWN0VGFnICYgUmVmKSB7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0RGV0YWNoUmVmKGN1cnJlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgc3dpdGNoIHN0YXRlbWVudCBpcyBvbmx5IGNvbmNlcm5lZCBhYm91dCBwbGFjZW1lbnQsXG4gICAgICAvLyB1cGRhdGVzLCBhbmQgZGVsZXRpb25zLiBUbyBhdm9pZCBuZWVkaW5nIHRvIGFkZCBhIGNhc2UgZm9yIGV2ZXJ5XG4gICAgICAvLyBwb3NzaWJsZSBiaXRtYXAgdmFsdWUsIHdlIHJlbW92ZSB0aGUgc2Vjb25kYXJ5IGVmZmVjdHMgZnJvbSB0aGVcbiAgICAgIC8vIGVmZmVjdCB0YWcgYW5kIHN3aXRjaCBvbiB0aGF0IHZhbHVlLlxuICAgICAgdmFyIHByaW1hcnlFZmZlY3RUYWcgPSBlZmZlY3RUYWcgJiB+KENhbGxiYWNrIHwgRXJyIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgUGVyZm9ybWVkV29yayk7XG4gICAgICBzd2l0Y2ggKHByaW1hcnlFZmZlY3RUYWcpIHtcbiAgICAgICAgY2FzZSBQbGFjZW1lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBmaW5kRE9NTm9kZSBkb2Vzbid0IHJlbHkgb24gdGhpcyBhbnkgbW9yZSBidXQgaXNNb3VudGVkXG4gICAgICAgICAgICAvLyBkb2VzIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGVcbiAgICAgICAgICAgIC8vIHRvIGtpbGwgdGhpcy5cbiAgICAgICAgICAgIG5leHRFZmZlY3QuZWZmZWN0VGFnICY9IH5QbGFjZW1lbnQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgUGxhY2VtZW50QW5kVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIC8vIFBsYWNlbWVudFxuICAgICAgICAgICAgY29tbWl0UGxhY2VtZW50KG5leHRFZmZlY3QpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXMgaW5zZXJ0ZWQsIGJlZm9yZVxuICAgICAgICAgICAgLy8gYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgICAgICAgICBuZXh0RWZmZWN0LmVmZmVjdFRhZyAmPSB+UGxhY2VtZW50O1xuXG4gICAgICAgICAgICAvLyBVcGRhdGVcbiAgICAgICAgICAgIHZhciBfY3VycmVudCA9IG5leHRFZmZlY3QuYWx0ZXJuYXRlO1xuICAgICAgICAgICAgY29tbWl0V29yayhfY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIGNhc2UgVXBkYXRlOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3VycmVudDIgPSBuZXh0RWZmZWN0LmFsdGVybmF0ZTtcbiAgICAgICAgICAgIGNvbW1pdFdvcmsoX2N1cnJlbnQyLCBuZXh0RWZmZWN0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBEZWxldGlvbjpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgY29tbWl0RGVsZXRpb24obmV4dEVmZmVjdCk7XG4gICAgICAgICAgICBpc1VubW91bnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgfVxuXG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbW1pdEFsbExpZmVDeWNsZXMoKSB7XG4gICAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgIHZhciBlZmZlY3RUYWcgPSBuZXh0RWZmZWN0LmVmZmVjdFRhZztcblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIChVcGRhdGUgfCBDYWxsYmFjaykpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIHZhciBjdXJyZW50ID0gbmV4dEVmZmVjdC5hbHRlcm5hdGU7XG4gICAgICAgIGNvbW1pdExpZmVDeWNsZXMoY3VycmVudCwgbmV4dEVmZmVjdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlZmZlY3RUYWcgJiBSZWYpIHtcbiAgICAgICAgcmVjb3JkRWZmZWN0KCk7XG4gICAgICAgIGNvbW1pdEF0dGFjaFJlZihuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVmZmVjdFRhZyAmIEVycikge1xuICAgICAgICByZWNvcmRFZmZlY3QoKTtcbiAgICAgICAgY29tbWl0RXJyb3JIYW5kbGluZyhuZXh0RWZmZWN0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5leHQgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSBjbGVhbiB0aGVzZSB1cCBzbyB0aGF0IHdlIGRvbid0IGFjY2lkZW50YWxseSBrZWVwIHRoZW0uXG4gICAgICAvLyBJJ20gbm90IGFjdHVhbGx5IHN1cmUgdGhpcyBtYXR0ZXJzIGJlY2F1c2Ugd2UgY2FuJ3QgcmVzZXQgZmlyc3RFZmZlY3RcbiAgICAgIC8vIGFuZCBsYXN0RWZmZWN0IHNpbmNlIHRoZXkncmUgb24gZXZlcnkgbm9kZSwgbm90IGp1c3QgdGhlIGVmZmVjdGZ1bFxuICAgICAgLy8gb25lcy4gU28gd2UgaGF2ZSB0byBjbGVhbiBldmVyeXRoaW5nIGFzIHdlIHJldXNlIG5vZGVzIGFueXdheS5cbiAgICAgIG5leHRFZmZlY3QubmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICAvLyBFbnN1cmUgdGhhdCB3ZSByZXNldCB0aGUgZWZmZWN0VGFnIGhlcmUgc28gdGhhdCB3ZSBjYW4gcmVseSBvbiBlZmZlY3RcbiAgICAgIC8vIHRhZ3MgdG8gcmVhc29uIGFib3V0IHRoZSBjdXJyZW50IGxpZmUtY3ljbGUuXG4gICAgICBuZXh0RWZmZWN0ID0gbmV4dDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb21taXRSb290KGZpbmlzaGVkV29yaykge1xuICAgIC8vIFdlIGtlZXAgdHJhY2sgb2YgdGhpcyBzbyB0aGF0IGNhcHR1cmVFcnJvciBjYW4gY29sbGVjdCBhbnkgYm91bmRhcmllc1xuICAgIC8vIHRoYXQgY2FwdHVyZSBhbiBlcnJvciBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhlIHJlYXNvbiB0aGVzZSBhcmVuJ3RcbiAgICAvLyBsb2NhbCB0byB0aGlzIGZ1bmN0aW9uIGlzIGJlY2F1c2UgZXJyb3JzIHRoYXQgb2NjdXIgZHVyaW5nIGNXVSBhcmVcbiAgICAvLyBjYXB0dXJlZCBlbHNld2hlcmUsIHRvIHByZXZlbnQgdGhlIHVubW91bnQgZnJvbSBiZWluZyBpbnRlcnJ1cHRlZC5cbiAgICBpc1dvcmtpbmcgPSB0cnVlO1xuICAgIGlzQ29tbWl0dGluZyA9IHRydWU7XG4gICAgc3RhcnRDb21taXRUaW1lcigpO1xuXG4gICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICEocm9vdC5jdXJyZW50ICE9PSBmaW5pc2hlZFdvcmspID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyByZWxhdGVkIHRvIHRoZSByZXR1cm4gZmllbGQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gZmFsc2U7XG5cbiAgICAvLyBSZXNldCB0aGlzIHRvIG51bGwgYmVmb3JlIGNhbGxpbmcgbGlmZWN5Y2xlc1xuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgdmFyIGZpcnN0RWZmZWN0ID0gdm9pZCAwO1xuICAgIGlmIChmaW5pc2hlZFdvcmsuZWZmZWN0VGFnID4gUGVyZm9ybWVkV29yaykge1xuICAgICAgLy8gQSBmaWJlcidzIGVmZmVjdCBsaXN0IGNvbnNpc3RzIG9ubHkgb2YgaXRzIGNoaWxkcmVuLCBub3QgaXRzZWxmLiBTbyBpZlxuICAgICAgLy8gdGhlIHJvb3QgaGFzIGFuIGVmZmVjdCwgd2UgbmVlZCB0byBhZGQgaXQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdC4gVGhlXG4gICAgICAvLyByZXN1bHRpbmcgbGlzdCBpcyB0aGUgc2V0IHRoYXQgd291bGQgYmVsb25nIHRvIHRoZSByb290J3MgcGFyZW50LCBpZlxuICAgICAgLy8gaXQgaGFkIG9uZTsgdGhhdCBpcywgYWxsIHRoZSBlZmZlY3RzIGluIHRoZSB0cmVlIGluY2x1ZGluZyB0aGUgcm9vdC5cbiAgICAgIGlmIChmaW5pc2hlZFdvcmsubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICBmaW5pc2hlZFdvcmsubGFzdEVmZmVjdC5uZXh0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0RWZmZWN0ID0gZmluaXNoZWRXb3JrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGVyZSBpcyBubyBlZmZlY3Qgb24gdGhlIHJvb3QuXG4gICAgICBmaXJzdEVmZmVjdCA9IGZpbmlzaGVkV29yay5maXJzdEVmZmVjdDtcbiAgICB9XG5cbiAgICBwcmVwYXJlRm9yQ29tbWl0KCk7XG5cbiAgICAvLyBDb21taXQgYWxsIHRoZSBzaWRlLWVmZmVjdHMgd2l0aGluIGEgdHJlZS4gV2UnbGwgZG8gdGhpcyBpbiB0d28gcGFzc2VzLlxuICAgIC8vIFRoZSBmaXJzdCBwYXNzIHBlcmZvcm1zIGFsbCB0aGUgaG9zdCBpbnNlcnRpb25zLCB1cGRhdGVzLCBkZWxldGlvbnMgYW5kXG4gICAgLy8gcmVmIHVubW91bnRzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdEhvc3RFZmZlY3RzVGltZXIoKTtcbiAgICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yID0gdm9pZCAwO1xuICAgICAge1xuICAgICAgICBpbnZva2VHdWFyZGVkQ2FsbGJhY2skMShudWxsLCBjb21taXRBbGxIb3N0RWZmZWN0cywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgZGlkRXJyb3IgPSB0cnVlO1xuICAgICAgICAgIF9lcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcik7XG4gICAgICAgIC8vIENsZWFuLXVwXG4gICAgICAgIGlmIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgbmV4dEVmZmVjdCA9IG5leHRFZmZlY3QubmV4dEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBzdG9wQ29tbWl0SG9zdEVmZmVjdHNUaW1lcigpO1xuXG4gICAgcmVzZXRBZnRlckNvbW1pdCgpO1xuXG4gICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgZmlyc3QgcGFzcyBvZiB0aGUgY29tbWl0IHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsXG4gICAgLy8gY3VycmVudCBkdXJpbmcgY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIHNlY29uZCBwYXNzLCBzbyB0aGF0XG4gICAgLy8gdGhlIGZpbmlzaGVkIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yaztcblxuICAgIC8vIEluIHRoZSBzZWNvbmQgcGFzcyB3ZSdsbCBwZXJmb3JtIGFsbCBsaWZlLWN5Y2xlcyBhbmQgcmVmIGNhbGxiYWNrcy5cbiAgICAvLyBMaWZlLWN5Y2xlcyBoYXBwZW4gYXMgYSBzZXBhcmF0ZSBwYXNzIHNvIHRoYXQgYWxsIHBsYWNlbWVudHMsIHVwZGF0ZXMsXG4gICAgLy8gYW5kIGRlbGV0aW9ucyBpbiB0aGUgZW50aXJlIHRyZWUgaGF2ZSBhbHJlYWR5IGJlZW4gaW52b2tlZC5cbiAgICAvLyBUaGlzIHBhc3MgYWxzbyB0cmlnZ2VycyBhbnkgcmVuZGVyZXItc3BlY2lmaWMgaW5pdGlhbCBlZmZlY3RzLlxuICAgIG5leHRFZmZlY3QgPSBmaXJzdEVmZmVjdDtcbiAgICBzdGFydENvbW1pdExpZmVDeWNsZXNUaW1lcigpO1xuICAgIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RpZEVycm9yID0gZmFsc2U7XG4gICAgICB2YXIgX2Vycm9yMiA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgY29tbWl0QWxsTGlmZUN5Y2xlcywgbnVsbCk7XG4gICAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgICAgX2RpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBfZXJyb3IyID0gY2xlYXJDYXVnaHRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoX2RpZEVycm9yKSB7XG4gICAgICAgICEobmV4dEVmZmVjdCAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBuZXh0IGVmZmVjdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgY2FwdHVyZUVycm9yKG5leHRFZmZlY3QsIF9lcnJvcjIpO1xuICAgICAgICBpZiAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIG5leHRFZmZlY3QgPSBuZXh0RWZmZWN0Lm5leHRFZmZlY3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpc0NvbW1pdHRpbmcgPSBmYWxzZTtcbiAgICBpc1dvcmtpbmcgPSBmYWxzZTtcbiAgICBzdG9wQ29tbWl0TGlmZUN5Y2xlc1RpbWVyKCk7XG4gICAgc3RvcENvbW1pdFRpbWVyKCk7XG4gICAgaWYgKHR5cGVvZiBvbkNvbW1pdFJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9uQ29tbWl0Um9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbW1pdFdvcmsoZmluaXNoZWRXb3JrKTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBjYXVnaHQgYW55IGVycm9ycyBkdXJpbmcgdGhpcyBjb21taXQsIHNjaGVkdWxlIHRoZWlyIGJvdW5kYXJpZXNcbiAgICAvLyB0byB1cGRhdGUuXG4gICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcykge1xuICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmZvckVhY2goc2NoZWR1bGVFcnJvclJlY292ZXJ5KTtcbiAgICAgIGNvbW1pdFBoYXNlQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKGZpcnN0VW5jYXVnaHRFcnJvciAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9lcnJvcjMgPSBmaXJzdFVuY2F1Z2h0RXJyb3I7XG4gICAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgb25VbmNhdWdodEVycm9yKF9lcnJvcjMpO1xuICAgIH1cblxuICAgIHZhciByZW1haW5pbmdUaW1lID0gcm9vdC5jdXJyZW50LmV4cGlyYXRpb25UaW1lO1xuXG4gICAgaWYgKHJlbWFpbmluZ1RpbWUgPT09IE5vV29yaykge1xuICAgICAgY2FwdHVyZWRFcnJvcnMgPSBudWxsO1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlbWFpbmluZ1RpbWU7XG4gIH1cblxuICBmdW5jdGlvbiByZXNldEV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzLCByZW5kZXJUaW1lKSB7XG4gICAgaWYgKHJlbmRlclRpbWUgIT09IE5ldmVyICYmIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID09PSBOZXZlcikge1xuICAgICAgLy8gVGhlIGNoaWxkcmVuIG9mIHRoaXMgY29tcG9uZW50IGFyZSBoaWRkZW4uIERvbid0IGJ1YmJsZSB0aGVpclxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgcGVuZGluZyB1cGRhdGVzLlxuICAgIHZhciBuZXdFeHBpcmF0aW9uVGltZSA9IGdldFVwZGF0ZUV4cGlyYXRpb25UaW1lKHdvcmtJblByb2dyZXNzKTtcblxuICAgIC8vIFRPRE86IENhbGxzIG5lZWQgdG8gdmlzaXQgc3RhdGVOb2RlXG5cbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGlmIChjaGlsZC5leHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChuZXdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5ld0V4cGlyYXRpb25UaW1lID4gY2hpbGQuZXhwaXJhdGlvblRpbWUpKSB7XG4gICAgICAgIG5ld0V4cGlyYXRpb25UaW1lID0gY2hpbGQuZXhwaXJhdGlvblRpbWU7XG4gICAgICB9XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICAgIHdvcmtJblByb2dyZXNzLmV4cGlyYXRpb25UaW1lID0gbmV3RXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICBmdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgICAvLyBtZWFucyB0aGF0IHdlIGRvbid0IG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpblxuICAgICAgLy8gcHJvZ3Jlc3MuXG4gICAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcbiAgICAgIHtcbiAgICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5zZXRDdXJyZW50RmliZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgICAgdmFyIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAgICB7XG4gICAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJldHVybkZpYmVyID0gd29ya0luUHJvZ3Jlc3NbJ3JldHVybiddO1xuICAgICAgdmFyIHNpYmxpbmdGaWJlciA9IHdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG5cbiAgICAgIHJlc2V0RXhwaXJhdGlvblRpbWUod29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG5cbiAgICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkNvbXBsZXRlV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgY29tcGxldGluZyB0aGlzIHdvcmsgc3Bhd25lZCBuZXcgd29yaywgZG8gdGhhdCBuZXh0LiBXZSdsbCBjb21lXG4gICAgICAgIC8vIGJhY2sgaGVyZSBhZ2Fpbi5cbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAvLyBBcHBlbmQgYWxsIHRoZSBlZmZlY3RzIG9mIHRoZSBzdWJ0cmVlIGFuZCB0aGlzIGZpYmVyIG9udG8gdGhlIGVmZmVjdFxuICAgICAgICAvLyBsaXN0IG9mIHRoZSBwYXJlbnQuIFRoZSBjb21wbGV0aW9uIG9yZGVyIG9mIHRoZSBjaGlsZHJlbiBhZmZlY3RzIHRoZVxuICAgICAgICAvLyBzaWRlLWVmZmVjdCBvcmRlci5cbiAgICAgICAgaWYgKHJldHVybkZpYmVyLmZpcnN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuRmliZXIuZmlyc3RFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChyZXR1cm5GaWJlci5sYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0Lm5leHRFZmZlY3QgPSB3b3JrSW5Qcm9ncmVzcy5maXJzdEVmZmVjdDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuRmliZXIubGFzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzLmxhc3RFZmZlY3Q7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGlzIGZpYmVyIGhhZCBzaWRlLWVmZmVjdHMsIHdlIGFwcGVuZCBpdCBBRlRFUiB0aGUgY2hpbGRyZW4nc1xuICAgICAgICAvLyBzaWRlLWVmZmVjdHMuIFdlIGNhbiBwZXJmb3JtIGNlcnRhaW4gc2lkZS1lZmZlY3RzIGVhcmxpZXIgaWZcbiAgICAgICAgLy8gbmVlZGVkLCBieSBkb2luZyBtdWx0aXBsZSBwYXNzZXMgb3ZlciB0aGUgZWZmZWN0IGxpc3QuIFdlIGRvbid0IHdhbnRcbiAgICAgICAgLy8gdG8gc2NoZWR1bGUgb3VyIG93biBzaWRlLWVmZmVjdCBvbiBvdXIgb3duIGxpc3QgYmVjYXVzZSBpZiBlbmQgdXBcbiAgICAgICAgLy8gcmV1c2luZyBjaGlsZHJlbiB3ZSdsbCBzY2hlZHVsZSB0aGlzIGVmZmVjdCBvbnRvIGl0c2VsZiBzaW5jZSB3ZSdyZVxuICAgICAgICAvLyBhdCB0aGUgZW5kLlxuICAgICAgICB2YXIgZWZmZWN0VGFnID0gd29ya0luUHJvZ3Jlc3MuZWZmZWN0VGFnO1xuICAgICAgICAvLyBTa2lwIGJvdGggTm9Xb3JrIGFuZCBQZXJmb3JtZWRXb3JrIHRhZ3Mgd2hlbiBjcmVhdGluZyB0aGUgZWZmZWN0IGxpc3QuXG4gICAgICAgIC8vIFBlcmZvcm1lZFdvcmsgZWZmZWN0IGlzIHJlYWQgYnkgUmVhY3QgRGV2VG9vbHMgYnV0IHNob3VsZG4ndCBiZSBjb21taXR0ZWQuXG4gICAgICAgIGlmIChlZmZlY3RUYWcgPiBQZXJmb3JtZWRXb3JrKSB7XG4gICAgICAgICAgaWYgKHJldHVybkZpYmVyLmxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybkZpYmVyLmxhc3RFZmZlY3QubmV4dEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm5GaWJlci5maXJzdEVmZmVjdCA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm5GaWJlci5sYXN0RWZmZWN0ID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RvcFdvcmtUaW1lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Db21wbGV0ZVdvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICAgIHJldHVybiBzaWJsaW5nRmliZXI7XG4gICAgICB9IGVsc2UgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrIGluIHRoaXMgcmV0dXJuRmliZXIuIENvbXBsZXRlIHRoZSByZXR1cm5GaWJlci5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuICAgICAgICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gV2l0aG91dCB0aGlzIGV4cGxpY2l0IG51bGwgcmV0dXJuIEZsb3cgY29tcGxhaW5zIG9mIGludmFsaWQgcmV0dXJuIHR5cGVcbiAgICAvLyBUT0RPIFJlbW92ZSB0aGUgYWJvdmUgd2hpbGUodHJ1ZSkgbG9vcFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnJlYWNoYWJsZVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLlxuICAgIC8vIElkZWFsbHkgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlXG4gICAgLy8gbWVhbnMgdGhhdCB3ZSBkb24ndCBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW5cbiAgICAvLyBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIC8vIFNlZSBpZiBiZWdpbm5pbmcgdGhpcyB3b3JrIHNwYXducyBtb3JlIHdvcmsuXG4gICAgc3RhcnRXb3JrVGltZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIuc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gICAgdmFyIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSk7XG4gICAge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5yZXNldEN1cnJlbnRGaWJlcigpO1xuICAgIH1cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sKSB7XG4gICAgICBSZWFjdEZpYmVySW5zdHJ1bWVudGF0aW9uXzEuZGVidWdUb29sLm9uQmVnaW5Xb3JrKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgICAgbmV4dCA9IGNvbXBsZXRlVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG5cbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKHdvcmtJblByb2dyZXNzKSB7XG4gICAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS5cbiAgICAvLyBJZGVhbGx5IG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZVxuICAgIC8vIG1lYW5zIHRoYXQgd2UgZG9uJ3QgbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluXG4gICAgLy8gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICAvLyBTZWUgaWYgYmVnaW5uaW5nIHRoaXMgd29yayBzcGF3bnMgbW9yZSB3b3JrLlxuICAgIHN0YXJ0V29ya1RpbWVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICAgIHZhciBuZXh0ID0gYmVnaW5GYWlsZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUpO1xuICAgIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RmliZXIucmVzZXRDdXJyZW50RmliZXIoKTtcbiAgICB9XG4gICAgaWYgKHRydWUgJiYgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbCkge1xuICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vbkJlZ2luV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICAgIG5leHQgPSBjb21wbGV0ZVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuXG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICBmdW5jdGlvbiB3b3JrTG9vcChleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIHVuaGFuZGxlZCBlcnJvcnMsIHN3aXRjaCB0byB0aGUgc2xvdyB3b3JrIGxvb3AuXG4gICAgICAvLyBUT0RPOiBIb3cgdG8gYXZvaWQgdGhpcyBjaGVjayBpbiB0aGUgZmFzdCBwYXRoPyBNYXliZSB0aGUgcmVuZGVyZXJcbiAgICAgIC8vIGNvdWxkIGtlZXAgdHJhY2sgb2Ygd2hpY2ggcm9vdHMgaGF2ZSB1bmhhbmRsZWQgZXJyb3JzIGFuZCBjYWxsIGFcbiAgICAgIC8vIGZvcmtlZCB2ZXJzaW9uIG9mIHJlbmRlclJvb3QuXG4gICAgICBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybVVuaXRPZldvcmsobmV4dFVuaXRPZldvcmspO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGbHVzaCBhc3luY2hyb25vdXMgd29yayB1bnRpbCB0aGUgZGVhZGxpbmUgcnVucyBvdXQgb2YgdGltZS5cbiAgICAgIHdoaWxlIChuZXh0VW5pdE9mV29yayAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzbG93V29ya0xvb3BUaGF0Q2hlY2tzRm9yRmFpbGVkV29yayhleHBpcmF0aW9uVGltZSkge1xuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPiBleHBpcmF0aW9uVGltZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgPD0gbW9zdFJlY2VudEN1cnJlbnRUaW1lKSB7XG4gICAgICAvLyBGbHVzaCBhbGwgZXhwaXJlZCB3b3JrLlxuICAgICAgd2hpbGUgKG5leHRVbml0T2ZXb3JrICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChoYXNDYXB0dXJlZEVycm9yKG5leHRVbml0T2ZXb3JrKSkge1xuICAgICAgICAgIC8vIFVzZSBhIGZvcmtlZCB2ZXJzaW9uIG9mIHBlcmZvcm1Vbml0T2ZXb3JrXG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtRmFpbGVkVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dFVuaXRPZldvcmsgPSBwZXJmb3JtVW5pdE9mV29yayhuZXh0VW5pdE9mV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmNocm9ub3VzIHdvcmsgdW50aWwgdGhlIGRlYWRsaW5lIHJ1bnMgb3V0IG9mIHRpbWUuXG4gICAgICB3aGlsZSAobmV4dFVuaXRPZldvcmsgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgaWYgKGhhc0NhcHR1cmVkRXJyb3IobmV4dFVuaXRPZldvcmspKSB7XG4gICAgICAgICAgLy8gVXNlIGEgZm9ya2VkIHZlcnNpb24gb2YgcGVyZm9ybVVuaXRPZldvcmtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1GYWlsZWRVbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXh0VW5pdE9mV29yayA9IHBlcmZvcm1Vbml0T2ZXb3JrKG5leHRVbml0T2ZXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlclJvb3RDYXRjaEJsb2NrKHJvb3QsIGZhaWxlZFdvcmssIGJvdW5kYXJ5LCBleHBpcmF0aW9uVGltZSkge1xuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIHJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHRoYXQgY2FwdHVyZWQgdGhlIGVycm9yLlxuICAgIC8vIENvbmNlcHR1YWxseSwgd2UncmUgdW53aW5kaW5nIHRoZSBzdGFjay4gV2UgbmVlZCB0byB1bndpbmQgdGhlXG4gICAgLy8gY29udGV4dCBzdGFjaywgdG9vLlxuICAgIHVud2luZENvbnRleHRzKGZhaWxlZFdvcmssIGJvdW5kYXJ5KTtcblxuICAgIC8vIFJlc3RhcnQgdGhlIGVycm9yIGJvdW5kYXJ5IHVzaW5nIGEgZm9ya2VkIHZlcnNpb24gb2ZcbiAgICAvLyBwZXJmb3JtVW5pdE9mV29yayB0aGF0IGRlbGV0ZXMgdGhlIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoZSBlbnRpcmVcbiAgICAvLyBmYWlsZWQgc3VicmVlIHdpbGwgYmUgdW5tb3VudGVkLiBEdXJpbmcgdGhlIGNvbW1pdCBwaGFzZSwgYSBzcGVjaWFsXG4gICAgLy8gbGlmZWN5Y2xlIG1ldGhvZCBpcyBjYWxsZWQgb24gdGhlIGVycm9yIGJvdW5kYXJ5LCB3aGljaCB0cmlnZ2Vyc1xuICAgIC8vIGEgcmUtcmVuZGVyLlxuICAgIG5leHRVbml0T2ZXb3JrID0gcGVyZm9ybUZhaWxlZFVuaXRPZldvcmsoYm91bmRhcnkpO1xuXG4gICAgLy8gQ29udGludWUgd29ya2luZy5cbiAgICB3b3JrTG9vcChleHBpcmF0aW9uVGltZSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgISFpc1dvcmtpbmcgPyBpbnZhcmlhbnQoZmFsc2UsICdyZW5kZXJSb290IHdhcyBjYWxsZWQgcmVjdXJzaXZlbHkuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG4gICAgaXNXb3JraW5nID0gdHJ1ZTtcblxuICAgIC8vIFdlJ3JlIGFib3V0IHRvIG11dGF0ZSB0aGUgd29yay1pbi1wcm9ncmVzcyB0cmVlLiBJZiB0aGUgcm9vdCB3YXMgcGVuZGluZ1xuICAgIC8vIGNvbW1pdCwgaXQgbm8gbG9uZ2VyIGlzOiB3ZSdsbCBuZWVkIHRvIGNvbXBsZXRlIGl0IGFnYWluLlxuICAgIHJvb3QuaXNSZWFkeUZvckNvbW1pdCA9IGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgc3RhcnRpbmcgZnJvbSBhIGZyZXNoIHN0YWNrLCBvciBpZiB3ZSdyZSByZXN1bWluZyBmcm9tXG4gICAgLy8gcHJldmlvdXNseSB5aWVsZGVkIHdvcmsuXG4gICAgaWYgKHJvb3QgIT09IG5leHRSb290IHx8IGV4cGlyYXRpb25UaW1lICE9PSBuZXh0UmVuZGVyRXhwaXJhdGlvblRpbWUgfHwgbmV4dFVuaXRPZldvcmsgPT09IG51bGwpIHtcbiAgICAgIC8vIFJlc2V0IHRoZSBzdGFjayBhbmQgc3RhcnQgd29ya2luZyBmcm9tIHRoZSByb290LlxuICAgICAgcmVzZXRDb250ZXh0U3RhY2soKTtcbiAgICAgIG5leHRSb290ID0gcm9vdDtcbiAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgbmV4dFVuaXRPZldvcmsgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhuZXh0Um9vdC5jdXJyZW50LCBudWxsLCBleHBpcmF0aW9uVGltZSk7XG4gICAgfVxuXG4gICAgc3RhcnRXb3JrTG9vcFRpbWVyKG5leHRVbml0T2ZXb3JrKTtcblxuICAgIHZhciBkaWRFcnJvciA9IGZhbHNlO1xuICAgIHZhciBlcnJvciA9IG51bGw7XG4gICAge1xuICAgICAgaW52b2tlR3VhcmRlZENhbGxiYWNrJDEobnVsbCwgd29ya0xvb3AsIG51bGwsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgIGlmIChoYXNDYXVnaHRFcnJvcigpKSB7XG4gICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgZXJyb3IgPSBjbGVhckNhdWdodEVycm9yKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQW4gZXJyb3Igd2FzIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB3aGlsZSAoZGlkRXJyb3IpIHtcbiAgICAgIGlmIChkaWRGYXRhbCkge1xuICAgICAgICAvLyBUaGlzIHdhcyBhIGZhdGFsIGVycm9yLiBEb24ndCBhdHRlbXB0IHRvIHJlY292ZXIgZnJvbSBpdC5cbiAgICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gZXJyb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgZmFpbGVkV29yayA9IG5leHRVbml0T2ZXb3JrO1xuICAgICAgaWYgKGZhaWxlZFdvcmsgPT09IG51bGwpIHtcbiAgICAgICAgLy8gQW4gZXJyb3Igd2FzIHRocm93biBidXQgdGhlcmUncyBubyBjdXJyZW50IHVuaXQgb2Ygd29yay4gVGhpcyBjYW5cbiAgICAgICAgLy8gaGFwcGVuIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIGlmIHRoZXJlJ3MgYSBidWcgaW4gdGhlIHJlbmRlcmVyLlxuICAgICAgICBkaWRGYXRhbCA9IHRydWU7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBcIkNhcHR1cmVcIiB0aGUgZXJyb3IgYnkgZmluZGluZyB0aGUgbmVhcmVzdCBib3VuZGFyeS4gSWYgdGhlcmUgaXMgbm9cbiAgICAgIC8vIGVycm9yIGJvdW5kYXJ5LCB3ZSB1c2UgdGhlIHJvb3QuXG4gICAgICB2YXIgYm91bmRhcnkgPSBjYXB0dXJlRXJyb3IoZmFpbGVkV29yaywgZXJyb3IpO1xuICAgICAgIShib3VuZGFyeSAhPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdTaG91bGQgaGF2ZSBmb3VuZCBhbiBlcnJvciBib3VuZGFyeS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICAgIC8vIFRoZSBlcnJvciB3ZSBqdXN0IGNhcHR1cmVkIHdhcyBhIGZhdGFsIGVycm9yLiBUaGlzIGhhcHBlbnNcbiAgICAgICAgLy8gd2hlbiB0aGUgZXJyb3IgcHJvcGFnYXRlcyB0byB0aGUgcm9vdCBtb3JlIHRoYW4gb25jZS5cbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGRpZEVycm9yID0gZmFsc2U7XG4gICAgICBlcnJvciA9IG51bGw7XG4gICAgICB7XG4gICAgICAgIGludm9rZUd1YXJkZWRDYWxsYmFjayQxKG51bGwsIHJlbmRlclJvb3RDYXRjaEJsb2NrLCBudWxsLCByb290LCBmYWlsZWRXb3JrLCBib3VuZGFyeSwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoaGFzQ2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgIGRpZEVycm9yID0gdHJ1ZTtcbiAgICAgICAgICBlcnJvciA9IGNsZWFyQ2F1Z2h0RXJyb3IoKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gV2UncmUgZmluaXNoZWQgd29ya2luZy4gRXhpdCB0aGUgZXJyb3IgbG9vcC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciB1bmNhdWdodEVycm9yID0gZmlyc3RVbmNhdWdodEVycm9yO1xuXG4gICAgLy8gV2UncmUgZG9uZSBwZXJmb3JtaW5nIHdvcmsuIFRpbWUgdG8gY2xlYW4gdXAuXG4gICAgc3RvcFdvcmtMb29wVGltZXIoaW50ZXJydXB0ZWRCeSk7XG4gICAgaW50ZXJydXB0ZWRCeSA9IG51bGw7XG4gICAgaXNXb3JraW5nID0gZmFsc2U7XG4gICAgZGlkRmF0YWwgPSBmYWxzZTtcbiAgICBmaXJzdFVuY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4gICAgaWYgKHVuY2F1Z2h0RXJyb3IgIT09IG51bGwpIHtcbiAgICAgIG9uVW5jYXVnaHRFcnJvcih1bmNhdWdodEVycm9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcm9vdC5pc1JlYWR5Rm9yQ29tbWl0ID8gcm9vdC5jdXJyZW50LmFsdGVybmF0ZSA6IG51bGw7XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBib3VuZGFyeSB0aGF0IGNhcHR1cmVkIHRoZSBlcnJvciwgb3IgbnVsbCBpZiB0aGUgZXJyb3IgaXMgaWdub3JlZFxuICBmdW5jdGlvbiBjYXB0dXJlRXJyb3IoZmFpbGVkV29yaywgZXJyb3IpIHtcbiAgICAvLyBJdCBpcyBubyBsb25nZXIgdmFsaWQgYmVjYXVzZSB3ZSBleGl0ZWQgdGhlIHVzZXIgY29kZS5cbiAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICB7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZpYmVyLnJlc2V0Q3VycmVudEZpYmVyKCk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmVhcmVzdCBlcnJvciBib3VuZGFyeS5cbiAgICB2YXIgYm91bmRhcnkgPSBudWxsO1xuXG4gICAgLy8gUGFzc2VkIHRvIGxvZ0NhcHR1cmVkRXJyb3IoKVxuICAgIHZhciBlcnJvckJvdW5kYXJ5Rm91bmQgPSBmYWxzZTtcbiAgICB2YXIgd2lsbFJldHJ5ID0gZmFsc2U7XG4gICAgdmFyIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcblxuICAgIC8vIEhvc3QgY29udGFpbmVycyBhcmUgYSBzcGVjaWFsIGNhc2UuIElmIHRoZSBmYWlsZWQgd29yayBpdHNlbGYgaXMgYSBob3N0XG4gICAgLy8gY29udGFpbmVyLCB0aGVuIGl0IGFjdHMgYXMgaXRzIG93biBib3VuZGFyeS4gSW4gYWxsIG90aGVyIGNhc2VzLCB3ZVxuICAgIC8vIGlnbm9yZSB0aGUgd29yayBpdHNlbGYgYW5kIG9ubHkgc2VhcmNoIHRocm91Z2ggdGhlIHBhcmVudHMuXG4gICAgaWYgKGZhaWxlZFdvcmsudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgYm91bmRhcnkgPSBmYWlsZWRXb3JrO1xuXG4gICAgICBpZiAoaXNGYWlsZWRCb3VuZGFyeShmYWlsZWRXb3JrKSkge1xuICAgICAgICAvLyBJZiB0aGlzIHJvb3QgYWxyZWFkeSBmYWlsZWQsIHRoZXJlIG11c3QgaGF2ZSBiZWVuIGFuIGVycm9yIHdoZW5cbiAgICAgICAgLy8gYXR0ZW1wdGluZyB0byB1bm1vdW50IGl0LiBUaGlzIGlzIGEgd29yc3QtY2FzZSBzY2VuYXJpbyBhbmRcbiAgICAgICAgLy8gc2hvdWxkIG9ubHkgYmUgcG9zc2libGUgaWYgdGhlcmUncyBhIGJ1ZyBpbiB0aGUgcmVuZGVyZXIuXG4gICAgICAgIGRpZEZhdGFsID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vZGUgPSBmYWlsZWRXb3JrWydyZXR1cm4nXTtcbiAgICAgIHdoaWxlIChub2RlICE9PSBudWxsICYmIGJvdW5kYXJ5ID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBlcnJvckJvdW5kYXJ5Rm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lKG5vZGUpO1xuXG4gICAgICAgICAgICAvLyBGb3VuZCBhbiBlcnJvciBib3VuZGFyeSFcbiAgICAgICAgICAgIGJvdW5kYXJ5ID0gbm9kZTtcbiAgICAgICAgICAgIHdpbGxSZXRyeSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgICAgICAgIC8vIFRyZWF0IHRoZSByb290IGxpa2UgYSBuby1vcCBlcnJvciBib3VuZGFyeVxuICAgICAgICAgIGJvdW5kYXJ5ID0gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0ZhaWxlZEJvdW5kYXJ5KG5vZGUpKSB7XG4gICAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBhbHJlYWR5IGluIGEgZmFpbGVkIHN0YXRlLlxuXG4gICAgICAgICAgLy8gSWYgd2UncmUgY3VycmVudGx5IHVubW91bnRpbmcsIHRoYXQgbWVhbnMgdGhpcyBlcnJvciB3YXNcbiAgICAgICAgICAvLyB0aHJvd24gd2hpbGUgdW5tb3VudGluZyBhIGZhaWxlZCBzdWJ0cmVlLiBXZSBzaG91bGQgaWdub3JlXG4gICAgICAgICAgLy8gdGhlIGVycm9yLlxuICAgICAgICAgIGlmIChpc1VubW91bnRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIElmIHdlJ3JlIGluIHRoZSBjb21taXQgcGhhc2UsIHdlIHNob3VsZCBjaGVjayB0byBzZWUgaWZcbiAgICAgICAgICAvLyB0aGlzIGJvdW5kYXJ5IGFscmVhZHkgY2FwdHVyZWQgYW4gZXJyb3IgZHVyaW5nIHRoaXMgY29tbWl0LlxuICAgICAgICAgIC8vIFRoaXMgY2FzZSBleGlzdHMgYmVjYXVzZSBtdWx0aXBsZSBlcnJvcnMgY2FuIGJlIHRocm93biBkdXJpbmdcbiAgICAgICAgICAvLyBhIHNpbmdsZSBjb21taXQgd2l0aG91dCBpbnRlcnJ1cHRpb24uXG4gICAgICAgICAgaWYgKGNvbW1pdFBoYXNlQm91bmRhcmllcyAhPT0gbnVsbCAmJiAoY29tbWl0UGhhc2VCb3VuZGFyaWVzLmhhcyhub2RlKSB8fCBub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21taXRQaGFzZUJvdW5kYXJpZXMuaGFzKG5vZGUuYWx0ZXJuYXRlKSkpIHtcbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBzaG91bGQgaWdub3JlIHRoaXMgZXJyb3IuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUaGUgZXJyb3Igc2hvdWxkIHByb3BhZ2F0ZSB0byB0aGUgbmV4dCBib3VuZGFyeSAt4oCUIHdlIGtlZXAgbG9va2luZy5cbiAgICAgICAgICBib3VuZGFyeSA9IG51bGw7XG4gICAgICAgICAgd2lsbFJldHJ5ID0gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGJvdW5kYXJ5ICE9PSBudWxsKSB7XG4gICAgICAvLyBBZGQgdG8gdGhlIGNvbGxlY3Rpb24gb2YgZmFpbGVkIGJvdW5kYXJpZXMuIFRoaXMgbGV0cyB1cyBrbm93IHRoYXRcbiAgICAgIC8vIHN1YnNlcXVlbnQgZXJyb3JzIGluIHRoaXMgc3VidHJlZSBzaG91bGQgcHJvcGFnYXRlIHRvIHRoZSBuZXh0IGJvdW5kYXJ5LlxuICAgICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGJvdW5kYXJ5KTtcblxuICAgICAgLy8gVGhpcyBtZXRob2QgaXMgdW5zYWZlIG91dHNpZGUgb2YgdGhlIGJlZ2luIGFuZCBjb21wbGV0ZSBwaGFzZXMuXG4gICAgICAvLyBXZSBtaWdodCBiZSBpbiB0aGUgY29tbWl0IHBoYXNlIHdoZW4gYW4gZXJyb3IgaXMgY2FwdHVyZWQuXG4gICAgICAvLyBUaGUgcmlzayBpcyB0aGF0IHRoZSByZXR1cm4gcGF0aCBmcm9tIHRoaXMgRmliZXIgbWF5IG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgIC8vIFRoYXQgcmlzayBpcyBhY2NlcHRhYmxlIGdpdmVuIHRoZSBiZW5lZml0IG9mIHByb3ZpZGluZyB1c2VycyBtb3JlIGNvbnRleHQuXG4gICAgICB2YXIgX2NvbXBvbmVudFN0YWNrID0gZ2V0U3RhY2tBZGRlbmR1bUJ5V29ya0luUHJvZ3Jlc3NGaWJlcihmYWlsZWRXb3JrKTtcbiAgICAgIHZhciBfY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWUoZmFpbGVkV29yayk7XG5cbiAgICAgIC8vIEFkZCB0byB0aGUgY29sbGVjdGlvbiBvZiBjYXB0dXJlZCBlcnJvcnMuIFRoaXMgaXMgc3RvcmVkIGFzIGEgZ2xvYmFsXG4gICAgICAvLyBtYXAgb2YgZXJyb3JzIGFuZCB0aGVpciBjb21wb25lbnQgc3RhY2sgbG9jYXRpb24ga2V5ZWQgYnkgdGhlIGJvdW5kYXJpZXNcbiAgICAgIC8vIHRoYXQgY2FwdHVyZSB0aGVtLiBXZSBtb3N0bHkgdXNlIHRoaXMgTWFwIGFzIGEgU2V0OyBpdCdzIGEgTWFwIG9ubHkgdG9cbiAgICAgIC8vIGF2b2lkIGFkZGluZyBhIGZpZWxkIHRvIEZpYmVyIHRvIHN0b3JlIHRoZSBlcnJvci5cbiAgICAgIGlmIChjYXB0dXJlZEVycm9ycyA9PT0gbnVsbCkge1xuICAgICAgICBjYXB0dXJlZEVycm9ycyA9IG5ldyBNYXAoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGNhcHR1cmVkRXJyb3IgPSB7XG4gICAgICAgIGNvbXBvbmVudE5hbWU6IF9jb21wb25lbnROYW1lLFxuICAgICAgICBjb21wb25lbnRTdGFjazogX2NvbXBvbmVudFN0YWNrLFxuICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgIGVycm9yQm91bmRhcnk6IGVycm9yQm91bmRhcnlGb3VuZCA/IGJvdW5kYXJ5LnN0YXRlTm9kZSA6IG51bGwsXG4gICAgICAgIGVycm9yQm91bmRhcnlGb3VuZDogZXJyb3JCb3VuZGFyeUZvdW5kLFxuICAgICAgICBlcnJvckJvdW5kYXJ5TmFtZTogZXJyb3JCb3VuZGFyeU5hbWUsXG4gICAgICAgIHdpbGxSZXRyeTogd2lsbFJldHJ5XG4gICAgICB9O1xuXG4gICAgICBjYXB0dXJlZEVycm9ycy5zZXQoYm91bmRhcnksIGNhcHR1cmVkRXJyb3IpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBsb2dDYXB0dXJlZEVycm9yKGNhcHR1cmVkRXJyb3IpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBQcmV2ZW50IGN5Y2xlIGlmIGxvZ0NhcHR1cmVkRXJyb3IoKSB0aHJvd3MuXG4gICAgICAgIC8vIEEgY3ljbGUgbWF5IHN0aWxsIG9jY3VyIGlmIGxvZ0NhcHR1cmVkRXJyb3IgcmVuZGVycyBhIGNvbXBvbmVudCB0aGF0IHRocm93cy5cbiAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgd2UncmUgaW4gdGhlIGNvbW1pdCBwaGFzZSwgZGVmZXIgc2NoZWR1bGluZyBhbiB1cGRhdGUgb24gdGhlXG4gICAgICAvLyBib3VuZGFyeSB1bnRpbCBhZnRlciB0aGUgY29tbWl0IGlzIGNvbXBsZXRlXG4gICAgICBpZiAoaXNDb21taXR0aW5nKSB7XG4gICAgICAgIGlmIChjb21taXRQaGFzZUJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRQaGFzZUJvdW5kYXJpZXMgPSBuZXcgU2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29tbWl0UGhhc2VCb3VuZGFyaWVzLmFkZChib3VuZGFyeSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBPdGhlcndpc2UsIHNjaGVkdWxlIGFuIHVwZGF0ZSBub3cuXG4gICAgICAgIC8vIFRPRE86IElzIHRoaXMgYWN0dWFsbHkgbmVjZXNzYXJ5IGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlPyBJcyBpdFxuICAgICAgICAvLyBwb3NzaWJsZSB0byB1bndpbmQgYW5kIGNvbnRpbnVlIHJlbmRlcmluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSxcbiAgICAgICAgLy8gd2l0aG91dCBjb3JydXB0aW5nIGludGVybmFsIHN0YXRlP1xuICAgICAgICBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoYm91bmRhcnkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJvdW5kYXJ5O1xuICAgIH0gZWxzZSBpZiAoZmlyc3RVbmNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICAvLyBJZiBubyBib3VuZGFyeSBpcyBmb3VuZCwgd2UnbGwgbmVlZCB0byB0aHJvdyB0aGUgZXJyb3JcbiAgICAgIGZpcnN0VW5jYXVnaHRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGhhc0NhcHR1cmVkRXJyb3IoZmliZXIpIHtcbiAgICAvLyBUT0RPOiBjYXB0dXJlZEVycm9ycyBzaG91bGQgc3RvcmUgdGhlIGJvdW5kYXJ5IGluc3RhbmNlLCB0byBhdm9pZCBuZWVkaW5nXG4gICAgLy8gdG8gY2hlY2sgdGhlIGFsdGVybmF0ZS5cbiAgICByZXR1cm4gY2FwdHVyZWRFcnJvcnMgIT09IG51bGwgJiYgKGNhcHR1cmVkRXJyb3JzLmhhcyhmaWJlcikgfHwgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNhcHR1cmVkRXJyb3JzLmhhcyhmaWJlci5hbHRlcm5hdGUpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRmFpbGVkQm91bmRhcnkoZmliZXIpIHtcbiAgICAvLyBUT0RPOiBmYWlsZWRCb3VuZGFyaWVzIHNob3VsZCBzdG9yZSB0aGUgYm91bmRhcnkgaW5zdGFuY2UsIHRvIGF2b2lkXG4gICAgLy8gbmVlZGluZyB0byBjaGVjayB0aGUgYWx0ZXJuYXRlLlxuICAgIHJldHVybiBmYWlsZWRCb3VuZGFyaWVzICE9PSBudWxsICYmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgZmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGZpYmVyLmFsdGVybmF0ZSkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tbWl0RXJyb3JIYW5kbGluZyhlZmZlY3RmdWxGaWJlcikge1xuICAgIHZhciBjYXB0dXJlZEVycm9yID0gdm9pZCAwO1xuICAgIGlmIChjYXB0dXJlZEVycm9ycyAhPT0gbnVsbCkge1xuICAgICAgY2FwdHVyZWRFcnJvciA9IGNhcHR1cmVkRXJyb3JzLmdldChlZmZlY3RmdWxGaWJlcik7XG4gICAgICBjYXB0dXJlZEVycm9yc1snZGVsZXRlJ10oZWZmZWN0ZnVsRmliZXIpO1xuICAgICAgaWYgKGNhcHR1cmVkRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICBpZiAoZWZmZWN0ZnVsRmliZXIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgZWZmZWN0ZnVsRmliZXIgPSBlZmZlY3RmdWxGaWJlci5hbHRlcm5hdGU7XG4gICAgICAgICAgY2FwdHVyZWRFcnJvciA9IGNhcHR1cmVkRXJyb3JzLmdldChlZmZlY3RmdWxGaWJlcik7XG4gICAgICAgICAgY2FwdHVyZWRFcnJvcnNbJ2RlbGV0ZSddKGVmZmVjdGZ1bEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgICEoY2FwdHVyZWRFcnJvciAhPSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ05vIGVycm9yIGZvciBnaXZlbiB1bml0IG9mIHdvcmsuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJykgOiB2b2lkIDA7XG5cbiAgICBzd2l0Y2ggKGVmZmVjdGZ1bEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZWZmZWN0ZnVsRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIHZhciBpbmZvID0ge1xuICAgICAgICAgIGNvbXBvbmVudFN0YWNrOiBjYXB0dXJlZEVycm9yLmNvbXBvbmVudFN0YWNrXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQWxsb3cgdGhlIGJvdW5kYXJ5IHRvIGhhbmRsZSB0aGUgZXJyb3IsIHVzdWFsbHkgYnkgc2NoZWR1bGluZ1xuICAgICAgICAvLyBhbiB1cGRhdGUgdG8gaXRzZWxmXG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoKGNhcHR1cmVkRXJyb3IuZXJyb3IsIGluZm8pO1xuICAgICAgICByZXR1cm47XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICBpZiAoZmlyc3RVbmNhdWdodEVycm9yID09PSBudWxsKSB7XG4gICAgICAgICAgZmlyc3RVbmNhdWdodEVycm9yID0gY2FwdHVyZWRFcnJvci5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHR5cGUgb2Ygd29yay4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1bndpbmRDb250ZXh0cyhmcm9tLCB0bykge1xuICAgIHZhciBub2RlID0gZnJvbTtcbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHBvcENvbnRleHRQcm92aWRlcihub2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHBvcEhvc3RDb250YWluZXIobm9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBwb3BIb3N0Q29udGFpbmVyKG5vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKG5vZGUgPT09IHRvIHx8IG5vZGUuYWx0ZXJuYXRlID09PSB0bykge1xuICAgICAgICBzdG9wRmFpbGVkV29ya1RpbWVyKG5vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0b3BXb3JrVGltZXIobm9kZSk7XG4gICAgICB9XG4gICAgICBub2RlID0gbm9kZVsncmV0dXJuJ107XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUFzeW5jRXhwaXJhdGlvbigpIHtcbiAgICAvLyBHaXZlbiB0aGUgY3VycmVudCBjbG9jayB0aW1lLCByZXR1cm5zIGFuIGV4cGlyYXRpb24gdGltZS4gV2UgdXNlIHJvdW5kaW5nXG4gICAgLy8gdG8gYmF0Y2ggbGlrZSB1cGRhdGVzIHRvZ2V0aGVyLlxuICAgIC8vIFNob3VsZCBjb21wbGV0ZSB3aXRoaW4gfjEwMDBtcy4gMTIwMG1zIG1heC5cbiAgICB2YXIgY3VycmVudFRpbWUgPSByZWNhbGN1bGF0ZUN1cnJlbnRUaW1lKCk7XG4gICAgdmFyIGV4cGlyYXRpb25NcyA9IDEwMDA7XG4gICAgdmFyIGJ1Y2tldFNpemVNcyA9IDIwMDtcbiAgICByZXR1cm4gY29tcHV0ZUV4cGlyYXRpb25CdWNrZXQoY3VycmVudFRpbWUsIGV4cGlyYXRpb25NcywgYnVja2V0U2l6ZU1zKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIoZmliZXIpIHtcbiAgICB2YXIgZXhwaXJhdGlvblRpbWUgPSB2b2lkIDA7XG4gICAgaWYgKGV4cGlyYXRpb25Db250ZXh0ICE9PSBOb1dvcmspIHtcbiAgICAgIC8vIEFuIGV4cGxpY2l0IGV4cGlyYXRpb24gY29udGV4dCB3YXMgc2V0O1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uQ29udGV4dDtcbiAgICB9IGVsc2UgaWYgKGlzV29ya2luZykge1xuICAgICAgaWYgKGlzQ29tbWl0dGluZykge1xuICAgICAgICAvLyBVcGRhdGVzIHRoYXQgb2NjdXIgZHVyaW5nIHRoZSBjb21taXQgcGhhc2Ugc2hvdWxkIGhhdmUgc3luYyBwcmlvcml0eVxuICAgICAgICAvLyBieSBkZWZhdWx0LlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcGRhdGVzIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIHNob3VsZCBleHBpcmUgYXQgdGhlIHNhbWUgdGltZSBhc1xuICAgICAgICAvLyB0aGUgd29yayB0aGF0IGlzIGJlaW5nIHJlbmRlcmVkLlxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gZXhwbGljaXQgZXhwaXJhdGlvbiBjb250ZXh0IHdhcyBzZXQsIGFuZCB3ZSdyZSBub3QgY3VycmVudGx5XG4gICAgICAvLyBwZXJmb3JtaW5nIHdvcmsuIENhbGN1bGF0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWUuXG4gICAgICBpZiAodXNlU3luY1NjaGVkdWxpbmcgJiYgIShmaWJlci5pbnRlcm5hbENvbnRleHRUYWcgJiBBc3luY1VwZGF0ZXMpKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IFN5bmM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIHVwZGF0ZVxuICAgICAgICBleHBpcmF0aW9uVGltZSA9IGNvbXB1dGVBc3luY0V4cGlyYXRpb24oKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGV4cGlyYXRpb25UaW1lO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrKGZpYmVyLCBleHBpcmF0aW9uVGltZSkge1xuICAgIHJldHVybiBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBleHBpcmF0aW9uVGltZSwgZmFsc2UpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2NoZWR1bGVXb3JrSW1wbChmaWJlciwgZXhwaXJhdGlvblRpbWUsIGlzRXJyb3JSZWNvdmVyeSkge1xuICAgIHJlY29yZFNjaGVkdWxlVXBkYXRlKCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWlzRXJyb3JSZWNvdmVyeSAmJiBmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgd2FybkFib3V0SW52YWxpZFVwZGF0ZXMoaW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBub2RlID0gZmliZXI7XG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgZWFjaCBub2RlJ3NcbiAgICAgIC8vIGV4cGlyYXRpb24gdGltZS5cbiAgICAgIGlmIChub2RlLmV4cGlyYXRpb25UaW1lID09PSBOb1dvcmsgfHwgbm9kZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIG5vZGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIH1cbiAgICAgIGlmIChub2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPT09IE5vV29yayB8fCBub2RlLmFsdGVybmF0ZS5leHBpcmF0aW9uVGltZSA+IGV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgICAgbm9kZS5hbHRlcm5hdGUuZXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vZGVbJ3JldHVybiddID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgICAgICB2YXIgcm9vdCA9IG5vZGUuc3RhdGVOb2RlO1xuICAgICAgICAgIGlmICghaXNXb3JraW5nICYmIHJvb3QgPT09IG5leHRSb290ICYmIGV4cGlyYXRpb25UaW1lIDw9IG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSkge1xuICAgICAgICAgICAgLy8gUmVzdGFydCB0aGUgcm9vdCBmcm9tIHRoZSB0b3AuXG4gICAgICAgICAgICBpZiAobmV4dFVuaXRPZldvcmsgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnRlcnJ1cHRpb24uIChVc2VkIGZvciBwZXJmb3JtYW5jZSB0cmFja2luZy4pXG4gICAgICAgICAgICAgIGludGVycnVwdGVkQnkgPSBmaWJlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRSb290ID0gbnVsbDtcbiAgICAgICAgICAgIG5leHRVbml0T2ZXb3JrID0gbnVsbDtcbiAgICAgICAgICAgIG5leHRSZW5kZXJFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxdWVzdFdvcmsocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghaXNFcnJvclJlY292ZXJ5ICYmIGZpYmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgICAgICAgICAgd2FybkFib3V0VXBkYXRlT25Vbm1vdW50ZWQoZmliZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG5vZGUgPSBub2RlWydyZXR1cm4nXTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzY2hlZHVsZUVycm9yUmVjb3ZlcnkoZmliZXIpIHtcbiAgICBzY2hlZHVsZVdvcmtJbXBsKGZpYmVyLCBTeW5jLCB0cnVlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSB7XG4gICAgLy8gU3VidHJhY3QgaW5pdGlhbCB0aW1lIHNvIGl0IGZpdHMgaW5zaWRlIDMyYml0c1xuICAgIHZhciBtcyA9IG5vdygpIC0gc3RhcnRUaW1lO1xuICAgIG1vc3RSZWNlbnRDdXJyZW50VGltZSA9IG1zVG9FeHBpcmF0aW9uVGltZShtcyk7XG4gICAgcmV0dXJuIG1vc3RSZWNlbnRDdXJyZW50VGltZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICAgIHZhciBwcmV2aW91c0V4cGlyYXRpb25Db250ZXh0ID0gZXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgZXhwaXJhdGlvbkNvbnRleHQgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBleHBpcmF0aW9uQ29udGV4dCA9IHByZXZpb3VzRXhwaXJhdGlvbkNvbnRleHQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc3luY1VwZGF0ZXMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dCA9IGV4cGlyYXRpb25Db250ZXh0O1xuICAgIGV4cGlyYXRpb25Db250ZXh0ID0gU3luYztcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGV4cGlyYXRpb25Db250ZXh0ID0gcHJldmlvdXNFeHBpcmF0aW9uQ29udGV4dDtcbiAgICB9XG4gIH1cblxuICAvLyBUT0RPOiBFdmVyeXRoaW5nIGJlbG93IHRoaXMgaXMgd3JpdHRlbiBhcyBpZiBpdCBoYXMgYmVlbiBsaWZ0ZWQgdG8gdGhlXG4gIC8vIHJlbmRlcmVycy4gSSdsbCBkbyB0aGlzIGluIGEgZm9sbG93LXVwLlxuXG4gIC8vIExpbmtlZC1saXN0IG9mIHJvb3RzXG4gIHZhciBmaXJzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICB2YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuXG4gIHZhciBpc0NhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG4gIHZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB2YXIgbmV4dEZsdXNoZWRSb290ID0gbnVsbDtcbiAgdmFyIG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPSBOb1dvcms7XG4gIHZhciBkZWFkbGluZURpZEV4cGlyZSA9IGZhbHNlO1xuICB2YXIgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgdmFyIHVuaGFuZGxlZEVycm9yID0gbnVsbDtcbiAgdmFyIGRlYWRsaW5lID0gbnVsbDtcblxuICB2YXIgaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgdmFyIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcblxuICAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG4gIHZhciBORVNURURfVVBEQVRFX0xJTUlUID0gMTAwMDtcbiAgdmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcblxuICB2YXIgdGltZUhldXJpc3RpY0ZvclVuaXRPZldvcmsgPSAxO1xuXG4gIC8vIHJlcXVlc3RXb3JrIGlzIGNhbGxlZCBieSB0aGUgc2NoZWR1bGVyIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuXG4gIC8vIEl0J3MgdXAgdG8gdGhlIHJlbmRlcmVyIHRvIGNhbGwgcmVuZGVyUm9vdCBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUuXG4gIGZ1bmN0aW9uIHJlcXVlc3RXb3JrKHJvb3QsIGV4cGlyYXRpb25UaW1lKSB7XG4gICAgaWYgKG5lc3RlZFVwZGF0ZUNvdW50ID4gTkVTVEVEX1VQREFURV9MSU1JVCkge1xuICAgICAgaW52YXJpYW50KGZhbHNlLCAnTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50IHJlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgY29tcG9uZW50RGlkVXBkYXRlLiBSZWFjdCBsaW1pdHMgdGhlIG51bWJlciBvZiBuZXN0ZWQgdXBkYXRlcyB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgcm9vdCB0byB0aGUgc2NoZWR1bGUuXG4gICAgLy8gQ2hlY2sgaWYgdGhpcyByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gICAgaWYgKHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgcm9vdCBpcyBub3QgYWxyZWFkeSBzY2hlZHVsZWQuIEFkZCBpdC5cbiAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBleHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChsYXN0U2NoZWR1bGVkUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBzY2hlZHVsZWQsIGJ1dCBpdHMgcHJpb3JpdHkgbWF5IGhhdmUgaW5jcmVhc2VkLlxuICAgICAgdmFyIHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZTtcbiAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IGV4cGlyYXRpb25UaW1lIDwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUpIHtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSBwcmlvcml0eS5cbiAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc1JlbmRlcmluZykge1xuICAgICAgLy8gUHJldmVudCByZWVudHJhbmN5LiBSZW1haW5pbmcgd29yayB3aWxsIGJlIHNjaGVkdWxlZCBhdCB0aGUgZW5kIG9mXG4gICAgICAvLyB0aGUgY3VycmVudGx5IHJlbmRlcmluZyBiYXRjaC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaXNCYXRjaGluZ1VwZGF0ZXMpIHtcbiAgICAgIC8vIEZsdXNoIHdvcmsgYXQgdGhlIGVuZCBvZiB0aGUgYmF0Y2guXG4gICAgICBpZiAoaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgICAvLyAuLi51bmxlc3Mgd2UncmUgaW5zaWRlIHVuYmF0Y2hlZFVwZGF0ZXMsIGluIHdoaWNoIGNhc2Ugd2Ugc2hvdWxkXG4gICAgICAgIC8vIGZsdXNoIGl0IG5vdy5cbiAgICAgICAgcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgU3luYyk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gVE9ETzogR2V0IHJpZCBvZiBTeW5jIGFuZCB1c2UgY3VycmVudCB0aW1lP1xuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gU3luYykge1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfSBlbHNlIGlmICghaXNDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yayk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKSB7XG4gICAgdmFyIGhpZ2hlc3RQcmlvcml0eVdvcmsgPSBOb1dvcms7XG4gICAgdmFyIGhpZ2hlc3RQcmlvcml0eVJvb3QgPSBudWxsO1xuXG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNTY2hlZHVsZWRSb290ID0gbGFzdFNjaGVkdWxlZFJvb3Q7XG4gICAgICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcbiAgICAgIHdoaWxlIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciByZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWU7XG4gICAgICAgIGlmIChyZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IG5vIGxvbmdlciBoYXMgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlci5cblxuICAgICAgICAgIC8vIFRPRE86IFRoaXMgY2hlY2sgaXMgcmVkdWRhbnQsIGJ1dCBGbG93IGlzIGNvbmZ1c2VkIGJ5IHRoZSBicmFuY2hcbiAgICAgICAgICAvLyBiZWxvdyB3aGVyZSB3ZSBzZXQgbGFzdFNjaGVkdWxlZFJvb3QgdG8gbnVsbCwgZXZlbiB0aG91Z2ggd2UgYnJlYWtcbiAgICAgICAgICAvLyBmcm9tIHRoZSBsb29wIHJpZ2h0IGFmdGVyLlxuICAgICAgICAgICEocHJldmlvdXNTY2hlZHVsZWRSb290ICE9PSBudWxsICYmIGxhc3RTY2hlZHVsZWRSb290ICE9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ1Nob3VsZCBoYXZlIGEgcHJldmlvdXMgYW5kIGxhc3Qgcm9vdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcbiAgICAgICAgICBpZiAocm9vdCA9PT0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgb25seSByb290IGluIHRoZSBsaXN0LlxuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGZpcnN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3Qgcm9vdCBpbiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG5leHQ7XG4gICAgICAgICAgICByb290Lm5leHRTY2hlZHVsZWRSb290ID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBsYXN0IHJvb3QgaW4gdGhlIGxpc3QuXG4gICAgICAgICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHByZXZpb3VzU2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuICAgICAgICAgICAgcm9vdC5uZXh0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290ID0gcm9vdC5uZXh0U2NoZWR1bGVkUm9vdDtcbiAgICAgICAgICAgIHJvb3QubmV4dFNjaGVkdWxlZFJvb3QgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByb290ID0gcHJldmlvdXNTY2hlZHVsZWRSb290Lm5leHRTY2hlZHVsZWRSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChoaWdoZXN0UHJpb3JpdHlXb3JrID09PSBOb1dvcmsgfHwgcmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPCBoaWdoZXN0UHJpb3JpdHlXb3JrKSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHByaW9yaXR5LCBpZiBpdCdzIGhpZ2hlclxuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5V29yayA9IHJlbWFpbmluZ0V4cGlyYXRpb25UaW1lO1xuICAgICAgICAgICAgaGlnaGVzdFByaW9yaXR5Um9vdCA9IHJvb3Q7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHByZXZpb3VzU2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgICAgICAgcm9vdCA9IHJvb3QubmV4dFNjaGVkdWxlZFJvb3Q7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgbmV4dCByb290IGlzIHRoZSBzYW1lIGFzIHRoZSBwcmV2aW91cyByb290LCB0aGlzIGlzIGEgbmVzdGVkXG4gICAgLy8gdXBkYXRlLiBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGluY3JlbWVudCB0aGUgbmVzdGVkIHVwZGF0ZSBjb3VudC5cbiAgICB2YXIgcHJldmlvdXNGbHVzaGVkUm9vdCA9IG5leHRGbHVzaGVkUm9vdDtcbiAgICBpZiAocHJldmlvdXNGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiBwcmV2aW91c0ZsdXNoZWRSb290ID09PSBoaWdoZXN0UHJpb3JpdHlSb290KSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZXNldCB3aGVuZXZlciB3ZSBzd2l0Y2ggcm9vdHMuXG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgfVxuICAgIG5leHRGbHVzaGVkUm9vdCA9IGhpZ2hlc3RQcmlvcml0eVJvb3Q7XG4gICAgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSA9IGhpZ2hlc3RQcmlvcml0eVdvcms7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtQXN5bmNXb3JrKGRsKSB7XG4gICAgcGVyZm9ybVdvcmsoTm9Xb3JrLCBkbCk7XG4gIH1cblxuICBmdW5jdGlvbiBwZXJmb3JtV29yayhtaW5FeHBpcmF0aW9uVGltZSwgZGwpIHtcbiAgICBkZWFkbGluZSA9IGRsO1xuXG4gICAgLy8gS2VlcCB3b3JraW5nIG9uIHJvb3RzIHVudGlsIHRoZXJlJ3Mgbm8gbW9yZSB3b3JrLCBvciB1bnRpbCB0aGUgd2UgcmVhY2hcbiAgICAvLyB0aGUgZGVhZGxuZS5cbiAgICBmaW5kSGlnaGVzdFByaW9yaXR5Um9vdCgpO1xuICAgIHdoaWxlIChuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwgJiYgbmV4dEZsdXNoZWRFeHBpcmF0aW9uVGltZSAhPT0gTm9Xb3JrICYmIChtaW5FeHBpcmF0aW9uVGltZSA9PT0gTm9Xb3JrIHx8IG5leHRGbHVzaGVkRXhwaXJhdGlvblRpbWUgPD0gbWluRXhwaXJhdGlvblRpbWUpICYmICFkZWFkbGluZURpZEV4cGlyZSkge1xuICAgICAgcGVyZm9ybVdvcmtPblJvb3QobmV4dEZsdXNoZWRSb290LCBuZXh0Rmx1c2hlZEV4cGlyYXRpb25UaW1lKTtcbiAgICAgIC8vIEZpbmQgdGhlIG5leHQgaGlnaGVzdCBwcmlvcml0eSB3b3JrLlxuICAgICAgZmluZEhpZ2hlc3RQcmlvcml0eVJvb3QoKTtcbiAgICB9XG5cbiAgICAvLyBXZSdyZSBkb25lIGZsdXNoaW5nIHdvcmsuIEVpdGhlciB3ZSByYW4gb3V0IG9mIHRpbWUgaW4gdGhpcyBjYWxsYmFjayxcbiAgICAvLyBvciB0aGVyZSdzIG5vIG1vcmUgd29yayBsZWZ0IHdpdGggc3VmZmljaWVudCBwcmlvcml0eS5cblxuICAgIC8vIElmIHdlJ3JlIGluc2lkZSBhIGNhbGxiYWNrLCBzZXQgdGhpcyB0byBmYWxzZSBzaW5jZSB3ZSBqdXN0IGNvbXBsZXRlZCBpdC5cbiAgICBpZiAoZGVhZGxpbmUgIT09IG51bGwpIHtcbiAgICAgIGlzQ2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gSWYgdGhlcmUncyB3b3JrIGxlZnQgb3Zlciwgc2NoZWR1bGUgYSBuZXcgY2FsbGJhY2suXG4gICAgaWYgKG5leHRGbHVzaGVkUm9vdCAhPT0gbnVsbCAmJiAhaXNDYWxsYmFja1NjaGVkdWxlZCkge1xuICAgICAgaXNDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICBzY2hlZHVsZURlZmVycmVkQ2FsbGJhY2socGVyZm9ybUFzeW5jV29yayk7XG4gICAgfVxuXG4gICAgLy8gQ2xlYW4tdXAuXG4gICAgZGVhZGxpbmUgPSBudWxsO1xuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gZmFsc2U7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuXG4gICAgaWYgKGhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICB2YXIgX2Vycm9yNCA9IHVuaGFuZGxlZEVycm9yO1xuICAgICAgdW5oYW5kbGVkRXJyb3IgPSBudWxsO1xuICAgICAgaGFzVW5oYW5kbGVkRXJyb3IgPSBmYWxzZTtcbiAgICAgIHRocm93IF9lcnJvcjQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybVdvcmtPblJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpIHtcbiAgICAhIWlzUmVuZGVyaW5nID8gaW52YXJpYW50KGZhbHNlLCAncGVyZm9ybVdvcmtPblJvb3Qgd2FzIGNhbGxlZCByZWN1cnNpdmVseS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKSA6IHZvaWQgMDtcblxuICAgIGlzUmVuZGVyaW5nID0gdHJ1ZTtcblxuICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYXN5bmMgd29yayBvciBzeW5jL2V4cGlyZWQgd29yay5cbiAgICAvLyBUT0RPOiBQYXNzIGN1cnJlbnQgdGltZSBhcyBhcmd1bWVudCB0byByZW5kZXJSb290LCBjb21taXRSb290XG4gICAgaWYgKGV4cGlyYXRpb25UaW1lIDw9IHJlY2FsY3VsYXRlQ3VycmVudFRpbWUoKSkge1xuICAgICAgLy8gRmx1c2ggc3luYyB3b3JrLlxuICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuZmluaXNoZWRXb3JrO1xuICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChmaW5pc2hlZFdvcmspO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICBmaW5pc2hlZFdvcmsgPSByZW5kZXJSb290KHJvb3QsIGV4cGlyYXRpb25UaW1lKTtcbiAgICAgICAgaWYgKGZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ29tbWl0IGl0LlxuICAgICAgICAgIHJvb3QucmVtYWluaW5nRXhwaXJhdGlvblRpbWUgPSBjb21taXRSb290KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRmx1c2ggYXN5bmMgd29yay5cbiAgICAgIHZhciBfZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIHJvb3QgaXMgYWxyZWFkeSBjb21wbGV0ZS4gV2UgY2FuIGNvbW1pdCBpdC5cbiAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICAgICAgICByb290LnJlbWFpbmluZ0V4cGlyYXRpb25UaW1lID0gY29tbWl0Um9vdChfZmluaXNoZWRXb3JrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgICAgICAgX2ZpbmlzaGVkV29yayA9IHJlbmRlclJvb3Qocm9vdCwgZXhwaXJhdGlvblRpbWUpO1xuICAgICAgICBpZiAoX2ZpbmlzaGVkV29yayAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3ZlIGNvbXBsZXRlZCB0aGUgcm9vdC4gQ2hlY2sgdGhlIGRlYWRsaW5lIG9uZSBtb3JlIHRpbWVcbiAgICAgICAgICAvLyBiZWZvcmUgY29tbWl0dGluZy5cbiAgICAgICAgICBpZiAoIXNob3VsZFlpZWxkKCkpIHtcbiAgICAgICAgICAgIC8vIFN0aWxsIHRpbWUgbGVmdC4gQ29tbWl0IHRoZSByb290LlxuICAgICAgICAgICAgcm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IGNvbW1pdFJvb3QoX2ZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZXJlJ3Mgbm8gdGltZSBsZWZ0LiBNYXJrIHRoaXMgcm9vdCBhcyBjb21wbGV0ZS4gV2UnbGwgY29tZVxuICAgICAgICAgICAgLy8gYmFjayBhbmQgY29tbWl0IGl0IGxhdGVyLlxuICAgICAgICAgICAgcm9vdC5maW5pc2hlZFdvcmsgPSBfZmluaXNoZWRXb3JrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICAvLyBXaGVuIHdvcmtpbmcgb24gYXN5bmMgd29yaywgdGhlIHJlY29uY2lsZXIgYXNrcyB0aGUgcmVuZGVyZXIgaWYgaXQgc2hvdWxkXG4gIC8vIHlpZWxkIGV4ZWN1dGlvbi4gRm9yIERPTSwgd2UgaW1wbGVtZW50IHRoaXMgd2l0aCByZXF1ZXN0SWRsZUNhbGxiYWNrLlxuICBmdW5jdGlvbiBzaG91bGRZaWVsZCgpIHtcbiAgICBpZiAoZGVhZGxpbmUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGRlYWRsaW5lLnRpbWVSZW1haW5pbmcoKSA+IHRpbWVIZXVyaXN0aWNGb3JVbml0T2ZXb3JrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGRlYWRsaW5lRGlkRXhwaXJlID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8vIFRPRE86IE5vdCBoYXBweSBhYm91dCB0aGlzIGhvb2suIENvbmNlcHR1YWxseSwgcmVuZGVyUm9vdCBzaG91bGQgcmV0dXJuIGFcbiAgLy8gdHVwbGUgb2YgKGlzUmVhZHlGb3JDb21taXQsIGRpZEVycm9yLCBlcnJvcilcbiAgZnVuY3Rpb24gb25VbmNhdWdodEVycm9yKGVycm9yKSB7XG4gICAgIShuZXh0Rmx1c2hlZFJvb3QgIT09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnU2hvdWxkIGJlIHdvcmtpbmcgb24gYSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpIDogdm9pZCAwO1xuICAgIC8vIFVuc2NoZWR1bGUgdGhpcyByb290IHNvIHdlIGRvbid0IHdvcmsgb24gaXQgYWdhaW4gdW50aWwgdGhlcmUnc1xuICAgIC8vIGFub3RoZXIgdXBkYXRlLlxuICAgIG5leHRGbHVzaGVkUm9vdC5yZW1haW5pbmdFeHBpcmF0aW9uVGltZSA9IE5vV29yaztcbiAgICBpZiAoIWhhc1VuaGFuZGxlZEVycm9yKSB7XG4gICAgICBoYXNVbmhhbmRsZWRFcnJvciA9IHRydWU7XG4gICAgICB1bmhhbmRsZWRFcnJvciA9IGVycm9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IEJhdGNoaW5nIHNob3VsZCBiZSBpbXBsZW1lbnRlZCBhdCB0aGUgcmVuZGVyZXIgbGV2ZWwsIG5vdCBpbnNpZGVcbiAgLy8gdGhlIHJlY29uY2lsZXIuXG4gIGZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gICAgdmFyIHByZXZpb3VzSXNCYXRjaGluZ1VwZGF0ZXMgPSBpc0JhdGNoaW5nVXBkYXRlcztcbiAgICBpc0JhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBmbihhKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgaWYgKCFpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNSZW5kZXJpbmcpIHtcbiAgICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogQmF0Y2hpbmcgc2hvdWxkIGJlIGltcGxlbWVudGVkIGF0IHRoZSByZW5kZXJlciBsZXZlbCwgbm90IGluc2lkZVxuICAvLyB0aGUgcmVjb25jaWxlci5cbiAgZnVuY3Rpb24gdW5iYXRjaGVkVXBkYXRlcyhmbikge1xuICAgIGlmIChpc0JhdGNoaW5nVXBkYXRlcyAmJiAhaXNVbmJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgaXNVbmJhdGNoaW5nVXBkYXRlcyA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlzVW5iYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZuKCk7XG4gIH1cblxuICAvLyBUT0RPOiBCYXRjaGluZyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgYXQgdGhlIHJlbmRlcmVyIGxldmVsLCBub3Qgd2l0aGluXG4gIC8vIHRoZSByZWNvbmNpbGVyLlxuICBmdW5jdGlvbiBmbHVzaFN5bmMoZm4pIHtcbiAgICB2YXIgcHJldmlvdXNJc0JhdGNoaW5nVXBkYXRlcyA9IGlzQmF0Y2hpbmdVcGRhdGVzO1xuICAgIGlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHN5bmNVcGRhdGVzKGZuKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNCYXRjaGluZ1VwZGF0ZXMgPSBwcmV2aW91c0lzQmF0Y2hpbmdVcGRhdGVzO1xuICAgICAgISFpc1JlbmRlcmluZyA/IGludmFyaWFudChmYWxzZSwgJ2ZsdXNoU3luYyB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgbGlmZWN5Y2xlIG1ldGhvZC4gSXQgY2Fubm90IGJlIGNhbGxlZCB3aGVuIFJlYWN0IGlzIGFscmVhZHkgcmVuZGVyaW5nLicpIDogdm9pZCAwO1xuICAgICAgcGVyZm9ybVdvcmsoU3luYywgbnVsbCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uOiBjb21wdXRlQXN5bmNFeHBpcmF0aW9uLFxuICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXI6IGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIsXG4gICAgc2NoZWR1bGVXb3JrOiBzY2hlZHVsZVdvcmssXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuICAgIHVuYmF0Y2hlZFVwZGF0ZXM6IHVuYmF0Y2hlZFVwZGF0ZXMsXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG4gICAgZGVmZXJyZWRVcGRhdGVzOiBkZWZlcnJlZFVwZGF0ZXNcbiAgfTtcbn07XG5cbntcbiAgdmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSBmYWxzZTtcbn1cblxuLy8gMCBpcyBQUk9ELCAxIGlzIERFVi5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eU9iamVjdDtcbiAgfVxuXG4gIHZhciBmaWJlciA9IGdldChwYXJlbnRDb21wb25lbnQpO1xuICB2YXIgcGFyZW50Q29udGV4dCA9IGZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0KGZpYmVyKTtcbiAgcmV0dXJuIGlzQ29udGV4dFByb3ZpZGVyKGZpYmVyKSA/IHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIHBhcmVudENvbnRleHQpIDogcGFyZW50Q29udGV4dDtcbn1cblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgPSBmdW5jdGlvbiAoY29uZmlnKSB7XG4gIHZhciBnZXRQdWJsaWNJbnN0YW5jZSA9IGNvbmZpZy5nZXRQdWJsaWNJbnN0YW5jZTtcblxuICB2YXIgX1JlYWN0RmliZXJTY2hlZHVsZXIgPSBSZWFjdEZpYmVyU2NoZWR1bGVyKGNvbmZpZyksXG4gICAgICBjb21wdXRlQXN5bmNFeHBpcmF0aW9uID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuY29tcHV0ZUFzeW5jRXhwaXJhdGlvbixcbiAgICAgIGNvbXB1dGVFeHBpcmF0aW9uRm9yRmliZXIgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5jb21wdXRlRXhwaXJhdGlvbkZvckZpYmVyLFxuICAgICAgc2NoZWR1bGVXb3JrID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuc2NoZWR1bGVXb3JrLFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci5iYXRjaGVkVXBkYXRlcyxcbiAgICAgIHVuYmF0Y2hlZFVwZGF0ZXMgPSBfUmVhY3RGaWJlclNjaGVkdWxlci51bmJhdGNoZWRVcGRhdGVzLFxuICAgICAgZmx1c2hTeW5jID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZmx1c2hTeW5jLFxuICAgICAgZGVmZXJyZWRVcGRhdGVzID0gX1JlYWN0RmliZXJTY2hlZHVsZXIuZGVmZXJyZWRVcGRhdGVzO1xuXG4gIGZ1bmN0aW9uIHNjaGVkdWxlVG9wTGV2ZWxVcGRhdGUoY3VycmVudCwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICB7XG4gICAgICBpZiAoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5waGFzZSA9PT0gJ3JlbmRlcicgJiYgUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50ICE9PSBudWxsICYmICFkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWUoUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5jdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcbiAgICB7XG4gICAgICB3YXJuaW5nKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJywgJ3JlbmRlciguLi4pOiBFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgIH1cblxuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IHZvaWQgMDtcbiAgICAvLyBDaGVjayBpZiB0aGUgdG9wLWxldmVsIGVsZW1lbnQgaXMgYW4gYXN5bmMgd3JhcHBlciBjb21wb25lbnQuIElmIHNvLFxuICAgIC8vIHRyZWF0IHVwZGF0ZXMgdG8gdGhlIHJvb3QgYXMgYXN5bmMuIFRoaXMgaXMgYSBiaXQgd2VpcmQgYnV0IGxldHMgdXNcbiAgICAvLyBhdm9pZCBhIHNlcGFyYXRlIGByZW5kZXJBc3luY2AgQVBJLlxuICAgIGlmIChlbmFibGVBc3luY1N1YnRyZWVBUEkgJiYgZWxlbWVudCAhPSBudWxsICYmIGVsZW1lbnQudHlwZSAhPSBudWxsICYmIGVsZW1lbnQudHlwZS5wcm90b3R5cGUgIT0gbnVsbCAmJiBlbGVtZW50LnR5cGUucHJvdG90eXBlLnVuc3RhYmxlX2lzQXN5bmNSZWFjdENvbXBvbmVudCA9PT0gdHJ1ZSkge1xuICAgICAgZXhwaXJhdGlvblRpbWUgPSBjb21wdXRlQXN5bmNFeHBpcmF0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cGlyYXRpb25UaW1lID0gY29tcHV0ZUV4cGlyYXRpb25Gb3JGaWJlcihjdXJyZW50KTtcbiAgICB9XG5cbiAgICB2YXIgdXBkYXRlID0ge1xuICAgICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgICAgcGFydGlhbFN0YXRlOiB7IGVsZW1lbnQ6IGVsZW1lbnQgfSxcbiAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgIGlzUmVwbGFjZTogZmFsc2UsXG4gICAgICBpc0ZvcmNlZDogZmFsc2UsXG4gICAgICBuZXh0Q2FsbGJhY2s6IG51bGwsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpbnNlcnRVcGRhdGVJbnRvRmliZXIoY3VycmVudCwgdXBkYXRlKTtcbiAgICBzY2hlZHVsZVdvcmsoY3VycmVudCwgZXhwaXJhdGlvblRpbWUpO1xuICB9XG5cbiAgZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZShmaWJlcikge1xuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG4gICAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBob3N0RmliZXIuc3RhdGVOb2RlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjcmVhdGVDb250YWluZXI6IGZ1bmN0aW9uIChjb250YWluZXJJbmZvLCBoeWRyYXRlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIGh5ZHJhdGUpO1xuICAgIH0sXG4gICAgdXBkYXRlQ29udGFpbmVyOiBmdW5jdGlvbiAoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gICAgICAvLyBUT0RPOiBJZiB0aGlzIGlzIGEgbmVzdGVkIGNvbnRhaW5lciwgdGhpcyB3b24ndCBiZSB0aGUgcm9vdC5cbiAgICAgIHZhciBjdXJyZW50ID0gY29udGFpbmVyLmN1cnJlbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wpIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIFJlYWN0RmliZXJJbnN0cnVtZW50YXRpb25fMS5kZWJ1Z1Rvb2wub25Nb3VudENvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVubW91bnRDb250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgUmVhY3RGaWJlckluc3RydW1lbnRhdGlvbl8xLmRlYnVnVG9vbC5vblVwZGF0ZUNvbnRhaW5lcihjb250YWluZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG4gICAgICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICAgICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIH1cblxuICAgICAgc2NoZWR1bGVUb3BMZXZlbFVwZGF0ZShjdXJyZW50LCBlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgfSxcblxuXG4gICAgYmF0Y2hlZFVwZGF0ZXM6IGJhdGNoZWRVcGRhdGVzLFxuXG4gICAgdW5iYXRjaGVkVXBkYXRlczogdW5iYXRjaGVkVXBkYXRlcyxcblxuICAgIGRlZmVycmVkVXBkYXRlczogZGVmZXJyZWRVcGRhdGVzLFxuXG4gICAgZmx1c2hTeW5jOiBmbHVzaFN5bmMsXG5cbiAgICBnZXRQdWJsaWNSb290SW5zdGFuY2U6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAgIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuICAgICAgaWYgKCFjb250YWluZXJGaWJlci5jaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgfVxuICAgIH0sXG5cblxuICAgIGZpbmRIb3N0SW5zdGFuY2U6IGZpbmRIb3N0SW5zdGFuY2UsXG5cbiAgICBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFsczogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcbiAgICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbiAgICB9LFxuICAgIGluamVjdEludG9EZXZUb29sczogZnVuY3Rpb24gKGRldlRvb2xzQ29uZmlnKSB7XG4gICAgICB2YXIgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgPSBkZXZUb29sc0NvbmZpZy5maW5kRmliZXJCeUhvc3RJbnN0YW5jZTtcblxuICAgICAgcmV0dXJuIGluamVjdEludGVybmFscyhfYXNzaWduKHt9LCBkZXZUb29sc0NvbmZpZywge1xuICAgICAgICBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcjogZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZpbmRIb3N0SW5zdGFuY2UoZmliZXIpO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICAgICAgaWYgKCFmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSkge1xuICAgICAgICAgICAgLy8gTWlnaHQgbm90IGJlIGltcGxlbWVudGVkIGJ5IHRoZSByZW5kZXJlci5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfVxuICB9O1xufTtcblxudmFyIFJlYWN0RmliZXJSZWNvbmNpbGVyJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RGaWJlclJlY29uY2lsZXIkMVxufSk7XG5cbnZhciBSZWFjdEZpYmVyUmVjb25jaWxlciQzID0gKCBSZWFjdEZpYmVyUmVjb25jaWxlciQyICYmIFJlYWN0RmliZXJSZWNvbmNpbGVyJDEgKSB8fCBSZWFjdEZpYmVyUmVjb25jaWxlciQyO1xuXG4vLyBUT0RPOiBidW5kbGUgRmxvdyB0eXBlcyB3aXRoIHRoZSBwYWNrYWdlLlxuXG5cblxuLy8gVE9ETzogZGVjaWRlIG9uIHRoZSB0b3AtbGV2ZWwgZXhwb3J0IGZvcm0uXG4vLyBUaGlzIGlzIGhhY2t5IGJ1dCBtYWtlcyBpdCB3b3JrIHdpdGggYm90aCBSb2xsdXAgYW5kIEplc3QuXG52YXIgcmVhY3RSZWNvbmNpbGVyID0gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddID8gUmVhY3RGaWJlclJlY29uY2lsZXIkM1snZGVmYXVsdCddIDogUmVhY3RGaWJlclJlY29uY2lsZXIkMztcblxuLy8gVE9ETzogdGhpcyBpcyBzcGVjaWFsIGJlY2F1c2UgaXQgZ2V0cyBpbXBvcnRlZCBkdXJpbmcgYnVpbGQuXG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTYuMS4wJztcblxuLy8gYSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUsIHN0b3JpbmcgdGhlIHRpbWUgZm9yIHRoZSBzdGFydCBvZiB0aGUgZnJhbWUsIHRoZW5cbi8vIHNjaGVkdWxpbmcgYSBwb3N0TWVzc2FnZSB3aGljaCBnZXRzIHNjaGVkdWxlZCBhZnRlciBwYWludC4gV2l0aGluIHRoZVxuLy8gcG9zdE1lc3NhZ2UgaGFuZGxlciBkbyBhcyBtdWNoIHdvcmsgYXMgcG9zc2libGUgdW50aWwgdGltZSArIGZyYW1lIHJhdGUuXG4vLyBCeSBzZXBhcmF0aW5nIHRoZSBpZGxlIGNhbGwgaW50byBhIHNlcGFyYXRlIGV2ZW50IHRpY2sgd2UgZW5zdXJlIHRoYXRcbi8vIGxheW91dCwgcGFpbnQgYW5kIG90aGVyIGJyb3dzZXIgd29yayBpcyBjb3VudGVkIGFnYWluc3QgdGhlIGF2YWlsYWJsZSB0aW1lLlxuLy8gVGhlIGZyYW1lIHJhdGUgaXMgZHluYW1pY2FsbHkgYWRqdXN0ZWQuXG5cbntcbiAgaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiB0eXBlb2YgcmVxdWVzdEFuaW1hdGlvbkZyYW1lICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRlcGVuZHMgb24gcmVxdWVzdEFuaW1hdGlvbkZyYW1lLiBNYWtlIHN1cmUgdGhhdCB5b3UgbG9hZCBhICcgKyAncG9seWZpbGwgaW4gb2xkZXIgYnJvd3NlcnMuIGh0dHA6Ly9mYi5tZS9yZWFjdC1wb2x5ZmlsbHMnKTtcbiAgfVxufVxuXG52YXIgaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbnZhciBub3cgPSB2b2lkIDA7XG5pZiAoaGFzTmF0aXZlUGVyZm9ybWFuY2VOb3cpIHtcbiAgbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIG5vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcbiAgfTtcbn1cblxuLy8gVE9ETzogVGhlcmUncyBubyB3YXkgdG8gY2FuY2VsLCBiZWNhdXNlIEZpYmVyIGRvZXNuJ3QgYXRtLlxudmFyIHJJQyA9IHZvaWQgMDtcblxuaWYgKCFFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgcklDID0gZnVuY3Rpb24gKGZyYW1lQ2FsbGJhY2spIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGZyYW1lQ2FsbGJhY2soe1xuICAgICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIEluZmluaXR5O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gMDtcbiAgfTtcbn0gZWxzZSBpZiAodHlwZW9mIHJlcXVlc3RJZGxlQ2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgLy8gUG9seWZpbGwgcmVxdWVzdElkbGVDYWxsYmFjay5cblxuICB2YXIgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuXG4gIHZhciBpc0lkbGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgdmFyIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICB2YXIgZnJhbWVEZWFkbGluZSA9IDA7XG4gIC8vIFdlIHN0YXJ0IG91dCBhc3N1bWluZyB0aGF0IHdlIHJ1biBhdCAzMGZwcyBidXQgdGhlbiB0aGUgaGV1cmlzdGljIHRyYWNraW5nXG4gIC8vIHdpbGwgYWRqdXN0IHRoaXMgdmFsdWUgdG8gYSBmYXN0ZXIgZnBzIGlmIHdlIGdldCBtb3JlIGZyZXF1ZW50IGFuaW1hdGlvblxuICAvLyBmcmFtZXMuXG4gIHZhciBwcmV2aW91c0ZyYW1lVGltZSA9IDMzO1xuICB2YXIgYWN0aXZlRnJhbWVUaW1lID0gMzM7XG5cbiAgdmFyIGZyYW1lRGVhZGxpbmVPYmplY3Q7XG4gIGlmIChoYXNOYXRpdmVQZXJmb3JtYW5jZU5vdykge1xuICAgIGZyYW1lRGVhZGxpbmVPYmplY3QgPSB7XG4gICAgICB0aW1lUmVtYWluaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFdlIGFzc3VtZSB0aGF0IGlmIHdlIGhhdmUgYSBwZXJmb3JtYW5jZSB0aW1lciB0aGF0IHRoZSByQUYgY2FsbGJhY2tcbiAgICAgICAgLy8gZ2V0cyBhIHBlcmZvcm1hbmNlIHRpbWVyIHZhbHVlLiBOb3Qgc3VyZSBpZiB0aGlzIGlzIGFsd2F5cyB0cnVlLlxuICAgICAgICByZXR1cm4gZnJhbWVEZWFkbGluZSAtIHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgfVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnJhbWVEZWFkbGluZU9iamVjdCA9IHtcbiAgICAgIHRpbWVSZW1haW5pbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gRmFsbGJhY2sgdG8gRGF0ZS5ub3coKVxuICAgICAgICByZXR1cm4gZnJhbWVEZWFkbGluZSAtIERhdGUubm93KCk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8vIFdlIHVzZSB0aGUgcG9zdE1lc3NhZ2UgdHJpY2sgdG8gZGVmZXIgaWRsZSB3b3JrIHVudGlsIGFmdGVyIHRoZSByZXBhaW50LlxuICB2YXIgbWVzc2FnZUtleSA9ICdfX3JlYWN0SWRsZUNhbGxiYWNrJCcgKyBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zbGljZSgyKTtcbiAgdmFyIGlkbGVUaWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnNvdXJjZSAhPT0gd2luZG93IHx8IGV2ZW50LmRhdGEgIT09IG1lc3NhZ2VLZXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaXNJZGxlU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgdmFyIGNhbGxiYWNrID0gc2NoZWR1bGVkUklDQ2FsbGJhY2s7XG4gICAgc2NoZWR1bGVkUklDQ2FsbGJhY2sgPSBudWxsO1xuICAgIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAgY2FsbGJhY2soZnJhbWVEZWFkbGluZU9iamVjdCk7XG4gICAgfVxuICB9O1xuICAvLyBBc3N1bWVzIHRoYXQgd2UgaGF2ZSBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgZW52aXJvbm1lbnQuIE1pZ2h0IG5lZWRcbiAgLy8gc29tZXRoaW5nIGJldHRlciBmb3Igb2xkIElFLlxuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGlkbGVUaWNrLCBmYWxzZSk7XG5cbiAgdmFyIGFuaW1hdGlvblRpY2sgPSBmdW5jdGlvbiAocmFmVGltZSkge1xuICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB2YXIgbmV4dEZyYW1lVGltZSA9IHJhZlRpbWUgLSBmcmFtZURlYWRsaW5lICsgYWN0aXZlRnJhbWVUaW1lO1xuICAgIGlmIChuZXh0RnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lICYmIHByZXZpb3VzRnJhbWVUaW1lIDwgYWN0aXZlRnJhbWVUaW1lKSB7XG4gICAgICBpZiAobmV4dEZyYW1lVGltZSA8IDgpIHtcbiAgICAgICAgLy8gRGVmZW5zaXZlIGNvZGluZy4gV2UgZG9uJ3Qgc3VwcG9ydCBoaWdoZXIgZnJhbWUgcmF0ZXMgdGhhbiAxMjBoei5cbiAgICAgICAgLy8gSWYgd2UgZ2V0IGxvd2VyIHRoYW4gdGhhdCwgaXQgaXMgcHJvYmFibHkgYSBidWcuXG4gICAgICAgIG5leHRGcmFtZVRpbWUgPSA4O1xuICAgICAgfVxuICAgICAgLy8gSWYgb25lIGZyYW1lIGdvZXMgbG9uZywgdGhlbiB0aGUgbmV4dCBvbmUgY2FuIGJlIHNob3J0IHRvIGNhdGNoIHVwLlxuICAgICAgLy8gSWYgdHdvIGZyYW1lcyBhcmUgc2hvcnQgaW4gYSByb3csIHRoZW4gdGhhdCdzIGFuIGluZGljYXRpb24gdGhhdCB3ZVxuICAgICAgLy8gYWN0dWFsbHkgaGF2ZSBhIGhpZ2hlciBmcmFtZSByYXRlIHRoYW4gd2hhdCB3ZSdyZSBjdXJyZW50bHkgb3B0aW1pemluZy5cbiAgICAgIC8vIFdlIGFkanVzdCBvdXIgaGV1cmlzdGljIGR5bmFtaWNhbGx5IGFjY29yZGluZ2x5LiBGb3IgZXhhbXBsZSwgaWYgd2UncmVcbiAgICAgIC8vIHJ1bm5pbmcgb24gMTIwaHogZGlzcGxheSBvciA5MGh6IFZSIGRpc3BsYXkuXG4gICAgICAvLyBUYWtlIHRoZSBtYXggb2YgdGhlIHR3byBpbiBjYXNlIG9uZSBvZiB0aGVtIHdhcyBhbiBhbm9tYWx5IGR1ZSB0b1xuICAgICAgLy8gbWlzc2VkIGZyYW1lIGRlYWRsaW5lcy5cbiAgICAgIGFjdGl2ZUZyYW1lVGltZSA9IG5leHRGcmFtZVRpbWUgPCBwcmV2aW91c0ZyYW1lVGltZSA/IHByZXZpb3VzRnJhbWVUaW1lIDogbmV4dEZyYW1lVGltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJldmlvdXNGcmFtZVRpbWUgPSBuZXh0RnJhbWVUaW1lO1xuICAgIH1cbiAgICBmcmFtZURlYWRsaW5lID0gcmFmVGltZSArIGFjdGl2ZUZyYW1lVGltZTtcbiAgICBpZiAoIWlzSWRsZVNjaGVkdWxlZCkge1xuICAgICAgaXNJZGxlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgIHdpbmRvdy5wb3N0TWVzc2FnZShtZXNzYWdlS2V5LCAnKicpO1xuICAgIH1cbiAgfTtcblxuICBySUMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBUaGlzIGFzc3VtZXMgdGhhdCB3ZSBvbmx5IHNjaGVkdWxlIG9uZSBjYWxsYmFjayBhdCBhIHRpbWUgYmVjYXVzZSB0aGF0J3NcbiAgICAvLyBob3cgRmliZXIgdXNlcyBpdC5cbiAgICBzY2hlZHVsZWRSSUNDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIGlmICghaXNBbmltYXRpb25GcmFtZVNjaGVkdWxlZCkge1xuICAgICAgLy8gSWYgckFGIGRpZG4ndCBhbHJlYWR5IHNjaGVkdWxlIG9uZSwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGZyYW1lLlxuICAgICAgLy8gVE9ETzogSWYgdGhpcyByQUYgZG9lc24ndCBtYXRlcmlhbGl6ZSBiZWNhdXNlIHRoZSBicm93c2VyIHRocm90dGxlcywgd2VcbiAgICAgIC8vIG1pZ2h0IHdhbnQgdG8gc3RpbGwgaGF2ZSBzZXRUaW1lb3V0IHRyaWdnZXIgcklDIGFzIGEgYmFja3VwIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB3ZSBrZWVwIHBlcmZvcm1pbmcgd29yay5cbiAgICAgIGlzQW5pbWF0aW9uRnJhbWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvblRpY2spO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn0gZWxzZSB7XG4gIHJJQyA9IHJlcXVlc3RJZGxlQ2FsbGJhY2s7XG59XG5cbi8qKlxuICogRm9ya2VkIGZyb20gZmJqcy93YXJuaW5nOlxuICogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2ZianMvYmxvYi9lNjZiYTIwYWQ1YmU0MzNlYjU0NDIzZjJiMDk3ZDgyOTMyNGQ5ZGU2L3BhY2thZ2VzL2ZianMvc3JjL19fZm9ya3NfXy93YXJuaW5nLmpzXG4gKlxuICogT25seSBjaGFuZ2UgaXMgd2UgdXNlIGNvbnNvbGUud2FybiBpbnN0ZWFkIG9mIGNvbnNvbGUuZXJyb3IsXG4gKiBhbmQgZG8gbm90aGluZyB3aGVuICdjb25zb2xlJyBpcyBub3Qgc3VwcG9ydGVkLlxuICogVGhpcyByZWFsbHkgc2ltcGxpZmllcyB0aGUgY29kZS5cbiAqIC0tLVxuICogU2ltaWxhciB0byBpbnZhcmlhbnQgYnV0IG9ubHkgbG9ncyBhIHdhcm5pbmcgaWYgdGhlIGNvbmRpdGlvbiBpcyBub3QgbWV0LlxuICogVGhpcyBjYW4gYmUgdXNlZCB0byBsb2cgaXNzdWVzIGluIGRldmVsb3BtZW50IGVudmlyb25tZW50cyBpbiBjcml0aWNhbFxuICogcGF0aHMuIFJlbW92aW5nIHRoZSBsb2dnaW5nIGNvZGUgZm9yIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzIHdpbGwga2VlcCB0aGVcbiAqIHNhbWUgbG9naWMgYW5kIGZvbGxvdyB0aGUgc2FtZSBjb2RlIHBhdGhzLlxuICovXG5cbnZhciBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7fTtcblxue1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIC8vIC0tLSBXZWxjb21lIHRvIGRlYnVnZ2luZyBSZWFjdCAtLS1cbiAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgLy8gdG8gZmluZCB0aGUgY2FsbHNpdGUgdGhhdCBjYXVzZWQgdGhpcyB3YXJuaW5nIHRvIGZpcmUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgfSBjYXRjaCAoeCkge31cbiAgfTtcblxuICBsb3dQcmlvcml0eVdhcm5pbmcgPSBmdW5jdGlvbiAoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG52YXIgbG93UHJpb3JpdHlXYXJuaW5nJDEgPSBsb3dQcmlvcml0eVdhcm5pbmc7XG5cbi8vIGlzQXR0cmlidXRlTmFtZVNhZmUoKSBpcyBjdXJyZW50bHkgZHVwbGljYXRlZCBpbiBET01NYXJrdXBPcGVyYXRpb25zLlxuLy8gVE9ETzogRmluZCBhIGJldHRlciBwbGFjZSBmb3IgdGhpcy5cbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IG5ldyBSZWdFeHAoJ15bJyArIEFUVFJJQlVURV9OQU1FX1NUQVJUX0NIQVIgKyAnXVsnICsgQVRUUklCVVRFX05BTUVfQ0hBUiArICddKiQnKTtcbnZhciBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG52YXIgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlID0ge307XG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzaG91bGRJZ25vcmVWYWx1ZSgpIGlzIGN1cnJlbnRseSBkdXBsaWNhdGVkIGluIERPTU1hcmt1cE9wZXJhdGlvbnMuXG4vLyBUT0RPOiBGaW5kIGEgYmV0dGVyIHBsYWNlIGZvciB0aGlzLlxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuLyoqXG4gKiBPcGVyYXRpb25zIGZvciBkZWFsaW5nIHdpdGggRE9NIHByb3BlcnRpZXMuXG4gKi9cblxuXG5cblxuXG4vKipcbiAqIEdldCB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSBcImV4cGVjdGVkXCIgYXJndW1lbnQgaXMgdXNlZCBhcyBhIGhpbnQgb2Ygd2hhdCB0aGUgZXhwZWN0ZWQgdmFsdWUgaXMuXG4gKiBTb21lIHByb3BlcnRpZXMgaGF2ZSBtdWx0aXBsZSBlcXVpdmFsZW50IHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZ2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcbiAgICBpZiAocHJvcGVydHlJbmZvKSB7XG4gICAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgICBpZiAobXV0YXRpb25NZXRob2QgfHwgcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gbm9kZVtwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWU7XG5cbiAgICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gbnVsbDtcblxuICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUpIHtcbiAgICAgICAgICBpZiAobm9kZS5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSAnJykge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGV4cGVjdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChub2RlLmhhc0F0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgICAgLy8gV2UgaGFkIGFuIGF0dHJpYnV0ZSBidXQgc2hvdWxkbid0IGhhdmUgaGFkIG9uZSwgc28gcmVhZCBpdFxuICAgICAgICAgICAgLy8gZm9yIHRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAgICAgICAgcmV0dXJuIG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyB3YXMgYSBib29sZWFuLCBpdCBkb2Vzbid0IG1hdHRlciB3aGF0IHRoZSB2YWx1ZSBpc1xuICAgICAgICAgICAgLy8gdGhlIGZhY3QgdGhhdCB3ZSBoYXZlIGl0IGlzIHRoZSBzYW1lIGFzIHRoZSBleHBlY3RlZC5cbiAgICAgICAgICAgIHJldHVybiBleHBlY3RlZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRXZlbiBpZiB0aGlzIHByb3BlcnR5IHVzZXMgYSBuYW1lc3BhY2Ugd2UgdXNlIGdldEF0dHJpYnV0ZVxuICAgICAgICAgIC8vIGJlY2F1c2Ugd2UgYXNzdW1lIGl0cyBuYW1lc3BhY2VkIG5hbWUgaXMgdGhlIHNhbWUgYXMgb3VyIGNvbmZpZy5cbiAgICAgICAgICAvLyBUbyB1c2UgZ2V0QXR0cmlidXRlTlMgd2UgbmVlZCB0aGUgbG9jYWwgbmFtZSB3aGljaCB3ZSBkb24ndCBoYXZlXG4gICAgICAgICAgLy8gaW4gb3VyIGNvbmZpZyBhdG0uXG4gICAgICAgICAgc3RyaW5nVmFsdWUgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIGV4cGVjdGVkKSkge1xuICAgICAgICAgIHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gbnVsbCA/IGV4cGVjdGVkIDogc3RyaW5nVmFsdWU7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RyaW5nVmFsdWUgPT09ICcnICsgZXhwZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZSBmb3IgYSBhdHRyaWJ1dGUgb24gYSBub2RlLiBPbmx5IHVzZWQgaW4gREVWIGZvciBTU1IgdmFsaWRhdGlvbi5cbiAqIFRoZSB0aGlyZCBhcmd1bWVudCBpcyB1c2VkIGFzIGEgaGludCBvZiB3aGF0IHRoZSBleHBlY3RlZCB2YWx1ZSBpcy4gU29tZVxuICogYXR0cmlidXRlcyBoYXZlIG11bHRpcGxlIGVxdWl2YWxlbnQgdmFsdWVzLlxuICovXG5mdW5jdGlvbiBnZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCBleHBlY3RlZCkge1xuICB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbm9kZS5oYXNBdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIHJldHVybiBleHBlY3RlZCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogbnVsbDtcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG4gICAgaWYgKHZhbHVlID09PSAnJyArIGV4cGVjdGVkKSB7XG4gICAgICByZXR1cm4gZXhwZWN0ZWQ7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0geyp9IHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yUHJvcGVydHkobm9kZSwgbmFtZSwgdmFsdWUpIHtcbiAgdmFyIHByb3BlcnR5SW5mbyA9IGdldFByb3BlcnR5SW5mbyhuYW1lKTtcblxuICBpZiAocHJvcGVydHlJbmZvICYmIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKTtcbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5tdXN0VXNlUHJvcGVydHkpIHtcbiAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgIC8vIGB0b1N0cmluZ2BlZCBieSBJRTgvOS5cbiAgICAgIG5vZGVbcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZTtcbiAgICAgIHZhciBuYW1lc3BhY2UgPSBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlO1xuICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgLy8gKCcnICsgdmFsdWUpIG1ha2VzIGl0IG91dHB1dCB0aGUgY29ycmVjdCB0b1N0cmluZygpLXZhbHVlLlxuICAgICAgaWYgKG5hbWVzcGFjZSkge1xuICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNldFZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUsIHNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkgPyB2YWx1ZSA6IG51bGwpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSkge1xuICBpZiAoIWlzQXR0cmlidXRlTmFtZVNhZmUobmFtZSkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShuYW1lLCAnJyArIHZhbHVlKTtcbiAgfVxuXG4gIHtcbiAgICBcbiAgfVxufVxuXG4vKipcbiAqIERlbGV0ZXMgYW4gYXR0cmlidXRlcyBmcm9tIGEgbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKG5vZGUsIG5hbWUpIHtcbiAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG59XG5cbi8qKlxuICogRGVsZXRlcyB0aGUgdmFsdWUgZm9yIGEgcHJvcGVydHkgb24gYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqL1xuZnVuY3Rpb24gZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lKSB7XG4gIHZhciBwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8obmFtZSk7XG4gIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICB2YXIgbXV0YXRpb25NZXRob2QgPSBwcm9wZXJ0eUluZm8ubXV0YXRpb25NZXRob2Q7XG4gICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkge1xuICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgIGlmIChwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlKSB7XG4gICAgICAgIG5vZGVbcHJvcE5hbWVdID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlW3Byb3BOYW1lXSA9ICcnO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5cbnZhciBSZWFjdENvbnRyb2xsZWRWYWx1ZVByb3BUeXBlcyA9IHtcbiAgY2hlY2tQcm9wVHlwZXM6IG51bGxcbn07XG5cbntcbiAgdmFyIGhhc1JlYWRPbmx5VmFsdWUgPSB7XG4gICAgYnV0dG9uOiB0cnVlLFxuICAgIGNoZWNrYm94OiB0cnVlLFxuICAgIGltYWdlOiB0cnVlLFxuICAgIGhpZGRlbjogdHJ1ZSxcbiAgICByYWRpbzogdHJ1ZSxcbiAgICByZXNldDogdHJ1ZSxcbiAgICBzdWJtaXQ6IHRydWVcbiAgfTtcblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIHZhbHVlOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgICBpZiAoIXByb3BzW3Byb3BOYW1lXSB8fCBoYXNSZWFkT25seVZhbHVlW3Byb3BzLnR5cGVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYHZhbHVlYCBwcm9wIHRvIGEgZm9ybSBmaWVsZCB3aXRob3V0IGFuICcgKyAnYG9uQ2hhbmdlYCBoYW5kbGVyLiBUaGlzIHdpbGwgcmVuZGVyIGEgcmVhZC1vbmx5IGZpZWxkLiBJZiAnICsgJ3RoZSBmaWVsZCBzaG91bGQgYmUgbXV0YWJsZSB1c2UgYGRlZmF1bHRWYWx1ZWAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgICB9LFxuICAgIGNoZWNrZWQ6IGZ1bmN0aW9uIChwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUpIHtcbiAgICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IHByb3BzLm9uQ2hhbmdlIHx8IHByb3BzLnJlYWRPbmx5IHx8IHByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBFcnJvcignWW91IHByb3ZpZGVkIGEgYGNoZWNrZWRgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdENoZWNrZWRgLiBPdGhlcndpc2UsICcgKyAnc2V0IGVpdGhlciBgb25DaGFuZ2VgIG9yIGByZWFkT25seWAuJyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgbGlua2VkIGB2YWx1ZWAgYXR0cmlidXRlIGZvciBjb250cm9sbGVkIGZvcm1zLiBZb3Ugc2hvdWxkIG5vdCB1c2VcbiAgICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAgICovXG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZnVuY3Rpb24gKHRhZ05hbWUsIHByb3BzLCBnZXRTdGFjaykge1xuICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgcHJvcHMsICdwcm9wJywgdGFnTmFtZSwgZ2V0U3RhY2spO1xuICB9O1xufVxuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlck93bmVyTmFtZTtcbnZhciBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMgPSBSZWFjdERlYnVnQ3VycmVudEZpYmVyLmdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW07XG5cbnZhciBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gZmFsc2U7XG52YXIgZGlkV2FybkNvbnRyb2xsZWRUb1VuY29udHJvbGxlZCA9IGZhbHNlO1xudmFyIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGVkKHByb3BzKSB7XG4gIHZhciB1c2VzQ2hlY2tlZCA9IHByb3BzLnR5cGUgPT09ICdjaGVja2JveCcgfHwgcHJvcHMudHlwZSA9PT0gJ3JhZGlvJztcbiAgcmV0dXJuIHVzZXNDaGVja2VkID8gcHJvcHMuY2hlY2tlZCAhPSBudWxsIDogcHJvcHMudmFsdWUgIT0gbnVsbDtcbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyB0aGVzZSBvcHRpb25hbFxuICogcHJvcHM6IGBjaGVja2VkYCwgYHZhbHVlYCwgYGRlZmF1bHRDaGVja2VkYCwgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICpcbiAqIElmIGBjaGVja2VkYCBvciBgdmFsdWVgIGFyZSBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zXG4gKiB0aGF0IGFmZmVjdCB0aGUgY2hlY2tlZCBzdGF0ZSBvciB2YWx1ZSB3aWxsIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC5cbiAqXG4gKiBJZiB0aGV5IGFyZSBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgbm90XG4gKiB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBwcm9wcyBtdXN0IGNoYW5nZSBpbiBvcmRlciBmb3JcbiAqIHRoZSByZW5kZXJlZCBlbGVtZW50IHRvIGJlIHVwZGF0ZWQuXG4gKlxuICogVGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBiZSBpbml0aWFsaXplZCBhcyB1bmNoZWNrZWQgKG9yIGBkZWZhdWx0Q2hlY2tlZGApXG4gKiB3aXRoIGFuIGVtcHR5IHZhbHVlIChvciBgZGVmYXVsdFZhbHVlYCkuXG4gKlxuICogU2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG5cbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oe1xuICAgIC8vIE1ha2Ugc3VyZSB3ZSBzZXQgLnR5cGUgYmVmb3JlIGFueSBvdGhlciBwcm9wZXJ0aWVzIChzZXR0aW5nIC52YWx1ZVxuICAgIC8vIGJlZm9yZSAudHlwZSBtZWFucyAudmFsdWUgaXMgbG9zdCBpbiBJRTExIGFuZCBiZWxvdylcbiAgICB0eXBlOiB1bmRlZmluZWQsXG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAuc3RlcCBiZWZvcmUgLnZhbHVlIChzZXR0aW5nIC52YWx1ZSBiZWZvcmUgLnN0ZXBcbiAgICAvLyBtZWFucyAudmFsdWUgaXMgcm91bmRlZCBvbiBtb3VudCwgYmFzZWQgdXBvbiBzdGVwIHByZWNpc2lvbilcbiAgICBzdGVwOiB1bmRlZmluZWQsXG4gICAgLy8gTWFrZSBzdXJlIHdlIHNldCAubWluICYgLm1heCBiZWZvcmUgLnZhbHVlICh0byBlbnN1cmUgcHJvcGVyIG9yZGVyXG4gICAgLy8gaW4gY29ybmVyIGNhc2VzIHN1Y2ggYXMgbWluIG9yIG1heCBkZXJpdmluZyBmcm9tIHZhbHVlLCBlLmcuIElzc3VlICM3MTcwKVxuICAgIG1pbjogdW5kZWZpbmVkLFxuICAgIG1heDogdW5kZWZpbmVkXG4gIH0sIHByb3BzLCB7XG4gICAgZGVmYXVsdENoZWNrZWQ6IHVuZGVmaW5lZCxcbiAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICBjaGVja2VkOiBjaGVja2VkICE9IG51bGwgPyBjaGVja2VkIDogbm9kZS5fd3JhcHBlclN0YXRlLmluaXRpYWxDaGVja2VkXG4gIH0pO1xuXG4gIHJldHVybiBob3N0UHJvcHM7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUoZWxlbWVudCwgcHJvcHMpIHtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMpO1xuXG4gICAgaWYgKHByb3BzLmNoZWNrZWQgIT09IHVuZGVmaW5lZCAmJiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgY29udGFpbnMgYW4gaW5wdXQgb2YgdHlwZSAlcyB3aXRoIGJvdGggY2hlY2tlZCBhbmQgZGVmYXVsdENoZWNrZWQgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIGNoZWNrZWQgcHJvcCwgb3IgdGhlIGRlZmF1bHRDaGVja2VkIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgYW5kIHJlbW92ZSBvbmUgb2YgdGhlc2UgcHJvcHMuIE1vcmUgaW5mbzogJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWNvbnRyb2xsZWQtY29tcG9uZW50cycsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQyKCkgfHwgJ0EgY29tcG9uZW50JywgcHJvcHMudHlwZSk7XG4gICAgICBkaWRXYXJuQ2hlY2tlZERlZmF1bHRDaGVja2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLnZhbHVlICE9PSB1bmRlZmluZWQgJiYgcHJvcHMuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJyVzIGNvbnRhaW5zIGFuIGlucHV0IG9mIHR5cGUgJXMgd2l0aCBib3RoIHZhbHVlIGFuZCBkZWZhdWx0VmFsdWUgcHJvcHMuICcgKyAnSW5wdXQgZWxlbWVudHMgbXVzdCBiZSBlaXRoZXIgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgJyArICcoc3BlY2lmeSBlaXRoZXIgdGhlIHZhbHVlIHByb3AsIG9yIHRoZSBkZWZhdWx0VmFsdWUgcHJvcCwgYnV0IG5vdCAnICsgJ2JvdGgpLiBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDIoKSB8fCAnQSBjb21wb25lbnQnLCBwcm9wcy50eXBlKTtcbiAgICAgIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmNoZWNrZWQgIT0gbnVsbCA/IHByb3BzLmNoZWNrZWQgOiBwcm9wcy5kZWZhdWx0Q2hlY2tlZCxcbiAgICBpbml0aWFsVmFsdWU6IHByb3BzLnZhbHVlICE9IG51bGwgPyBwcm9wcy52YWx1ZSA6IGRlZmF1bHRWYWx1ZSxcbiAgICBjb250cm9sbGVkOiBpc0NvbnRyb2xsZWQocHJvcHMpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB7XG4gICAgdmFyIGNvbnRyb2xsZWQgPSBpc0NvbnRyb2xsZWQocHJvcHMpO1xuXG4gICAgaWYgKCFub2RlLl93cmFwcGVyU3RhdGUuY29udHJvbGxlZCAmJiBjb250cm9sbGVkICYmICFkaWRXYXJuVW5jb250cm9sbGVkVG9Db250cm9sbGVkKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnQSBjb21wb25lbnQgaXMgY2hhbmdpbmcgYW4gdW5jb250cm9sbGVkIGlucHV0IG9mIHR5cGUgJXMgdG8gYmUgY29udHJvbGxlZC4gJyArICdJbnB1dCBlbGVtZW50cyBzaG91bGQgbm90IHN3aXRjaCBmcm9tIHVuY29udHJvbGxlZCB0byBjb250cm9sbGVkIChvciB2aWNlIHZlcnNhKS4gJyArICdEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkIGlucHV0ICcgKyAnZWxlbWVudCBmb3IgdGhlIGxpZmV0aW1lIG9mIHRoZSBjb21wb25lbnQuIE1vcmUgaW5mbzogaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMlcycsIHByb3BzLnR5cGUsIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kMygpKTtcbiAgICAgIGRpZFdhcm5VbmNvbnRyb2xsZWRUb0NvbnRyb2xsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAobm9kZS5fd3JhcHBlclN0YXRlLmNvbnRyb2xsZWQgJiYgIWNvbnRyb2xsZWQgJiYgIWRpZFdhcm5Db250cm9sbGVkVG9VbmNvbnRyb2xsZWQpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyBhIGNvbnRyb2xsZWQgaW5wdXQgb2YgdHlwZSAlcyB0byBiZSB1bmNvbnRyb2xsZWQuICcgKyAnSW5wdXQgZWxlbWVudHMgc2hvdWxkIG5vdCBzd2l0Y2ggZnJvbSBjb250cm9sbGVkIHRvIHVuY29udHJvbGxlZCAob3IgdmljZSB2ZXJzYSkuICcgKyAnRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCBpbnB1dCAnICsgJ2VsZW1lbnQgZm9yIHRoZSBsaWZldGltZSBvZiB0aGUgY29tcG9uZW50LiBNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJXMnLCBwcm9wcy50eXBlLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDMoKSk7XG4gICAgICBkaWRXYXJuQ29udHJvbGxlZFRvVW5jb250cm9sbGVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY2hlY2tlZCA9IHByb3BzLmNoZWNrZWQ7XG4gIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICBzZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsICdjaGVja2VkJywgY2hlY2tlZCB8fCBmYWxzZSk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICBpZiAodmFsdWUgPT09IDAgJiYgbm9kZS52YWx1ZSA9PT0gJycpIHtcbiAgICAgIG5vZGUudmFsdWUgPSAnMCc7XG4gICAgICAvLyBOb3RlOiBJRTkgcmVwb3J0cyBhIG51bWJlciBpbnB1dHMgYXMgJ3RleHQnLCBzbyBjaGVjayBwcm9wcyBpbnN0ZWFkLlxuICAgIH0gZWxzZSBpZiAocHJvcHMudHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIC8vIFNpbXVsYXRlIGBpbnB1dC52YWx1ZUFzTnVtYmVyYC4gSUU5IGRvZXMgbm90IHN1cHBvcnQgaXRcbiAgICAgIHZhciB2YWx1ZUFzTnVtYmVyID0gcGFyc2VGbG9hdChub2RlLnZhbHVlKSB8fCAwO1xuXG4gICAgICBpZiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIHZhbHVlICE9IHZhbHVlQXNOdW1iZXIgfHxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgdmFsdWUgPT0gdmFsdWVBc051bWJlciAmJiBub2RlLnZhbHVlICE9IHZhbHVlKSB7XG4gICAgICAgIC8vIENhc3QgYHZhbHVlYCB0byBhIHN0cmluZyB0byBlbnN1cmUgdGhlIHZhbHVlIGlzIHNldCBjb3JyZWN0bHkuIFdoaWxlXG4gICAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnZhbHVlICE9PSAnJyArIHZhbHVlKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgbm9kZS52YWx1ZSA9ICcnICsgdmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChwcm9wcy52YWx1ZSA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBJbiBDaHJvbWUsIGFzc2lnbmluZyBkZWZhdWx0VmFsdWUgdG8gY2VydGFpbiBpbnB1dCB0eXBlcyB0cmlnZ2VycyBpbnB1dCB2YWxpZGF0aW9uLlxuICAgICAgLy8gRm9yIG51bWJlciBpbnB1dHMsIHRoZSBkaXNwbGF5IHZhbHVlIGxvc2VzIHRyYWlsaW5nIGRlY2ltYWwgcG9pbnRzLiBGb3IgZW1haWwgaW5wdXRzLFxuICAgICAgLy8gQ2hyb21lIHJhaXNlcyBcIlRoZSBzcGVjaWZpZWQgdmFsdWUgPHg+IGlzIG5vdCBhIHZhbGlkIGVtYWlsIGFkZHJlc3NcIi5cbiAgICAgIC8vXG4gICAgICAvLyBIZXJlIHdlIGNoZWNrIHRvIHNlZSBpZiB0aGUgZGVmYXVsdFZhbHVlIGhhcyBhY3R1YWxseSBjaGFuZ2VkLCBhdm9pZGluZyB0aGVzZSBwcm9ibGVtc1xuICAgICAgLy8gd2hlbiB0aGUgdXNlciBpcyBpbnB1dHRpbmcgdGV4dFxuICAgICAgLy9cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNzI1M1xuICAgICAgaWYgKG5vZGUuZGVmYXVsdFZhbHVlICE9PSAnJyArIHByb3BzLmRlZmF1bHRWYWx1ZSkge1xuICAgICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9ICcnICsgcHJvcHMuZGVmYXVsdFZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIHByb3BzLmRlZmF1bHRDaGVja2VkICE9IG51bGwpIHtcbiAgICAgIG5vZGUuZGVmYXVsdENoZWNrZWQgPSAhIXByb3BzLmRlZmF1bHRDaGVja2VkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcblxuICAvLyBEZXRhY2ggdmFsdWUgZnJvbSBkZWZhdWx0VmFsdWUuIFdlIHdvbid0IGRvIGFueXRoaW5nIGlmIHdlJ3JlIHdvcmtpbmcgb25cbiAgLy8gc3VibWl0IG9yIHJlc2V0IGlucHV0cyBhcyB0aG9zZSB2YWx1ZXMgJiBkZWZhdWx0VmFsdWVzIGFyZSBsaW5rZWQuIFRoZXlcbiAgLy8gYXJlIG5vdCByZXNldGFibGUgbm9kZXMgc28gdGhpcyBvcGVyYXRpb24gZG9lc24ndCBtYXR0ZXIgYW5kIGFjdHVhbGx5XG4gIC8vIHJlbW92ZXMgYnJvd3Nlci1kZWZhdWx0IHZhbHVlcyAoZWcgXCJTdWJtaXQgUXVlcnlcIikgd2hlbiBubyB2YWx1ZSBpc1xuICAvLyBwcm92aWRlZC5cblxuICBzd2l0Y2ggKHByb3BzLnR5cGUpIHtcbiAgICBjYXNlICdzdWJtaXQnOlxuICAgIGNhc2UgJ3Jlc2V0JzpcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2NvbG9yJzpcbiAgICBjYXNlICdkYXRlJzpcbiAgICBjYXNlICdkYXRldGltZSc6XG4gICAgY2FzZSAnZGF0ZXRpbWUtbG9jYWwnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICBjYXNlICd0aW1lJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICAgIC8vIFRoaXMgZml4ZXMgdGhlIG5vLXNob3cgaXNzdWUgb24gaU9TIFNhZmFyaSBhbmQgQW5kcm9pZCBDaHJvbWU6XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzcyMzNcbiAgICAgIG5vZGUudmFsdWUgPSAnJztcbiAgICAgIG5vZGUudmFsdWUgPSBub2RlLmRlZmF1bHRWYWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBub2RlLnZhbHVlID0gbm9kZS52YWx1ZTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgLy8gTm9ybWFsbHksIHdlJ2QganVzdCBkbyBgbm9kZS5jaGVja2VkID0gbm9kZS5jaGVja2VkYCB1cG9uIGluaXRpYWwgbW91bnQsIGxlc3MgdGhpcyBidWdcbiAgLy8gdGhpcyBpcyBuZWVkZWQgdG8gd29yayBhcm91bmQgYSBjaHJvbWUgYnVnIHdoZXJlIHNldHRpbmcgZGVmYXVsdENoZWNrZWRcbiAgLy8gd2lsbCBzb21ldGltZXMgaW5mbHVlbmNlIHRoZSB2YWx1ZSBvZiBjaGVja2VkIChldmVuIGFmdGVyIGRldGFjaG1lbnQpLlxuICAvLyBSZWZlcmVuY2U6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTYwODQxNlxuICAvLyBXZSBuZWVkIHRvIHRlbXBvcmFyaWx5IHVuc2V0IG5hbWUgdG8gYXZvaWQgZGlzcnVwdGluZyByYWRpbyBidXR0b24gZ3JvdXBzLlxuICB2YXIgbmFtZSA9IG5vZGUubmFtZTtcbiAgaWYgKG5hbWUgIT09ICcnKSB7XG4gICAgbm9kZS5uYW1lID0gJyc7XG4gIH1cbiAgbm9kZS5kZWZhdWx0Q2hlY2tlZCA9ICFub2RlLmRlZmF1bHRDaGVja2VkO1xuICBub2RlLmRlZmF1bHRDaGVja2VkID0gIW5vZGUuZGVmYXVsdENoZWNrZWQ7XG4gIGlmIChuYW1lICE9PSAnJykge1xuICAgIG5vZGUubmFtZSA9IG5hbWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQxKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdXBkYXRlV3JhcHBlcihub2RlLCBwcm9wcyk7XG4gIHVwZGF0ZU5hbWVkQ291c2lucyhub2RlLCBwcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU5hbWVkQ291c2lucyhyb290Tm9kZSwgcHJvcHMpIHtcbiAgdmFyIG5hbWUgPSBwcm9wcy5uYW1lO1xuICBpZiAocHJvcHMudHlwZSA9PT0gJ3JhZGlvJyAmJiBuYW1lICE9IG51bGwpIHtcbiAgICB2YXIgcXVlcnlSb290ID0gcm9vdE5vZGU7XG5cbiAgICB3aGlsZSAocXVlcnlSb290LnBhcmVudE5vZGUpIHtcbiAgICAgIHF1ZXJ5Um9vdCA9IHF1ZXJ5Um9vdC5wYXJlbnROb2RlO1xuICAgIH1cblxuICAgIC8vIElmIGByb290Tm9kZS5mb3JtYCB3YXMgbm9uLW51bGwsIHRoZW4gd2UgY291bGQgdHJ5IGBmb3JtLmVsZW1lbnRzYCxcbiAgICAvLyBidXQgdGhhdCBzb21ldGltZXMgYmVoYXZlcyBzdHJhbmdlbHkgaW4gSUU4LiBXZSBjb3VsZCBhbHNvIHRyeSB1c2luZ1xuICAgIC8vIGBmb3JtLmdldEVsZW1lbnRzQnlOYW1lYCwgYnV0IHRoYXQgd2lsbCBvbmx5IHJldHVybiBkaXJlY3QgY2hpbGRyZW5cbiAgICAvLyBhbmQgd29uJ3QgaW5jbHVkZSBpbnB1dHMgdGhhdCB1c2UgdGhlIEhUTUw1IGBmb3JtPWAgYXR0cmlidXRlLiBTaW5jZVxuICAgIC8vIHRoZSBpbnB1dCBtaWdodCBub3QgZXZlbiBiZSBpbiBhIGZvcm0uIEl0IG1pZ2h0IG5vdCBldmVuIGJlIGluIHRoZVxuICAgIC8vIGRvY3VtZW50LiBMZXQncyBqdXN0IHVzZSB0aGUgbG9jYWwgYHF1ZXJ5U2VsZWN0b3JBbGxgIHRvIGVuc3VyZSB3ZSBkb24ndFxuICAgIC8vIG1pc3MgYW55dGhpbmcuXG4gICAgdmFyIGdyb3VwID0gcXVlcnlSb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0W25hbWU9JyArIEpTT04uc3RyaW5naWZ5KCcnICsgbmFtZSkgKyAnXVt0eXBlPVwicmFkaW9cIl0nKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBvdGhlck5vZGUgPSBncm91cFtpXTtcbiAgICAgIGlmIChvdGhlck5vZGUgPT09IHJvb3ROb2RlIHx8IG90aGVyTm9kZS5mb3JtICE9PSByb290Tm9kZS5mb3JtKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IGlmIHJhZGlvIGJ1dHRvbnMgcmVuZGVyZWQgYnkgZGlmZmVyZW50IGNvcGllcyBvZiBSZWFjdFxuICAgICAgLy8gYW5kIHRoZSBzYW1lIG5hbWUgYXJlIHJlbmRlcmVkIGludG8gdGhlIHNhbWUgZm9ybSAoc2FtZSBhcyAjMTkzOSkuXG4gICAgICAvLyBUaGF0J3MgcHJvYmFibHkgb2theTsgd2UgZG9uJ3Qgc3VwcG9ydCBpdCBqdXN0IGFzIHdlIGRvbid0IHN1cHBvcnRcbiAgICAgIC8vIG1peGluZyBSZWFjdCByYWRpbyBidXR0b25zIHdpdGggbm9uLVJlYWN0IG9uZXMuXG4gICAgICB2YXIgb3RoZXJQcm9wcyA9IGdldEZpYmVyQ3VycmVudFByb3BzRnJvbU5vZGUkMShvdGhlck5vZGUpO1xuICAgICAgIW90aGVyUHJvcHMgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgc2FtZSBgbmFtZWAgaXMgbm90IHN1cHBvcnRlZC4nKSA6IHZvaWQgMDtcbiAgICAgIC8vIElmIHRoaXMgaXMgYSBjb250cm9sbGVkIHJhZGlvIGJ1dHRvbiBncm91cCwgZm9yY2luZyB0aGUgaW5wdXQgdGhhdFxuICAgICAgLy8gd2FzIHByZXZpb3VzbHkgY2hlY2tlZCB0byB1cGRhdGUgd2lsbCBjYXVzZSBpdCB0byBiZSBjb21lIHJlLWNoZWNrZWRcbiAgICAgIC8vIGFzIGFwcHJvcHJpYXRlLlxuICAgICAgdXBkYXRlV3JhcHBlcihvdGhlck5vZGUsIG90aGVyUHJvcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ2hpbGRyZW4oY2hpbGRyZW4pIHtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICAvLyBGbGF0dGVuIGNoaWxkcmVuIGFuZCB3YXJuIGlmIHRoZXkgYXJlbid0IHN0cmluZ3Mgb3IgbnVtYmVycztcbiAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgLy8gV2UgY2FuIHNpbGVudGx5IHNraXAgdGhlbSBiZWNhdXNlIGludmFsaWQgRE9NIG5lc3Rpbmcgd2FybmluZ1xuICAvLyBjYXRjaGVzIHRoZXNlIGNhc2VzIGluIEZpYmVyLlxuICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICBpZiAoY2hpbGQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNoaWxkID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2hpbGQgPT09ICdudW1iZXInKSB7XG4gICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhbiA8b3B0aW9uPiBob3N0IGNvbXBvbmVudCB0aGF0IHdhcm5zIHdoZW4gYHNlbGVjdGVkYCBpcyBzZXQuXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wcyhlbGVtZW50LCBwcm9wcykge1xuICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgYHNlbGVjdGVkYCBpbiA8b3B0aW9uPi5cbiAge1xuICAgIHdhcm5pbmcocHJvcHMuc2VsZWN0ZWQgPT0gbnVsbCwgJ1VzZSB0aGUgYGRlZmF1bHRWYWx1ZWAgb3IgYHZhbHVlYCBwcm9wcyBvbiA8c2VsZWN0PiBpbnN0ZWFkIG9mICcgKyAnc2V0dGluZyBgc2VsZWN0ZWRgIG9uIDxvcHRpb24+LicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMShlbGVtZW50LCBwcm9wcykge1xuICAvLyB2YWx1ZT1cIlwiIHNob3VsZCBtYWtlIGEgdmFsdWUgYXR0cmlidXRlICgjNjIxOSlcbiAgaWYgKHByb3BzLnZhbHVlICE9IG51bGwpIHtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndmFsdWUnLCBwcm9wcy52YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFByb3BzJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIGhvc3RQcm9wcyA9IF9hc3NpZ24oeyBjaGlsZHJlbjogdW5kZWZpbmVkIH0sIHByb3BzKTtcblxuICB2YXIgY29udGVudCA9IGZsYXR0ZW5DaGlsZHJlbihwcm9wcy5jaGlsZHJlbik7XG5cbiAgaWYgKGNvbnRlbnQpIHtcbiAgICBob3N0UHJvcHMuY2hpbGRyZW4gPSBjb250ZW50O1xuICB9XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG5cbntcbiAgdmFyIGRpZFdhcm5WYWx1ZURlZmF1bHRWYWx1ZSQxID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAgdmFyIG93bmVyTmFtZSA9IGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQzKCk7XG4gIGlmIChvd25lck5hbWUpIHtcbiAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbnZhciB2YWx1ZVByb3BOYW1lcyA9IFsndmFsdWUnLCAnZGVmYXVsdFZhbHVlJ107XG5cbi8qKlxuICogVmFsaWRhdGlvbiBmdW5jdGlvbiBmb3IgYHZhbHVlYCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrU2VsZWN0UHJvcFR5cGVzKHByb3BzKSB7XG4gIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ0KTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlUHJvcE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHByb3BOYW1lID0gdmFsdWVQcm9wTmFtZXNbaV07XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHByb3BzW3Byb3BOYW1lXSk7XG4gICAgaWYgKHByb3BzLm11bHRpcGxlICYmICFpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGFuIGFycmF5IGlmICcgKyAnYG11bHRpcGxlYCBpcyB0cnVlLiVzJywgcHJvcE5hbWUsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpKTtcbiAgICB9IGVsc2UgaWYgKCFwcm9wcy5tdWx0aXBsZSAmJiBpc0FycmF5KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIGAlc2AgcHJvcCBzdXBwbGllZCB0byA8c2VsZWN0PiBtdXN0IGJlIGEgc2NhbGFyICcgKyAndmFsdWUgaWYgYG11bHRpcGxlYCBpcyBmYWxzZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnMobm9kZSwgbXVsdGlwbGUsIHByb3BWYWx1ZSwgc2V0RGVmYXVsdFNlbGVjdGVkKSB7XG4gIHZhciBvcHRpb25zID0gbm9kZS5vcHRpb25zO1xuXG4gIGlmIChtdWx0aXBsZSkge1xuICAgIHZhciBzZWxlY3RlZFZhbHVlcyA9IHByb3BWYWx1ZTtcbiAgICB2YXIgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2VsZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFByZWZpeCB0byBhdm9pZCBjaGFvcyB3aXRoIHNwZWNpYWwga2V5cy5cbiAgICAgIHNlbGVjdGVkVmFsdWVbJyQnICsgc2VsZWN0ZWRWYWx1ZXNbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IG9wdGlvbnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgc2VsZWN0ZWQgPSBzZWxlY3RlZFZhbHVlLmhhc093blByb3BlcnR5KCckJyArIG9wdGlvbnNbX2ldLnZhbHVlKTtcbiAgICAgIGlmIChvcHRpb25zW19pXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICAgIGlmIChzZWxlY3RlZCAmJiBzZXREZWZhdWx0U2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tfaV0uZGVmYXVsdFNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gRG8gbm90IHNldCBgc2VsZWN0LnZhbHVlYCBhcyBleGFjdCBiZWhhdmlvciBpc24ndCBjb25zaXN0ZW50IGFjcm9zcyBhbGxcbiAgICAvLyBicm93c2VycyBmb3IgYWxsIGNhc2VzLlxuICAgIHZhciBfc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIHZhciBkZWZhdWx0U2VsZWN0ZWQgPSBudWxsO1xuICAgIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IG9wdGlvbnMubGVuZ3RoOyBfaTIrKykge1xuICAgICAgaWYgKG9wdGlvbnNbX2kyXS52YWx1ZSA9PT0gX3NlbGVjdGVkVmFsdWUpIHtcbiAgICAgICAgb3B0aW9uc1tfaTJdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHNldERlZmF1bHRTZWxlY3RlZCkge1xuICAgICAgICAgIG9wdGlvbnNbX2kyXS5kZWZhdWx0U2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgPT09IG51bGwgJiYgIW9wdGlvbnNbX2kyXS5kaXNhYmxlZCkge1xuICAgICAgICBkZWZhdWx0U2VsZWN0ZWQgPSBvcHRpb25zW19pMl07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkZWZhdWx0U2VsZWN0ZWQgIT09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRTZWxlY3RlZC5zZWxlY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxzZWxlY3Q+IGhvc3QgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHJldHVybiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGluaXRXcmFwcGVyU3RhdGUkMShlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIHtcbiAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhwcm9wcyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgbm9kZS5fd3JhcHBlclN0YXRlID0ge1xuICAgIGluaXRpYWxWYWx1ZTogdmFsdWUgIT0gbnVsbCA/IHZhbHVlIDogcHJvcHMuZGVmYXVsdFZhbHVlLFxuICAgIHdhc011bHRpcGxlOiAhIXByb3BzLm11bHRpcGxlXG4gIH07XG5cbiAge1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1NlbGVjdCBlbGVtZW50cyBtdXN0IGJlIGVpdGhlciBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCAnICsgJyhzcGVjaWZ5IGVpdGhlciB0aGUgdmFsdWUgcHJvcCwgb3IgdGhlIGRlZmF1bHRWYWx1ZSBwcm9wLCBidXQgbm90ICcgKyAnYm90aCkuIERlY2lkZSBiZXR3ZWVuIHVzaW5nIGEgY29udHJvbGxlZCBvciB1bmNvbnRyb2xsZWQgc2VsZWN0ICcgKyAnZWxlbWVudCBhbmQgcmVtb3ZlIG9uZSBvZiB0aGVzZSBwcm9wcy4gTW9yZSBpbmZvOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJyk7XG4gICAgICBkaWRXYXJuVmFsdWVEZWZhdWx0VmFsdWUkMSA9IHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBvc3RNb3VudFdyYXBwZXIkMihlbGVtZW50LCBwcm9wcykge1xuICB2YXIgbm9kZSA9IGVsZW1lbnQ7XG4gIG5vZGUubXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH0gZWxzZSBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHByb3BzLmRlZmF1bHRWYWx1ZSwgdHJ1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9zdFVwZGF0ZVdyYXBwZXIoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBBZnRlciB0aGUgaW5pdGlhbCBtb3VudCwgd2UgY29udHJvbCBzZWxlY3RlZC1uZXNzIG1hbnVhbGx5IHNvIGRvbid0IHBhc3NcbiAgLy8gdGhpcyB2YWx1ZSBkb3duXG4gIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgdmFyIHdhc011bHRpcGxlID0gbm9kZS5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlO1xuICBub2RlLl93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGUgPSAhIXByb3BzLm11bHRpcGxlO1xuXG4gIHZhciB2YWx1ZSA9IHByb3BzLnZhbHVlO1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgdmFsdWUsIGZhbHNlKTtcbiAgfSBlbHNlIGlmICh3YXNNdWx0aXBsZSAhPT0gISFwcm9wcy5tdWx0aXBsZSkge1xuICAgIC8vIEZvciBzaW1wbGljaXR5LCByZWFwcGx5IGBkZWZhdWx0VmFsdWVgIGlmIGBtdWx0aXBsZWAgaXMgdG9nZ2xlZC5cbiAgICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHVwZGF0ZU9wdGlvbnMobm9kZSwgISFwcm9wcy5tdWx0aXBsZSwgcHJvcHMuZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmV2ZXJ0IHRoZSBzZWxlY3QgYmFjayB0byBpdHMgZGVmYXVsdCB1bnNlbGVjdGVkIHN0YXRlLlxuICAgICAgdXBkYXRlT3B0aW9ucyhub2RlLCAhIXByb3BzLm11bHRpcGxlLCBwcm9wcy5tdWx0aXBsZSA/IFtdIDogJycsIGZhbHNlKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgdmFyIHZhbHVlID0gcHJvcHMudmFsdWU7XG5cbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICB1cGRhdGVPcHRpb25zKG5vZGUsICEhcHJvcHMubXVsdGlwbGUsIHZhbHVlLCBmYWxzZSk7XG4gIH1cbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNSA9IFJlYWN0RGVidWdDdXJyZW50RmliZXIuZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bTtcblxudmFyIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gZmFsc2U7XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDx0ZXh0YXJlYT4gaG9zdCBjb21wb25lbnQgdGhhdCBhbGxvd3Mgc2V0dGluZyBgdmFsdWVgLCBhbmRcbiAqIGBkZWZhdWx0VmFsdWVgLiBUaGlzIGRpZmZlcnMgZnJvbSB0aGUgdHJhZGl0aW9uYWwgRE9NIEFQSSBiZWNhdXNlIHZhbHVlIGlzXG4gKiB1c3VhbGx5IHNldCBhcyBQQ0RBVEEgY2hpbGRyZW4uXG4gKlxuICogSWYgYHZhbHVlYCBpcyBub3Qgc3VwcGxpZWQgKG9yIG51bGwvdW5kZWZpbmVkKSwgdXNlciBhY3Rpb25zIHRoYXQgYWZmZWN0IHRoZVxuICogdmFsdWUgd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuXG4gKlxuICogSWYgYHZhbHVlYCBpcyBzdXBwbGllZCAoYW5kIG5vdCBudWxsL3VuZGVmaW5lZCksIHRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGxcbiAqIG5vdCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIGVsZW1lbnQuIEluc3RlYWQsIHRoZSBgdmFsdWVgIHByb3AgbXVzdCBjaGFuZ2UgaW5cbiAqIG9yZGVyIGZvciB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byBiZSB1cGRhdGVkLlxuICpcbiAqIFRoZSByZW5kZXJlZCBlbGVtZW50IHdpbGwgYmUgaW5pdGlhbGl6ZWQgd2l0aCBhbiBlbXB0eSB2YWx1ZSwgdGhlIHByb3BcbiAqIGBkZWZhdWx0VmFsdWVgIGlmIHNwZWNpZmllZCwgb3IgdGhlIGNoaWxkcmVuIGNvbnRlbnQgKGRlcHJlY2F0ZWQpLlxuICovXG5cbmZ1bmN0aW9uIGdldEhvc3RQcm9wcyQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAgIShwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsKSA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogdm9pZCAwO1xuXG4gIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gIC8vIGdldCByZXNldCBpZiBgdGV4dENvbnRlbnRgIGlzIG11dGF0ZWQuICBXZSBjb3VsZCBhZGQgYSBjaGVjayBpbiBzZXRUZXh0Q29udGVudFxuICAvLyB0byBvbmx5IHNldCB0aGUgdmFsdWUgaWYvd2hlbiB0aGUgdmFsdWUgZGlmZmVycyBmcm9tIHRoZSBub2RlIHZhbHVlICh3aGljaCB3b3VsZFxuICAvLyBjb21wbGV0ZWx5IHNvbHZlIHRoaXMgSUU5IGJ1ZyksIGJ1dCBTZWJhc3RpYW4rU29waGllIHNlZW1lZCB0byBsaWtlIHRoaXNcbiAgLy8gc29sdXRpb24uIFRoZSB2YWx1ZSBjYW4gYmUgYSBib29sZWFuIG9yIG9iamVjdCBzbyB0aGF0J3Mgd2h5IGl0J3MgZm9yY2VkXG4gIC8vIHRvIGJlIGEgc3RyaW5nLlxuICB2YXIgaG9zdFByb3BzID0gX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgIGRlZmF1bHRWYWx1ZTogdW5kZWZpbmVkLFxuICAgIGNoaWxkcmVuOiAnJyArIG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWVcbiAgfSk7XG5cbiAgcmV0dXJuIGhvc3RQcm9wcztcbn1cblxuZnVuY3Rpb24gaW5pdFdyYXBwZXJTdGF0ZSQyKGVsZW1lbnQsIHByb3BzKSB7XG4gIHZhciBub2RlID0gZWxlbWVudDtcbiAge1xuICAgIFJlYWN0Q29udHJvbGxlZFZhbHVlUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBnZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtJDUpO1xuICAgIGlmIChwcm9wcy52YWx1ZSAhPT0gdW5kZWZpbmVkICYmIHByb3BzLmRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuVmFsRGVmYXVsdFZhbCkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RleHRhcmVhIGVsZW1lbnRzIG11c3QgYmUgZWl0aGVyIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICcgKyAnKHNwZWNpZnkgZWl0aGVyIHRoZSB2YWx1ZSBwcm9wLCBvciB0aGUgZGVmYXVsdFZhbHVlIHByb3AsIGJ1dCBub3QgJyArICdib3RoKS4gRGVjaWRlIGJldHdlZW4gdXNpbmcgYSBjb250cm9sbGVkIG9yIHVuY29udHJvbGxlZCB0ZXh0YXJlYSAnICsgJ2FuZCByZW1vdmUgb25lIG9mIHRoZXNlIHByb3BzLiBNb3JlIGluZm86ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1jb250cm9sbGVkLWNvbXBvbmVudHMnKTtcbiAgICAgIGRpZFdhcm5WYWxEZWZhdWx0VmFsID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgdmFyIGluaXRpYWxWYWx1ZSA9IHZhbHVlO1xuXG4gIC8vIE9ubHkgYm90aGVyIGZldGNoaW5nIGRlZmF1bHQgdmFsdWUgaWYgd2UncmUgZ29pbmcgdG8gdXNlIGl0XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgICAvLyBUT0RPICh5dW5nc3RlcnMpOiBSZW1vdmUgc3VwcG9ydCBmb3IgY2hpbGRyZW4gY29udGVudCBpbiA8dGV4dGFyZWE+LlxuICAgIHZhciBjaGlsZHJlbiA9IHByb3BzLmNoaWxkcmVuO1xuICAgIGlmIChjaGlsZHJlbiAhPSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKTtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gaW52YXJpYW50KGZhbHNlLCAnSWYgeW91IHN1cHBseSBgZGVmYXVsdFZhbHVlYCBvbiBhIDx0ZXh0YXJlYT4sIGRvIG5vdCBwYXNzIGNoaWxkcmVuLicpIDogdm9pZCAwO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgICEoY2hpbGRyZW4ubGVuZ3RoIDw9IDEpID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogdm9pZCAwO1xuICAgICAgICBjaGlsZHJlbiA9IGNoaWxkcmVuWzBdO1xuICAgICAgfVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJyArIGNoaWxkcmVuO1xuICAgIH1cbiAgICBpZiAoZGVmYXVsdFZhbHVlID09IG51bGwpIHtcbiAgICAgIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIH1cbiAgICBpbml0aWFsVmFsdWUgPSBkZWZhdWx0VmFsdWU7XG4gIH1cblxuICBub2RlLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgaW5pdGlhbFZhbHVlOiAnJyArIGluaXRpYWxWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXcmFwcGVyJDEoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICB2YXIgdmFsdWUgPSBwcm9wcy52YWx1ZTtcbiAgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICB2YXIgbmV3VmFsdWUgPSAnJyArIHZhbHVlO1xuXG4gICAgLy8gVG8gYXZvaWQgc2lkZSBlZmZlY3RzIChzdWNoIGFzIGxvc2luZyB0ZXh0IHNlbGVjdGlvbiksIG9ubHkgc2V0IHZhbHVlIGlmIGNoYW5nZWRcbiAgICBpZiAobmV3VmFsdWUgIT09IG5vZGUudmFsdWUpIHtcbiAgICAgIG5vZGUudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICB9XG4gICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAocHJvcHMuZGVmYXVsdFZhbHVlICE9IG51bGwpIHtcbiAgICBub2RlLmRlZmF1bHRWYWx1ZSA9IHByb3BzLmRlZmF1bHRWYWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3N0TW91bnRXcmFwcGVyJDMoZWxlbWVudCwgcHJvcHMpIHtcbiAgdmFyIG5vZGUgPSBlbGVtZW50O1xuICAvLyBUaGlzIGlzIGluIHBvc3RNb3VudCBiZWNhdXNlIHdlIG5lZWQgYWNjZXNzIHRvIHRoZSBET00gbm9kZSwgd2hpY2ggaXMgbm90XG4gIC8vIGF2YWlsYWJsZSB1bnRpbCBhZnRlciB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLlxuICB2YXIgdGV4dENvbnRlbnQgPSBub2RlLnRleHRDb250ZW50O1xuXG4gIC8vIE9ubHkgc2V0IG5vZGUudmFsdWUgaWYgdGV4dENvbnRlbnQgaXMgZXF1YWwgdG8gdGhlIGV4cGVjdGVkXG4gIC8vIGluaXRpYWwgdmFsdWUuIEluIElFMTAvSUUxMSB0aGVyZSBpcyBhIGJ1ZyB3aGVyZSB0aGUgcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gIC8vIHdpbGwgcG9wdWxhdGUgdGV4dENvbnRlbnQgYXMgd2VsbC5cbiAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTAxNTI1L1xuICBpZiAodGV4dENvbnRlbnQgPT09IG5vZGUuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUpIHtcbiAgICBub2RlLnZhbHVlID0gdGV4dENvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZUNvbnRyb2xsZWRTdGF0ZSQzKGVsZW1lbnQsIHByb3BzKSB7XG4gIC8vIERPTSBjb21wb25lbnQgaXMgc3RpbGwgbW91bnRlZDsgdXBkYXRlXG4gIHVwZGF0ZVdyYXBwZXIkMShlbGVtZW50LCBwcm9wcyk7XG59XG5cbnZhciBIVE1MX05BTUVTUEFDRSQxID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGh0bWwnO1xudmFyIE1BVEhfTkFNRVNQQUNFID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnO1xudmFyIFNWR19OQU1FU1BBQ0UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuXG52YXIgTmFtZXNwYWNlcyA9IHtcbiAgaHRtbDogSFRNTF9OQU1FU1BBQ0UkMSxcbiAgbWF0aG1sOiBNQVRIX05BTUVTUEFDRSxcbiAgc3ZnOiBTVkdfTkFNRVNQQUNFXG59O1xuXG4vLyBBc3N1bWVzIHRoZXJlIGlzIG5vIHBhcmVudCBuYW1lc3BhY2UuXG5mdW5jdGlvbiBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICdzdmcnOlxuICAgICAgcmV0dXJuIFNWR19OQU1FU1BBQ0U7XG4gICAgY2FzZSAnbWF0aCc6XG4gICAgICByZXR1cm4gTUFUSF9OQU1FU1BBQ0U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBIVE1MX05BTUVTUEFDRSQxO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENoaWxkTmFtZXNwYWNlKHBhcmVudE5hbWVzcGFjZSwgdHlwZSkge1xuICBpZiAocGFyZW50TmFtZXNwYWNlID09IG51bGwgfHwgcGFyZW50TmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSQxKSB7XG4gICAgLy8gTm8gKG9yIGRlZmF1bHQpIHBhcmVudCBuYW1lc3BhY2U6IHBvdGVudGlhbCBlbnRyeSBwb2ludC5cbiAgICByZXR1cm4gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHR5cGUpO1xuICB9XG4gIGlmIChwYXJlbnROYW1lc3BhY2UgPT09IFNWR19OQU1FU1BBQ0UgJiYgdHlwZSA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gV2UncmUgbGVhdmluZyBTVkcuXG4gICAgcmV0dXJuIEhUTUxfTkFNRVNQQUNFJDE7XG4gIH1cbiAgLy8gQnkgZGVmYXVsdCwgcGFzcyBuYW1lc3BhY2UgYmVsb3cuXG4gIHJldHVybiBwYXJlbnROYW1lc3BhY2U7XG59XG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuLyoqXG4gKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCBoYXMgJ3Vuc2FmZScgcHJpdmlsZWdlcyAocmVxdWlyZWQgYnkgd2luZG93czggYXBwcylcbiAqL1xudmFyIGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24gPSBmdW5jdGlvbiAoZnVuYykge1xuICBpZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgTVNBcHAuZXhlY1Vuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZnVuYyhhcmcwLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZ1bmM7XG4gIH1cbn07XG5cbi8vIFNWRyB0ZW1wIGNvbnRhaW5lciBmb3IgSUUgbGFja2luZyBpbm5lckhUTUxcbnZhciByZXVzYWJsZVNWR0NvbnRhaW5lciA9IHZvaWQgMDtcblxuLyoqXG4gKiBTZXQgdGhlIGlubmVySFRNTCBwcm9wZXJ0eSBvZiBhIG5vZGVcbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBodG1sXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIHNldElubmVySFRNTCA9IGNyZWF0ZU1pY3Jvc29mdFVuc2FmZUxvY2FsRnVuY3Rpb24oZnVuY3Rpb24gKG5vZGUsIGh0bWwpIHtcbiAgLy8gSUUgZG9lcyBub3QgaGF2ZSBpbm5lckhUTUwgZm9yIFNWRyBub2Rlcywgc28gaW5zdGVhZCB3ZSBpbmplY3QgdGhlXG4gIC8vIG5ldyBtYXJrdXAgaW4gYSB0ZW1wIG5vZGUgYW5kIHRoZW4gbW92ZSB0aGUgY2hpbGQgbm9kZXMgYWNyb3NzIGludG9cbiAgLy8gdGhlIHRhcmdldCBub2RlXG5cbiAgaWYgKG5vZGUubmFtZXNwYWNlVVJJID09PSBOYW1lc3BhY2VzLnN2ZyAmJiAhKCdpbm5lckhUTUwnIGluIG5vZGUpKSB7XG4gICAgcmV1c2FibGVTVkdDb250YWluZXIgPSByZXVzYWJsZVNWR0NvbnRhaW5lciB8fCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXVzYWJsZVNWR0NvbnRhaW5lci5pbm5lckhUTUwgPSAnPHN2Zz4nICsgaHRtbCArICc8L3N2Zz4nO1xuICAgIHZhciBzdmdOb2RlID0gcmV1c2FibGVTVkdDb250YWluZXIuZmlyc3RDaGlsZDtcbiAgICB3aGlsZSAobm9kZS5maXJzdENoaWxkKSB7XG4gICAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHdoaWxlIChzdmdOb2RlLmZpcnN0Q2hpbGQpIHtcbiAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc3ZnTm9kZS5maXJzdENoaWxkKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICB9XG59KTtcblxuLy8gY29kZSBjb3BpZWQgYW5kIG1vZGlmaWVkIGZyb20gZXNjYXBlLWh0bWxcbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIG1hdGNoSHRtbFJlZ0V4cCA9IC9bXCInJjw+XS87XG5cbi8qKlxuICogRXNjYXBlIHNwZWNpYWwgY2hhcmFjdGVycyBpbiB0aGUgZ2l2ZW4gc3RyaW5nIG9mIGh0bWwuXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBlc2NhcGUgZm9yIGluc2VydGluZyBpbnRvIEhUTUxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICB2YXIgc3RyID0gJycgKyBzdHJpbmc7XG4gIHZhciBtYXRjaCA9IG1hdGNoSHRtbFJlZ0V4cC5leGVjKHN0cik7XG5cbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybiBzdHI7XG4gIH1cblxuICB2YXIgZXNjYXBlO1xuICB2YXIgaHRtbCA9ICcnO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdEluZGV4ID0gMDtcblxuICBmb3IgKGluZGV4ID0gbWF0Y2guaW5kZXg7IGluZGV4IDwgc3RyLmxlbmd0aDsgaW5kZXgrKykge1xuICAgIHN3aXRjaCAoc3RyLmNoYXJDb2RlQXQoaW5kZXgpKSB7XG4gICAgICBjYXNlIDM0OlxuICAgICAgICAvLyBcIlxuICAgICAgICBlc2NhcGUgPSAnJnF1b3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM4OlxuICAgICAgICAvLyAmXG4gICAgICAgIGVzY2FwZSA9ICcmYW1wOyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAzOTpcbiAgICAgICAgLy8gJ1xuICAgICAgICBlc2NhcGUgPSAnJiN4Mjc7JzsgLy8gbW9kaWZpZWQgZnJvbSBlc2NhcGUtaHRtbDsgdXNlZCB0byBiZSAnJiMzOSdcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYwOlxuICAgICAgICAvLyA8XG4gICAgICAgIGVzY2FwZSA9ICcmbHQ7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDYyOlxuICAgICAgICAvLyA+XG4gICAgICAgIGVzY2FwZSA9ICcmZ3Q7JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobGFzdEluZGV4ICE9PSBpbmRleCkge1xuICAgICAgaHRtbCArPSBzdHIuc3Vic3RyaW5nKGxhc3RJbmRleCwgaW5kZXgpO1xuICAgIH1cblxuICAgIGxhc3RJbmRleCA9IGluZGV4ICsgMTtcbiAgICBodG1sICs9IGVzY2FwZTtcbiAgfVxuXG4gIHJldHVybiBsYXN0SW5kZXggIT09IGluZGV4ID8gaHRtbCArIHN0ci5zdWJzdHJpbmcobGFzdEluZGV4LCBpbmRleCkgOiBodG1sO1xufVxuLy8gZW5kIGNvZGUgY29waWVkIGFuZCBtb2RpZmllZCBmcm9tIGVzY2FwZS1odG1sXG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgaWYgKHR5cGVvZiB0ZXh0ID09PSAnYm9vbGVhbicgfHwgdHlwZW9mIHRleHQgPT09ICdudW1iZXInKSB7XG4gICAgLy8gdGhpcyBzaG9ydGNpcmN1aXQgaGVscHMgcGVyZiBmb3IgdHlwZXMgdGhhdCB3ZSBrbm93IHdpbGwgbmV2ZXIgaGF2ZVxuICAgIC8vIHNwZWNpYWwgY2hhcmFjdGVycywgZXNwZWNpYWxseSBnaXZlbiB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgdXNlZCBvZnRlblxuICAgIC8vIGZvciBudW1lcmljIGRvbSBpZHMuXG4gICAgcmV0dXJuICcnICsgdGV4dDtcbiAgfVxuICByZXR1cm4gZXNjYXBlSHRtbCh0ZXh0KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIGlmICh0ZXh0KSB7XG4gICAgdmFyIGZpcnN0Q2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7XG5cbiAgICBpZiAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkID09PSBub2RlLmxhc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgIGZpcnN0Q2hpbGQubm9kZVZhbHVlID0gdGV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59O1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIGlmICghKCd0ZXh0Q29udGVudCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSkge1xuICAgIHNldFRleHRDb250ZW50ID0gZnVuY3Rpb24gKG5vZGUsIHRleHQpIHtcbiAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZS5ub2RlVmFsdWUgPSB0ZXh0O1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbnZhciBzZXRUZXh0Q29udGVudCQxID0gc2V0VGV4dENvbnRlbnQ7XG5cbi8qKlxuICogQ1NTIHByb3BlcnRpZXMgd2hpY2ggYWNjZXB0IG51bWJlcnMgYnV0IGFyZSBub3QgaW4gdW5pdHMgb2YgXCJweFwiLlxuICovXG52YXIgaXNVbml0bGVzc051bWJlciA9IHtcbiAgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6IHRydWUsXG4gIGJvcmRlckltYWdlT3V0c2V0OiB0cnVlLFxuICBib3JkZXJJbWFnZVNsaWNlOiB0cnVlLFxuICBib3JkZXJJbWFnZVdpZHRoOiB0cnVlLFxuICBib3hGbGV4OiB0cnVlLFxuICBib3hGbGV4R3JvdXA6IHRydWUsXG4gIGJveE9yZGluYWxHcm91cDogdHJ1ZSxcbiAgY29sdW1uQ291bnQ6IHRydWUsXG4gIGNvbHVtbnM6IHRydWUsXG4gIGZsZXg6IHRydWUsXG4gIGZsZXhHcm93OiB0cnVlLFxuICBmbGV4UG9zaXRpdmU6IHRydWUsXG4gIGZsZXhTaHJpbms6IHRydWUsXG4gIGZsZXhOZWdhdGl2ZTogdHJ1ZSxcbiAgZmxleE9yZGVyOiB0cnVlLFxuICBncmlkUm93OiB0cnVlLFxuICBncmlkUm93RW5kOiB0cnVlLFxuICBncmlkUm93U3BhbjogdHJ1ZSxcbiAgZ3JpZFJvd1N0YXJ0OiB0cnVlLFxuICBncmlkQ29sdW1uOiB0cnVlLFxuICBncmlkQ29sdW1uRW5kOiB0cnVlLFxuICBncmlkQ29sdW1uU3BhbjogdHJ1ZSxcbiAgZ3JpZENvbHVtblN0YXJ0OiB0cnVlLFxuICBmb250V2VpZ2h0OiB0cnVlLFxuICBsaW5lQ2xhbXA6IHRydWUsXG4gIGxpbmVIZWlnaHQ6IHRydWUsXG4gIG9wYWNpdHk6IHRydWUsXG4gIG9yZGVyOiB0cnVlLFxuICBvcnBoYW5zOiB0cnVlLFxuICB0YWJTaXplOiB0cnVlLFxuICB3aWRvd3M6IHRydWUsXG4gIHpJbmRleDogdHJ1ZSxcbiAgem9vbTogdHJ1ZSxcblxuICAvLyBTVkctcmVsYXRlZCBwcm9wZXJ0aWVzXG4gIGZpbGxPcGFjaXR5OiB0cnVlLFxuICBmbG9vZE9wYWNpdHk6IHRydWUsXG4gIHN0b3BPcGFjaXR5OiB0cnVlLFxuICBzdHJva2VEYXNoYXJyYXk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU1pdGVybGltaXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIENvbnZlcnQgYSB2YWx1ZSBpbnRvIHRoZSBwcm9wZXIgY3NzIHdyaXRhYmxlIHZhbHVlLiBUaGUgc3R5bGUgbmFtZSBgbmFtZWBcbiAqIHNob3VsZCBiZSBsb2dpY2FsIChubyBoeXBoZW5zKSwgYXMgc3BlY2lmaWVkXG4gKiBpbiBgQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcmAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQ1NTIHByb3BlcnR5IG5hbWUgc3VjaCBhcyBgdG9wTWFyZ2luYC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgQ1NTIHByb3BlcnR5IHZhbHVlIHN1Y2ggYXMgYDEwcHhgLlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIHN0eWxlIHZhbHVlIHdpdGggZGltZW5zaW9ucyBhcHBsaWVkLlxuICovXG5mdW5jdGlvbiBkYW5nZXJvdXNTdHlsZVZhbHVlKG5hbWUsIHZhbHVlLCBpc0N1c3RvbVByb3BlcnR5KSB7XG4gIC8vIE5vdGUgdGhhdCB3ZSd2ZSByZW1vdmVkIGVzY2FwZVRleHRGb3JCcm93c2VyKCkgY2FsbHMgaGVyZSBzaW5jZSB0aGVcbiAgLy8gd2hvbGUgc3RyaW5nIHdpbGwgYmUgZXNjYXBlZCB3aGVuIHRoZSBhdHRyaWJ1dGUgaXMgaW5qZWN0ZWQgaW50b1xuICAvLyB0aGUgbWFya3VwLiBJZiB5b3UgcHJvdmlkZSB1bnNhZmUgdXNlciBkYXRhIGhlcmUgdGhleSBjYW4gaW5qZWN0XG4gIC8vIGFyYml0cmFyeSBDU1Mgd2hpY2ggbWF5IGJlIHByb2JsZW1hdGljIChJIGNvdWxkbid0IHJlcHJvIHRoaXMpOlxuICAvLyBodHRwczovL3d3dy5vd2FzcC5vcmcvaW5kZXgucGhwL1hTU19GaWx0ZXJfRXZhc2lvbl9DaGVhdF9TaGVldFxuICAvLyBodHRwOi8vd3d3LnRoZXNwYW5uZXIuY28udWsvMjAwNy8xMS8yNi91bHRpbWF0ZS14c3MtY3NzLWluamVjdGlvbi9cbiAgLy8gVGhpcyBpcyBub3QgYW4gWFNTIGhvbGUgYnV0IGluc3RlYWQgYSBwb3RlbnRpYWwgQ1NTIGluamVjdGlvbiBpc3N1ZVxuICAvLyB3aGljaCBoYXMgbGVhZCB0byBhIGdyZWF0ZXIgZGlzY3Vzc2lvbiBhYm91dCBob3cgd2UncmUgZ29pbmcgdG9cbiAgLy8gdHJ1c3QgVVJMcyBtb3ZpbmcgZm9yd2FyZC4gU2VlICMyMTE1OTAxXG5cbiAgdmFyIGlzRW1wdHkgPSB2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nIHx8IHZhbHVlID09PSAnJztcbiAgaWYgKGlzRW1wdHkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAoIWlzQ3VzdG9tUHJvcGVydHkgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB2YWx1ZSAhPT0gMCAmJiAhKGlzVW5pdGxlc3NOdW1iZXIuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgaXNVbml0bGVzc051bWJlcltuYW1lXSkpIHtcbiAgICByZXR1cm4gdmFsdWUgKyAncHgnOyAvLyBQcmVzdW1lcyBpbXBsaWNpdCAncHgnIHN1ZmZpeCBmb3IgdW5pdGxlc3MgbnVtYmVyc1xuICB9XG5cbiAgcmV0dXJuICgnJyArIHZhbHVlKS50cmltKCk7XG59XG5cbnZhciB3YXJuVmFsaWRTdHlsZSA9IGVtcHR5RnVuY3Rpb24kMTtcblxue1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcbiAgdmFyIHdhcm5lZEZvck5hTlZhbHVlID0gZmFsc2U7XG4gIHZhciB3YXJuZWRGb3JJbmZpbml0eVZhbHVlID0gZmFsc2U7XG5cbiAgdmFyIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lID0gZnVuY3Rpb24gKG5hbWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlTmFtZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdVbnN1cHBvcnRlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSwgZ2V0U3RhY2spIHtcbiAgICBpZiAod2FybmVkU3R5bGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiB3YXJuZWRTdHlsZU5hbWVzW25hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkU3R5bGVOYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPyVzJywgbmFtZSwgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSksIGdldFN0YWNrKCkpO1xuICB9O1xuXG4gIHZhciB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsIFwiU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uLiBcIiArICdUcnkgXCIlczogJXNcIiBpbnN0ZWFkLiVzJywgbmFtZSwgdmFsdWUucmVwbGFjZShiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4sICcnKSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5TdHlsZVZhbHVlSXNOYU4gPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKHdhcm5lZEZvck5hTlZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9yTmFOVmFsdWUgPSB0cnVlO1xuICAgIHdhcm5pbmcoZmFsc2UsICdgTmFOYCBpcyBhbiBpbnZhbGlkIHZhbHVlIGZvciB0aGUgYCVzYCBjc3Mgc3R5bGUgcHJvcGVydHkuJXMnLCBuYW1lLCBnZXRTdGFjaygpKTtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCBnZXRTdGFjaykge1xuICAgIGlmICh3YXJuZWRGb3JJbmZpbml0eVZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FybmVkRm9ySW5maW5pdHlWYWx1ZSA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ2BJbmZpbml0eWAgaXMgYW4gaW52YWxpZCB2YWx1ZSBmb3IgdGhlIGAlc2AgY3NzIHN0eWxlIHByb3BlcnR5LiVzJywgbmFtZSwgZ2V0U3RhY2soKSk7XG4gIH07XG5cbiAgd2FyblZhbGlkU3R5bGUgPSBmdW5jdGlvbiAobmFtZSwgdmFsdWUsIGdldFN0YWNrKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUsIGdldFN0YWNrKTtcbiAgICB9IGVsc2UgaWYgKGJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybi50ZXN0KG5hbWUpKSB7XG4gICAgICB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUobmFtZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAoYmFkU3R5bGVWYWx1ZVdpdGhTZW1pY29sb25QYXR0ZXJuLnRlc3QodmFsdWUpKSB7XG4gICAgICB3YXJuU3R5bGVWYWx1ZVdpdGhTZW1pY29sb24obmFtZSwgdmFsdWUsIGdldFN0YWNrKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgaWYgKGlzTmFOKHZhbHVlKSkge1xuICAgICAgICB3YXJuU3R5bGVWYWx1ZUlzTmFOKG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0Zpbml0ZSh2YWx1ZSkpIHtcbiAgICAgICAgd2FyblN0eWxlVmFsdWVJc0luZmluaXR5KG5hbWUsIHZhbHVlLCBnZXRTdGFjayk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG52YXIgd2FyblZhbGlkU3R5bGUkMSA9IHdhcm5WYWxpZFN0eWxlO1xuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIGRlYWxpbmcgd2l0aCBDU1MgcHJvcGVydGllcy5cbiAqL1xuXG4vKipcbiAqIFRoaXMgY3JlYXRlcyBhIHN0cmluZyB0aGF0IGlzIGV4cGVjdGVkIHRvIGJlIGVxdWl2YWxlbnQgdG8gdGhlIHN0eWxlXG4gKiBhdHRyaWJ1dGUgZ2VuZXJhdGVkIGJ5IHNlcnZlci1zaWRlIHJlbmRlcmluZy4gSXQgYnktcGFzc2VzIHdhcm5pbmdzIGFuZFxuICogc2VjdXJpdHkgY2hlY2tzIHNvIGl0J3Mgbm90IHNhZmUgdG8gdXNlIHRoaXMgdmFsdWUgZm9yIGFueXRoaW5nIG90aGVyIHRoYW5cbiAqIGNvbXBhcmlzb24uIEl0IGlzIG9ubHkgdXNlZCBpbiBERVYgZm9yIFNTUiB2YWxpZGF0aW9uLlxuICovXG5mdW5jdGlvbiBjcmVhdGVEYW5nZXJvdXNTdHJpbmdGb3JTdHlsZXMoc3R5bGVzKSB7XG4gIHtcbiAgICB2YXIgc2VyaWFsaXplZCA9ICcnO1xuICAgIHZhciBkZWxpbWl0ZXIgPSAnJztcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XG4gICAgICBpZiAoIXN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBzdHlsZXNbc3R5bGVOYW1lXTtcbiAgICAgIGlmIChzdHlsZVZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIGlzQ3VzdG9tUHJvcGVydHkgPSBzdHlsZU5hbWUuaW5kZXhPZignLS0nKSA9PT0gMDtcbiAgICAgICAgc2VyaWFsaXplZCArPSBkZWxpbWl0ZXIgKyBoeXBoZW5hdGVTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSwgaXNDdXN0b21Qcm9wZXJ0eSk7XG5cbiAgICAgICAgZGVsaW1pdGVyID0gJzsnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZCB8fCBudWxsO1xuICB9XG59XG5cbi8qKlxuICogU2V0cyB0aGUgdmFsdWUgZm9yIG11bHRpcGxlIHN0eWxlcyBvbiBhIG5vZGUuICBJZiBhIHZhbHVlIGlzIHNwZWNpZmllZCBhc1xuICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gKi9cbmZ1bmN0aW9uIHNldFZhbHVlRm9yU3R5bGVzKG5vZGUsIHN0eWxlcywgZ2V0U3RhY2spIHtcbiAgdmFyIHN0eWxlID0gbm9kZS5zdHlsZTtcbiAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgIGlmICghc3R5bGVzLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgaXNDdXN0b21Qcm9wZXJ0eSA9IHN0eWxlTmFtZS5pbmRleE9mKCctLScpID09PSAwO1xuICAgIHtcbiAgICAgIGlmICghaXNDdXN0b21Qcm9wZXJ0eSkge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZSQxKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGdldFN0YWNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0sIGlzQ3VzdG9tUHJvcGVydHkpO1xuICAgIGlmIChzdHlsZU5hbWUgPT09ICdmbG9hdCcpIHtcbiAgICAgIHN0eWxlTmFtZSA9ICdjc3NGbG9hdCc7XG4gICAgfVxuICAgIGlmIChpc0N1c3RvbVByb3BlcnR5KSB7XG4gICAgICBzdHlsZS5zZXRQcm9wZXJ0eShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsLWNhc2UgdGFncy5cblxudmFyIG9taXR0ZWRDbG9zZVRhZ3MgPSB7XG4gIGFyZWE6IHRydWUsXG4gIGJhc2U6IHRydWUsXG4gIGJyOiB0cnVlLFxuICBjb2w6IHRydWUsXG4gIGVtYmVkOiB0cnVlLFxuICBocjogdHJ1ZSxcbiAgaW1nOiB0cnVlLFxuICBpbnB1dDogdHJ1ZSxcbiAga2V5Z2VuOiB0cnVlLFxuICBsaW5rOiB0cnVlLFxuICBtZXRhOiB0cnVlLFxuICBwYXJhbTogdHJ1ZSxcbiAgc291cmNlOiB0cnVlLFxuICB0cmFjazogdHJ1ZSxcbiAgd2JyOiB0cnVlXG59O1xuXG4vLyBGb3IgSFRNTCwgY2VydGFpbiB0YWdzIGNhbm5vdCBoYXZlIGNoaWxkcmVuLiBUaGlzIGhhcyB0aGUgc2FtZSBwdXJwb3NlIGFzXG4vLyBgb21pdHRlZENsb3NlVGFnc2AgZXhjZXB0IHRoYXQgYG1lbnVpdGVtYCBzaG91bGQgc3RpbGwgaGF2ZSBpdHMgY2xvc2luZyB0YWcuXG5cbnZhciB2b2lkRWxlbWVudFRhZ3MgPSBfYXNzaWduKHtcbiAgbWVudWl0ZW06IHRydWVcbn0sIG9taXR0ZWRDbG9zZVRhZ3MpO1xuXG52YXIgSFRNTCQxID0gJ19faHRtbCc7XG5cbmZ1bmN0aW9uIGFzc2VydFZhbGlkUHJvcHModGFnLCBwcm9wcywgZ2V0U3RhY2spIHtcbiAgaWYgKCFwcm9wcykge1xuICAgIHJldHVybjtcbiAgfVxuICAvLyBOb3RlIHRoZSB1c2Ugb2YgYD09YCB3aGljaCBjaGVja3MgZm9yIG51bGwgb3IgdW5kZWZpbmVkLlxuICBpZiAodm9pZEVsZW1lbnRUYWdzW3RhZ10pIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICclcyBpcyBhIHZvaWQgZWxlbWVudCB0YWcgYW5kIG11c3QgbmVpdGhlciBoYXZlIGBjaGlsZHJlbmAgbm9yIHVzZSBgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLiVzJywgdGFnLCBnZXRTdGFjaygpKSA6IHZvaWQgMDtcbiAgfVxuICBpZiAocHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICEocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCkgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW4gb25seSBzZXQgb25lIG9mIGBjaGlsZHJlbmAgb3IgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHZvaWQgMDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCQxIGluIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MKSA/IGludmFyaWFudChmYWxzZSwgJ2Bwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBpbiB0aGUgZm9ybSBge19faHRtbDogLi4ufWAuIFBsZWFzZSB2aXNpdCBodHRwczovL2ZiLm1lL3JlYWN0LWludmFyaWFudC1kYW5nZXJvdXNseS1zZXQtaW5uZXItaHRtbCBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IHZvaWQgMDtcbiAgfVxuICB7XG4gICAgd2FybmluZyhwcm9wcy5zdXBwcmVzc0NvbnRlbnRFZGl0YWJsZVdhcm5pbmcgfHwgIXByb3BzLmNvbnRlbnRFZGl0YWJsZSB8fCBwcm9wcy5jaGlsZHJlbiA9PSBudWxsLCAnQSBjb21wb25lbnQgaXMgYGNvbnRlbnRFZGl0YWJsZWAgYW5kIGNvbnRhaW5zIGBjaGlsZHJlbmAgbWFuYWdlZCBieSAnICsgJ1JlYWN0LiBJdCBpcyBub3cgeW91ciByZXNwb25zaWJpbGl0eSB0byBndWFyYW50ZWUgdGhhdCBub25lIG9mICcgKyAndGhvc2Ugbm9kZXMgYXJlIHVuZXhwZWN0ZWRseSBtb2RpZmllZCBvciBkdXBsaWNhdGVkLiBUaGlzIGlzICcgKyAncHJvYmFibHkgbm90IGludGVudGlvbmFsLiVzJywgZ2V0U3RhY2soKSk7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gaW52YXJpYW50KGZhbHNlLCAnVGhlIGBzdHlsZWAgcHJvcCBleHBlY3RzIGEgbWFwcGluZyBmcm9tIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLCBub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuIHVzaW5nIEpTWC4lcycsIGdldFN0YWNrKCkpIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICBpZiAodGFnTmFtZS5pbmRleE9mKCctJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBwcm9wcy5pcyA9PT0gJ3N0cmluZyc7XG4gIH1cbiAgc3dpdGNoICh0YWdOYW1lKSB7XG4gICAgLy8gVGhlc2UgYXJlIHJlc2VydmVkIFNWRyBhbmQgTWF0aE1MIGVsZW1lbnRzLlxuICAgIC8vIFdlIGRvbid0IG1pbmQgdGhpcyB3aGl0ZWxpc3QgdG9vIG11Y2ggYmVjYXVzZSB3ZSBleHBlY3QgaXQgdG8gbmV2ZXIgZ3Jvdy5cbiAgICAvLyBUaGUgYWx0ZXJuYXRpdmUgaXMgdG8gdHJhY2sgdGhlIG5hbWVzcGFjZSBpbiBhIGZldyBwbGFjZXMgd2hpY2ggaXMgY29udm9sdXRlZC5cbiAgICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2ViY29tcG9uZW50cy9zcGVjL2N1c3RvbS8jY3VzdG9tLWVsZW1lbnRzLWNvcmUtY29uY2VwdHNcbiAgICBjYXNlICdhbm5vdGF0aW9uLXhtbCc6XG4gICAgY2FzZSAnY29sb3ItcHJvZmlsZSc6XG4gICAgY2FzZSAnZm9udC1mYWNlJzpcbiAgICBjYXNlICdmb250LWZhY2Utc3JjJzpcbiAgICBjYXNlICdmb250LWZhY2UtdXJpJzpcbiAgICBjYXNlICdmb250LWZhY2UtZm9ybWF0JzpcbiAgICBjYXNlICdmb250LWZhY2UtbmFtZSc6XG4gICAgY2FzZSAnbWlzc2luZy1nbHlwaCc6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbnZhciBhcmlhUHJvcGVydGllcyA9IHtcbiAgJ2FyaWEtY3VycmVudCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWRldGFpbHMnOiAwLFxuICAnYXJpYS1kaXNhYmxlZCc6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWhpZGRlbic6IDAsIC8vIHN0YXRlXG4gICdhcmlhLWludmFsaWQnOiAwLCAvLyBzdGF0ZVxuICAnYXJpYS1rZXlzaG9ydGN1dHMnOiAwLFxuICAnYXJpYS1sYWJlbCc6IDAsXG4gICdhcmlhLXJvbGVkZXNjcmlwdGlvbic6IDAsXG4gIC8vIFdpZGdldCBBdHRyaWJ1dGVzXG4gICdhcmlhLWF1dG9jb21wbGV0ZSc6IDAsXG4gICdhcmlhLWNoZWNrZWQnOiAwLFxuICAnYXJpYS1leHBhbmRlZCc6IDAsXG4gICdhcmlhLWhhc3BvcHVwJzogMCxcbiAgJ2FyaWEtbGV2ZWwnOiAwLFxuICAnYXJpYS1tb2RhbCc6IDAsXG4gICdhcmlhLW11bHRpbGluZSc6IDAsXG4gICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IDAsXG4gICdhcmlhLW9yaWVudGF0aW9uJzogMCxcbiAgJ2FyaWEtcGxhY2Vob2xkZXInOiAwLFxuICAnYXJpYS1wcmVzc2VkJzogMCxcbiAgJ2FyaWEtcmVhZG9ubHknOiAwLFxuICAnYXJpYS1yZXF1aXJlZCc6IDAsXG4gICdhcmlhLXNlbGVjdGVkJzogMCxcbiAgJ2FyaWEtc29ydCc6IDAsXG4gICdhcmlhLXZhbHVlbWF4JzogMCxcbiAgJ2FyaWEtdmFsdWVtaW4nOiAwLFxuICAnYXJpYS12YWx1ZW5vdyc6IDAsXG4gICdhcmlhLXZhbHVldGV4dCc6IDAsXG4gIC8vIExpdmUgUmVnaW9uIEF0dHJpYnV0ZXNcbiAgJ2FyaWEtYXRvbWljJzogMCxcbiAgJ2FyaWEtYnVzeSc6IDAsXG4gICdhcmlhLWxpdmUnOiAwLFxuICAnYXJpYS1yZWxldmFudCc6IDAsXG4gIC8vIERyYWctYW5kLURyb3AgQXR0cmlidXRlc1xuICAnYXJpYS1kcm9wZWZmZWN0JzogMCxcbiAgJ2FyaWEtZ3JhYmJlZCc6IDAsXG4gIC8vIFJlbGF0aW9uc2hpcCBBdHRyaWJ1dGVzXG4gICdhcmlhLWFjdGl2ZWRlc2NlbmRhbnQnOiAwLFxuICAnYXJpYS1jb2xjb3VudCc6IDAsXG4gICdhcmlhLWNvbGluZGV4JzogMCxcbiAgJ2FyaWEtY29sc3Bhbic6IDAsXG4gICdhcmlhLWNvbnRyb2xzJzogMCxcbiAgJ2FyaWEtZGVzY3JpYmVkYnknOiAwLFxuICAnYXJpYS1lcnJvcm1lc3NhZ2UnOiAwLFxuICAnYXJpYS1mbG93dG8nOiAwLFxuICAnYXJpYS1sYWJlbGxlZGJ5JzogMCxcbiAgJ2FyaWEtb3ducyc6IDAsXG4gICdhcmlhLXBvc2luc2V0JzogMCxcbiAgJ2FyaWEtcm93Y291bnQnOiAwLFxuICAnYXJpYS1yb3dpbmRleCc6IDAsXG4gICdhcmlhLXJvd3NwYW4nOiAwLFxuICAnYXJpYS1zZXRzaXplJzogMFxufTtcblxudmFyIHdhcm5lZFByb3BlcnRpZXMgPSB7fTtcbnZhciByQVJJQSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xudmFyIHJBUklBQ2FtZWwgPSBuZXcgUmVnRXhwKCdeKGFyaWEpW0EtWl1bJyArIEFUVFJJQlVURV9OQU1FX0NIQVIgKyAnXSokJyk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0oKSB7XG4gIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuICByZXR1cm4gc3RhY2sgIT0gbnVsbCA/IHN0YWNrIDogJyc7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydHkodGFnTmFtZSwgbmFtZSkge1xuICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRQcm9wZXJ0aWVzLCBuYW1lKSAmJiB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAockFSSUFDYW1lbC50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGFyaWFOYW1lID0gJ2FyaWEtJyArIG5hbWUuc2xpY2UoNCkudG9Mb3dlckNhc2UoKTtcbiAgICB2YXIgY29ycmVjdE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShhcmlhTmFtZSkgPyBhcmlhTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKGNvcnJlY3ROYW1lID09IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIEFSSUEgYXR0cmlidXRlcyBmb2xsb3cgdGhlIHBhdHRlcm4gYXJpYS0qIGFuZCBtdXN0IGJlIGxvd2VyY2FzZS4lcycsIG5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBhcmlhLSogYXR0cmlidXRlcyBzaG91bGQgYmUgbG93ZXJjYXNlOyBzdWdnZXN0IHRoZSBsb3dlcmNhc2UgdmVyc2lvbi5cbiAgICBpZiAobmFtZSAhPT0gY29ycmVjdE5hbWUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIEFSSUEgYXR0cmlidXRlIGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgY29ycmVjdE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChyQVJJQS50ZXN0KG5hbWUpKSB7XG4gICAgdmFyIGxvd2VyQ2FzZWROYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhciBzdGFuZGFyZE5hbWUgPSBhcmlhUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShsb3dlckNhc2VkTmFtZSkgPyBsb3dlckNhc2VkTmFtZSA6IG51bGw7XG5cbiAgICAvLyBJZiB0aGlzIGlzIGFuIGFyaWEtKiBhdHRyaWJ1dGUsIGJ1dCBpcyBub3QgbGlzdGVkIGluIHRoZSBrbm93biBET01cbiAgICAvLyBET00gcHJvcGVydGllcywgdGhlbiBpdCBpcyBhbiBpbnZhbGlkIGFyaWEtKiBhdHRyaWJ1dGUuXG4gICAgaWYgKHN0YW5kYXJkTmFtZSA9PSBudWxsKSB7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gYXJpYS0qIGF0dHJpYnV0ZXMgc2hvdWxkIGJlIGxvd2VyY2FzZTsgc3VnZ2VzdCB0aGUgbG93ZXJjYXNlIHZlcnNpb24uXG4gICAgaWYgKG5hbWUgIT09IHN0YW5kYXJkTmFtZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gQVJJQSBhdHRyaWJ1dGUgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCBzdGFuZGFyZE5hbWUsIGdldFN0YWNrQWRkZW5kdW0oKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB3YXJuSW52YWxpZEFSSUFQcm9wcyh0eXBlLCBwcm9wcykge1xuICB2YXIgaW52YWxpZFByb3BzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgdmFyIGlzVmFsaWQgPSB2YWxpZGF0ZVByb3BlcnR5KHR5cGUsIGtleSk7XG4gICAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgICBpbnZhbGlkUHJvcHMucHVzaChrZXkpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1bmtub3duUHJvcFN0cmluZyA9IGludmFsaWRQcm9wcy5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICByZXR1cm4gJ2AnICsgcHJvcCArICdgJztcbiAgfSkuam9pbignLCAnKTtcblxuICBpZiAoaW52YWxpZFByb3BzLmxlbmd0aCA9PT0gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyaWEgcHJvcCAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9IGVsc2UgaWYgKGludmFsaWRQcm9wcy5sZW5ndGggPiAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJpYSBwcm9wcyAlcyBvbiA8JXM+IHRhZy4gJyArICdGb3IgZGV0YWlscywgc2VlIGh0dHBzOi8vZmIubWUvaW52YWxpZC1hcmlhLXByb3AlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtKCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyh0eXBlLCBwcm9wcykge1xuICBpZiAoaXNDdXN0b21Db21wb25lbnQodHlwZSwgcHJvcHMpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdhcm5JbnZhbGlkQVJJQVByb3BzKHR5cGUsIHByb3BzKTtcbn1cblxudmFyIGRpZFdhcm5WYWx1ZU51bGwgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0U3RhY2tBZGRlbmR1bSQxKCkge1xuICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcbiAgcmV0dXJuIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVByb3BlcnRpZXMkMSh0eXBlLCBwcm9wcykge1xuICBpZiAodHlwZSAhPT0gJ2lucHV0JyAmJiB0eXBlICE9PSAndGV4dGFyZWEnICYmIHR5cGUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHByb3BzICE9IG51bGwgJiYgcHJvcHMudmFsdWUgPT09IG51bGwgJiYgIWRpZFdhcm5WYWx1ZU51bGwpIHtcbiAgICBkaWRXYXJuVmFsdWVOdWxsID0gdHJ1ZTtcbiAgICBpZiAodHlwZSA9PT0gJ3NlbGVjdCcgJiYgcHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdgdmFsdWVgIHByb3Agb24gYCVzYCBzaG91bGQgbm90IGJlIG51bGwuICcgKyAnQ29uc2lkZXIgdXNpbmcgYW4gZW1wdHkgYXJyYXkgd2hlbiBgbXVsdGlwbGVgIGlzIHNldCB0byBgdHJ1ZWAgJyArICd0byBjbGVhciB0aGUgY29tcG9uZW50IG9yIGB1bmRlZmluZWRgIGZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ2B2YWx1ZWAgcHJvcCBvbiBgJXNgIHNob3VsZCBub3QgYmUgbnVsbC4gJyArICdDb25zaWRlciB1c2luZyBhbiBlbXB0eSBzdHJpbmcgdG8gY2xlYXIgdGhlIGNvbXBvbmVudCBvciBgdW5kZWZpbmVkYCAnICsgJ2ZvciB1bmNvbnRyb2xsZWQgY29tcG9uZW50cy4lcycsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMSgpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gV2hlbiBhZGRpbmcgYXR0cmlidXRlcyB0byB0aGUgSFRNTCBvciBTVkcgd2hpdGVsaXN0LCBiZSBzdXJlIHRvXG4vLyBhbHNvIGFkZCB0aGVtIHRvIHRoaXMgbW9kdWxlIHRvIGVuc3VyZSBjYXNpbmcgYW5kIGluY29ycmVjdCBuYW1lXG4vLyB3YXJuaW5ncy5cbnZhciBwb3NzaWJsZVN0YW5kYXJkTmFtZXMgPSB7XG4gIC8vIEhUTUxcbiAgYWNjZXB0OiAnYWNjZXB0JyxcbiAgYWNjZXB0Y2hhcnNldDogJ2FjY2VwdENoYXJzZXQnLFxuICAnYWNjZXB0LWNoYXJzZXQnOiAnYWNjZXB0Q2hhcnNldCcsXG4gIGFjY2Vzc2tleTogJ2FjY2Vzc0tleScsXG4gIGFjdGlvbjogJ2FjdGlvbicsXG4gIGFsbG93ZnVsbHNjcmVlbjogJ2FsbG93RnVsbFNjcmVlbicsXG4gIGFsdDogJ2FsdCcsXG4gIGFzOiAnYXMnLFxuICBhc3luYzogJ2FzeW5jJyxcbiAgYXV0b2NhcGl0YWxpemU6ICdhdXRvQ2FwaXRhbGl6ZScsXG4gIGF1dG9jb21wbGV0ZTogJ2F1dG9Db21wbGV0ZScsXG4gIGF1dG9jb3JyZWN0OiAnYXV0b0NvcnJlY3QnLFxuICBhdXRvZm9jdXM6ICdhdXRvRm9jdXMnLFxuICBhdXRvcGxheTogJ2F1dG9QbGF5JyxcbiAgYXV0b3NhdmU6ICdhdXRvU2F2ZScsXG4gIGNhcHR1cmU6ICdjYXB0dXJlJyxcbiAgY2VsbHBhZGRpbmc6ICdjZWxsUGFkZGluZycsXG4gIGNlbGxzcGFjaW5nOiAnY2VsbFNwYWNpbmcnLFxuICBjaGFsbGVuZ2U6ICdjaGFsbGVuZ2UnLFxuICBjaGFyc2V0OiAnY2hhclNldCcsXG4gIGNoZWNrZWQ6ICdjaGVja2VkJyxcbiAgY2hpbGRyZW46ICdjaGlsZHJlbicsXG4gIGNpdGU6ICdjaXRlJyxcbiAgJ2NsYXNzJzogJ2NsYXNzTmFtZScsXG4gIGNsYXNzaWQ6ICdjbGFzc0lEJyxcbiAgY2xhc3NuYW1lOiAnY2xhc3NOYW1lJyxcbiAgY29sczogJ2NvbHMnLFxuICBjb2xzcGFuOiAnY29sU3BhbicsXG4gIGNvbnRlbnQ6ICdjb250ZW50JyxcbiAgY29udGVudGVkaXRhYmxlOiAnY29udGVudEVkaXRhYmxlJyxcbiAgY29udGV4dG1lbnU6ICdjb250ZXh0TWVudScsXG4gIGNvbnRyb2xzOiAnY29udHJvbHMnLFxuICBjb250cm9sc2xpc3Q6ICdjb250cm9sc0xpc3QnLFxuICBjb29yZHM6ICdjb29yZHMnLFxuICBjcm9zc29yaWdpbjogJ2Nyb3NzT3JpZ2luJyxcbiAgZGFuZ2Vyb3VzbHlzZXRpbm5lcmh0bWw6ICdkYW5nZXJvdXNseVNldElubmVySFRNTCcsXG4gIGRhdGE6ICdkYXRhJyxcbiAgZGF0ZXRpbWU6ICdkYXRlVGltZScsXG4gICdkZWZhdWx0JzogJ2RlZmF1bHQnLFxuICBkZWZhdWx0Y2hlY2tlZDogJ2RlZmF1bHRDaGVja2VkJyxcbiAgZGVmYXVsdHZhbHVlOiAnZGVmYXVsdFZhbHVlJyxcbiAgZGVmZXI6ICdkZWZlcicsXG4gIGRpcjogJ2RpcicsXG4gIGRpc2FibGVkOiAnZGlzYWJsZWQnLFxuICBkb3dubG9hZDogJ2Rvd25sb2FkJyxcbiAgZHJhZ2dhYmxlOiAnZHJhZ2dhYmxlJyxcbiAgZW5jdHlwZTogJ2VuY1R5cGUnLFxuICAnZm9yJzogJ2h0bWxGb3InLFxuICBmb3JtOiAnZm9ybScsXG4gIGZvcm1tZXRob2Q6ICdmb3JtTWV0aG9kJyxcbiAgZm9ybWFjdGlvbjogJ2Zvcm1BY3Rpb24nLFxuICBmb3JtZW5jdHlwZTogJ2Zvcm1FbmNUeXBlJyxcbiAgZm9ybW5vdmFsaWRhdGU6ICdmb3JtTm9WYWxpZGF0ZScsXG4gIGZvcm10YXJnZXQ6ICdmb3JtVGFyZ2V0JyxcbiAgZnJhbWVib3JkZXI6ICdmcmFtZUJvcmRlcicsXG4gIGhlYWRlcnM6ICdoZWFkZXJzJyxcbiAgaGVpZ2h0OiAnaGVpZ2h0JyxcbiAgaGlkZGVuOiAnaGlkZGVuJyxcbiAgaGlnaDogJ2hpZ2gnLFxuICBocmVmOiAnaHJlZicsXG4gIGhyZWZsYW5nOiAnaHJlZkxhbmcnLFxuICBodG1sZm9yOiAnaHRtbEZvcicsXG4gIGh0dHBlcXVpdjogJ2h0dHBFcXVpdicsXG4gICdodHRwLWVxdWl2JzogJ2h0dHBFcXVpdicsXG4gIGljb246ICdpY29uJyxcbiAgaWQ6ICdpZCcsXG4gIGlubmVyaHRtbDogJ2lubmVySFRNTCcsXG4gIGlucHV0bW9kZTogJ2lucHV0TW9kZScsXG4gIGludGVncml0eTogJ2ludGVncml0eScsXG4gIGlzOiAnaXMnLFxuICBpdGVtaWQ6ICdpdGVtSUQnLFxuICBpdGVtcHJvcDogJ2l0ZW1Qcm9wJyxcbiAgaXRlbXJlZjogJ2l0ZW1SZWYnLFxuICBpdGVtc2NvcGU6ICdpdGVtU2NvcGUnLFxuICBpdGVtdHlwZTogJ2l0ZW1UeXBlJyxcbiAga2V5cGFyYW1zOiAna2V5UGFyYW1zJyxcbiAga2V5dHlwZTogJ2tleVR5cGUnLFxuICBraW5kOiAna2luZCcsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsYW5nOiAnbGFuZycsXG4gIGxpc3Q6ICdsaXN0JyxcbiAgbG9vcDogJ2xvb3AnLFxuICBsb3c6ICdsb3cnLFxuICBtYW5pZmVzdDogJ21hbmlmZXN0JyxcbiAgbWFyZ2lud2lkdGg6ICdtYXJnaW5XaWR0aCcsXG4gIG1hcmdpbmhlaWdodDogJ21hcmdpbkhlaWdodCcsXG4gIG1heDogJ21heCcsXG4gIG1heGxlbmd0aDogJ21heExlbmd0aCcsXG4gIG1lZGlhOiAnbWVkaWEnLFxuICBtZWRpYWdyb3VwOiAnbWVkaWFHcm91cCcsXG4gIG1ldGhvZDogJ21ldGhvZCcsXG4gIG1pbjogJ21pbicsXG4gIG1pbmxlbmd0aDogJ21pbkxlbmd0aCcsXG4gIG11bHRpcGxlOiAnbXVsdGlwbGUnLFxuICBtdXRlZDogJ211dGVkJyxcbiAgbmFtZTogJ25hbWUnLFxuICBub25jZTogJ25vbmNlJyxcbiAgbm92YWxpZGF0ZTogJ25vVmFsaWRhdGUnLFxuICBvcGVuOiAnb3BlbicsXG4gIG9wdGltdW06ICdvcHRpbXVtJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwbGFjZWhvbGRlcjogJ3BsYWNlaG9sZGVyJyxcbiAgcGxheXNpbmxpbmU6ICdwbGF5c0lubGluZScsXG4gIHBvc3RlcjogJ3Bvc3RlcicsXG4gIHByZWxvYWQ6ICdwcmVsb2FkJyxcbiAgcHJvZmlsZTogJ3Byb2ZpbGUnLFxuICByYWRpb2dyb3VwOiAncmFkaW9Hcm91cCcsXG4gIHJlYWRvbmx5OiAncmVhZE9ubHknLFxuICByZWZlcnJlcnBvbGljeTogJ3JlZmVycmVyUG9saWN5JyxcbiAgcmVsOiAncmVsJyxcbiAgcmVxdWlyZWQ6ICdyZXF1aXJlZCcsXG4gIHJldmVyc2VkOiAncmV2ZXJzZWQnLFxuICByb2xlOiAncm9sZScsXG4gIHJvd3M6ICdyb3dzJyxcbiAgcm93c3BhbjogJ3Jvd1NwYW4nLFxuICBzYW5kYm94OiAnc2FuZGJveCcsXG4gIHNjb3BlOiAnc2NvcGUnLFxuICBzY29wZWQ6ICdzY29wZWQnLFxuICBzY3JvbGxpbmc6ICdzY3JvbGxpbmcnLFxuICBzZWFtbGVzczogJ3NlYW1sZXNzJyxcbiAgc2VsZWN0ZWQ6ICdzZWxlY3RlZCcsXG4gIHNoYXBlOiAnc2hhcGUnLFxuICBzaXplOiAnc2l6ZScsXG4gIHNpemVzOiAnc2l6ZXMnLFxuICBzcGFuOiAnc3BhbicsXG4gIHNwZWxsY2hlY2s6ICdzcGVsbENoZWNrJyxcbiAgc3JjOiAnc3JjJyxcbiAgc3JjZG9jOiAnc3JjRG9jJyxcbiAgc3JjbGFuZzogJ3NyY0xhbmcnLFxuICBzcmNzZXQ6ICdzcmNTZXQnLFxuICBzdGFydDogJ3N0YXJ0JyxcbiAgc3RlcDogJ3N0ZXAnLFxuICBzdHlsZTogJ3N0eWxlJyxcbiAgc3VtbWFyeTogJ3N1bW1hcnknLFxuICB0YWJpbmRleDogJ3RhYkluZGV4JyxcbiAgdGFyZ2V0OiAndGFyZ2V0JyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHR5cGU6ICd0eXBlJyxcbiAgdXNlbWFwOiAndXNlTWFwJyxcbiAgdmFsdWU6ICd2YWx1ZScsXG4gIHdpZHRoOiAnd2lkdGgnLFxuICB3bW9kZTogJ3dtb2RlJyxcbiAgd3JhcDogJ3dyYXAnLFxuXG4gIC8vIFNWR1xuICBhYm91dDogJ2Fib3V0JyxcbiAgYWNjZW50aGVpZ2h0OiAnYWNjZW50SGVpZ2h0JyxcbiAgJ2FjY2VudC1oZWlnaHQnOiAnYWNjZW50SGVpZ2h0JyxcbiAgYWNjdW11bGF0ZTogJ2FjY3VtdWxhdGUnLFxuICBhZGRpdGl2ZTogJ2FkZGl0aXZlJyxcbiAgYWxpZ25tZW50YmFzZWxpbmU6ICdhbGlnbm1lbnRCYXNlbGluZScsXG4gICdhbGlnbm1lbnQtYmFzZWxpbmUnOiAnYWxpZ25tZW50QmFzZWxpbmUnLFxuICBhbGxvd3Jlb3JkZXI6ICdhbGxvd1Jlb3JkZXInLFxuICBhbHBoYWJldGljOiAnYWxwaGFiZXRpYycsXG4gIGFtcGxpdHVkZTogJ2FtcGxpdHVkZScsXG4gIGFyYWJpY2Zvcm06ICdhcmFiaWNGb3JtJyxcbiAgJ2FyYWJpYy1mb3JtJzogJ2FyYWJpY0Zvcm0nLFxuICBhc2NlbnQ6ICdhc2NlbnQnLFxuICBhdHRyaWJ1dGVuYW1lOiAnYXR0cmlidXRlTmFtZScsXG4gIGF0dHJpYnV0ZXR5cGU6ICdhdHRyaWJ1dGVUeXBlJyxcbiAgYXV0b3JldmVyc2U6ICdhdXRvUmV2ZXJzZScsXG4gIGF6aW11dGg6ICdhemltdXRoJyxcbiAgYmFzZWZyZXF1ZW5jeTogJ2Jhc2VGcmVxdWVuY3knLFxuICBiYXNlbGluZXNoaWZ0OiAnYmFzZWxpbmVTaGlmdCcsXG4gICdiYXNlbGluZS1zaGlmdCc6ICdiYXNlbGluZVNoaWZ0JyxcbiAgYmFzZXByb2ZpbGU6ICdiYXNlUHJvZmlsZScsXG4gIGJib3g6ICdiYm94JyxcbiAgYmVnaW46ICdiZWdpbicsXG4gIGJpYXM6ICdiaWFzJyxcbiAgYnk6ICdieScsXG4gIGNhbGNtb2RlOiAnY2FsY01vZGUnLFxuICBjYXBoZWlnaHQ6ICdjYXBIZWlnaHQnLFxuICAnY2FwLWhlaWdodCc6ICdjYXBIZWlnaHQnLFxuICBjbGlwOiAnY2xpcCcsXG4gIGNsaXBwYXRoOiAnY2xpcFBhdGgnLFxuICAnY2xpcC1wYXRoJzogJ2NsaXBQYXRoJyxcbiAgY2xpcHBhdGh1bml0czogJ2NsaXBQYXRoVW5pdHMnLFxuICBjbGlwcnVsZTogJ2NsaXBSdWxlJyxcbiAgJ2NsaXAtcnVsZSc6ICdjbGlwUnVsZScsXG4gIGNvbG9yOiAnY29sb3InLFxuICBjb2xvcmludGVycG9sYXRpb246ICdjb2xvckludGVycG9sYXRpb24nLFxuICAnY29sb3ItaW50ZXJwb2xhdGlvbic6ICdjb2xvckludGVycG9sYXRpb24nLFxuICBjb2xvcmludGVycG9sYXRpb25maWx0ZXJzOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gICdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnOiAnY29sb3JJbnRlcnBvbGF0aW9uRmlsdGVycycsXG4gIGNvbG9ycHJvZmlsZTogJ2NvbG9yUHJvZmlsZScsXG4gICdjb2xvci1wcm9maWxlJzogJ2NvbG9yUHJvZmlsZScsXG4gIGNvbG9ycmVuZGVyaW5nOiAnY29sb3JSZW5kZXJpbmcnLFxuICAnY29sb3ItcmVuZGVyaW5nJzogJ2NvbG9yUmVuZGVyaW5nJyxcbiAgY29udGVudHNjcmlwdHR5cGU6ICdjb250ZW50U2NyaXB0VHlwZScsXG4gIGNvbnRlbnRzdHlsZXR5cGU6ICdjb250ZW50U3R5bGVUeXBlJyxcbiAgY3Vyc29yOiAnY3Vyc29yJyxcbiAgY3g6ICdjeCcsXG4gIGN5OiAnY3knLFxuICBkOiAnZCcsXG4gIGRhdGF0eXBlOiAnZGF0YXR5cGUnLFxuICBkZWNlbGVyYXRlOiAnZGVjZWxlcmF0ZScsXG4gIGRlc2NlbnQ6ICdkZXNjZW50JyxcbiAgZGlmZnVzZWNvbnN0YW50OiAnZGlmZnVzZUNvbnN0YW50JyxcbiAgZGlyZWN0aW9uOiAnZGlyZWN0aW9uJyxcbiAgZGlzcGxheTogJ2Rpc3BsYXknLFxuICBkaXZpc29yOiAnZGl2aXNvcicsXG4gIGRvbWluYW50YmFzZWxpbmU6ICdkb21pbmFudEJhc2VsaW5lJyxcbiAgJ2RvbWluYW50LWJhc2VsaW5lJzogJ2RvbWluYW50QmFzZWxpbmUnLFxuICBkdXI6ICdkdXInLFxuICBkeDogJ2R4JyxcbiAgZHk6ICdkeScsXG4gIGVkZ2Vtb2RlOiAnZWRnZU1vZGUnLFxuICBlbGV2YXRpb246ICdlbGV2YXRpb24nLFxuICBlbmFibGViYWNrZ3JvdW5kOiAnZW5hYmxlQmFja2dyb3VuZCcsXG4gICdlbmFibGUtYmFja2dyb3VuZCc6ICdlbmFibGVCYWNrZ3JvdW5kJyxcbiAgZW5kOiAnZW5kJyxcbiAgZXhwb25lbnQ6ICdleHBvbmVudCcsXG4gIGV4dGVybmFscmVzb3VyY2VzcmVxdWlyZWQ6ICdleHRlcm5hbFJlc291cmNlc1JlcXVpcmVkJyxcbiAgZmlsbDogJ2ZpbGwnLFxuICBmaWxsb3BhY2l0eTogJ2ZpbGxPcGFjaXR5JyxcbiAgJ2ZpbGwtb3BhY2l0eSc6ICdmaWxsT3BhY2l0eScsXG4gIGZpbGxydWxlOiAnZmlsbFJ1bGUnLFxuICAnZmlsbC1ydWxlJzogJ2ZpbGxSdWxlJyxcbiAgZmlsdGVyOiAnZmlsdGVyJyxcbiAgZmlsdGVycmVzOiAnZmlsdGVyUmVzJyxcbiAgZmlsdGVydW5pdHM6ICdmaWx0ZXJVbml0cycsXG4gIGZsb29kb3BhY2l0eTogJ2Zsb29kT3BhY2l0eScsXG4gICdmbG9vZC1vcGFjaXR5JzogJ2Zsb29kT3BhY2l0eScsXG4gIGZsb29kY29sb3I6ICdmbG9vZENvbG9yJyxcbiAgJ2Zsb29kLWNvbG9yJzogJ2Zsb29kQ29sb3InLFxuICBmb2N1c2FibGU6ICdmb2N1c2FibGUnLFxuICBmb250ZmFtaWx5OiAnZm9udEZhbWlseScsXG4gICdmb250LWZhbWlseSc6ICdmb250RmFtaWx5JyxcbiAgZm9udHNpemU6ICdmb250U2l6ZScsXG4gICdmb250LXNpemUnOiAnZm9udFNpemUnLFxuICBmb250c2l6ZWFkanVzdDogJ2ZvbnRTaXplQWRqdXN0JyxcbiAgJ2ZvbnQtc2l6ZS1hZGp1c3QnOiAnZm9udFNpemVBZGp1c3QnLFxuICBmb250c3RyZXRjaDogJ2ZvbnRTdHJldGNoJyxcbiAgJ2ZvbnQtc3RyZXRjaCc6ICdmb250U3RyZXRjaCcsXG4gIGZvbnRzdHlsZTogJ2ZvbnRTdHlsZScsXG4gICdmb250LXN0eWxlJzogJ2ZvbnRTdHlsZScsXG4gIGZvbnR2YXJpYW50OiAnZm9udFZhcmlhbnQnLFxuICAnZm9udC12YXJpYW50JzogJ2ZvbnRWYXJpYW50JyxcbiAgZm9udHdlaWdodDogJ2ZvbnRXZWlnaHQnLFxuICAnZm9udC13ZWlnaHQnOiAnZm9udFdlaWdodCcsXG4gIGZvcm1hdDogJ2Zvcm1hdCcsXG4gIGZyb206ICdmcm9tJyxcbiAgZng6ICdmeCcsXG4gIGZ5OiAnZnknLFxuICBnMTogJ2cxJyxcbiAgZzI6ICdnMicsXG4gIGdseXBobmFtZTogJ2dseXBoTmFtZScsXG4gICdnbHlwaC1uYW1lJzogJ2dseXBoTmFtZScsXG4gIGdseXBob3JpZW50YXRpb25ob3Jpem9udGFsOiAnZ2x5cGhPcmllbnRhdGlvbkhvcml6b250YWwnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24taG9yaXpvbnRhbCc6ICdnbHlwaE9yaWVudGF0aW9uSG9yaXpvbnRhbCcsXG4gIGdseXBob3JpZW50YXRpb252ZXJ0aWNhbDogJ2dseXBoT3JpZW50YXRpb25WZXJ0aWNhbCcsXG4gICdnbHlwaC1vcmllbnRhdGlvbi12ZXJ0aWNhbCc6ICdnbHlwaE9yaWVudGF0aW9uVmVydGljYWwnLFxuICBnbHlwaHJlZjogJ2dseXBoUmVmJyxcbiAgZ3JhZGllbnR0cmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gIGdyYWRpZW50dW5pdHM6ICdncmFkaWVudFVuaXRzJyxcbiAgaGFuZ2luZzogJ2hhbmdpbmcnLFxuICBob3JpemFkdng6ICdob3JpekFkdlgnLFxuICAnaG9yaXotYWR2LXgnOiAnaG9yaXpBZHZYJyxcbiAgaG9yaXpvcmlnaW54OiAnaG9yaXpPcmlnaW5YJyxcbiAgJ2hvcml6LW9yaWdpbi14JzogJ2hvcml6T3JpZ2luWCcsXG4gIGlkZW9ncmFwaGljOiAnaWRlb2dyYXBoaWMnLFxuICBpbWFnZXJlbmRlcmluZzogJ2ltYWdlUmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlbmRlcmluZyc6ICdpbWFnZVJlbmRlcmluZycsXG4gIGluMjogJ2luMicsXG4gICdpbic6ICdpbicsXG4gIGlubGlzdDogJ2lubGlzdCcsXG4gIGludGVyY2VwdDogJ2ludGVyY2VwdCcsXG4gIGsxOiAnazEnLFxuICBrMjogJ2syJyxcbiAgazM6ICdrMycsXG4gIGs0OiAnazQnLFxuICBrOiAnaycsXG4gIGtlcm5lbG1hdHJpeDogJ2tlcm5lbE1hdHJpeCcsXG4gIGtlcm5lbHVuaXRsZW5ndGg6ICdrZXJuZWxVbml0TGVuZ3RoJyxcbiAga2VybmluZzogJ2tlcm5pbmcnLFxuICBrZXlwb2ludHM6ICdrZXlQb2ludHMnLFxuICBrZXlzcGxpbmVzOiAna2V5U3BsaW5lcycsXG4gIGtleXRpbWVzOiAna2V5VGltZXMnLFxuICBsZW5ndGhhZGp1c3Q6ICdsZW5ndGhBZGp1c3QnLFxuICBsZXR0ZXJzcGFjaW5nOiAnbGV0dGVyU3BhY2luZycsXG4gICdsZXR0ZXItc3BhY2luZyc6ICdsZXR0ZXJTcGFjaW5nJyxcbiAgbGlnaHRpbmdjb2xvcjogJ2xpZ2h0aW5nQ29sb3InLFxuICAnbGlnaHRpbmctY29sb3InOiAnbGlnaHRpbmdDb2xvcicsXG4gIGxpbWl0aW5nY29uZWFuZ2xlOiAnbGltaXRpbmdDb25lQW5nbGUnLFxuICBsb2NhbDogJ2xvY2FsJyxcbiAgbWFya2VyZW5kOiAnbWFya2VyRW5kJyxcbiAgJ21hcmtlci1lbmQnOiAnbWFya2VyRW5kJyxcbiAgbWFya2VyaGVpZ2h0OiAnbWFya2VySGVpZ2h0JyxcbiAgbWFya2VybWlkOiAnbWFya2VyTWlkJyxcbiAgJ21hcmtlci1taWQnOiAnbWFya2VyTWlkJyxcbiAgbWFya2Vyc3RhcnQ6ICdtYXJrZXJTdGFydCcsXG4gICdtYXJrZXItc3RhcnQnOiAnbWFya2VyU3RhcnQnLFxuICBtYXJrZXJ1bml0czogJ21hcmtlclVuaXRzJyxcbiAgbWFya2Vyd2lkdGg6ICdtYXJrZXJXaWR0aCcsXG4gIG1hc2s6ICdtYXNrJyxcbiAgbWFza2NvbnRlbnR1bml0czogJ21hc2tDb250ZW50VW5pdHMnLFxuICBtYXNrdW5pdHM6ICdtYXNrVW5pdHMnLFxuICBtYXRoZW1hdGljYWw6ICdtYXRoZW1hdGljYWwnLFxuICBtb2RlOiAnbW9kZScsXG4gIG51bW9jdGF2ZXM6ICdudW1PY3RhdmVzJyxcbiAgb2Zmc2V0OiAnb2Zmc2V0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknLFxuICBvcGVyYXRvcjogJ29wZXJhdG9yJyxcbiAgb3JkZXI6ICdvcmRlcicsXG4gIG9yaWVudDogJ29yaWVudCcsXG4gIG9yaWVudGF0aW9uOiAnb3JpZW50YXRpb24nLFxuICBvcmlnaW46ICdvcmlnaW4nLFxuICBvdmVyZmxvdzogJ292ZXJmbG93JyxcbiAgb3ZlcmxpbmVwb3NpdGlvbjogJ292ZXJsaW5lUG9zaXRpb24nLFxuICAnb3ZlcmxpbmUtcG9zaXRpb24nOiAnb3ZlcmxpbmVQb3NpdGlvbicsXG4gIG92ZXJsaW5ldGhpY2tuZXNzOiAnb3ZlcmxpbmVUaGlja25lc3MnLFxuICAnb3ZlcmxpbmUtdGhpY2tuZXNzJzogJ292ZXJsaW5lVGhpY2tuZXNzJyxcbiAgcGFpbnRvcmRlcjogJ3BhaW50T3JkZXInLFxuICAncGFpbnQtb3JkZXInOiAncGFpbnRPcmRlcicsXG4gIHBhbm9zZTE6ICdwYW5vc2UxJyxcbiAgJ3Bhbm9zZS0xJzogJ3Bhbm9zZTEnLFxuICBwYXRobGVuZ3RoOiAncGF0aExlbmd0aCcsXG4gIHBhdHRlcm5jb250ZW50dW5pdHM6ICdwYXR0ZXJuQ29udGVudFVuaXRzJyxcbiAgcGF0dGVybnRyYW5zZm9ybTogJ3BhdHRlcm5UcmFuc2Zvcm0nLFxuICBwYXR0ZXJudW5pdHM6ICdwYXR0ZXJuVW5pdHMnLFxuICBwb2ludGVyZXZlbnRzOiAncG9pbnRlckV2ZW50cycsXG4gICdwb2ludGVyLWV2ZW50cyc6ICdwb2ludGVyRXZlbnRzJyxcbiAgcG9pbnRzOiAncG9pbnRzJyxcbiAgcG9pbnRzYXR4OiAncG9pbnRzQXRYJyxcbiAgcG9pbnRzYXR5OiAncG9pbnRzQXRZJyxcbiAgcG9pbnRzYXR6OiAncG9pbnRzQXRaJyxcbiAgcHJlZml4OiAncHJlZml4JyxcbiAgcHJlc2VydmVhbHBoYTogJ3ByZXNlcnZlQWxwaGEnLFxuICBwcmVzZXJ2ZWFzcGVjdHJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gIHByaW1pdGl2ZXVuaXRzOiAncHJpbWl0aXZlVW5pdHMnLFxuICBwcm9wZXJ0eTogJ3Byb3BlcnR5JyxcbiAgcjogJ3InLFxuICByYWRpdXM6ICdyYWRpdXMnLFxuICByZWZ4OiAncmVmWCcsXG4gIHJlZnk6ICdyZWZZJyxcbiAgcmVuZGVyaW5naW50ZW50OiAncmVuZGVyaW5nSW50ZW50JyxcbiAgJ3JlbmRlcmluZy1pbnRlbnQnOiAncmVuZGVyaW5nSW50ZW50JyxcbiAgcmVwZWF0Y291bnQ6ICdyZXBlYXRDb3VudCcsXG4gIHJlcGVhdGR1cjogJ3JlcGVhdER1cicsXG4gIHJlcXVpcmVkZXh0ZW5zaW9uczogJ3JlcXVpcmVkRXh0ZW5zaW9ucycsXG4gIHJlcXVpcmVkZmVhdHVyZXM6ICdyZXF1aXJlZEZlYXR1cmVzJyxcbiAgcmVzb3VyY2U6ICdyZXNvdXJjZScsXG4gIHJlc3RhcnQ6ICdyZXN0YXJ0JyxcbiAgcmVzdWx0OiAncmVzdWx0JyxcbiAgcmVzdWx0czogJ3Jlc3VsdHMnLFxuICByb3RhdGU6ICdyb3RhdGUnLFxuICByeDogJ3J4JyxcbiAgcnk6ICdyeScsXG4gIHNjYWxlOiAnc2NhbGUnLFxuICBzZWN1cml0eTogJ3NlY3VyaXR5JyxcbiAgc2VlZDogJ3NlZWQnLFxuICBzaGFwZXJlbmRlcmluZzogJ3NoYXBlUmVuZGVyaW5nJyxcbiAgJ3NoYXBlLXJlbmRlcmluZyc6ICdzaGFwZVJlbmRlcmluZycsXG4gIHNsb3BlOiAnc2xvcGUnLFxuICBzcGFjaW5nOiAnc3BhY2luZycsXG4gIHNwZWN1bGFyY29uc3RhbnQ6ICdzcGVjdWxhckNvbnN0YW50JyxcbiAgc3BlY3VsYXJleHBvbmVudDogJ3NwZWN1bGFyRXhwb25lbnQnLFxuICBzcGVlZDogJ3NwZWVkJyxcbiAgc3ByZWFkbWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgc3RhcnRvZmZzZXQ6ICdzdGFydE9mZnNldCcsXG4gIHN0ZGRldmlhdGlvbjogJ3N0ZERldmlhdGlvbicsXG4gIHN0ZW1oOiAnc3RlbWgnLFxuICBzdGVtdjogJ3N0ZW12JyxcbiAgc3RpdGNodGlsZXM6ICdzdGl0Y2hUaWxlcycsXG4gIHN0b3Bjb2xvcjogJ3N0b3BDb2xvcicsXG4gICdzdG9wLWNvbG9yJzogJ3N0b3BDb2xvcicsXG4gIHN0b3BvcGFjaXR5OiAnc3RvcE9wYWNpdHknLFxuICAnc3RvcC1vcGFjaXR5JzogJ3N0b3BPcGFjaXR5JyxcbiAgc3RyaWtldGhyb3VnaHBvc2l0aW9uOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgJ3N0cmlrZXRocm91Z2gtcG9zaXRpb24nOiAnc3RyaWtldGhyb3VnaFBvc2l0aW9uJyxcbiAgc3RyaWtldGhyb3VnaHRoaWNrbmVzczogJ3N0cmlrZXRocm91Z2hUaGlja25lc3MnLFxuICAnc3RyaWtldGhyb3VnaC10aGlja25lc3MnOiAnc3RyaWtldGhyb3VnaFRoaWNrbmVzcycsXG4gIHN0cmluZzogJ3N0cmluZycsXG4gIHN0cm9rZTogJ3N0cm9rZScsXG4gIHN0cm9rZWRhc2hhcnJheTogJ3N0cm9rZURhc2hhcnJheScsXG4gICdzdHJva2UtZGFzaGFycmF5JzogJ3N0cm9rZURhc2hhcnJheScsXG4gIHN0cm9rZWRhc2hvZmZzZXQ6ICdzdHJva2VEYXNob2Zmc2V0JyxcbiAgJ3N0cm9rZS1kYXNob2Zmc2V0JzogJ3N0cm9rZURhc2hvZmZzZXQnLFxuICBzdHJva2VsaW5lY2FwOiAnc3Ryb2tlTGluZWNhcCcsXG4gICdzdHJva2UtbGluZWNhcCc6ICdzdHJva2VMaW5lY2FwJyxcbiAgc3Ryb2tlbGluZWpvaW46ICdzdHJva2VMaW5lam9pbicsXG4gICdzdHJva2UtbGluZWpvaW4nOiAnc3Ryb2tlTGluZWpvaW4nLFxuICBzdHJva2VtaXRlcmxpbWl0OiAnc3Ryb2tlTWl0ZXJsaW1pdCcsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6ICdzdHJva2VNaXRlcmxpbWl0JyxcbiAgc3Ryb2tld2lkdGg6ICdzdHJva2VXaWR0aCcsXG4gICdzdHJva2Utd2lkdGgnOiAnc3Ryb2tlV2lkdGgnLFxuICBzdHJva2VvcGFjaXR5OiAnc3Ryb2tlT3BhY2l0eScsXG4gICdzdHJva2Utb3BhY2l0eSc6ICdzdHJva2VPcGFjaXR5JyxcbiAgc3VwcHJlc3Njb250ZW50ZWRpdGFibGV3YXJuaW5nOiAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJyxcbiAgc3VwcHJlc3NoeWRyYXRpb253YXJuaW5nOiAnc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nJyxcbiAgc3VyZmFjZXNjYWxlOiAnc3VyZmFjZVNjYWxlJyxcbiAgc3lzdGVtbGFuZ3VhZ2U6ICdzeXN0ZW1MYW5ndWFnZScsXG4gIHRhYmxldmFsdWVzOiAndGFibGVWYWx1ZXMnLFxuICB0YXJnZXR4OiAndGFyZ2V0WCcsXG4gIHRhcmdldHk6ICd0YXJnZXRZJyxcbiAgdGV4dGFuY2hvcjogJ3RleHRBbmNob3InLFxuICAndGV4dC1hbmNob3InOiAndGV4dEFuY2hvcicsXG4gIHRleHRkZWNvcmF0aW9uOiAndGV4dERlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uJzogJ3RleHREZWNvcmF0aW9uJyxcbiAgdGV4dGxlbmd0aDogJ3RleHRMZW5ndGgnLFxuICB0ZXh0cmVuZGVyaW5nOiAndGV4dFJlbmRlcmluZycsXG4gICd0ZXh0LXJlbmRlcmluZyc6ICd0ZXh0UmVuZGVyaW5nJyxcbiAgdG86ICd0bycsXG4gIHRyYW5zZm9ybTogJ3RyYW5zZm9ybScsXG4gICd0eXBlb2YnOiAndHlwZW9mJyxcbiAgdTE6ICd1MScsXG4gIHUyOiAndTInLFxuICB1bmRlcmxpbmVwb3NpdGlvbjogJ3VuZGVybGluZVBvc2l0aW9uJyxcbiAgJ3VuZGVybGluZS1wb3NpdGlvbic6ICd1bmRlcmxpbmVQb3NpdGlvbicsXG4gIHVuZGVybGluZXRoaWNrbmVzczogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gICd1bmRlcmxpbmUtdGhpY2tuZXNzJzogJ3VuZGVybGluZVRoaWNrbmVzcycsXG4gIHVuaWNvZGU6ICd1bmljb2RlJyxcbiAgdW5pY29kZWJpZGk6ICd1bmljb2RlQmlkaScsXG4gICd1bmljb2RlLWJpZGknOiAndW5pY29kZUJpZGknLFxuICB1bmljb2RlcmFuZ2U6ICd1bmljb2RlUmFuZ2UnLFxuICAndW5pY29kZS1yYW5nZSc6ICd1bmljb2RlUmFuZ2UnLFxuICB1bml0c3BlcmVtOiAndW5pdHNQZXJFbScsXG4gICd1bml0cy1wZXItZW0nOiAndW5pdHNQZXJFbScsXG4gIHVuc2VsZWN0YWJsZTogJ3Vuc2VsZWN0YWJsZScsXG4gIHZhbHBoYWJldGljOiAndkFscGhhYmV0aWMnLFxuICAndi1hbHBoYWJldGljJzogJ3ZBbHBoYWJldGljJyxcbiAgdmFsdWVzOiAndmFsdWVzJyxcbiAgdmVjdG9yZWZmZWN0OiAndmVjdG9yRWZmZWN0JyxcbiAgJ3ZlY3Rvci1lZmZlY3QnOiAndmVjdG9yRWZmZWN0JyxcbiAgdmVyc2lvbjogJ3ZlcnNpb24nLFxuICB2ZXJ0YWR2eTogJ3ZlcnRBZHZZJyxcbiAgJ3ZlcnQtYWR2LXknOiAndmVydEFkdlknLFxuICB2ZXJ0b3JpZ2lueDogJ3ZlcnRPcmlnaW5YJyxcbiAgJ3ZlcnQtb3JpZ2luLXgnOiAndmVydE9yaWdpblgnLFxuICB2ZXJ0b3JpZ2lueTogJ3ZlcnRPcmlnaW5ZJyxcbiAgJ3ZlcnQtb3JpZ2luLXknOiAndmVydE9yaWdpblknLFxuICB2aGFuZ2luZzogJ3ZIYW5naW5nJyxcbiAgJ3YtaGFuZ2luZyc6ICd2SGFuZ2luZycsXG4gIHZpZGVvZ3JhcGhpYzogJ3ZJZGVvZ3JhcGhpYycsXG4gICd2LWlkZW9ncmFwaGljJzogJ3ZJZGVvZ3JhcGhpYycsXG4gIHZpZXdib3g6ICd2aWV3Qm94JyxcbiAgdmlld3RhcmdldDogJ3ZpZXdUYXJnZXQnLFxuICB2aXNpYmlsaXR5OiAndmlzaWJpbGl0eScsXG4gIHZtYXRoZW1hdGljYWw6ICd2TWF0aGVtYXRpY2FsJyxcbiAgJ3YtbWF0aGVtYXRpY2FsJzogJ3ZNYXRoZW1hdGljYWwnLFxuICB2b2NhYjogJ3ZvY2FiJyxcbiAgd2lkdGhzOiAnd2lkdGhzJyxcbiAgd29yZHNwYWNpbmc6ICd3b3JkU3BhY2luZycsXG4gICd3b3JkLXNwYWNpbmcnOiAnd29yZFNwYWNpbmcnLFxuICB3cml0aW5nbW9kZTogJ3dyaXRpbmdNb2RlJyxcbiAgJ3dyaXRpbmctbW9kZSc6ICd3cml0aW5nTW9kZScsXG4gIHgxOiAneDEnLFxuICB4MjogJ3gyJyxcbiAgeDogJ3gnLFxuICB4Y2hhbm5lbHNlbGVjdG9yOiAneENoYW5uZWxTZWxlY3RvcicsXG4gIHhoZWlnaHQ6ICd4SGVpZ2h0JyxcbiAgJ3gtaGVpZ2h0JzogJ3hIZWlnaHQnLFxuICB4bGlua2FjdHVhdGU6ICd4bGlua0FjdHVhdGUnLFxuICAneGxpbms6YWN0dWF0ZSc6ICd4bGlua0FjdHVhdGUnLFxuICB4bGlua2FyY3JvbGU6ICd4bGlua0FyY3JvbGUnLFxuICAneGxpbms6YXJjcm9sZSc6ICd4bGlua0FyY3JvbGUnLFxuICB4bGlua2hyZWY6ICd4bGlua0hyZWYnLFxuICAneGxpbms6aHJlZic6ICd4bGlua0hyZWYnLFxuICB4bGlua3JvbGU6ICd4bGlua1JvbGUnLFxuICAneGxpbms6cm9sZSc6ICd4bGlua1JvbGUnLFxuICB4bGlua3Nob3c6ICd4bGlua1Nob3cnLFxuICAneGxpbms6c2hvdyc6ICd4bGlua1Nob3cnLFxuICB4bGlua3RpdGxlOiAneGxpbmtUaXRsZScsXG4gICd4bGluazp0aXRsZSc6ICd4bGlua1RpdGxlJyxcbiAgeGxpbmt0eXBlOiAneGxpbmtUeXBlJyxcbiAgJ3hsaW5rOnR5cGUnOiAneGxpbmtUeXBlJyxcbiAgeG1sYmFzZTogJ3htbEJhc2UnLFxuICAneG1sOmJhc2UnOiAneG1sQmFzZScsXG4gIHhtbGxhbmc6ICd4bWxMYW5nJyxcbiAgJ3htbDpsYW5nJzogJ3htbExhbmcnLFxuICB4bWxuczogJ3htbG5zJyxcbiAgJ3htbDpzcGFjZSc6ICd4bWxTcGFjZScsXG4gIHhtbG5zeGxpbms6ICd4bWxuc1hsaW5rJyxcbiAgJ3htbG5zOnhsaW5rJzogJ3htbG5zWGxpbmsnLFxuICB4bWxzcGFjZTogJ3htbFNwYWNlJyxcbiAgeTE6ICd5MScsXG4gIHkyOiAneTInLFxuICB5OiAneScsXG4gIHljaGFubmVsc2VsZWN0b3I6ICd5Q2hhbm5lbFNlbGVjdG9yJyxcbiAgejogJ3onLFxuICB6b29tYW5kcGFuOiAnem9vbUFuZFBhbidcbn07XG5cbmZ1bmN0aW9uIGdldFN0YWNrQWRkZW5kdW0kMigpIHtcbiAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG4gIHJldHVybiBzdGFjayAhPSBudWxsID8gc3RhY2sgOiAnJztcbn1cblxue1xuICB2YXIgd2FybmVkUHJvcGVydGllcyQxID0ge307XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSQxID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIEVWRU5UX05BTUVfUkVHRVggPSAvXm9uW0EtWl0vO1xuICB2YXIgckFSSUEkMSA9IG5ldyBSZWdFeHAoJ14oYXJpYSktWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuICB2YXIgckFSSUFDYW1lbCQxID0gbmV3IFJlZ0V4cCgnXihhcmlhKVtBLVpdWycgKyBBVFRSSUJVVEVfTkFNRV9DSEFSICsgJ10qJCcpO1xuXG4gIHZhciB2YWxpZGF0ZVByb3BlcnR5JDEgPSBmdW5jdGlvbiAodGFnTmFtZSwgbmFtZSwgdmFsdWUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkkMS5jYWxsKHdhcm5lZFByb3BlcnRpZXMkMSwgbmFtZSkgJiYgd2FybmVkUHJvcGVydGllcyQxW25hbWVdKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChwbHVnaW5zLmxlbmd0aCA9PT0gMCAmJiBFVkVOVF9OQU1FX1JFR0VYLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIElmIG5vIGV2ZW50IHBsdWdpbnMgaGF2ZSBiZWVuIGluamVjdGVkLCB3ZSBtaWdodCBiZSBpbiBhIHNlcnZlciBlbnZpcm9ubWVudC5cbiAgICAgIC8vIERvbid0IGNoZWNrIGV2ZW50cyBpbiB0aGlzIGNhc2UuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgbG93ZXJDYXNlZE5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgdmFyIHJlZ2lzdHJhdGlvbk5hbWUgPSBwb3NzaWJsZVJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KGxvd2VyQ2FzZWROYW1lKSA/IHBvc3NpYmxlUmVnaXN0cmF0aW9uTmFtZXNbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGV2ZW50IGhhbmRsZXIgcHJvcGVydHkgYCVzYC4gRGlkIHlvdSBtZWFuIGAlc2A/JXMnLCBuYW1lLCByZWdpc3RyYXRpb25OYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lLmluZGV4T2YoJ29uJykgPT09IDAgJiYgbG93ZXJDYXNlZE5hbWUubGVuZ3RoID4gMikge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1Vua25vd24gZXZlbnQgaGFuZGxlciBwcm9wZXJ0eSBgJXNgLiBJdCB3aWxsIGJlIGlnbm9yZWQuJXMnLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSBBUklBIGF0dHJpYnV0ZSBob29rIHZhbGlkYXRlIEFSSUEgYXR0cmlidXRlc1xuICAgIGlmIChyQVJJQSQxLnRlc3QobmFtZSkgfHwgckFSSUFDYW1lbCQxLnRlc3QobmFtZSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChsb3dlckNhc2VkTmFtZSA9PT0gJ29uZm9jdXNpbicgfHwgbG93ZXJDYXNlZE5hbWUgPT09ICdvbmZvY3Vzb3V0Jykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IHVzZXMgb25Gb2N1cyBhbmQgb25CbHVyIGluc3RlYWQgb2Ygb25Gb2N1c0luIGFuZCBvbkZvY3VzT3V0LiAnICsgJ0FsbCBSZWFjdCBldmVudHMgYXJlIG5vcm1hbGl6ZWQgdG8gYnViYmxlLCBzbyBvbkZvY3VzSW4gYW5kIG9uRm9jdXNPdXQgJyArICdhcmUgbm90IG5lZWRlZC9zdXBwb3J0ZWQgYnkgUmVhY3QuJyk7XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKGxvd2VyQ2FzZWROYW1lID09PSAnaW5uZXJodG1sJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdhcmlhJykge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1RoZSBgYXJpYWAgYXR0cmlidXRlIGlzIHJlc2VydmVkIGZvciBmdXR1cmUgdXNlIGluIFJlYWN0LiAnICsgJ1Bhc3MgaW5kaXZpZHVhbCBgYXJpYS1gIGF0dHJpYnV0ZXMgaW5zdGVhZC4nKTtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAobG93ZXJDYXNlZE5hbWUgPT09ICdpcycgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsdWUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnUmVjZWl2ZWQgYSBgJXNgIGZvciBhIHN0cmluZyBhdHRyaWJ1dGUgYGlzYC4gSWYgdGhpcyBpcyBleHBlY3RlZCwgY2FzdCAnICsgJ3RoZSB2YWx1ZSB0byBhIHN0cmluZy4lcycsIHR5cGVvZiB2YWx1ZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIGlzTmFOKHZhbHVlKSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIE5hTiBmb3IgdGhlIGAlc2AgYXR0cmlidXRlLiBJZiB0aGlzIGlzIGV4cGVjdGVkLCBjYXN0ICcgKyAndGhlIHZhbHVlIHRvIGEgc3RyaW5nLiVzJywgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHZhciBpc1Jlc2VydmVkID0gaXNSZXNlcnZlZFByb3AobmFtZSk7XG5cbiAgICAvLyBLbm93biBhdHRyaWJ1dGVzIHNob3VsZCBtYXRjaCB0aGUgY2FzaW5nIHNwZWNpZmllZCBpbiB0aGUgcHJvcGVydHkgY29uZmlnLlxuICAgIGlmIChwb3NzaWJsZVN0YW5kYXJkTmFtZXMuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpKSB7XG4gICAgICB2YXIgc3RhbmRhcmROYW1lID0gcG9zc2libGVTdGFuZGFyZE5hbWVzW2xvd2VyQ2FzZWROYW1lXTtcbiAgICAgIGlmIChzdGFuZGFyZE5hbWUgIT09IG5hbWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgRE9NIHByb3BlcnR5IGAlc2AuIERpZCB5b3UgbWVhbiBgJXNgPyVzJywgbmFtZSwgc3RhbmRhcmROYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQgJiYgbmFtZSAhPT0gbG93ZXJDYXNlZE5hbWUpIHtcbiAgICAgIC8vIFVua25vd24gYXR0cmlidXRlcyBzaG91bGQgaGF2ZSBsb3dlcmNhc2UgY2FzaW5nIHNpbmNlIHRoYXQncyBob3cgdGhleVxuICAgICAgLy8gd2lsbCBiZSBjYXNlZCBhbnl3YXkgd2l0aCBzZXJ2ZXIgcmVuZGVyaW5nLlxuICAgICAgd2FybmluZyhmYWxzZSwgJ1JlYWN0IGRvZXMgbm90IHJlY29nbml6ZSB0aGUgYCVzYCBwcm9wIG9uIGEgRE9NIGVsZW1lbnQuIElmIHlvdSAnICsgJ2ludGVudGlvbmFsbHkgd2FudCBpdCB0byBhcHBlYXIgaW4gdGhlIERPTSBhcyBhIGN1c3RvbSAnICsgJ2F0dHJpYnV0ZSwgc3BlbGwgaXQgYXMgbG93ZXJjYXNlIGAlc2AgaW5zdGVhZC4gJyArICdJZiB5b3UgYWNjaWRlbnRhbGx5IHBhc3NlZCBpdCBmcm9tIGEgcGFyZW50IGNvbXBvbmVudCwgcmVtb3ZlICcgKyAnaXQgZnJvbSB0aGUgRE9NIGVsZW1lbnQuJXMnLCBuYW1lLCBsb3dlckNhc2VkTmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgd2FybmVkUHJvcGVydGllcyQxW25hbWVdID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyAmJiAhc2hvdWxkQXR0cmlidXRlQWNjZXB0Qm9vbGVhblZhbHVlKG5hbWUpKSB7XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS4lcycsIHZhbHVlLCBuYW1lLCBuYW1lLCB2YWx1ZSwgbmFtZSwgZ2V0U3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd2FybmluZyhmYWxzZSwgJ1JlY2VpdmVkIGAlc2AgZm9yIGEgbm9uLWJvb2xlYW4gYXR0cmlidXRlIGAlc2AuXFxuXFxuJyArICdJZiB5b3Ugd2FudCB0byB3cml0ZSBpdCB0byB0aGUgRE9NLCBwYXNzIGEgc3RyaW5nIGluc3RlYWQ6ICcgKyAnJXM9XCIlc1wiIG9yICVzPXt2YWx1ZS50b1N0cmluZygpfS5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgdmFsdWUsIG5hbWUsIG5hbWUsIHZhbHVlLCBuYW1lLCBuYW1lLCBuYW1lLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gICAgICB9XG4gICAgICB3YXJuZWRQcm9wZXJ0aWVzJDFbbmFtZV0gPSB0cnVlO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoYXQgd2UndmUgdmFsaWRhdGVkIGNhc2luZywgZG8gbm90IHZhbGlkYXRlXG4gICAgLy8gZGF0YSB0eXBlcyBmb3IgcmVzZXJ2ZWQgcHJvcHNcbiAgICBpZiAoaXNSZXNlcnZlZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gV2FybiB3aGVuIGEga25vd24gYXR0cmlidXRlIGlzIGEgYmFkIHR5cGVcbiAgICBpZiAoIXNob3VsZFNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkpIHtcbiAgICAgIHdhcm5lZFByb3BlcnRpZXMkMVtuYW1lXSA9IHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG59XG5cbnZhciB3YXJuVW5rbm93blByb3BlcnRpZXMgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgdmFyIHVua25vd25Qcm9wcyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICB2YXIgaXNWYWxpZCA9IHZhbGlkYXRlUHJvcGVydHkkMSh0eXBlLCBrZXksIHByb3BzW2tleV0pO1xuICAgIGlmICghaXNWYWxpZCkge1xuICAgICAgdW5rbm93blByb3BzLnB1c2goa2V5KTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5rbm93blByb3BTdHJpbmcgPSB1bmtub3duUHJvcHMubWFwKGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgcmV0dXJuICdgJyArIHByb3AgKyAnYCc7XG4gIH0pLmpvaW4oJywgJyk7XG4gIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID09PSAxKSB7XG4gICAgd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgdmFsdWUgZm9yIHByb3AgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgaXQgZnJvbSB0aGUgZWxlbWVudCwgJyArICdvciBwYXNzIGEgc3RyaW5nIG9yIG51bWJlciB2YWx1ZSB0byBrZWVwIGl0IGluIHRoZSBET00uICcgKyAnRm9yIGRldGFpbHMsIHNlZSBodHRwczovL2ZiLm1lL3JlYWN0LWF0dHJpYnV0ZS1iZWhhdmlvciVzJywgdW5rbm93blByb3BTdHJpbmcsIHR5cGUsIGdldFN0YWNrQWRkZW5kdW0kMigpKTtcbiAgfSBlbHNlIGlmICh1bmtub3duUHJvcHMubGVuZ3RoID4gMSkge1xuICAgIHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIHZhbHVlcyBmb3IgcHJvcHMgJXMgb24gPCVzPiB0YWcuIEVpdGhlciByZW1vdmUgdGhlbSBmcm9tIHRoZSBlbGVtZW50LCAnICsgJ29yIHBhc3MgYSBzdHJpbmcgb3IgbnVtYmVyIHZhbHVlIHRvIGtlZXAgdGhlbSBpbiB0aGUgRE9NLiAnICsgJ0ZvciBkZXRhaWxzLCBzZWUgaHR0cHM6Ly9mYi5tZS9yZWFjdC1hdHRyaWJ1dGUtYmVoYXZpb3IlcycsIHVua25vd25Qcm9wU3RyaW5nLCB0eXBlLCBnZXRTdGFja0FkZGVuZHVtJDIoKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcGVydGllcyQyKHR5cGUsIHByb3BzKSB7XG4gIGlmIChpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcykpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2FyblVua25vd25Qcm9wZXJ0aWVzKHR5cGUsIHByb3BzKTtcbn1cblxuLy8gVE9ETzogZGlyZWN0IGltcG9ydHMgbGlrZSBzb21lLXBhY2thZ2Uvc3JjLyogYXJlIGJhZC4gRml4IG1lLlxudmFyIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJPd25lck5hbWU7XG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSBmYWxzZTtcbnZhciBkaWRXYXJuU2hhZHlET00gPSBmYWxzZTtcblxudmFyIERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MID0gJ2Rhbmdlcm91c2x5U2V0SW5uZXJIVE1MJztcbnZhciBTVVBQUkVTU19DT05URU5UX0VESVRBQkxFX1dBUk5JTkcgPSAnc3VwcHJlc3NDb250ZW50RWRpdGFibGVXYXJuaW5nJztcbnZhciBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG52YXIgQVVUT0ZPQ1VTID0gJ2F1dG9Gb2N1cyc7XG52YXIgQ0hJTERSRU4gPSAnY2hpbGRyZW4nO1xudmFyIFNUWUxFID0gJ3N0eWxlJztcbnZhciBIVE1MID0gJ19faHRtbCc7XG5cbnZhciBIVE1MX05BTUVTUEFDRSA9IE5hbWVzcGFjZXMuaHRtbDtcblxuXG52YXIgZ2V0U3RhY2sgPSBlbXB0eUZ1bmN0aW9uJDEudGhhdFJldHVybnMoJycpO1xuXG57XG4gIGdldFN0YWNrID0gZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyO1xuXG4gIHZhciB3YXJuZWRVbmtub3duVGFncyA9IHtcbiAgICAvLyBDaHJvbWUgaXMgdGhlIG9ubHkgbWFqb3IgYnJvd3NlciBub3Qgc2hpcHBpbmcgPHRpbWU+LiBCdXQgYXMgb2YgSnVseVxuICAgIC8vIDIwMTcgaXQgaW50ZW5kcyB0byBzaGlwIGl0IGR1ZSB0byB3aWRlc3ByZWFkIHVzYWdlLiBXZSBpbnRlbnRpb25hbGx5XG4gICAgLy8gKmRvbid0KiB3YXJuIGZvciA8dGltZT4gZXZlbiBpZiBpdCdzIHVucmVjb2duaXplZCBieSBDaHJvbWUgYmVjYXVzZVxuICAgIC8vIGl0IHNvb24gd2lsbCBiZSwgYW5kIG1hbnkgYXBwcyBoYXZlIGJlZW4gdXNpbmcgaXQgYW55d2F5LlxuICAgIHRpbWU6IHRydWUsXG4gICAgLy8gVGhlcmUgYXJlIHdvcmtpbmcgcG9seWZpbGxzIGZvciA8ZGlhbG9nPi4gTGV0IHBlb3BsZSB1c2UgaXQuXG4gICAgZGlhbG9nOiB0cnVlXG4gIH07XG5cbiAgdmFyIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQgPSBmdW5jdGlvbiAodHlwZSwgcHJvcHMpIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXModHlwZSwgcHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllcyQxKHR5cGUsIHByb3BzKTtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXMkMih0eXBlLCBwcm9wcyk7XG4gIH07XG5cbiAgLy8gSFRNTCBwYXJzaW5nIG5vcm1hbGl6ZXMgQ1IgYW5kIENSTEYgdG8gTEYuXG4gIC8vIEl0IGFsc28gY2FuIHR1cm4gXFx1MDAwMCBpbnRvIFxcdUZGRkQgaW5zaWRlIGF0dHJpYnV0ZXMuXG4gIC8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zaW5nbGUtcGFnZS5odG1sI3ByZXByb2Nlc3NpbmctdGhlLWlucHV0LXN0cmVhbVxuICAvLyBJZiB3ZSBoYXZlIGEgbWlzbWF0Y2gsIGl0IG1pZ2h0IGJlIGNhdXNlZCBieSB0aGF0LlxuICAvLyBXZSB3aWxsIHN0aWxsIHBhdGNoIHVwIGluIHRoaXMgY2FzZSBidXQgbm90IGZpcmUgdGhlIHdhcm5pbmcuXG4gIHZhciBOT1JNQUxJWkVfTkVXTElORVNfUkVHRVggPSAvXFxyXFxuPy9nO1xuICB2YXIgTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYID0gL1xcdTAwMDB8XFx1RkZGRC9nO1xuXG4gIHZhciBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUgPSBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgdmFyIG1hcmt1cFN0cmluZyA9IHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnID8gbWFya3VwIDogJycgKyBtYXJrdXA7XG4gICAgcmV0dXJuIG1hcmt1cFN0cmluZy5yZXBsYWNlKE5PUk1BTElaRV9ORVdMSU5FU19SRUdFWCwgJ1xcbicpLnJlcGxhY2UoTk9STUFMSVpFX05VTExfQU5EX1JFUExBQ0VNRU5UX1JFR0VYLCAnJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChzZXJ2ZXJUZXh0LCBjbGllbnRUZXh0KSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VGV4dCA9IG5vcm1hbGl6ZU1hcmt1cEZvclRleHRPckF0dHJpYnV0ZShjbGllbnRUZXh0KTtcbiAgICB2YXIgbm9ybWFsaXplZFNlcnZlclRleHQgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVGV4dCk7XG4gICAgaWYgKG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0ID09PSBub3JtYWxpemVkQ2xpZW50VGV4dCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1RleHQgY29udGVudCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6IFwiJXNcIiBDbGllbnQ6IFwiJXNcIicsIG5vcm1hbGl6ZWRTZXJ2ZXJUZXh0LCBub3JtYWxpemVkQ2xpZW50VGV4dCk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZSA9IGZ1bmN0aW9uIChwcm9wTmFtZSwgc2VydmVyVmFsdWUsIGNsaWVudFZhbHVlKSB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBub3JtYWxpemVkQ2xpZW50VmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoY2xpZW50VmFsdWUpO1xuICAgIHZhciBub3JtYWxpemVkU2VydmVyVmFsdWUgPSBub3JtYWxpemVNYXJrdXBGb3JUZXh0T3JBdHRyaWJ1dGUoc2VydmVyVmFsdWUpO1xuICAgIGlmIChub3JtYWxpemVkU2VydmVyVmFsdWUgPT09IG5vcm1hbGl6ZWRDbGllbnRWYWx1ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ1Byb3AgYCVzYCBkaWQgbm90IG1hdGNoLiBTZXJ2ZXI6ICVzIENsaWVudDogJXMnLCBwcm9wTmFtZSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZFNlcnZlclZhbHVlKSwgSlNPTi5zdHJpbmdpZnkobm9ybWFsaXplZENsaWVudFZhbHVlKSk7XG4gIH07XG5cbiAgdmFyIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoYXR0cmlidXRlTmFtZXMpIHtcbiAgICBpZiAoZGlkV2FybkludmFsaWRIeWRyYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2FybkludmFsaWRIeWRyYXRpb24gPSB0cnVlO1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGF0dHJpYnV0ZU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gICAgd2FybmluZyhmYWxzZSwgJ0V4dHJhIGF0dHJpYnV0ZXMgZnJvbSB0aGUgc2VydmVyOiAlcycsIG5hbWVzKTtcbiAgfTtcblxuICB2YXIgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKSB7XG4gICAgaWYgKGxpc3RlbmVyID09PSBmYWxzZSkge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ0V4cGVjdGVkIGAlc2AgbGlzdGVuZXIgdG8gYmUgYSBmdW5jdGlvbiwgaW5zdGVhZCBnb3QgYGZhbHNlYC5cXG5cXG4nICsgJ0lmIHlvdSB1c2VkIHRvIGNvbmRpdGlvbmFsbHkgb21pdCBpdCB3aXRoICVzPXtjb25kaXRpb24gJiYgdmFsdWV9LCAnICsgJ3Bhc3MgJXM9e2NvbmRpdGlvbiA/IHZhbHVlIDogdW5kZWZpbmVkfSBpbnN0ZWFkLiVzJywgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgcmVnaXN0cmF0aW9uTmFtZSwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgYCVzYCBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCBhIHZhbHVlIG9mIGAlc2AgdHlwZS4lcycsIHJlZ2lzdHJhdGlvbk5hbWUsIHR5cGVvZiBsaXN0ZW5lciwgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQyKCkpO1xuICAgIH1cbiAgfTtcblxuICAvLyBQYXJzZSB0aGUgSFRNTCBhbmQgcmVhZCBpdCBiYWNrIHRvIG5vcm1hbGl6ZSB0aGUgSFRNTCBzdHJpbmcgc28gdGhhdCBpdFxuICAvLyBjYW4gYmUgdXNlZCBmb3IgY29tcGFyaXNvbi5cbiAgdmFyIG5vcm1hbGl6ZUhUTUwgPSBmdW5jdGlvbiAocGFyZW50LCBodG1sKSB7XG4gICAgLy8gV2UgY291bGQgaGF2ZSBjcmVhdGVkIGEgc2VwYXJhdGUgZG9jdW1lbnQgaGVyZSB0byBhdm9pZFxuICAgIC8vIHJlLWluaXRpYWxpemluZyBjdXN0b20gZWxlbWVudHMgaWYgdGhleSBleGlzdC4gQnV0IHRoaXMgYnJlYWtzXG4gICAgLy8gaG93IDxub3NjcmlwdD4gaXMgYmVpbmcgaGFuZGxlZC4gU28gd2UgdXNlIHRoZSBzYW1lIGRvY3VtZW50LlxuICAgIC8vIFNlZSB0aGUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMTE1Ny5cbiAgICB2YXIgdGVzdEVsZW1lbnQgPSBwYXJlbnQubmFtZXNwYWNlVVJJID09PSBIVE1MX05BTUVTUEFDRSA/IHBhcmVudC5vd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQocGFyZW50LnRhZ05hbWUpIDogcGFyZW50Lm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHBhcmVudC5uYW1lc3BhY2VVUkksIHBhcmVudC50YWdOYW1lKTtcbiAgICB0ZXN0RWxlbWVudC5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiB0ZXN0RWxlbWVudC5pbm5lckhUTUw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCByZWdpc3RyYXRpb25OYW1lKSB7XG4gIHZhciBpc0RvY3VtZW50T3JGcmFnbWVudCA9IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IHJvb3RDb250YWluZXJFbGVtZW50Lm5vZGVUeXBlID09PSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFO1xuICB2YXIgZG9jID0gaXNEb2N1bWVudE9yRnJhZ21lbnQgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG4gIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG59XG5cbmZ1bmN0aW9uIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkge1xuICByZXR1cm4gcm9vdENvbnRhaW5lckVsZW1lbnQubm9kZVR5cGUgPT09IERPQ1VNRU5UX05PREUgPyByb290Q29udGFpbmVyRWxlbWVudCA6IHJvb3RDb250YWluZXJFbGVtZW50Lm93bmVyRG9jdW1lbnQ7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQ2xpY2tPbk5vbkludGVyYWN0aXZlRWxlbWVudChub2RlKSB7XG4gIC8vIE1vYmlsZSBTYWZhcmkgZG9lcyBub3QgZmlyZSBwcm9wZXJseSBidWJibGUgY2xpY2sgZXZlbnRzIG9uXG4gIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgLy8gZmlyZS4gVGhlIHdvcmthcm91bmQgZm9yIHRoaXMgYnVnIGludm9sdmVzIGF0dGFjaGluZyBhbiBlbXB0eSBjbGlja1xuICAvLyBsaXN0ZW5lciBvbiB0aGUgdGFyZ2V0IG5vZGUuXG4gIC8vIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvYmxvZy9hcmNoaXZlcy8yMDEwLzA5L2NsaWNrX2V2ZW50X2RlbC5odG1sXG4gIC8vIEp1c3Qgc2V0IGl0IHVzaW5nIHRoZSBvbmNsaWNrIHByb3BlcnR5IHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZSB0byBtYW5hZ2UgYW55XG4gIC8vIGJvb2trZWVwaW5nIGZvciBpdC4gTm90IHN1cmUgaWYgd2UgbmVlZCB0byBjbGVhciBpdCB3aGVuIHRoZSBsaXN0ZW5lciBpc1xuICAvLyByZW1vdmVkLlxuICAvLyBUT0RPOiBPbmx5IGRvIHRoaXMgZm9yIHRoZSByZWxldmFudCBTYWZhcmlzIG1heWJlP1xuICBub2RlLm9uY2xpY2sgPSBlbXB0eUZ1bmN0aW9uJDE7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxET01Qcm9wZXJ0aWVzKHRhZywgZG9tRWxlbWVudCwgcm9vdENvbnRhaW5lckVsZW1lbnQsIG5leHRQcm9wcywgaXNDdXN0b21Db21wb25lbnRUYWcpIHtcbiAgZm9yICh2YXIgcHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgLy8gRnJlZXplIHRoZSBuZXh0IHN0eWxlIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBhc3N1bWUgaXQgd29uJ3QgYmVcbiAgICAgICAgICAvLyBtdXRhdGVkLiBXZSBoYXZlIGFscmVhZHkgd2FybmVkIGZvciB0aGlzIGluIHRoZSBwYXN0LlxuICAgICAgICAgIE9iamVjdC5mcmVlemUobmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBSZWxpZXMgb24gYHVwZGF0ZVN0eWxlc0J5SURgIG5vdCBtdXRhdGluZyBgc3R5bGVVcGRhdGVzYC5cbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIG5leHRQcm9wLCBnZXRTdGFjayk7XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCkge1xuICAgICAgdmFyIG5leHRIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBuZXh0SHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gQXZvaWQgc2V0dGluZyBpbml0aWFsIHRleHRDb250ZW50IHdoZW4gdGhlIHRleHQgaXMgZW1wdHkuIEluIElFMTEgc2V0dGluZ1xuICAgICAgICAvLyB0ZXh0Q29udGVudCBvbiBhIDx0ZXh0YXJlYT4gd2lsbCBjYXVzZSB0aGUgcGxhY2Vob2xkZXIgdG8gbm90XG4gICAgICAgIC8vIHNob3cgd2l0aGluIHRoZSA8dGV4dGFyZWE+IHVudGlsIGl0IGhhcyBiZWVuIGZvY3VzZWQgYW5kIGJsdXJyZWQgYWdhaW4uXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvNjczMSNpc3N1ZWNvbW1lbnQtMjU0ODc0NTUzXG4gICAgICAgIHZhciBjYW5TZXRUZXh0Q29udGVudCA9IHRhZyAhPT0gJ3RleHRhcmVhJyB8fCBuZXh0UHJvcCAhPT0gJyc7XG4gICAgICAgIGlmIChjYW5TZXRUZXh0Q29udGVudCkge1xuICAgICAgICAgIHNldFRleHRDb250ZW50JDEoZG9tRWxlbWVudCwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgc2V0VGV4dENvbnRlbnQkMShkb21FbGVtZW50LCAnJyArIG5leHRQcm9wKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIFdlIHBvbHlmaWxsIGl0IHNlcGFyYXRlbHkgb24gdGhlIGNsaWVudCBkdXJpbmcgY29tbWl0LlxuICAgICAgLy8gV2UgYmxhY2tsaXN0IGl0IGhlcmUgcmF0aGVyIHRoYW4gaW4gdGhlIHByb3BlcnR5IGxpc3QgYmVjYXVzZSB3ZSBlbWl0IGl0IGluIFNTUi5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICBpZiAodHJ1ZSAmJiB0eXBlb2YgbmV4dFByb3AgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB3YXJuRm9ySW52YWxpZEV2ZW50TGlzdGVuZXIocHJvcEtleSwgbmV4dFByb3ApO1xuICAgICAgICB9XG4gICAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCBwcm9wS2V5KTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBzZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgfSBlbHNlIGlmIChuZXh0UHJvcCAhPSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRlbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgICAvLyBicmluZ3MgdXMgaW4gbGluZSB3aXRoIHRoZSBzYW1lIGJlaGF2aW9yIHdlIGhhdmUgb24gaW5pdGlhbCByZW5kZXIuXG4gICAgICBzZXRWYWx1ZUZvclByb3BlcnR5KGRvbUVsZW1lbnQsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRE9NUHJvcGVydGllcyhkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB3YXNDdXN0b21Db21wb25lbnRUYWcsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gIC8vIFRPRE86IEhhbmRsZSB3YXNDdXN0b21Db21wb25lbnRUYWdcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVQYXlsb2FkLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIHByb3BLZXkgPSB1cGRhdGVQYXlsb2FkW2ldO1xuICAgIHZhciBwcm9wVmFsdWUgPSB1cGRhdGVQYXlsb2FkW2kgKyAxXTtcbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHNldFZhbHVlRm9yU3R5bGVzKGRvbUVsZW1lbnQsIHByb3BWYWx1ZSwgZ2V0U3RhY2spO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gREFOR0VST1VTTFlfU0VUX0lOTkVSX0hUTUwpIHtcbiAgICAgIHNldElubmVySFRNTChkb21FbGVtZW50LCBwcm9wVmFsdWUpO1xuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIHNldFRleHRDb250ZW50JDEoZG9tRWxlbWVudCwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgc2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZVZhbHVlRm9yQXR0cmlidXRlKGRvbUVsZW1lbnQsIHByb3BLZXkpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcFZhbHVlICE9IG51bGwpIHtcbiAgICAgIHNldFZhbHVlRm9yUHJvcGVydHkoZG9tRWxlbWVudCwgcHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgd2UncmUgdXBkYXRpbmcgdG8gbnVsbCBvciB1bmRlZmluZWQsIHdlIHNob3VsZCByZW1vdmUgdGhlIHByb3BlcnR5XG4gICAgICAvLyBmcm9tIHRoZSBET00gbm9kZSBpbnN0ZWFkIG9mIGluYWR2ZXJ0ZW50bHkgc2V0dGluZyB0byBhIHN0cmluZy4gVGhpc1xuICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVyRWxlbWVudCwgcGFyZW50TmFtZXNwYWNlKSB7XG4gIC8vIFdlIGNyZWF0ZSB0YWdzIGluIHRoZSBuYW1lc3BhY2Ugb2YgdGhlaXIgcGFyZW50IGNvbnRhaW5lciwgZXhjZXB0IEhUTUxcbiAgdmFyIG93bmVyRG9jdW1lbnQgPSBnZXRPd25lckRvY3VtZW50RnJvbVJvb3RDb250YWluZXIocm9vdENvbnRhaW5lckVsZW1lbnQpO1xuICB2YXIgZG9tRWxlbWVudDtcbiAgdmFyIG5hbWVzcGFjZVVSSSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICBuYW1lc3BhY2VVUkkgPSBnZXRJbnRyaW5zaWNOYW1lc3BhY2UodHlwZSk7XG4gIH1cbiAgaWYgKG5hbWVzcGFjZVVSSSA9PT0gSFRNTF9OQU1FU1BBQ0UpIHtcbiAgICB7XG4gICAgICB2YXIgaXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gICAgICAvLyBTaG91bGQgdGhpcyBjaGVjayBiZSBnYXRlZCBieSBwYXJlbnQgbmFtZXNwYWNlPyBOb3Qgc3VyZSB3ZSB3YW50IHRvXG4gICAgICAvLyBhbGxvdyA8U1ZHPiBvciA8bUFUSD4uXG4gICAgICB3YXJuaW5nKGlzQ3VzdG9tQ29tcG9uZW50VGFnIHx8IHR5cGUgPT09IHR5cGUudG9Mb3dlckNhc2UoKSwgJzwlcyAvPiBpcyB1c2luZyB1cHBlcmNhc2UgSFRNTC4gQWx3YXlzIHVzZSBsb3dlcmNhc2UgSFRNTCB0YWdzICcgKyAnaW4gUmVhY3QuJywgdHlwZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09ICdzY3JpcHQnKSB7XG4gICAgICAvLyBDcmVhdGUgdGhlIHNjcmlwdCB2aWEgLmlubmVySFRNTCBzbyBpdHMgXCJwYXJzZXItaW5zZXJ0ZWRcIiBmbGFnIGlzXG4gICAgICAvLyBzZXQgdG8gdHJ1ZSBhbmQgaXQgZG9lcyBub3QgZXhlY3V0ZVxuICAgICAgdmFyIGRpdiA9IG93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICBkaXYuaW5uZXJIVE1MID0gJzxzY3JpcHQ+PCcgKyAnL3NjcmlwdD4nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAvLyBUaGlzIGlzIGd1YXJhbnRlZWQgdG8geWllbGQgYSBzY3JpcHQgZWxlbWVudC5cbiAgICAgIHZhciBmaXJzdENoaWxkID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICBkb21FbGVtZW50ID0gZGl2LnJlbW92ZUNoaWxkKGZpcnN0Q2hpbGQpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHByb3BzLmlzID09PSAnc3RyaW5nJykge1xuICAgICAgLy8gJEZsb3dJc3N1ZSBgY3JlYXRlRWxlbWVudGAgc2hvdWxkIGJlIHVwZGF0ZWQgZm9yIFdlYiBDb21wb25lbnRzXG4gICAgICBkb21FbGVtZW50ID0gb3duZXJEb2N1bWVudC5jcmVhdGVFbGVtZW50KHR5cGUsIHsgaXM6IHByb3BzLmlzIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXBhcmF0ZSBlbHNlIGJyYW5jaCBpbnN0ZWFkIG9mIHVzaW5nIGBwcm9wcy5pcyB8fCB1bmRlZmluZWRgIGFib3ZlIGJlY2F1c2Ugb2YgYSBGaXJlZm94IGJ1Zy5cbiAgICAgIC8vIFNlZSBkaXNjdXNzaW9uIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzY4OTZcbiAgICAgIC8vIGFuZCBkaXNjdXNzaW9uIGluIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEyNzYyNDBcbiAgICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodHlwZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGRvbUVsZW1lbnQgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhuYW1lc3BhY2VVUkksIHR5cGUpO1xuICB9XG5cbiAge1xuICAgIGlmIChuYW1lc3BhY2VVUkkgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICBpZiAoIWlzQ3VzdG9tQ29tcG9uZW50VGFnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChkb21FbGVtZW50KSA9PT0gJ1tvYmplY3QgSFRNTFVua25vd25FbGVtZW50XScgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh3YXJuZWRVbmtub3duVGFncywgdHlwZSkpIHtcbiAgICAgICAgd2FybmVkVW5rbm93blRhZ3NbdHlwZV0gPSB0cnVlO1xuICAgICAgICB3YXJuaW5nKGZhbHNlLCAnVGhlIHRhZyA8JXM+IGlzIHVucmVjb2duaXplZCBpbiB0aGlzIGJyb3dzZXIuICcgKyAnSWYgeW91IG1lYW50IHRvIHJlbmRlciBhIFJlYWN0IGNvbXBvbmVudCwgc3RhcnQgaXRzIG5hbWUgd2l0aCAnICsgJ2FuIHVwcGVyY2FzZSBsZXR0ZXIuJywgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbUVsZW1lbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlJDEodGV4dCwgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgcmV0dXJuIGdldE93bmVyRG9jdW1lbnRGcm9tUm9vdENvbnRhaW5lcihyb290Q29udGFpbmVyRWxlbWVudCkuY3JlYXRlVGV4dE5vZGUodGV4dCk7XG59XG5cbmZ1bmN0aW9uIHNldEluaXRpYWxQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcm9vdENvbnRhaW5lckVsZW1lbnQpIHtcbiAgdmFyIGlzQ3VzdG9tQ29tcG9uZW50VGFnID0gaXNDdXN0b21Db21wb25lbnQodGFnLCByYXdQcm9wcyk7XG4gIHtcbiAgICB2YWxpZGF0ZVByb3BlcnRpZXNJbkRldmVsb3BtZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZyAmJiAhZGlkV2FyblNoYWR5RE9NICYmIGRvbUVsZW1lbnQuc2hhZHlSb290KSB7XG4gICAgICB3YXJuaW5nKGZhbHNlLCAnJXMgaXMgdXNpbmcgc2hhZHkgRE9NLiBVc2luZyBzaGFkeSBET00gd2l0aCBSZWFjdCBjYW4gJyArICdjYXVzZSB0aGluZ3MgdG8gYnJlYWsgc3VidGx5LicsIGdldEN1cnJlbnRGaWJlck93bmVyTmFtZSQxKCkgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICBkaWRXYXJuU2hhZHlET00gPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGF0IHdlIGNoZWNrIGlzTW91bnRlZCBiZWZvcmUgZmlyaW5nIGFueSBvZiB0aGVzZSBldmVudHMuXG4gIHZhciBwcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuICAgICAgLy8gQ3JlYXRlIGxpc3RlbmVyIGZvciBlYWNoIG1lZGlhIGV2ZW50XG4gICAgICBmb3IgKHZhciBldmVudCBpbiBtZWRpYUV2ZW50cykge1xuICAgICAgICBpZiAobWVkaWFFdmVudHMuaGFzT3duUHJvcGVydHkoZXZlbnQpKSB7XG4gICAgICAgICAgdHJhcEJ1YmJsZWRFdmVudChldmVudCwgbWVkaWFFdmVudHNbZXZlbnRdLCBkb21FbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NvdXJjZSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BFcnJvcicsICdlcnJvcicsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgcHJvcHMgPSByYXdQcm9wcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wUmVzZXQnLCAncmVzZXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFN1Ym1pdCcsICdzdWJtaXQnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcFRvZ2dsZScsICd0b2dnbGUnLCBkb21FbGVtZW50KTtcbiAgICAgIHByb3BzID0gcmF3UHJvcHM7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHByb3BzID0gZ2V0SG9zdFByb3BzJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMShkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIGluaXRXcmFwcGVyU3RhdGUkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBwcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBwcm9wcyA9IHJhd1Byb3BzO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHByb3BzLCBnZXRTdGFjayk7XG5cbiAgc2V0SW5pdGlhbERPTVByb3BlcnRpZXModGFnLCBkb21FbGVtZW50LCByb290Q29udGFpbmVyRWxlbWVudCwgcHJvcHMsIGlzQ3VzdG9tQ29tcG9uZW50VGFnKTtcblxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHdlIGNoZWNrIGlmIHRoaXMgaXMgc3RpbGwgdW5tb3VudGVkIG9yIGRvIGFueSBjbGVhblxuICAgICAgLy8gdXAgbmVjZXNzYXJ5IHNpbmNlIHdlIG5ldmVyIHN0b3AgdHJhY2tpbmcgYW55bW9yZS5cbiAgICAgIHRyYWNrKGRvbUVsZW1lbnQpO1xuICAgICAgcG9zdE1vdW50V3JhcHBlciQzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICBwb3N0TW91bnRXcmFwcGVyJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMihkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cblxuLy8gQ2FsY3VsYXRlIHRoZSBkaWZmIGJldHdlZW4gdGhlIHR3byBvYmplY3RzLlxuZnVuY3Rpb24gZGlmZlByb3BlcnRpZXMkMShkb21FbGVtZW50LCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFsaWRhdGVQcm9wZXJ0aWVzSW5EZXZlbG9wbWVudCh0YWcsIG5leHRSYXdQcm9wcyk7XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG5cbiAgdmFyIGxhc3RQcm9wcztcbiAgdmFyIG5leHRQcm9wcztcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBsYXN0UHJvcHMgPSBnZXRIb3N0UHJvcHMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyhkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQxKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIGxhc3RQcm9wcyA9IGdldEhvc3RQcm9wcyQyKGRvbUVsZW1lbnQsIGxhc3RSYXdQcm9wcyk7XG4gICAgICBuZXh0UHJvcHMgPSBnZXRIb3N0UHJvcHMkMihkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgbGFzdFByb3BzID0gZ2V0SG9zdFByb3BzJDMoZG9tRWxlbWVudCwgbGFzdFJhd1Byb3BzKTtcbiAgICAgIG5leHRQcm9wcyA9IGdldEhvc3RQcm9wcyQzKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgbGFzdFByb3BzID0gbGFzdFJhd1Byb3BzO1xuICAgICAgbmV4dFByb3BzID0gbmV4dFJhd1Byb3BzO1xuICAgICAgaWYgKHR5cGVvZiBsYXN0UHJvcHMub25DbGljayAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgbmV4dFByb3BzLm9uQ2xpY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBjYXN0IG1heSBub3QgYmUgc291bmQgZm9yIFNWRywgTWF0aE1MIG9yIGN1c3RvbSBlbGVtZW50cy5cbiAgICAgICAgdHJhcENsaWNrT25Ob25JbnRlcmFjdGl2ZUVsZW1lbnQoZG9tRWxlbWVudCk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgfVxuXG4gIGFzc2VydFZhbGlkUHJvcHModGFnLCBuZXh0UHJvcHMsIGdldFN0YWNrKTtcblxuICB2YXIgcHJvcEtleTtcbiAgdmFyIHN0eWxlTmFtZTtcbiAgdmFyIHN0eWxlVXBkYXRlcyA9IG51bGw7XG4gIGZvciAocHJvcEtleSBpbiBsYXN0UHJvcHMpIHtcbiAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbGFzdFByb3BzW3Byb3BLZXldID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgIHZhciBsYXN0U3R5bGUgPSBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgaWYgKGxhc3RTdHlsZS5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XG4gICAgICAgICAgaWYgKCFzdHlsZVVwZGF0ZXMpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9ICcnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBEQU5HRVJPVVNMWV9TRVRfSU5ORVJfSFRNTCB8fCBwcm9wS2V5ID09PSBDSElMRFJFTikge1xuICAgICAgLy8gTm9vcC4gVGhpcyBpcyBoYW5kbGVkIGJ5IHRoZSBjbGVhciB0ZXh0IG1lY2hhbmlzbS5cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxKSB7XG4gICAgICAvLyBOb29wXG4gICAgfSBlbHNlIGlmIChwcm9wS2V5ID09PSBBVVRPRk9DVVMpIHtcbiAgICAgIC8vIE5vb3AuIEl0IGRvZXNuJ3Qgd29yayBvbiB1cGRhdGVzIGFueXdheS5cbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlLiBJZiBhbnkgbGlzdGVuZXIgdXBkYXRlcyB3ZSBuZWVkIHRvIGVuc3VyZVxuICAgICAgLy8gdGhhdCB0aGUgXCJjdXJyZW50XCIgZmliZXIgcG9pbnRlciBnZXRzIHVwZGF0ZWQgc28gd2UgbmVlZCBhIGNvbW1pdFxuICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICB1cGRhdGVQYXlsb2FkID0gW107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEZvciBhbGwgb3RoZXIgZGVsZXRlZCBwcm9wZXJ0aWVzIHdlIGFkZCBpdCB0byB0aGUgcXVldWUuIFdlIHVzZVxuICAgICAgLy8gdGhlIHdoaXRlbGlzdCBpbiB0aGUgY29tbWl0IHBoYXNlIGluc3RlYWQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbnVsbCk7XG4gICAgfVxuICB9XG4gIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICB2YXIgbmV4dFByb3AgPSBuZXh0UHJvcHNbcHJvcEtleV07XG4gICAgdmFyIGxhc3RQcm9wID0gbGFzdFByb3BzICE9IG51bGwgPyBsYXN0UHJvcHNbcHJvcEtleV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCFuZXh0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkgfHwgbmV4dFByb3AgPT09IGxhc3RQcm9wIHx8IG5leHRQcm9wID09IG51bGwgJiYgbGFzdFByb3AgPT0gbnVsbCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAge1xuICAgICAgICBpZiAobmV4dFByb3ApIHtcbiAgICAgICAgICAvLyBGcmVlemUgdGhlIG5leHQgc3R5bGUgb2JqZWN0IHNvIHRoYXQgd2UgY2FuIGFzc3VtZSBpdCB3b24ndCBiZVxuICAgICAgICAgIC8vIG11dGF0ZWQuIFdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgZm9yIHRoaXMgaW4gdGhlIHBhc3QuXG4gICAgICAgICAgT2JqZWN0LmZyZWV6ZShuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsYXN0UHJvcCkge1xuICAgICAgICAvLyBVbnNldCBzdHlsZXMgb24gYGxhc3RQcm9wYCBidXQgbm90IG9uIGBuZXh0UHJvcGAuXG4gICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgaWYgKGxhc3RQcm9wLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkgJiYgKCFuZXh0UHJvcCB8fCAhbmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkpIHtcbiAgICAgICAgICAgIGlmICghc3R5bGVVcGRhdGVzKSB7XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3R5bGVVcGRhdGVzW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXBkYXRlIHN0eWxlcyB0aGF0IGNoYW5nZWQgc2luY2UgYGxhc3RQcm9wYC5cbiAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAobmV4dFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiBsYXN0UHJvcFtzdHlsZU5hbWVdICE9PSBuZXh0UHJvcFtzdHlsZU5hbWVdKSB7XG4gICAgICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gbmV4dFByb3Bbc3R5bGVOYW1lXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICBpZiAoIXN0eWxlVXBkYXRlcykge1xuICAgICAgICAgIGlmICghdXBkYXRlUGF5bG9hZCkge1xuICAgICAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkLnB1c2gocHJvcEtleSwgc3R5bGVVcGRhdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZVVwZGF0ZXMgPSBuZXh0UHJvcDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcCA/IG5leHRQcm9wW0hUTUxdIDogdW5kZWZpbmVkO1xuICAgICAgdmFyIGxhc3RIdG1sID0gbGFzdFByb3AgPyBsYXN0UHJvcFtIVE1MXSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICAgIGlmIChsYXN0SHRtbCAhPT0gbmV4dEh0bWwpIHtcbiAgICAgICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgJycgKyBuZXh0SHRtbCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRPRE86IEl0IG1pZ2h0IGJlIHRvbyBsYXRlIHRvIGNsZWFyIHRoaXMgaWYgd2UgaGF2ZSBjaGlsZHJlblxuICAgICAgICAvLyBpbnNlcnRlZCBhbHJlYWR5LlxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gQ0hJTERSRU4pIHtcbiAgICAgIGlmIChsYXN0UHJvcCAhPT0gbmV4dFByb3AgJiYgKHR5cGVvZiBuZXh0UHJvcCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykpIHtcbiAgICAgICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKHByb3BLZXksICcnICsgbmV4dFByb3ApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvcEtleSA9PT0gU1VQUFJFU1NfQ09OVEVOVF9FRElUQUJMRV9XQVJOSU5HIHx8IHByb3BLZXkgPT09IFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDEpIHtcbiAgICAgIC8vIE5vb3BcbiAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAvLyBXZSBlYWdlcmx5IGxpc3RlbiB0byB0aGlzIGV2ZW4gdGhvdWdoIHdlIGhhdmVuJ3QgY29tbWl0dGVkIHlldC5cbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgICBpZiAoIXVwZGF0ZVBheWxvYWQgJiYgbGFzdFByb3AgIT09IG5leHRQcm9wKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UuIElmIGFueSBsaXN0ZW5lciB1cGRhdGVzIHdlIG5lZWQgdG8gZW5zdXJlXG4gICAgICAgIC8vIHRoYXQgdGhlIFwiY3VycmVudFwiIHByb3BzIHBvaW50ZXIgZ2V0cyB1cGRhdGVkIHNvIHdlIG5lZWQgYSBjb21taXRcbiAgICAgICAgLy8gdG8gdXBkYXRlIHRoaXMgZWxlbWVudC5cbiAgICAgICAgdXBkYXRlUGF5bG9hZCA9IFtdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBGb3IgYW55IG90aGVyIHByb3BlcnR5IHdlIGFsd2F5cyBhZGQgaXQgdG8gdGhlIHF1ZXVlIGFuZCB0aGVuIHdlXG4gICAgICAvLyBmaWx0ZXIgaXQgb3V0IHVzaW5nIHRoZSB3aGl0ZWxpc3QgZHVyaW5nIHRoZSBjb21taXQuXG4gICAgICAodXBkYXRlUGF5bG9hZCA9IHVwZGF0ZVBheWxvYWQgfHwgW10pLnB1c2gocHJvcEtleSwgbmV4dFByb3ApO1xuICAgIH1cbiAgfVxuICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgKHVwZGF0ZVBheWxvYWQgPSB1cGRhdGVQYXlsb2FkIHx8IFtdKS5wdXNoKFNUWUxFLCBzdHlsZVVwZGF0ZXMpO1xuICB9XG4gIHJldHVybiB1cGRhdGVQYXlsb2FkO1xufVxuXG4vLyBBcHBseSB0aGUgZGlmZi5cbmZ1bmN0aW9uIHVwZGF0ZVByb3BlcnRpZXMkMShkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0YWcsIGxhc3RSYXdQcm9wcywgbmV4dFJhd1Byb3BzKSB7XG4gIHZhciB3YXNDdXN0b21Db21wb25lbnRUYWcgPSBpc0N1c3RvbUNvbXBvbmVudCh0YWcsIGxhc3RSYXdQcm9wcyk7XG4gIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgbmV4dFJhd1Byb3BzKTtcbiAgLy8gQXBwbHkgdGhlIGRpZmYuXG4gIHVwZGF0ZURPTVByb3BlcnRpZXMoZG9tRWxlbWVudCwgdXBkYXRlUGF5bG9hZCwgd2FzQ3VzdG9tQ29tcG9uZW50VGFnLCBpc0N1c3RvbUNvbXBvbmVudFRhZyk7XG5cbiAgLy8gVE9ETzogRW5zdXJlIHRoYXQgYW4gdXBkYXRlIGdldHMgc2NoZWR1bGVkIGlmIGFueSBvZiB0aGUgc3BlY2lhbCBwcm9wc1xuICAvLyBjaGFuZ2VkLlxuICBzd2l0Y2ggKHRhZykge1xuICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgIC8vIFVwZGF0ZSB0aGUgd3JhcHBlciBhcm91bmQgaW5wdXRzICphZnRlciogdXBkYXRpbmcgcHJvcHMuIFRoaXMgaGFzIHRvXG4gICAgICAvLyBoYXBwZW4gYWZ0ZXIgYHVwZGF0ZURPTVByb3BlcnRpZXNgLiBPdGhlcndpc2UgSFRNTDUgaW5wdXQgdmFsaWRhdGlvbnNcbiAgICAgIC8vIHJhaXNlIHdhcm5pbmdzIGFuZCBwcmV2ZW50IHRoZSBuZXcgdmFsdWUgZnJvbSBiZWluZyBhc3NpZ25lZC5cbiAgICAgIHVwZGF0ZVdyYXBwZXIoZG9tRWxlbWVudCwgbmV4dFJhd1Byb3BzKTtcblxuICAgICAgLy8gV2UgYWxzbyBjaGVjayB0aGF0IHdlIGhhdmVuJ3QgbWlzc2VkIGEgdmFsdWUgdXBkYXRlLCBzdWNoIGFzIGFcbiAgICAgIC8vIFJhZGlvIGdyb3VwIHNoaWZ0aW5nIHRoZSBjaGVja2VkIHZhbHVlIHRvIGFub3RoZXIgbmFtZWQgcmFkaW8gaW5wdXQuXG4gICAgICB1cGRhdGVWYWx1ZUlmQ2hhbmdlZChkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHVwZGF0ZVdyYXBwZXIkMShkb21FbGVtZW50LCBuZXh0UmF3UHJvcHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIC8vIDxzZWxlY3Q+IHZhbHVlIHVwZGF0ZSBuZWVkcyB0byBvY2N1ciBhZnRlciA8b3B0aW9uPiBjaGlsZHJlblxuICAgICAgLy8gcmVjb25jaWxpYXRpb25cbiAgICAgIHBvc3RVcGRhdGVXcmFwcGVyKGRvbUVsZW1lbnQsIG5leHRSYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgfVxufVxuXG5mdW5jdGlvbiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDEoZG9tRWxlbWVudCwgdGFnLCByYXdQcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVyRWxlbWVudCkge1xuICB7XG4gICAgdmFyIHN1cHByZXNzSHlkcmF0aW9uV2FybmluZyA9IHJhd1Byb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HJDFdID09PSB0cnVlO1xuICAgIHZhciBpc0N1c3RvbUNvbXBvbmVudFRhZyA9IGlzQ3VzdG9tQ29tcG9uZW50KHRhZywgcmF3UHJvcHMpO1xuICAgIHZhbGlkYXRlUHJvcGVydGllc0luRGV2ZWxvcG1lbnQodGFnLCByYXdQcm9wcyk7XG4gICAgaWYgKGlzQ3VzdG9tQ29tcG9uZW50VGFnICYmICFkaWRXYXJuU2hhZHlET00gJiYgZG9tRWxlbWVudC5zaGFkeVJvb3QpIHtcbiAgICAgIHdhcm5pbmcoZmFsc2UsICclcyBpcyB1c2luZyBzaGFkeSBET00uIFVzaW5nIHNoYWR5IERPTSB3aXRoIFJlYWN0IGNhbiAnICsgJ2NhdXNlIHRoaW5ncyB0byBicmVhayBzdWJ0bHkuJywgZ2V0Q3VycmVudEZpYmVyT3duZXJOYW1lJDEoKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIGRpZFdhcm5TaGFkeURPTSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLy8gVE9ETzogTWFrZSBzdXJlIHRoYXQgd2UgY2hlY2sgaXNNb3VudGVkIGJlZm9yZSBmaXJpbmcgYW55IG9mIHRoZXNlIGV2ZW50cy5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpZnJhbWUnOlxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BMb2FkJywgJ2xvYWQnLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICAvLyBDcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICB0cmFwQnViYmxlZEV2ZW50KGV2ZW50LCBtZWRpYUV2ZW50c1tldmVudF0sIGRvbUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzb3VyY2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgY2FzZSAnaW1hZ2UnOlxuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wRXJyb3InLCAnZXJyb3InLCBkb21FbGVtZW50KTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcExvYWQnLCAnbG9hZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BSZXNldCcsICdyZXNldCcsIGRvbUVsZW1lbnQpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wU3VibWl0JywgJ3N1Ym1pdCcsIGRvbUVsZW1lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZGV0YWlscyc6XG4gICAgICB0cmFwQnViYmxlZEV2ZW50KCd0b3BUb2dnbGUnLCAndG9nZ2xlJywgZG9tRWxlbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICB2YWxpZGF0ZVByb3BzKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbml0V3JhcHBlclN0YXRlJDEoZG9tRWxlbWVudCwgcmF3UHJvcHMpO1xuICAgICAgdHJhcEJ1YmJsZWRFdmVudCgndG9wSW52YWxpZCcsICdpbnZhbGlkJywgZG9tRWxlbWVudCk7XG4gICAgICAvLyBGb3IgY29udHJvbGxlZCBjb21wb25lbnRzIHdlIGFsd2F5cyBuZWVkIHRvIGVuc3VyZSB3ZSdyZSBsaXN0ZW5pbmdcbiAgICAgIC8vIHRvIG9uQ2hhbmdlLiBFdmVuIGlmIHRoZXJlIGlzIG5vIGxpc3RlbmVyLlxuICAgICAgZW5zdXJlTGlzdGVuaW5nVG8ocm9vdENvbnRhaW5lckVsZW1lbnQsICdvbkNoYW5nZScpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgaW5pdFdyYXBwZXJTdGF0ZSQyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIHRyYXBCdWJibGVkRXZlbnQoJ3RvcEludmFsaWQnLCAnaW52YWxpZCcsIGRvbUVsZW1lbnQpO1xuICAgICAgLy8gRm9yIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3ZSBhbHdheXMgbmVlZCB0byBlbnN1cmUgd2UncmUgbGlzdGVuaW5nXG4gICAgICAvLyB0byBvbkNoYW5nZS4gRXZlbiBpZiB0aGVyZSBpcyBubyBsaXN0ZW5lci5cbiAgICAgIGVuc3VyZUxpc3RlbmluZ1RvKHJvb3RDb250YWluZXJFbGVtZW50LCAnb25DaGFuZ2UnKTtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgYXNzZXJ0VmFsaWRQcm9wcyh0YWcsIHJhd1Byb3BzLCBnZXRTdGFjayk7XG5cbiAge1xuICAgIHZhciBleHRyYUF0dHJpYnV0ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgIHZhciBhdHRyaWJ1dGVzID0gZG9tRWxlbWVudC5hdHRyaWJ1dGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5hbWUgPSBhdHRyaWJ1dGVzW2ldLm5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAvLyBCdWlsdC1pbiBTU1IgYXR0cmlidXRlIGlzIHdoaXRlbGlzdGVkXG4gICAgICAgIGNhc2UgJ2RhdGEtcmVhY3Ryb290JzpcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gQ29udHJvbGxlZCBhdHRyaWJ1dGVzIGFyZSBub3QgdmFsaWRhdGVkXG4gICAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgICBjYXNlICd2YWx1ZSc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NoZWNrZWQnOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWxlY3RlZCc6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2UgdGhlIG9yaWdpbmFsIG5hbWUuXG4gICAgICAgICAgLy8gU2VlIGRpc2N1c3Npb24gaW4gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTA2NzYuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lcy5hZGQoYXR0cmlidXRlc1tpXS5uYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlUGF5bG9hZCA9IG51bGw7XG4gIGZvciAodmFyIHByb3BLZXkgaW4gcmF3UHJvcHMpIHtcbiAgICBpZiAoIXJhd1Byb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIG5leHRQcm9wID0gcmF3UHJvcHNbcHJvcEtleV07XG4gICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAvLyBGb3IgdGV4dCBjb250ZW50IGNoaWxkcmVuIHdlIGNvbXBhcmUgYWdhaW5zdCB0ZXh0Q29udGVudC4gVGhpc1xuICAgICAgLy8gbWlnaHQgbWF0Y2ggYWRkaXRpb25hbCBIVE1MIHRoYXQgaXMgaGlkZGVuIHdoZW4gd2UgcmVhZCBpdCB1c2luZ1xuICAgICAgLy8gdGV4dENvbnRlbnQuIEUuZy4gXCJmb29cIiB3aWxsIG1hdGNoIFwiZjxzcGFuPm9vPC9zcGFuPlwiIGJ1dCB0aGF0IHN0aWxsXG4gICAgICAvLyBzYXRpc2ZpZXMgb3VyIHJlcXVpcmVtZW50LiBPdXIgcmVxdWlyZW1lbnQgaXMgbm90IHRvIHByb2R1Y2UgcGVyZmVjdFxuICAgICAgLy8gSFRNTCBhbmQgYXR0cmlidXRlcy4gSWRlYWxseSB3ZSBzaG91bGQgcHJlc2VydmUgc3RydWN0dXJlIGJ1dCBpdCdzXG4gICAgICAvLyBvayBub3QgdG8gaWYgdGhlIHZpc2libGUgY29udGVudCBpcyBzdGlsbCBlbm91Z2ggdG8gaW5kaWNhdGUgd2hhdFxuICAgICAgLy8gZXZlbiBsaXN0ZW5lcnMgdGhlc2Ugbm9kZXMgbWlnaHQgYmUgd2lyZWQgdXAgdG8uXG4gICAgICAvLyBUT0RPOiBXYXJuIGlmIHRoZXJlIGlzIG1vcmUgdGhhbiBhIHNpbmdsZSB0ZXh0Tm9kZSBhcyBhIGNoaWxkLlxuICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIHVzZSBkb21FbGVtZW50LmZpcnN0Q2hpbGQubm9kZVZhbHVlIHRvIGNvbXBhcmU/XG4gICAgICBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gbmV4dFByb3ApIHtcbiAgICAgICAgICBpZiAodHJ1ZSAmJiAhc3VwcHJlc3NIeWRyYXRpb25XYXJuaW5nKSB7XG4gICAgICAgICAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UoZG9tRWxlbWVudC50ZXh0Q29udGVudCwgbmV4dFByb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVQYXlsb2FkID0gW0NISUxEUkVOLCBuZXh0UHJvcF07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5leHRQcm9wID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoZG9tRWxlbWVudC50ZXh0Q29udGVudCAhPT0gJycgKyBuZXh0UHJvcCkge1xuICAgICAgICAgIGlmICh0cnVlICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgICAgICAgIHdhcm5Gb3JUZXh0RGlmZmVyZW5jZShkb21FbGVtZW50LnRleHRDb250ZW50LCBuZXh0UHJvcCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZVBheWxvYWQgPSBbQ0hJTERSRU4sICcnICsgbmV4dFByb3BdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSkge1xuICAgICAgaWYgKG5leHRQcm9wICE9IG51bGwpIHtcbiAgICAgICAgaWYgKHRydWUgJiYgdHlwZW9mIG5leHRQcm9wICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgd2FybkZvckludmFsaWRFdmVudExpc3RlbmVyKHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgICBlbnN1cmVMaXN0ZW5pbmdUbyhyb290Q29udGFpbmVyRWxlbWVudCwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFZhbGlkYXRlIHRoYXQgdGhlIHByb3BlcnRpZXMgY29ycmVzcG9uZCB0byB0aGVpciBleHBlY3RlZCB2YWx1ZXMuXG4gICAgICB2YXIgc2VydmVyVmFsdWU7XG4gICAgICB2YXIgcHJvcGVydHlJbmZvO1xuICAgICAgaWYgKHN1cHByZXNzSHlkcmF0aW9uV2FybmluZykge1xuICAgICAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nLiBXZSdyZSBpZ25vcmluZyBhbGwgdGhlc2Ugd2FybmluZ3MuXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNVUFBSRVNTX0NPTlRFTlRfRURJVEFCTEVfV0FSTklORyB8fCBwcm9wS2V5ID09PSBTVVBQUkVTU19IWURSQVRJT05fV0FSTklORyQxIHx8XG4gICAgICAvLyBDb250cm9sbGVkIGF0dHJpYnV0ZXMgYXJlIG5vdCB2YWxpZGF0ZWRcbiAgICAgIC8vIFRPRE86IE9ubHkgaWdub3JlIHRoZW0gb24gY29udHJvbGxlZCB0YWdzLlxuICAgICAgcHJvcEtleSA9PT0gJ3ZhbHVlJyB8fCBwcm9wS2V5ID09PSAnY2hlY2tlZCcgfHwgcHJvcEtleSA9PT0gJ3NlbGVjdGVkJykge1xuICAgICAgICAvLyBOb29wXG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IERBTkdFUk9VU0xZX1NFVF9JTk5FUl9IVE1MKSB7XG4gICAgICAgIHZhciByYXdIdG1sID0gbmV4dFByb3AgPyBuZXh0UHJvcFtIVE1MXSB8fCAnJyA6ICcnO1xuICAgICAgICB2YXIgc2VydmVySFRNTCA9IGRvbUVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICB2YXIgZXhwZWN0ZWRIVE1MID0gbm9ybWFsaXplSFRNTChkb21FbGVtZW50LCByYXdIdG1sKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkSFRNTCAhPT0gc2VydmVySFRNTCkge1xuICAgICAgICAgIHdhcm5Gb3JQcm9wRGlmZmVyZW5jZShwcm9wS2V5LCBzZXJ2ZXJIVE1MLCBleHBlY3RlZEhUTUwpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHByb3BLZXkgPT09IFNUWUxFKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcEtleSk7XG4gICAgICAgIHZhciBleHBlY3RlZFN0eWxlID0gY3JlYXRlRGFuZ2Vyb3VzU3RyaW5nRm9yU3R5bGVzKG5leHRQcm9wKTtcbiAgICAgICAgc2VydmVyVmFsdWUgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICAgICAgaWYgKGV4cGVjdGVkU3R5bGUgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBleHBlY3RlZFN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChpc0N1c3RvbUNvbXBvbmVudFRhZykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgIGV4dHJhQXR0cmlidXRlTmFtZXNbJ2RlbGV0ZSddKHByb3BLZXkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JBdHRyaWJ1dGUoZG9tRWxlbWVudCwgcHJvcEtleSwgbmV4dFByb3ApO1xuXG4gICAgICAgIGlmIChuZXh0UHJvcCAhPT0gc2VydmVyVmFsdWUpIHtcbiAgICAgICAgICB3YXJuRm9yUHJvcERpZmZlcmVuY2UocHJvcEtleSwgc2VydmVyVmFsdWUsIG5leHRQcm9wKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzaG91bGRTZXRBdHRyaWJ1dGUocHJvcEtleSwgbmV4dFByb3ApKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eUluZm8gPSBnZXRQcm9wZXJ0eUluZm8ocHJvcEtleSkpIHtcbiAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgZXh0cmFBdHRyaWJ1dGVOYW1lc1snZGVsZXRlJ10ocHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICAgIHNlcnZlclZhbHVlID0gZ2V0VmFsdWVGb3JQcm9wZXJ0eShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG93bk5hbWVzcGFjZSA9IHBhcmVudE5hbWVzcGFjZTtcbiAgICAgICAgICBpZiAob3duTmFtZXNwYWNlID09PSBIVE1MX05BTUVTUEFDRSkge1xuICAgICAgICAgICAgb3duTmFtZXNwYWNlID0gZ2V0SW50cmluc2ljTmFtZXNwYWNlKHRhZyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvd25OYW1lc3BhY2UgPT09IEhUTUxfTkFNRVNQQUNFKSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyAkRmxvd0ZpeE1lIC0gU2hvdWxkIGJlIGluZmVycmVkIGFzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBleHRyYUF0dHJpYnV0ZU5hbWVzWydkZWxldGUnXShwcm9wS2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VydmVyVmFsdWUgPSBnZXRWYWx1ZUZvckF0dHJpYnV0ZShkb21FbGVtZW50LCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV4dFByb3AgIT09IHNlcnZlclZhbHVlKSB7XG4gICAgICAgICAgd2FybkZvclByb3BEaWZmZXJlbmNlKHByb3BLZXksIHNlcnZlclZhbHVlLCBuZXh0UHJvcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB7XG4gICAgLy8gJEZsb3dGaXhNZSAtIFNob3VsZCBiZSBpbmZlcnJlZCBhcyBub3QgdW5kZWZpbmVkLlxuICAgIGlmIChleHRyYUF0dHJpYnV0ZU5hbWVzLnNpemUgPiAwICYmICFzdXBwcmVzc0h5ZHJhdGlvbldhcm5pbmcpIHtcbiAgICAgIC8vICRGbG93Rml4TWUgLSBTaG91bGQgYmUgaW5mZXJyZWQgYXMgbm90IHVuZGVmaW5lZC5cbiAgICAgIHdhcm5Gb3JFeHRyYUF0dHJpYnV0ZXMoZXh0cmFBdHRyaWJ1dGVOYW1lcyk7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICAvLyBUT0RPOiBNYWtlIHN1cmUgd2UgY2hlY2sgaWYgdGhpcyBpcyBzdGlsbCB1bm1vdW50ZWQgb3IgZG8gYW55IGNsZWFuXG4gICAgICAvLyB1cCBuZWNlc3Nhcnkgc2luY2Ugd2UgbmV2ZXIgc3RvcCB0cmFja2luZyBhbnltb3JlLlxuICAgICAgdHJhY2soZG9tRWxlbWVudCk7XG4gICAgICBwb3N0TW91bnRXcmFwcGVyKGRvbUVsZW1lbnQsIHJhd1Byb3BzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB3ZSBjaGVjayBpZiB0aGlzIGlzIHN0aWxsIHVubW91bnRlZCBvciBkbyBhbnkgY2xlYW5cbiAgICAgIC8vIHVwIG5lY2Vzc2FyeSBzaW5jZSB3ZSBuZXZlciBzdG9wIHRyYWNraW5nIGFueW1vcmUuXG4gICAgICB0cmFjayhkb21FbGVtZW50KTtcbiAgICAgIHBvc3RNb3VudFdyYXBwZXIkMyhkb21FbGVtZW50LCByYXdQcm9wcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdzZWxlY3QnOlxuICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAvLyBGb3IgaW5wdXQgYW5kIHRleHRhcmVhIHdlIGN1cnJlbnQgYWx3YXlzIHNldCB0aGUgdmFsdWUgcHJvcGVydHkgYXRcbiAgICAgIC8vIHBvc3QgbW91bnQgdG8gZm9yY2UgaXQgdG8gZGl2ZXJnZSBmcm9tIGF0dHJpYnV0ZXMuIEhvd2V2ZXIsIGZvclxuICAgICAgLy8gb3B0aW9uIGFuZCBzZWxlY3Qgd2UgZG9uJ3QgcXVpdGUgZG8gdGhlIHNhbWUgdGhpbmcgYW5kIHNlbGVjdFxuICAgICAgLy8gaXMgbm90IHJlc2lsaWVudCB0byB0aGUgRE9NIHN0YXRlIGNoYW5naW5nIHNvIHdlIGRvbid0IGRvIHRoYXQgaGVyZS5cbiAgICAgIC8vIFRPRE86IENvbnNpZGVyIG5vdCBkb2luZyB0aGlzIGZvciBpbnB1dCBhbmQgdGV4dGFyZWEuXG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgaWYgKHR5cGVvZiByYXdQcm9wcy5vbkNsaWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFRPRE86IFRoaXMgY2FzdCBtYXkgbm90IGJlIHNvdW5kIGZvciBTVkcsIE1hdGhNTCBvciBjdXN0b20gZWxlbWVudHMuXG4gICAgICAgIHRyYXBDbGlja09uTm9uSW50ZXJhY3RpdmVFbGVtZW50KGRvbUVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cblxuICByZXR1cm4gdXBkYXRlUGF5bG9hZDtcbn1cblxuZnVuY3Rpb24gZGlmZkh5ZHJhdGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHZhciBpc0RpZmZlcmVudCA9IHRleHROb2RlLm5vZGVWYWx1ZSAhPT0gdGV4dDtcbiAgcmV0dXJuIGlzRGlmZmVyZW50O1xufVxuXG5mdW5jdGlvbiB3YXJuRm9yVW5tYXRjaGVkVGV4dCQxKHRleHROb2RlLCB0ZXh0KSB7XG4gIHtcbiAgICB3YXJuRm9yVGV4dERpZmZlcmVuY2UodGV4dE5vZGUubm9kZVZhbHVlLCB0ZXh0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVFbGVtZW50JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gYSA8JXM+IGluIDwlcz4uJywgY2hpbGQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEocGFyZW50Tm9kZSwgY2hpbGQpIHtcbiAge1xuICAgIGlmIChkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkaWRXYXJuSW52YWxpZEh5ZHJhdGlvbiA9IHRydWU7XG4gICAgd2FybmluZyhmYWxzZSwgJ0RpZCBub3QgZXhwZWN0IHNlcnZlciBIVE1MIHRvIGNvbnRhaW4gdGhlIHRleHQgbm9kZSBcIiVzXCIgaW4gPCVzPi4nLCBjaGlsZC5ub2RlVmFsdWUsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEocGFyZW50Tm9kZSwgdGFnLCBwcm9wcykge1xuICB7XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIDwlcz4gaW4gPCVzPi4nLCB0YWcsIHBhcmVudE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEocGFyZW50Tm9kZSwgdGV4dCkge1xuICB7XG4gICAgaWYgKHRleHQgPT09ICcnKSB7XG4gICAgICAvLyBXZSBleHBlY3QgdG8gaW5zZXJ0IGVtcHR5IHRleHQgbm9kZXMgc2luY2UgdGhleSdyZSBub3QgcmVwcmVzZW50ZWQgaW5cbiAgICAgIC8vIHRoZSBIVE1MLlxuICAgICAgLy8gVE9ETzogUmVtb3ZlIHRoaXMgc3BlY2lhbCBjYXNlIGlmIHdlIGNhbiBqdXN0IGF2b2lkIGluc2VydGluZyBlbXB0eVxuICAgICAgLy8gdGV4dCBub2Rlcy5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRpZFdhcm5JbnZhbGlkSHlkcmF0aW9uID0gdHJ1ZTtcbiAgICB3YXJuaW5nKGZhbHNlLCAnRXhwZWN0ZWQgc2VydmVyIEhUTUwgdG8gY29udGFpbiBhIG1hdGNoaW5nIHRleHQgbm9kZSBmb3IgXCIlc1wiIGluIDwlcz4uJywgdGV4dCwgcGFyZW50Tm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlQ29udHJvbGxlZFN0YXRlKGRvbUVsZW1lbnQsIHRhZywgcHJvcHMpIHtcbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlICdpbnB1dCc6XG4gICAgICByZXN0b3JlQ29udHJvbGxlZFN0YXRlJDEoZG9tRWxlbWVudCwgcHJvcHMpO1xuICAgICAgcmV0dXJuO1xuICAgIGNhc2UgJ3RleHRhcmVhJzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMyhkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgIHJlc3RvcmVDb250cm9sbGVkU3RhdGUkMihkb21FbGVtZW50LCBwcm9wcyk7XG4gICAgICByZXR1cm47XG4gIH1cbn1cblxudmFyIFJlYWN0RE9NRmliZXJDb21wb25lbnQgPSBPYmplY3QuZnJlZXplKHtcblx0Y3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudCQxLFxuXHRjcmVhdGVUZXh0Tm9kZTogY3JlYXRlVGV4dE5vZGUkMSxcblx0c2V0SW5pdGlhbFByb3BlcnRpZXM6IHNldEluaXRpYWxQcm9wZXJ0aWVzJDEsXG5cdGRpZmZQcm9wZXJ0aWVzOiBkaWZmUHJvcGVydGllcyQxLFxuXHR1cGRhdGVQcm9wZXJ0aWVzOiB1cGRhdGVQcm9wZXJ0aWVzJDEsXG5cdGRpZmZIeWRyYXRlZFByb3BlcnRpZXM6IGRpZmZIeWRyYXRlZFByb3BlcnRpZXMkMSxcblx0ZGlmZkh5ZHJhdGVkVGV4dDogZGlmZkh5ZHJhdGVkVGV4dCQxLFxuXHR3YXJuRm9yVW5tYXRjaGVkVGV4dDogd2FybkZvclVubWF0Y2hlZFRleHQkMSxcblx0d2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudDogd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCQxLFxuXHR3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0OiB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRFbGVtZW50JDEsXG5cdHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dDogd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0JDEsXG5cdHJlc3RvcmVDb250cm9sbGVkU3RhdGU6IHJlc3RvcmVDb250cm9sbGVkU3RhdGVcbn0pO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgZ2V0Q3VycmVudEZpYmVyU3RhY2tBZGRlbmR1bSQ2ID0gUmVhY3REZWJ1Z0N1cnJlbnRGaWJlci5nZXRDdXJyZW50RmliZXJTdGFja0FkZGVuZHVtO1xuXG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gZW1wdHlGdW5jdGlvbiQxO1xuXG57XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgY3VycmVudDogbnVsbCxcblxuICAgIGZvcm1UYWc6IG51bGwsXG4gICAgYVRhZ0luU2NvcGU6IG51bGwsXG4gICAgYnV0dG9uVGFnSW5TY29wZTogbnVsbCxcbiAgICBub2JyVGFnSW5TY29wZTogbnVsbCxcbiAgICBwVGFnSW5CdXR0b25TY29wZTogbnVsbCxcblxuICAgIGxpc3RJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGwsXG4gICAgZGxJdGVtVGFnQXV0b2Nsb3Npbmc6IG51bGxcbiAgfTtcblxuICB2YXIgdXBkYXRlZEFuY2VzdG9ySW5mbyQxID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gX2Fzc2lnbih7fSwgb2xkSW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIGluZm8gPSB7IHRhZzogdGFnLCBpbnN0YW5jZTogaW5zdGFuY2UgfTtcblxuICAgIGlmIChpblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGUgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGJ1dHRvblNjb3BlVGFncy5pbmRleE9mKHRhZykgIT09IC0xKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlZSBydWxlcyBmb3IgJ2xpJywgJ2RkJywgJ2R0JyBzdGFydCB0YWdzIGluXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIGlmIChzcGVjaWFsVGFncy5pbmRleE9mKHRhZykgIT09IC0xICYmIHRhZyAhPT0gJ2FkZHJlc3MnICYmIHRhZyAhPT0gJ2RpdicgJiYgdGFnICE9PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IG51bGw7XG4gICAgfVxuXG4gICAgYW5jZXN0b3JJbmZvLmN1cnJlbnQgPSBpbmZvO1xuXG4gICAgaWYgKHRhZyA9PT0gJ2Zvcm0nKSB7XG4gICAgICBhbmNlc3RvckluZm8uZm9ybVRhZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdhJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2J1dHRvbicpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5idXR0b25UYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ25vYnInKSB7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAncCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdsaScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ2RkJyB8fCB0YWcgPT09ICdkdCcpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5kbEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuY2VzdG9ySW5mbztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyXG4gICAqL1xuICB2YXIgaXNUYWdWYWxpZFdpdGhQYXJlbnQgPSBmdW5jdGlvbiAodGFnLCBwYXJlbnRUYWcpIHtcbiAgICAvLyBGaXJzdCwgbGV0J3MgY2hlY2sgaWYgd2UncmUgaW4gYW4gdW51c3VhbCBwYXJzaW5nIG1vZGUuLi5cbiAgICBzd2l0Y2ggKHBhcmVudFRhZykge1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluc2VsZWN0XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICdvcHRncm91cCcgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgY2FzZSAnb3B0Z3JvdXAnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnb3B0aW9uJyB8fCB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBTdHJpY3RseSBzcGVha2luZywgc2VlaW5nIGFuIDxvcHRpb24+IGRvZXNuJ3QgbWVhbiB3ZSdyZSBpbiBhIDxzZWxlY3Q+XG4gICAgICAvLyBidXRcbiAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICcjdGV4dCc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRib2R5XG4gICAgICBjYXNlICd0Ym9keSc6XG4gICAgICBjYXNlICd0aGVhZCc6XG4gICAgICBjYXNlICd0Zm9vdCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0cicgfHwgdGFnID09PSAnc3R5bGUnIHx8IHRhZyA9PT0gJ3NjcmlwdCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY29sZ3JvdXBcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NvbCcgfHwgdGFnID09PSAndGVtcGxhdGUnO1xuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5oZWFkXG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2Jhc2UnIHx8IHRhZyA9PT0gJ2Jhc2Vmb250JyB8fCB0YWcgPT09ICdiZ3NvdW5kJyB8fCB0YWcgPT09ICdsaW5rJyB8fCB0YWcgPT09ICdtZXRhJyB8fCB0YWcgPT09ICd0aXRsZScgfHwgdGFnID09PSAnbm9zY3JpcHQnIHx8IHRhZyA9PT0gJ25vZnJhbWVzJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zZW1hbnRpY3MuaHRtbCN0aGUtaHRtbC1lbGVtZW50XG4gICAgICBjYXNlICdodG1sJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2hlYWQnIHx8IHRhZyA9PT0gJ2JvZHknO1xuICAgICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2h0bWwnO1xuICAgIH1cblxuICAgIC8vIFByb2JhYmx5IGluIHRoZSBcImluIGJvZHlcIiBwYXJzaW5nIG1vZGUsIHNvIHdlIG91dGxhdyBvbmx5IHRhZyBjb21ib3NcbiAgICAvLyB3aGVyZSB0aGUgcGFyc2luZyBydWxlcyBjYXVzZSBpbXBsaWNpdCBvcGVucyBvciBjbG9zZXMgdG8gYmUgYWRkZWQuXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keVxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBwYXJlbnRUYWcgIT09ICdoMScgJiYgcGFyZW50VGFnICE9PSAnaDInICYmIHBhcmVudFRhZyAhPT0gJ2gzJyAmJiBwYXJlbnRUYWcgIT09ICdoNCcgJiYgcGFyZW50VGFnICE9PSAnaDUnICYmIHBhcmVudFRhZyAhPT0gJ2g2JztcblxuICAgICAgY2FzZSAncnAnOlxuICAgICAgY2FzZSAncnQnOlxuICAgICAgICByZXR1cm4gaW1wbGllZEVuZFRhZ3MuaW5kZXhPZihwYXJlbnRUYWcpID09PSAtMTtcblxuICAgICAgY2FzZSAnYm9keSc6XG4gICAgICBjYXNlICdjYXB0aW9uJzpcbiAgICAgIGNhc2UgJ2NvbCc6XG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICBjYXNlICdmcmFtZSc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2h0bWwnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuICAgICAgY2FzZSAncHJlJzpcbiAgICAgIGNhc2UgJ2xpc3RpbmcnOlxuICAgICAgY2FzZSAndGFibGUnOlxuICAgICAgY2FzZSAnaHInOlxuICAgICAgY2FzZSAneG1wJzpcbiAgICAgIGNhc2UgJ2gxJzpcbiAgICAgIGNhc2UgJ2gyJzpcbiAgICAgIGNhc2UgJ2gzJzpcbiAgICAgIGNhc2UgJ2g0JzpcbiAgICAgIGNhc2UgJ2g1JzpcbiAgICAgIGNhc2UgJ2g2JzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZTtcblxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZm9ybVRhZyB8fCBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2xpJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5saXN0SXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdkZCc6XG4gICAgICBjYXNlICdkdCc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3Npbmc7XG5cbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZTtcblxuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIC8vIFNwZWMgc2F5cyBzb21ldGhpbmcgYWJvdXQgc3RvcmluZyBhIGxpc3Qgb2YgbWFya2VycywgYnV0IGl0IHNvdW5kc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIHRoaXMgY2hlY2suXG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8uYVRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ25vYnInOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZFRleHQsIGFuY2VzdG9ySW5mbykge1xuICAgIGFuY2VzdG9ySW5mbyA9IGFuY2VzdG9ySW5mbyB8fCBlbXB0eUFuY2VzdG9ySW5mbztcbiAgICB2YXIgcGFyZW50SW5mbyA9IGFuY2VzdG9ySW5mby5jdXJyZW50O1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgaWYgKGNoaWxkVGV4dCAhPSBudWxsKSB7XG4gICAgICB3YXJuaW5nKGNoaWxkVGFnID09IG51bGwsICd2YWxpZGF0ZURPTU5lc3Rpbmc6IHdoZW4gY2hpbGRUZXh0IGlzIHBhc3NlZCwgY2hpbGRUYWcgc2hvdWxkIGJlIG51bGwnKTtcbiAgICAgIGNoaWxkVGFnID0gJyN0ZXh0JztcbiAgICB9XG5cbiAgICB2YXIgaW52YWxpZFBhcmVudCA9IGlzVGFnVmFsaWRXaXRoUGFyZW50KGNoaWxkVGFnLCBwYXJlbnRUYWcpID8gbnVsbCA6IHBhcmVudEluZm87XG4gICAgdmFyIGludmFsaWRBbmNlc3RvciA9IGludmFsaWRQYXJlbnQgPyBudWxsIDogZmluZEludmFsaWRBbmNlc3RvckZvclRhZyhjaGlsZFRhZywgYW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW52YWxpZFBhcmVudE9yQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50IHx8IGludmFsaWRBbmNlc3RvcjtcbiAgICBpZiAoIWludmFsaWRQYXJlbnRPckFuY2VzdG9yKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGFuY2VzdG9yVGFnID0gaW52YWxpZFBhcmVudE9yQW5jZXN0b3IudGFnO1xuICAgIHZhciBhZGRlbmR1bSA9IGdldEN1cnJlbnRGaWJlclN0YWNrQWRkZW5kdW0kNigpO1xuXG4gICAgdmFyIHdhcm5LZXkgPSAhIWludmFsaWRQYXJlbnQgKyAnfCcgKyBjaGlsZFRhZyArICd8JyArIGFuY2VzdG9yVGFnICsgJ3wnICsgYWRkZW5kdW07XG4gICAgaWYgKGRpZFdhcm5bd2FybktleV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGlkV2Fyblt3YXJuS2V5XSA9IHRydWU7XG5cbiAgICB2YXIgdGFnRGlzcGxheU5hbWUgPSBjaGlsZFRhZztcbiAgICB2YXIgd2hpdGVzcGFjZUluZm8gPSAnJztcbiAgICBpZiAoY2hpbGRUYWcgPT09ICcjdGV4dCcpIHtcbiAgICAgIGlmICgvXFxTLy50ZXN0KGNoaWxkVGV4dCkpIHtcbiAgICAgICAgdGFnRGlzcGxheU5hbWUgPSAnVGV4dCBub2Rlcyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0YWdEaXNwbGF5TmFtZSA9ICdXaGl0ZXNwYWNlIHRleHQgbm9kZXMnO1xuICAgICAgICB3aGl0ZXNwYWNlSW5mbyA9IFwiIE1ha2Ugc3VyZSB5b3UgZG9uJ3QgaGF2ZSBhbnkgZXh0cmEgd2hpdGVzcGFjZSBiZXR3ZWVuIHRhZ3Mgb24gXCIgKyAnZWFjaCBsaW5lIG9mIHlvdXIgc291cmNlIGNvZGUuJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGFnRGlzcGxheU5hbWUgPSAnPCcgKyBjaGlsZFRhZyArICc+JztcbiAgICB9XG5cbiAgICBpZiAoaW52YWxpZFBhcmVudCkge1xuICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgIGlmIChhbmNlc3RvclRhZyA9PT0gJ3RhYmxlJyAmJiBjaGlsZFRhZyA9PT0gJ3RyJykge1xuICAgICAgICBpbmZvICs9ICcgQWRkIGEgPHRib2R5PiB0byB5b3VyIGNvZGUgdG8gbWF0Y2ggdGhlIERPTSB0cmVlIGdlbmVyYXRlZCBieSAnICsgJ3RoZSBicm93c2VyLic7XG4gICAgICB9XG4gICAgICB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6ICVzIGNhbm5vdCBhcHBlYXIgYXMgYSBjaGlsZCBvZiA8JXM+LiVzJXMlcycsIHRhZ0Rpc3BsYXlOYW1lLCBhbmNlc3RvclRhZywgd2hpdGVzcGFjZUluZm8sIGluZm8sIGFkZGVuZHVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd2FybmluZyhmYWxzZSwgJ3ZhbGlkYXRlRE9NTmVzdGluZyguLi4pOiAlcyBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uJXMnLCB0YWdEaXNwbGF5TmFtZSwgYW5jZXN0b3JUYWcsIGFkZGVuZHVtKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gVE9ETzogdHVybiB0aGlzIGludG8gYSBuYW1lZCBleHBvcnRcbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvJDE7XG5cbiAgLy8gRm9yIHRlc3RpbmdcbiAgdmFsaWRhdGVET01OZXN0aW5nLmlzVGFnVmFsaWRJbkNvbnRleHQgPSBmdW5jdGlvbiAodGFnLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8uY3VycmVudDtcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyQxID0gdmFsaWRhdGVET01OZXN0aW5nO1xuXG4vLyBUT0RPOiBkaXJlY3QgaW1wb3J0cyBsaWtlIHNvbWUtcGFja2FnZS9zcmMvKiBhcmUgYmFkLiBGaXggbWUuXG52YXIgY3JlYXRlRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQkMTtcbnZhciBjcmVhdGVUZXh0Tm9kZSA9IGNyZWF0ZVRleHROb2RlJDE7XG52YXIgc2V0SW5pdGlhbFByb3BlcnRpZXMgPSBzZXRJbml0aWFsUHJvcGVydGllcyQxO1xudmFyIGRpZmZQcm9wZXJ0aWVzID0gZGlmZlByb3BlcnRpZXMkMTtcbnZhciB1cGRhdGVQcm9wZXJ0aWVzID0gdXBkYXRlUHJvcGVydGllcyQxO1xudmFyIGRpZmZIeWRyYXRlZFByb3BlcnRpZXMgPSBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzJDE7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dCA9IGRpZmZIeWRyYXRlZFRleHQkMTtcbnZhciB3YXJuRm9yVW5tYXRjaGVkVGV4dCA9IHdhcm5Gb3JVbm1hdGNoZWRUZXh0JDE7XG52YXIgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlRWxlbWVudCA9IHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQkMTtcbnZhciB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0ID0gd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudCQxO1xudmFyIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCA9IHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dCQxO1xudmFyIHVwZGF0ZWRBbmNlc3RvckluZm8gPSB2YWxpZGF0ZURPTU5lc3RpbmckMS51cGRhdGVkQW5jZXN0b3JJbmZvO1xudmFyIHByZWNhY2hlRmliZXJOb2RlID0gcHJlY2FjaGVGaWJlck5vZGUkMTtcbnZhciB1cGRhdGVGaWJlclByb3BzID0gdXBkYXRlRmliZXJQcm9wcyQxO1xuXG5cbntcbiAgdmFyIFNVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HID0gJ3N1cHByZXNzSHlkcmF0aW9uV2FybmluZyc7XG4gIGlmICh0eXBlb2YgTWFwICE9PSAnZnVuY3Rpb24nIHx8IE1hcC5wcm90b3R5cGUgPT0gbnVsbCB8fCB0eXBlb2YgTWFwLnByb3RvdHlwZS5mb3JFYWNoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQgIT09ICdmdW5jdGlvbicgfHwgU2V0LnByb3RvdHlwZSA9PSBudWxsIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmNsZWFyICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBTZXQucHJvdG90eXBlLmZvckVhY2ggIT09ICdmdW5jdGlvbicpIHtcbiAgICB3YXJuaW5nKGZhbHNlLCAnUmVhY3QgZGVwZW5kcyBvbiBNYXAgYW5kIFNldCBidWlsdC1pbiB0eXBlcy4gTWFrZSBzdXJlIHRoYXQgeW91IGxvYWQgYSAnICsgJ3BvbHlmaWxsIGluIG9sZGVyIGJyb3dzZXJzLiBodHRwOi8vZmIubWUvcmVhY3QtcG9seWZpbGxzJyk7XG4gIH1cbn1cblxuaW5qZWN0aW9uJDMuaW5qZWN0RmliZXJDb250cm9sbGVkSG9zdENvbXBvbmVudChSZWFjdERPTUZpYmVyQ29tcG9uZW50KTtcblxudmFyIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xudmFyIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBUcnVlIGlmIHRoZSBzdXBwbGllZCBET00gbm9kZSBpcyBhIHZhbGlkIG5vZGUgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlIFRoZSBjYW5kaWRhdGUgRE9NIG5vZGUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBET00gaXMgYSB2YWxpZCBET00gbm9kZS5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQ29udGFpbmVyKG5vZGUpIHtcbiAgcmV0dXJuICEhKG5vZGUgJiYgKG5vZGUubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSB8fCBub2RlLm5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFIHx8IG5vZGUubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREUgfHwgbm9kZS5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFICYmIG5vZGUubm9kZVZhbHVlID09PSAnIHJlYWN0LW1vdW50LXBvaW50LXVuc3RhYmxlICcpKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcikge1xuICBpZiAoIWNvbnRhaW5lcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfTk9ERSkge1xuICAgIHJldHVybiBjb250YWluZXIuZG9jdW1lbnRFbGVtZW50O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjb250YWluZXIuZmlyc3RDaGlsZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRIeWRyYXRlRHVlVG9MZWdhY3lIZXVyaXN0aWMoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gISEocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290RWxlbWVudC5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRBdXRvRm9jdXNIb3N0Q29tcG9uZW50KHR5cGUsIHByb3BzKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgY2FzZSAnaW5wdXQnOlxuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgcmV0dXJuICEhcHJvcHMuYXV0b0ZvY3VzO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIERPTVJlbmRlcmVyID0gcmVhY3RSZWNvbmNpbGVyKHtcbiAgZ2V0Um9vdEhvc3RDb250ZXh0OiBmdW5jdGlvbiAocm9vdENvbnRhaW5lckluc3RhbmNlKSB7XG4gICAgdmFyIHR5cGUgPSB2b2lkIDA7XG4gICAgdmFyIG5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB2YXIgbm9kZVR5cGUgPSByb290Q29udGFpbmVySW5zdGFuY2Uubm9kZVR5cGU7XG4gICAgc3dpdGNoIChub2RlVHlwZSkge1xuICAgICAgY2FzZSBET0NVTUVOVF9OT0RFOlxuICAgICAgY2FzZSBET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICB7XG4gICAgICAgICAgdHlwZSA9IG5vZGVUeXBlID09PSBET0NVTUVOVF9OT0RFID8gJyNkb2N1bWVudCcgOiAnI2ZyYWdtZW50JztcbiAgICAgICAgICB2YXIgcm9vdCA9IHJvb3RDb250YWluZXJJbnN0YW5jZS5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgbmFtZXNwYWNlID0gcm9vdCA/IHJvb3QubmFtZXNwYWNlVVJJIDogZ2V0Q2hpbGROYW1lc3BhY2UobnVsbCwgJycpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IG5vZGVUeXBlID09PSBDT01NRU5UX05PREUgPyByb290Q29udGFpbmVySW5zdGFuY2UucGFyZW50Tm9kZSA6IHJvb3RDb250YWluZXJJbnN0YW5jZTtcbiAgICAgICAgICB2YXIgb3duTmFtZXNwYWNlID0gY29udGFpbmVyLm5hbWVzcGFjZVVSSSB8fCBudWxsO1xuICAgICAgICAgIHR5cGUgPSBjb250YWluZXIudGFnTmFtZTtcbiAgICAgICAgICBuYW1lc3BhY2UgPSBnZXRDaGlsZE5hbWVzcGFjZShvd25OYW1lc3BhY2UsIHR5cGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHtcbiAgICAgIHZhciB2YWxpZGF0ZWRUYWcgPSB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8obnVsbCwgdmFsaWRhdGVkVGFnLCBudWxsKTtcbiAgICAgIHJldHVybiB7IG5hbWVzcGFjZTogbmFtZXNwYWNlLCBhbmNlc3RvckluZm86IF9hbmNlc3RvckluZm8gfTtcbiAgICB9XG4gICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgfSxcbiAgZ2V0Q2hpbGRIb3N0Q29udGV4dDogZnVuY3Rpb24gKHBhcmVudEhvc3RDb250ZXh0LCB0eXBlKSB7XG4gICAge1xuICAgICAgdmFyIHBhcmVudEhvc3RDb250ZXh0RGV2ID0gcGFyZW50SG9zdENvbnRleHQ7XG4gICAgICB2YXIgX25hbWVzcGFjZSA9IGdldENoaWxkTmFtZXNwYWNlKHBhcmVudEhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZSwgdHlwZSk7XG4gICAgICB2YXIgX2FuY2VzdG9ySW5mbzIgPSB1cGRhdGVkQW5jZXN0b3JJbmZvKHBhcmVudEhvc3RDb250ZXh0RGV2LmFuY2VzdG9ySW5mbywgdHlwZSwgbnVsbCk7XG4gICAgICByZXR1cm4geyBuYW1lc3BhY2U6IF9uYW1lc3BhY2UsIGFuY2VzdG9ySW5mbzogX2FuY2VzdG9ySW5mbzIgfTtcbiAgICB9XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHBhcmVudEhvc3RDb250ZXh0O1xuICAgIHJldHVybiBnZXRDaGlsZE5hbWVzcGFjZShwYXJlbnROYW1lc3BhY2UsIHR5cGUpO1xuICB9LFxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9LFxuICBwcmVwYXJlRm9yQ29tbWl0OiBmdW5jdGlvbiAoKSB7XG4gICAgZXZlbnRzRW5hYmxlZCA9IGlzRW5hYmxlZCgpO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gZ2V0U2VsZWN0aW9uSW5mb3JtYXRpb24oKTtcbiAgICBzZXRFbmFibGVkKGZhbHNlKTtcbiAgfSxcbiAgcmVzZXRBZnRlckNvbW1pdDogZnVuY3Rpb24gKCkge1xuICAgIHJlc3RvcmVTZWxlY3Rpb24oc2VsZWN0aW9uSW5mb3JtYXRpb24pO1xuICAgIHNlbGVjdGlvbkluZm9ybWF0aW9uID0gbnVsbDtcbiAgICBzZXRFbmFibGVkKGV2ZW50c0VuYWJsZWQpO1xuICAgIGV2ZW50c0VuYWJsZWQgPSBudWxsO1xuICB9LFxuICBjcmVhdGVJbnN0YW5jZTogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGhvc3RDb250ZXh0LCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICB7XG4gICAgICAvLyBUT0RPOiB0YWtlIG5hbWVzcGFjZSBpbnRvIGFjY291bnQgd2hlbiB2YWxpZGF0aW5nLlxuICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICB2YWxpZGF0ZURPTU5lc3RpbmckMSh0eXBlLCBudWxsLCBob3N0Q29udGV4dERldi5hbmNlc3RvckluZm8pO1xuICAgICAgaWYgKHR5cGVvZiBwcm9wcy5jaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBwcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgICAgcGFyZW50TmFtZXNwYWNlID0gaG9zdENvbnRleHREZXYubmFtZXNwYWNlO1xuICAgIH1cbiAgICB2YXIgZG9tRWxlbWVudCA9IGNyZWF0ZUVsZW1lbnQodHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgcGFyZW50TmFtZXNwYWNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCBkb21FbGVtZW50KTtcbiAgICB1cGRhdGVGaWJlclByb3BzKGRvbUVsZW1lbnQsIHByb3BzKTtcbiAgICByZXR1cm4gZG9tRWxlbWVudDtcbiAgfSxcbiAgYXBwZW5kSW5pdGlhbENoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkKSB7XG4gICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICB9LFxuICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIHByb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpIHtcbiAgICBzZXRJbml0aWFsUHJvcGVydGllcyhkb21FbGVtZW50LCB0eXBlLCBwcm9wcywgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICByZXR1cm4gc2hvdWxkQXV0b0ZvY3VzSG9zdENvbXBvbmVudCh0eXBlLCBwcm9wcyk7XG4gIH0sXG4gIHByZXBhcmVVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQpIHtcbiAgICB7XG4gICAgICB2YXIgaG9zdENvbnRleHREZXYgPSBob3N0Q29udGV4dDtcbiAgICAgIGlmICh0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gIT09IHR5cGVvZiBvbGRQcm9wcy5jaGlsZHJlbiAmJiAodHlwZW9mIG5ld1Byb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgbmV3UHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInKSkge1xuICAgICAgICB2YXIgc3RyaW5nID0gJycgKyBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgICAgICAgdmFyIG93bkFuY2VzdG9ySW5mbyA9IHVwZGF0ZWRBbmNlc3RvckluZm8oaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvLCB0eXBlLCBudWxsKTtcbiAgICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgc3RyaW5nLCBvd25BbmNlc3RvckluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlmZlByb3BlcnRpZXMoZG9tRWxlbWVudCwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICB9LFxuICBzaG91bGRTZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzKSB7XG4gICAgcmV0dXJuIHR5cGUgPT09ICd0ZXh0YXJlYScgfHwgdHlwZW9mIHByb3BzLmNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgcHJvcHMuY2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgIT09IG51bGwgJiYgdHlwZW9mIHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbCA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIHNob3VsZERlcHJpb3JpdGl6ZVN1YnRyZWU6IGZ1bmN0aW9uICh0eXBlLCBwcm9wcykge1xuICAgIHJldHVybiAhIXByb3BzLmhpZGRlbjtcbiAgfSxcbiAgY3JlYXRlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBob3N0Q29udGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgIHtcbiAgICAgIHZhciBob3N0Q29udGV4dERldiA9IGhvc3RDb250ZXh0O1xuICAgICAgdmFsaWRhdGVET01OZXN0aW5nJDEobnVsbCwgdGV4dCwgaG9zdENvbnRleHREZXYuYW5jZXN0b3JJbmZvKTtcbiAgICB9XG4gICAgdmFyIHRleHROb2RlID0gY3JlYXRlVGV4dE5vZGUodGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlKTtcbiAgICBwcmVjYWNoZUZpYmVyTm9kZShpbnRlcm5hbEluc3RhbmNlSGFuZGxlLCB0ZXh0Tm9kZSk7XG4gICAgcmV0dXJuIHRleHROb2RlO1xuICB9LFxuXG5cbiAgbm93OiBub3csXG5cbiAgbXV0YXRpb246IHtcbiAgICBjb21taXRNb3VudDogZnVuY3Rpb24gKGRvbUVsZW1lbnQsIHR5cGUsIG5ld1Byb3BzLCBpbnRlcm5hbEluc3RhbmNlSGFuZGxlKSB7XG4gICAgICBkb21FbGVtZW50LmZvY3VzKCk7XG4gICAgfSxcbiAgICBjb21taXRVcGRhdGU6IGZ1bmN0aW9uIChkb21FbGVtZW50LCB1cGRhdGVQYXlsb2FkLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcHJvcHMgaGFuZGxlIHNvIHRoYXQgd2Uga25vdyB3aGljaCBwcm9wcyBhcmUgdGhlIG9uZXMgd2l0aFxuICAgICAgLy8gd2l0aCBjdXJyZW50IGV2ZW50IGhhbmRsZXJzLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhkb21FbGVtZW50LCBuZXdQcm9wcyk7XG4gICAgICAvLyBBcHBseSB0aGUgZGlmZiB0byB0aGUgRE9NIG5vZGUuXG4gICAgICB1cGRhdGVQcm9wZXJ0aWVzKGRvbUVsZW1lbnQsIHVwZGF0ZVBheWxvYWQsIHR5cGUsIG9sZFByb3BzLCBuZXdQcm9wcyk7XG4gICAgfSxcbiAgICByZXNldFRleHRDb250ZW50OiBmdW5jdGlvbiAoZG9tRWxlbWVudCkge1xuICAgICAgZG9tRWxlbWVudC50ZXh0Q29udGVudCA9ICcnO1xuICAgIH0sXG4gICAgY29tbWl0VGV4dFVwZGF0ZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgb2xkVGV4dCwgbmV3VGV4dCkge1xuICAgICAgdGV4dEluc3RhbmNlLm5vZGVWYWx1ZSA9IG5ld1RleHQ7XG4gICAgfSxcbiAgICBhcHBlbmRDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQpIHtcbiAgICAgIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IENPTU1FTlRfTk9ERSkge1xuICAgICAgICBjb250YWluZXIucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2hpbGQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaW5zZXJ0QmVmb3JlOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogZnVuY3Rpb24gKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSB7XG4gICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBDT01NRU5UX05PREUpIHtcbiAgICAgICAgY29udGFpbmVyLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKGNoaWxkLCBiZWZvcmVDaGlsZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVDaGlsZDogZnVuY3Rpb24gKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyOiBmdW5jdGlvbiAoY29udGFpbmVyLCBjaGlsZCkge1xuICAgICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGh5ZHJhdGlvbjoge1xuICAgIGNhbkh5ZHJhdGVJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0eXBlLCBwcm9wcykge1xuICAgICAgcmV0dXJuIGluc3RhbmNlLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUgJiYgdHlwZS50b0xvd2VyQ2FzZSgpID09PSBpbnN0YW5jZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH0sXG4gICAgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKGluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodGV4dCA9PT0gJycpIHtcbiAgICAgICAgLy8gRW1wdHkgc3RyaW5ncyBhcmUgbm90IHBhcnNlZCBieSBIVE1MIHNvIHRoZXJlIHdvbid0IGJlIGEgY29ycmVjdCBtYXRjaCBoZXJlLlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5zdGFuY2Uubm9kZVR5cGUgPT09IFRFWFRfTk9ERTtcbiAgICB9LFxuICAgIGdldE5leHRIeWRyYXRhYmxlU2libGluZzogZnVuY3Rpb24gKGluc3RhbmNlKSB7XG4gICAgICB2YXIgbm9kZSA9IGluc3RhbmNlLm5leHRTaWJsaW5nO1xuICAgICAgLy8gU2tpcCBub24taHlkcmF0YWJsZSBub2Rlcy5cbiAgICAgIHdoaWxlIChub2RlICYmIG5vZGUubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSAmJiBub2RlLm5vZGVUeXBlICE9PSBURVhUX05PREUpIHtcbiAgICAgICAgbm9kZSA9IG5vZGUubmV4dFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgIGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkOiBmdW5jdGlvbiAocGFyZW50SW5zdGFuY2UpIHtcbiAgICAgIHZhciBuZXh0ID0gcGFyZW50SW5zdGFuY2UuZmlyc3RDaGlsZDtcbiAgICAgIC8vIFNraXAgbm9uLWh5ZHJhdGFibGUgbm9kZXMuXG4gICAgICB3aGlsZSAobmV4dCAmJiBuZXh0Lm5vZGVUeXBlICE9PSBFTEVNRU5UX05PREUgJiYgbmV4dC5ub2RlVHlwZSAhPT0gVEVYVF9OT0RFKSB7XG4gICAgICAgIG5leHQgPSBuZXh0Lm5leHRTaWJsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfSxcbiAgICBoeWRyYXRlSW5zdGFuY2U6IGZ1bmN0aW9uIChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgaG9zdENvbnRleHQsIGludGVybmFsSW5zdGFuY2VIYW5kbGUpIHtcbiAgICAgIHByZWNhY2hlRmliZXJOb2RlKGludGVybmFsSW5zdGFuY2VIYW5kbGUsIGluc3RhbmNlKTtcbiAgICAgIC8vIFRPRE86IFBvc3NpYmx5IGRlZmVyIHRoaXMgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSB3aGVyZSBhbGwgdGhlIGV2ZW50c1xuICAgICAgLy8gZ2V0IGF0dGFjaGVkLlxuICAgICAgdXBkYXRlRmliZXJQcm9wcyhpbnN0YW5jZSwgcHJvcHMpO1xuICAgICAgdmFyIHBhcmVudE5hbWVzcGFjZSA9IHZvaWQgMDtcbiAgICAgIHtcbiAgICAgICAgdmFyIGhvc3RDb250ZXh0RGV2ID0gaG9zdENvbnRleHQ7XG4gICAgICAgIHBhcmVudE5hbWVzcGFjZSA9IGhvc3RDb250ZXh0RGV2Lm5hbWVzcGFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRQcm9wZXJ0aWVzKGluc3RhbmNlLCB0eXBlLCBwcm9wcywgcGFyZW50TmFtZXNwYWNlLCByb290Q29udGFpbmVySW5zdGFuY2UpO1xuICAgIH0sXG4gICAgaHlkcmF0ZVRleHRJbnN0YW5jZTogZnVuY3Rpb24gKHRleHRJbnN0YW5jZSwgdGV4dCwgaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgcHJlY2FjaGVGaWJlck5vZGUoaW50ZXJuYWxJbnN0YW5jZUhhbmRsZSwgdGV4dEluc3RhbmNlKTtcbiAgICAgIHJldHVybiBkaWZmSHlkcmF0ZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgfSxcbiAgICBkaWROb3RNYXRjaEh5ZHJhdGVkQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0SW5zdGFuY2UsIHRleHQpIHtcbiAgICAgIHtcbiAgICAgICAgd2FybkZvclVubWF0Y2hlZFRleHQodGV4dEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdE1hdGNoSHlkcmF0ZWRUZXh0SW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRUeXBlLCBwYXJlbnRQcm9wcywgcGFyZW50SW5zdGFuY2UsIHRleHRJbnN0YW5jZSwgdGV4dCkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIHdhcm5Gb3JVbm1hdGNoZWRUZXh0KHRleHRJbnN0YW5jZSwgdGV4dCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkaWROb3RIeWRyYXRlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKSB7XG4gICAgICB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50Q29udGFpbmVyLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2FybkZvckRlbGV0ZWRIeWRyYXRhYmxlVGV4dChwYXJlbnRDb250YWluZXIsIGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90SHlkcmF0ZUluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSkge1xuICAgICAgaWYgKHRydWUgJiYgcGFyZW50UHJvcHNbU1VQUFJFU1NfSFlEUkFUSU9OX1dBUk5JTkddICE9PSB0cnVlKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgIHdhcm5Gb3JEZWxldGVkSHlkcmF0YWJsZUVsZW1lbnQocGFyZW50SW5zdGFuY2UsIGluc3RhbmNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3YXJuRm9yRGVsZXRlZEh5ZHJhdGFibGVUZXh0KHBhcmVudEluc3RhbmNlLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVySW5zdGFuY2U6IGZ1bmN0aW9uIChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkRWxlbWVudChwYXJlbnRDb250YWluZXIsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlQ29udGFpbmVyVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50Q29udGFpbmVyLCB0ZXh0KSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5Gb3JJbnNlcnRlZEh5ZHJhdGVkVGV4dChwYXJlbnRDb250YWluZXIsIHRleHQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGlkTm90RmluZEh5ZHJhdGFibGVJbnN0YW5jZTogZnVuY3Rpb24gKHBhcmVudFR5cGUsIHBhcmVudFByb3BzLCBwYXJlbnRJbnN0YW5jZSwgdHlwZSwgcHJvcHMpIHtcbiAgICAgIGlmICh0cnVlICYmIHBhcmVudFByb3BzW1NVUFBSRVNTX0hZRFJBVElPTl9XQVJOSU5HXSAhPT0gdHJ1ZSkge1xuICAgICAgICB3YXJuRm9ySW5zZXJ0ZWRIeWRyYXRlZEVsZW1lbnQocGFyZW50SW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRpZE5vdEZpbmRIeWRyYXRhYmxlVGV4dEluc3RhbmNlOiBmdW5jdGlvbiAocGFyZW50VHlwZSwgcGFyZW50UHJvcHMsIHBhcmVudEluc3RhbmNlLCB0ZXh0KSB7XG4gICAgICBpZiAodHJ1ZSAmJiBwYXJlbnRQcm9wc1tTVVBQUkVTU19IWURSQVRJT05fV0FSTklOR10gIT09IHRydWUpIHtcbiAgICAgICAgd2FybkZvckluc2VydGVkSHlkcmF0ZWRUZXh0KHBhcmVudEluc3RhbmNlLCB0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgc2NoZWR1bGVEZWZlcnJlZENhbGxiYWNrOiBySUMsXG5cbiAgdXNlU3luY1NjaGVkdWxpbmc6ICFlbmFibGVBc3luY1NjaGVkdWxpbmdCeURlZmF1bHRJblJlYWN0RE9NXG59KTtcblxuaW5qZWN0aW9uJDQuaW5qZWN0RmliZXJCYXRjaGVkVXBkYXRlcyhET01SZW5kZXJlci5iYXRjaGVkVXBkYXRlcyk7XG5cbnZhciB3YXJuZWRBYm91dEh5ZHJhdGVBUEkgPSBmYWxzZTtcblxuZnVuY3Rpb24gcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocGFyZW50Q29tcG9uZW50LCBjaGlsZHJlbiwgY29udGFpbmVyLCBmb3JjZUh5ZHJhdGUsIGNhbGxiYWNrKSB7XG4gICFpc1ZhbGlkQ29udGFpbmVyKGNvbnRhaW5lcikgPyBpbnZhcmlhbnQoZmFsc2UsICdUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gIHtcbiAgICBpZiAoY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXIgJiYgY29udGFpbmVyLm5vZGVUeXBlICE9PSBDT01NRU5UX05PREUpIHtcbiAgICAgIHZhciBob3N0SW5zdGFuY2UgPSBET01SZW5kZXJlci5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lci5jdXJyZW50KTtcbiAgICAgIGlmIChob3N0SW5zdGFuY2UpIHtcbiAgICAgICAgd2FybmluZyhob3N0SW5zdGFuY2UucGFyZW50Tm9kZSA9PT0gY29udGFpbmVyLCAncmVuZGVyKC4uLik6IEl0IGxvb2tzIGxpa2UgdGhlIFJlYWN0LXJlbmRlcmVkIGNvbnRlbnQgb2YgdGhpcyAnICsgJ2NvbnRhaW5lciB3YXMgcmVtb3ZlZCB3aXRob3V0IHVzaW5nIFJlYWN0LiBUaGlzIGlzIG5vdCAnICsgJ3N1cHBvcnRlZCBhbmQgd2lsbCBjYXVzZSBlcnJvcnMuIEluc3RlYWQsIGNhbGwgJyArICdSZWFjdERPTS51bm1vdW50Q29tcG9uZW50QXROb2RlIHRvIGVtcHR5IGEgY29udGFpbmVyLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBpc1Jvb3RSZW5kZXJlZEJ5U29tZVJlYWN0ID0gISFjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgICB2YXIgcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdmFyIGhhc05vblJvb3RSZWFjdENoaWxkID0gISEocm9vdEVsICYmIGdldEluc3RhbmNlRnJvbU5vZGUkMShyb290RWwpKTtcblxuICAgIHdhcm5pbmcoIWhhc05vblJvb3RSZWFjdENoaWxkIHx8IGlzUm9vdFJlbmRlcmVkQnlTb21lUmVhY3QsICdyZW5kZXIoLi4uKTogUmVwbGFjaW5nIFJlYWN0LXJlbmRlcmVkIGNoaWxkcmVuIHdpdGggYSBuZXcgcm9vdCAnICsgJ2NvbXBvbmVudC4gSWYgeW91IGludGVuZGVkIHRvIHVwZGF0ZSB0aGUgY2hpbGRyZW4gb2YgdGhpcyBub2RlLCAnICsgJ3lvdSBzaG91bGQgaW5zdGVhZCBoYXZlIHRoZSBleGlzdGluZyBjaGlsZHJlbiB1cGRhdGUgdGhlaXIgc3RhdGUgJyArICdhbmQgcmVuZGVyIHRoZSBuZXcgY29tcG9uZW50cyBpbnN0ZWFkIG9mIGNhbGxpbmcgUmVhY3RET00ucmVuZGVyLicpO1xuXG4gICAgd2FybmluZyhjb250YWluZXIubm9kZVR5cGUgIT09IEVMRU1FTlRfTk9ERSB8fCAhY29udGFpbmVyLnRhZ05hbWUgfHwgY29udGFpbmVyLnRhZ05hbWUudG9VcHBlckNhc2UoKSAhPT0gJ0JPRFknLCAncmVuZGVyKCk6IFJlbmRlcmluZyBjb21wb25lbnRzIGRpcmVjdGx5IGludG8gZG9jdW1lbnQuYm9keSBpcyAnICsgJ2Rpc2NvdXJhZ2VkLCBzaW5jZSBpdHMgY2hpbGRyZW4gYXJlIG9mdGVuIG1hbmlwdWxhdGVkIGJ5IHRoaXJkLXBhcnR5ICcgKyAnc2NyaXB0cyBhbmQgYnJvd3NlciBleHRlbnNpb25zLiBUaGlzIG1heSBsZWFkIHRvIHN1YnRsZSAnICsgJ3JlY29uY2lsaWF0aW9uIGlzc3Vlcy4gVHJ5IHJlbmRlcmluZyBpbnRvIGEgY29udGFpbmVyIGVsZW1lbnQgY3JlYXRlZCAnICsgJ2ZvciB5b3VyIGFwcC4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gY29udGFpbmVyLl9yZWFjdFJvb3RDb250YWluZXI7XG4gIGlmICghcm9vdCkge1xuICAgIHZhciBzaG91bGRIeWRyYXRlID0gZm9yY2VIeWRyYXRlIHx8IHNob3VsZEh5ZHJhdGVEdWVUb0xlZ2FjeUhldXJpc3RpYyhjb250YWluZXIpO1xuICAgIC8vIEZpcnN0IGNsZWFyIGFueSBleGlzdGluZyBjb250ZW50LlxuICAgIGlmICghc2hvdWxkSHlkcmF0ZSkge1xuICAgICAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICAgICAgdmFyIHJvb3RTaWJsaW5nID0gdm9pZCAwO1xuICAgICAgd2hpbGUgKHJvb3RTaWJsaW5nID0gY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKCF3YXJuZWQgJiYgcm9vdFNpYmxpbmcubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERSAmJiByb290U2libGluZy5oYXNBdHRyaWJ1dGUoUk9PVF9BVFRSSUJVVEVfTkFNRSkpIHtcbiAgICAgICAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICAgICAgICB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250YWluZXIucmVtb3ZlQ2hpbGQocm9vdFNpYmxpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICB7XG4gICAgICBpZiAoc2hvdWxkSHlkcmF0ZSAmJiAhZm9yY2VIeWRyYXRlICYmICF3YXJuZWRBYm91dEh5ZHJhdGVBUEkpIHtcbiAgICAgICAgd2FybmVkQWJvdXRIeWRyYXRlQVBJID0gdHJ1ZTtcbiAgICAgICAgbG93UHJpb3JpdHlXYXJuaW5nJDEoZmFsc2UsICdyZW5kZXIoKTogQ2FsbGluZyBSZWFjdERPTS5yZW5kZXIoKSB0byBoeWRyYXRlIHNlcnZlci1yZW5kZXJlZCBtYXJrdXAgJyArICd3aWxsIHN0b3Agd29ya2luZyBpbiBSZWFjdCB2MTcuIFJlcGxhY2UgdGhlIFJlYWN0RE9NLnJlbmRlcigpIGNhbGwgJyArICd3aXRoIFJlYWN0RE9NLmh5ZHJhdGUoKSBpZiB5b3Ugd2FudCBSZWFjdCB0byBhdHRhY2ggdG8gdGhlIHNlcnZlciBIVE1MLicpO1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgbmV3Um9vdCA9IERPTVJlbmRlcmVyLmNyZWF0ZUNvbnRhaW5lcihjb250YWluZXIsIHNob3VsZEh5ZHJhdGUpO1xuICAgIHJvb3QgPSBjb250YWluZXIuX3JlYWN0Um9vdENvbnRhaW5lciA9IG5ld1Jvb3Q7XG4gICAgLy8gSW5pdGlhbCBtb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgRE9NUmVuZGVyZXIudW5iYXRjaGVkVXBkYXRlcyhmdW5jdGlvbiAoKSB7XG4gICAgICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIoY2hpbGRyZW4sIG5ld1Jvb3QsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIERPTVJlbmRlcmVyLnVwZGF0ZUNvbnRhaW5lcihjaGlsZHJlbiwgcm9vdCwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbiAgcmV0dXJuIERPTVJlbmRlcmVyLmdldFB1YmxpY1Jvb3RJbnN0YW5jZShyb290KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIpIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcblxuICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAnVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgYSBET00gZWxlbWVudC4nKSA6IHZvaWQgMDtcbiAgLy8gVE9ETzogcGFzcyBSZWFjdERPTSBwb3J0YWwgaW1wbGVtZW50YXRpb24gYXMgdGhpcmQgYXJndW1lbnRcbiAgcmV0dXJuIGNyZWF0ZVBvcnRhbCQxKGNoaWxkcmVuLCBjb250YWluZXIsIG51bGwsIGtleSk7XG59XG5cbmZ1bmN0aW9uIFJlYWN0Um9vdChjb250YWluZXIsIGh5ZHJhdGUpIHtcbiAgdmFyIHJvb3QgPSBET01SZW5kZXJlci5jcmVhdGVDb250YWluZXIoY29udGFpbmVyLCBoeWRyYXRlKTtcbiAgdGhpcy5fcmVhY3RSb290Q29udGFpbmVyID0gcm9vdDtcbn1cblJlYWN0Um9vdC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKGNoaWxkcmVuLCBjYWxsYmFjaykge1xuICB2YXIgcm9vdCA9IHRoaXMuX3JlYWN0Um9vdENvbnRhaW5lcjtcbiAgRE9NUmVuZGVyZXIudXBkYXRlQ29udGFpbmVyKGNoaWxkcmVuLCByb290LCBudWxsLCBjYWxsYmFjayk7XG59O1xuUmVhY3RSb290LnByb3RvdHlwZS51bm1vdW50ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gIHZhciByb290ID0gdGhpcy5fcmVhY3RSb290Q29udGFpbmVyO1xuICBET01SZW5kZXJlci51cGRhdGVDb250YWluZXIobnVsbCwgcm9vdCwgbnVsbCwgY2FsbGJhY2spO1xufTtcblxudmFyIFJlYWN0RE9NID0ge1xuICBjcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICBmaW5kRE9NTm9kZTogZnVuY3Rpb24gKGNvbXBvbmVudE9yRWxlbWVudCkge1xuICAgIHtcbiAgICAgIHZhciBvd25lciA9IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQ7XG4gICAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHdhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gb3duZXIuc3RhdGVOb2RlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcjtcbiAgICAgICAgd2FybmluZyh3YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBmaW5kRE9NTm9kZSBpbnNpZGUgaXRzIHJlbmRlcigpLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZShvd25lcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICAgIG93bmVyLnN0YXRlTm9kZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSBFTEVNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiBjb21wb25lbnRPckVsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIGluc3QgPSBnZXQoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgICBpZiAoaW5zdCkge1xuICAgICAgcmV0dXJuIERPTVJlbmRlcmVyLmZpbmRIb3N0SW5zdGFuY2UoaW5zdCk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnRPckVsZW1lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbnZhcmlhbnQoZmFsc2UsICdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlLiBLZXlzOiAlcycsIE9iamVjdC5rZXlzKGNvbXBvbmVudE9yRWxlbWVudCkpO1xuICAgIH1cbiAgfSxcbiAgaHlkcmF0ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB0aHJvdyBvciB3YXJuIGlmIHdlIGNvdWxkbid0IGh5ZHJhdGU/XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgdHJ1ZSwgY2FsbGJhY2spO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIChlbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKG51bGwsIGVsZW1lbnQsIGNvbnRhaW5lciwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgfSxcbiAgdW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXI6IGZ1bmN0aW9uIChwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGNhbGxiYWNrKSB7XG4gICAgIShwYXJlbnRDb21wb25lbnQgIT0gbnVsbCAmJiBoYXMocGFyZW50Q29tcG9uZW50KSkgPyBpbnZhcmlhbnQoZmFsc2UsICdwYXJlbnRDb21wb25lbnQgbXVzdCBiZSBhIHZhbGlkIFJlYWN0IENvbXBvbmVudCcpIDogdm9pZCAwO1xuICAgIHJldHVybiByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihwYXJlbnRDb21wb25lbnQsIGVsZW1lbnQsIGNvbnRhaW5lck5vZGUsIGZhbHNlLCBjYWxsYmFjayk7XG4gIH0sXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGZ1bmN0aW9uIChjb250YWluZXIpIHtcbiAgICAhaXNWYWxpZENvbnRhaW5lcihjb250YWluZXIpID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogdm9pZCAwO1xuXG4gICAgaWYgKGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyKSB7XG4gICAgICB7XG4gICAgICAgIHZhciByb290RWwgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgICAgdmFyIHJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCA9IHJvb3RFbCAmJiAhZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKHJvb3RFbCk7XG4gICAgICAgIHdhcm5pbmcoIXJlbmRlcmVkQnlEaWZmZXJlbnRSZWFjdCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IGFub3RoZXIgY29weSBvZiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gVW5tb3VudCBzaG91bGQgbm90IGJlIGJhdGNoZWQuXG4gICAgICBET01SZW5kZXJlci51bmJhdGNoZWRVcGRhdGVzKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVuZGVyU3VidHJlZUludG9Db250YWluZXIobnVsbCwgbnVsbCwgY29udGFpbmVyLCBmYWxzZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRhaW5lci5fcmVhY3RSb290Q29udGFpbmVyID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIElmIHlvdSBjYWxsIHVubW91bnRDb21wb25lbnRBdE5vZGUgdHdpY2UgaW4gcXVpY2sgc3VjY2Vzc2lvbiwgeW91J2xsXG4gICAgICAvLyBnZXQgYHRydWVgIHR3aWNlLiBUaGF0J3MgcHJvYmFibHkgZmluZT9cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB7XG4gICAgICAgIHZhciBfcm9vdEVsID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgICAgIHZhciBoYXNOb25Sb290UmVhY3RDaGlsZCA9ICEhKF9yb290RWwgJiYgZ2V0SW5zdGFuY2VGcm9tTm9kZSQxKF9yb290RWwpKTtcblxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGFpbmVyIGl0c2VsZiBpcyBhIFJlYWN0IHJvb3Qgbm9kZS5cbiAgICAgICAgdmFyIGlzQ29udGFpbmVyUmVhY3RSb290ID0gY29udGFpbmVyLm5vZGVUeXBlID09PSAxICYmIGlzVmFsaWRDb250YWluZXIoY29udGFpbmVyLnBhcmVudE5vZGUpICYmICEhY29udGFpbmVyLnBhcmVudE5vZGUuX3JlYWN0Um9vdENvbnRhaW5lcjtcblxuICAgICAgICB3YXJuaW5nKCFoYXNOb25Sb290UmVhY3RDaGlsZCwgXCJ1bm1vdW50Q29tcG9uZW50QXROb2RlKCk6IFRoZSBub2RlIHlvdSdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgXCIgKyAnd2FzIHJlbmRlcmVkIGJ5IFJlYWN0IGFuZCBpcyBub3QgYSB0b3AtbGV2ZWwgY29udGFpbmVyLiAlcycsIGlzQ29udGFpbmVyUmVhY3RSb290ID8gJ1lvdSBtYXkgaGF2ZSBhY2NpZGVudGFsbHkgcGFzc2VkIGluIGEgUmVhY3Qgcm9vdCBub2RlIGluc3RlYWQgJyArICdvZiBpdHMgY29udGFpbmVyLicgOiAnSW5zdGVhZCwgaGF2ZSB0aGUgcGFyZW50IGNvbXBvbmVudCB1cGRhdGUgaXRzIHN0YXRlIGFuZCAnICsgJ3JlcmVuZGVyIGluIG9yZGVyIHRvIHJlbW92ZSB0aGlzIGNvbXBvbmVudC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSxcblxuXG4gIC8vIFRlbXBvcmFyeSBhbGlhcyBzaW5jZSB3ZSBhbHJlYWR5IHNoaXBwZWQgUmVhY3QgMTYgUkMgd2l0aCBpdC5cbiAgLy8gVE9ETzogcmVtb3ZlIGluIFJlYWN0IDE3LlxuICB1bnN0YWJsZV9jcmVhdGVQb3J0YWw6IGNyZWF0ZVBvcnRhbCxcblxuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG5cbiAgdW5zdGFibGVfZGVmZXJyZWRVcGRhdGVzOiBET01SZW5kZXJlci5kZWZlcnJlZFVwZGF0ZXMsXG5cbiAgZmx1c2hTeW5jOiBET01SZW5kZXJlci5mbHVzaFN5bmMsXG5cbiAgX19TRUNSRVRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQ6IHtcbiAgICAvLyBGb3IgVGFwRXZlbnRQbHVnaW4gd2hpY2ggaXMgcG9wdWxhciBpbiBvcGVuIHNvdXJjZVxuICAgIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1YixcbiAgICAvLyBVc2VkIGJ5IHRlc3QtdXRpbHNcbiAgICBFdmVudFBsdWdpblJlZ2lzdHJ5OiBFdmVudFBsdWdpblJlZ2lzdHJ5LFxuICAgIEV2ZW50UHJvcGFnYXRvcnM6IEV2ZW50UHJvcGFnYXRvcnMsXG4gICAgUmVhY3RDb250cm9sbGVkQ29tcG9uZW50OiBSZWFjdENvbnRyb2xsZWRDb21wb25lbnQsXG4gICAgUmVhY3RET01Db21wb25lbnRUcmVlOiBSZWFjdERPTUNvbXBvbmVudFRyZWUsXG4gICAgUmVhY3RET01FdmVudExpc3RlbmVyOiBSZWFjdERPTUV2ZW50TGlzdGVuZXJcbiAgfVxufTtcblxuaWYgKGVuYWJsZUNyZWF0ZVJvb3QpIHtcbiAgUmVhY3RET00uY3JlYXRlUm9vdCA9IGZ1bmN0aW9uIGNyZWF0ZVJvb3QoY29udGFpbmVyLCBvcHRpb25zKSB7XG4gICAgdmFyIGh5ZHJhdGUgPSBvcHRpb25zICE9IG51bGwgJiYgb3B0aW9ucy5oeWRyYXRlID09PSB0cnVlO1xuICAgIHJldHVybiBuZXcgUmVhY3RSb290KGNvbnRhaW5lciwgaHlkcmF0ZSk7XG4gIH07XG59XG5cbnZhciBmb3VuZERldlRvb2xzID0gRE9NUmVuZGVyZXIuaW5qZWN0SW50b0RldlRvb2xzKHtcbiAgZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U6IGdldENsb3Nlc3RJbnN0YW5jZUZyb21Ob2RlLFxuICBidW5kbGVUeXBlOiAxLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb24sXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdyZWFjdC1kb20nXG59KTtcblxue1xuICBpZiAoIWZvdW5kRGV2VG9vbHMgJiYgRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmIHdpbmRvdy50b3AgPT09IHdpbmRvdy5zZWxmKSB7XG4gICAgLy8gSWYgd2UncmUgaW4gQ2hyb21lIG9yIEZpcmVmb3gsIHByb3ZpZGUgYSBkb3dubG9hZCBsaW5rIGlmIG5vdCBpbnN0YWxsZWQuXG4gICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgdmFyIHByb3RvY29sID0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sO1xuICAgICAgLy8gRG9uJ3Qgd2FybiBpbiBleG90aWMgY2FzZXMgbGlrZSBjaHJvbWUtZXh0ZW5zaW9uOi8vLlxuICAgICAgaWYgKC9eKGh0dHBzP3xmaWxlKTokLy50ZXN0KHByb3RvY29sKSkge1xuICAgICAgICBjb25zb2xlLmluZm8oJyVjRG93bmxvYWQgdGhlIFJlYWN0IERldlRvb2xzICcgKyAnZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycgKyAocHJvdG9jb2wgPT09ICdmaWxlOicgPyAnXFxuWW91IG1pZ2h0IG5lZWQgdG8gdXNlIGEgbG9jYWwgSFRUUCBzZXJ2ZXIgKGluc3RlYWQgb2YgZmlsZTovLyk6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scy1mYXEnIDogJycpLCAnZm9udC13ZWlnaHQ6Ym9sZCcpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5cblxudmFyIFJlYWN0RE9NJDIgPSBPYmplY3QuZnJlZXplKHtcblx0ZGVmYXVsdDogUmVhY3RET01cbn0pO1xuXG52YXIgUmVhY3RET00kMyA9ICggUmVhY3RET00kMiAmJiBSZWFjdERPTSApIHx8IFJlYWN0RE9NJDI7XG5cbi8vIFRPRE86IGRlY2lkZSBvbiB0aGUgdG9wLWxldmVsIGV4cG9ydCBmb3JtLlxuLy8gVGhpcyBpcyBoYWNreSBidXQgbWFrZXMgaXQgd29yayB3aXRoIGJvdGggUm9sbHVwIGFuZCBKZXN0LlxudmFyIHJlYWN0RG9tID0gUmVhY3RET00kM1snZGVmYXVsdCddID8gUmVhY3RET00kM1snZGVmYXVsdCddIDogUmVhY3RET00kMztcblxubW9kdWxlLmV4cG9ydHMgPSByZWFjdERvbTtcbiAgfSkoKTtcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1kb20vY2pzL3JlYWN0LWRvbS5kZXZlbG9wbWVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoeXBoZW5hdGUgPSByZXF1aXJlKCcuL2h5cGhlbmF0ZScpO1xuXG52YXIgbXNQYXR0ZXJuID0gL15tcy0vO1xuXG4vKipcbiAqIEh5cGhlbmF0ZXMgYSBjYW1lbGNhc2VkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdiYWNrZ3JvdW5kQ29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZC1jb2xvclwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdNb3pUcmFuc2l0aW9uJylcbiAqICAgPCBcIi1tb3otdHJhbnNpdGlvblwiXG4gKiAgID4gaHlwaGVuYXRlU3R5bGVOYW1lKCdtc1RyYW5zaXRpb24nKVxuICogICA8IFwiLW1zLXRyYW5zaXRpb25cIlxuICpcbiAqIEFzIE1vZGVybml6ciBzdWdnZXN0cyAoaHR0cDovL21vZGVybml6ci5jb20vZG9jcy8jcHJlZml4ZWQpLCBhbiBgbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGAtbXMtYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHJpbmcpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZShzdHJpbmcpLnJlcGxhY2UobXNQYXR0ZXJuLCAnLW1zLScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGh5cGhlbmF0ZVN0eWxlTmFtZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvaHlwaGVuYXRlU3R5bGVOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICpcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW1lbGl6ZSA9IHJlcXVpcmUoJy4vY2FtZWxpemUnKTtcblxudmFyIG1zUGF0dGVybiA9IC9eLW1zLS87XG5cbi8qKlxuICogQ2FtZWxjYXNlcyBhIGh5cGhlbmF0ZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbW96LXRyYW5zaXRpb24nKVxuICogICA8IFwiTW96VHJhbnNpdGlvblwiXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJy1tcy10cmFuc2l0aW9uJylcbiAqICAgPCBcIm1zVHJhbnNpdGlvblwiXG4gKlxuICogQXMgQW5kaSBTbWl0aCBzdWdnZXN0c1xuICogKGh0dHA6Ly93d3cuYW5kaXNtaXRoLmNvbS9ibG9nLzIwMTIvMDIvbW9kZXJuaXpyLXByZWZpeGVkLyksIGFuIGAtbXNgIHByZWZpeFxuICogaXMgY29udmVydGVkIHRvIGxvd2VyY2FzZSBgbXNgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemVTdHlsZU5hbWUoc3RyaW5nKSB7XG4gIHJldHVybiBjYW1lbGl6ZShzdHJpbmcucmVwbGFjZShtc1BhdHRlcm4sICdtcy0nKSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemVTdHlsZU5hbWU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogQHR5cGVjaGVja3NcbiAqL1xuXG52YXIgX2h5cGhlblBhdHRlcm4gPSAvLSguKS9nO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIHN0cmluZywgZm9yIGV4YW1wbGU6XG4gKlxuICogICA+IGNhbWVsaXplKCdiYWNrZ3JvdW5kLWNvbG9yJylcbiAqICAgPCBcImJhY2tncm91bmRDb2xvclwiXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZ1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBjYW1lbGl6ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF9oeXBoZW5QYXR0ZXJuLCBmdW5jdGlvbiAoXywgY2hhcmFjdGVyKSB7XG4gICAgcmV0dXJuIGNoYXJhY3Rlci50b1VwcGVyQ2FzZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjYW1lbGl6ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZmJqcy9saWIvY2FtZWxpemUuanMiLCJpbXBvcnQgUmVhY3QsIHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBCYXNpY0luZm8gZnJvbSAnLi9jb21wb25lbnRzL2Jhc2ljaW5mbyc7XG5pbXBvcnQgQmlvIGZyb20gJy4vY29tcG9uZW50cy9iaW8nO1xuaW1wb3J0IFRlY2hTa2lsbHMgZnJvbSAnLi9jb21wb25lbnRzL3RlY2hza2lsbHMnO1xuaW1wb3J0IEV4cGVyaWVuY2UgZnJvbSAnLi9jb21wb25lbnRzL2V4cGVyaWVuY2UnO1xuaW1wb3J0IFByb2plY3RzIGZyb20gJy4vY29tcG9uZW50cy9wcm9qZWN0cyc7XG5cbmNsYXNzIEFwcCBleHRlbmRzIENvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKXtcbiAgICBzdXBlcihwcm9wcyk7XG5cbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgZGF0YToge31cbiAgICB9XG5cbiAgICB0aGlzLmxvYWRDb21tZW50c0Zyb21TZXJ2ZXIgPSB0aGlzLmxvYWRDb21tZW50c0Zyb21TZXJ2ZXIuYmluZCh0aGlzKTtcblxuICB9XG5cbiAgbG9hZENvbW1lbnRzRnJvbVNlcnZlcigpIHtcbiAgICBheGlvcy5nZXQodGhpcy5wcm9wcy51cmwpXG4gICAgICAudGhlbihyZXMgPT4ge1xuICAgICAgICB0aGlzLnNldFN0YXRlKHsgZGF0YTogcmVzLmRhdGFbMF0gfSk7XG4gICAgfSlcbiAgfVxuXG5cbiAgY29tcG9uZW50RGlkTW91bnQoKXtcbiAgICB0aGlzLmxvYWRDb21tZW50c0Zyb21TZXJ2ZXIoKVxuICB9O1xuXG4gIHJlbmRlcigpIHtcbiAgICByZXR1cm4gKFxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJ3cmFwcGVyXCI+XG4gICAgICAgIDxCYXNpY0luZm8gaW5mbyA9IHt0aGlzLnN0YXRlLmRhdGEuYmFzaWNpbmZvfSAvPlxuICAgICAgICA8QmlvIGluZm8gPSB7dGhpcy5zdGF0ZS5kYXRhLmJpb30gLz5cbiAgICAgICAgPFRlY2hTa2lsbHMgaW5mbyA9IHt0aGlzLnN0YXRlLmRhdGEuc2tpbGxzfSAvPlxuICAgICAgICA8RXhwZXJpZW5jZSBpbmZvID0ge3RoaXMuc3RhdGUuZGF0YS5leHBlcmllbmNlfSAvPlxuICAgICAgICA8UHJvamVjdHMgaW5mbyA9IHt0aGlzLnN0YXRlLmRhdGEucHJvamVjdHN9IC8+XG4gICAgICA8L2Rpdj5cbiAgICApXG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgQXBwO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2FwcC5qcyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBBeGlvcyA9IHJlcXVpcmUoJy4vY29yZS9BeGlvcycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZhdWx0Q29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdENvbmZpZykge1xuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcbiAgdmFyIGluc3RhbmNlID0gYmluZChBeGlvcy5wcm90b3R5cGUucmVxdWVzdCwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBBeGlvcy5wcm90b3R5cGUsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIGNvbnRleHQpO1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuLy8gQ3JlYXRlIHRoZSBkZWZhdWx0IGluc3RhbmNlIHRvIGJlIGV4cG9ydGVkXG52YXIgYXhpb3MgPSBjcmVhdGVJbnN0YW5jZShkZWZhdWx0cyk7XG5cbi8vIEV4cG9zZSBBeGlvcyBjbGFzcyB0byBhbGxvdyBjbGFzcyBpbmhlcml0YW5jZVxuYXhpb3MuQXhpb3MgPSBBeGlvcztcblxuLy8gRmFjdG9yeSBmb3IgY3JlYXRpbmcgbmV3IGluc3RhbmNlc1xuYXhpb3MuY3JlYXRlID0gZnVuY3Rpb24gY3JlYXRlKGluc3RhbmNlQ29uZmlnKSB7XG4gIHJldHVybiBjcmVhdGVJbnN0YW5jZSh1dGlscy5tZXJnZShkZWZhdWx0cywgaW5zdGFuY2VDb25maWcpKTtcbn07XG5cbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxuYXhpb3MuQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsJyk7XG5heGlvcy5DYW5jZWxUb2tlbiA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbFRva2VuJyk7XG5heGlvcy5pc0NhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL2lzQ2FuY2VsJyk7XG5cbi8vIEV4cG9zZSBhbGwvc3ByZWFkXG5heGlvcy5hbGwgPSBmdW5jdGlvbiBhbGwocHJvbWlzZXMpIHtcbiAgcmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKTtcbn07XG5heGlvcy5zcHJlYWQgPSByZXF1aXJlKCcuL2hlbHBlcnMvc3ByZWFkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyIsIi8qIVxuICogRGV0ZXJtaW5lIGlmIGFuIG9iamVjdCBpcyBhIEJ1ZmZlclxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIEludGVyY2VwdG9yTWFuYWdlciA9IHJlcXVpcmUoJy4vSW50ZXJjZXB0b3JNYW5hZ2VyJyk7XG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gcmVxdWlyZSgnLi9kaXNwYXRjaFJlcXVlc3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gaW5zdGFuY2VDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcbiAgdGhpcy5kZWZhdWx0cyA9IGluc3RhbmNlQ29uZmlnO1xuICB0aGlzLmludGVyY2VwdG9ycyA9IHtcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXG4gICAgcmVzcG9uc2U6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKVxuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyBzcGVjaWZpYyBmb3IgdGhpcyByZXF1ZXN0IChtZXJnZWQgd2l0aCB0aGlzLmRlZmF1bHRzKVxuICovXG5BeGlvcy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIHJlcXVlc3QoY29uZmlnKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICAvLyBBbGxvdyBmb3IgYXhpb3MoJ2V4YW1wbGUvdXJsJ1ssIGNvbmZpZ10pIGEgbGEgZmV0Y2ggQVBJXG4gIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIGNvbmZpZyA9IHV0aWxzLm1lcmdlKHtcbiAgICAgIHVybDogYXJndW1lbnRzWzBdXG4gICAgfSwgYXJndW1lbnRzWzFdKTtcbiAgfVxuXG4gIGNvbmZpZyA9IHV0aWxzLm1lcmdlKGRlZmF1bHRzLCB0aGlzLmRlZmF1bHRzLCB7IG1ldGhvZDogJ2dldCcgfSwgY29uZmlnKTtcbiAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcblxuICAvLyBIb29rIHVwIGludGVyY2VwdG9ycyBtaWRkbGV3YXJlXG4gIHZhciBjaGFpbiA9IFtkaXNwYXRjaFJlcXVlc3QsIHVuZGVmaW5lZF07XG4gIHZhciBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgY2hhaW4udW5zaGlmdChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcbiAgfSk7XG5cbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVzcG9uc2UuZm9yRWFjaChmdW5jdGlvbiBwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi5wdXNoKGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihjaGFpbi5zaGlmdCgpLCBjaGFpbi5zaGlmdCgpKTtcbiAgfVxuXG4gIHJldHVybiBwcm9taXNlO1xufTtcblxuLy8gUHJvdmlkZSBhbGlhc2VzIGZvciBzdXBwb3J0ZWQgcmVxdWVzdCBtZXRob2RzXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHV0aWxzLm1lcmdlKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XG4gIHV0aWxzLmZvckVhY2goaGVhZGVycywgZnVuY3Rpb24gcHJvY2Vzc0hlYWRlcih2YWx1ZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICE9PSBub3JtYWxpemVkTmFtZSAmJiBuYW1lLnRvVXBwZXJDYXNlKCkgPT09IG5vcm1hbGl6ZWROYW1lLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XG4gICAgICBkZWxldGUgaGVhZGVyc1tuYW1lXTtcbiAgICB9XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3JlYXRlRXJyb3IgPSByZXF1aXJlKCcuL2NyZWF0ZUVycm9yJyk7XG5cbi8qKlxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZXNvbHZlIEEgZnVuY3Rpb24gdGhhdCByZXNvbHZlcyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXNwb25zZSBUaGUgcmVzcG9uc2UuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcbiAgdmFyIHZhbGlkYXRlU3RhdHVzID0gcmVzcG9uc2UuY29uZmlnLnZhbGlkYXRlU3RhdHVzO1xuICAvLyBOb3RlOiBzdGF0dXMgaXMgbm90IGV4cG9zZWQgYnkgWERvbWFpblJlcXVlc3RcbiAgaWYgKCFyZXNwb25zZS5zdGF0dXMgfHwgIXZhbGlkYXRlU3RhdHVzIHx8IHZhbGlkYXRlU3RhdHVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgfSBlbHNlIHtcbiAgICByZWplY3QoY3JlYXRlRXJyb3IoXG4gICAgICAnUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAnICsgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxuICAgICAgbnVsbCxcbiAgICAgIHJlc3BvbnNlLnJlcXVlc3QsXG4gICAgICByZXNwb25zZVxuICAgICkpO1xuICB9XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVcGRhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIGNvbmZpZywgZXJyb3IgY29kZSwgYW5kIHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIFRoZSBlcnJvciB0byB1cGRhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICBlcnJvci5jb25maWcgPSBjb25maWc7XG4gIGlmIChjb2RlKSB7XG4gICAgZXJyb3IuY29kZSA9IGNvZGU7XG4gIH1cbiAgZXJyb3IucmVxdWVzdCA9IHJlcXVlc3Q7XG4gIGVycm9yLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gIHJldHVybiBlcnJvcjtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICB2YXIgbXNpZSA9IC8obXNpZXx0cmlkZW50KS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgIHZhciBvcmlnaW5VUkw7XG5cbiAgICAvKipcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmwgVGhlIFVSTCB0byBiZSBwYXJzZWRcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAgKi9cbiAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgdmFyIGhyZWYgPSB1cmw7XG5cbiAgICAgIGlmIChtc2llKSB7XG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xuICAgICAgfVxuXG4gICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgLy8gdXJsUGFyc2luZ05vZGUgcHJvdmlkZXMgdGhlIFVybFV0aWxzIGludGVyZmFjZSAtIGh0dHA6Ly91cmwuc3BlYy53aGF0d2cub3JnLyN1cmx1dGlsc1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgcHJvdG9jb2w6IHVybFBhcnNpbmdOb2RlLnByb3RvY29sID8gdXJsUGFyc2luZ05vZGUucHJvdG9jb2wucmVwbGFjZSgvOiQvLCAnJykgOiAnJyxcbiAgICAgICAgaG9zdDogdXJsUGFyc2luZ05vZGUuaG9zdCxcbiAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICBoYXNoOiB1cmxQYXJzaW5nTm9kZS5oYXNoID8gdXJsUGFyc2luZ05vZGUuaGFzaC5yZXBsYWNlKC9eIy8sICcnKSA6ICcnLFxuICAgICAgICBob3N0bmFtZTogdXJsUGFyc2luZ05vZGUuaG9zdG5hbWUsXG4gICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgIHBhdGhuYW1lOiAodXJsUGFyc2luZ05vZGUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpID9cbiAgICAgICAgICAgICAgICAgIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lIDpcbiAgICAgICAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXG4gICAgICB9O1xuICAgIH1cblxuICAgIG9yaWdpblVSTCA9IHJlc29sdmVVUkwod2luZG93LmxvY2F0aW9uLmhyZWYpO1xuXG4gICAgLyoqXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxuICAgICpcbiAgICAqIEBwYXJhbSB7U3RyaW5nfSByZXF1ZXN0VVJMIFRoZSBVUkwgdG8gdGVzdFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxuICAgICovXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICB2YXIgcGFyc2VkID0gKHV0aWxzLmlzU3RyaW5nKHJlcXVlc3RVUkwpKSA/IHJlc29sdmVVUkwocmVxdWVzdFVSTCkgOiByZXF1ZXN0VVJMO1xuICAgICAgcmV0dXJuIChwYXJzZWQucHJvdG9jb2wgPT09IG9yaWdpblVSTC5wcm90b2NvbCAmJlxuICAgICAgICAgICAgcGFyc2VkLmhvc3QgPT09IG9yaWdpblVSTC5ob3N0KTtcbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnZzICh3ZWIgd29ya2VycywgcmVhY3QtbmF0aXZlKSBsYWNrIG5lZWRlZCBzdXBwb3J0LlxuICAoZnVuY3Rpb24gbm9uU3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICB9KSgpXG4pO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciB0cmFuc2Zvcm1EYXRhID0gcmVxdWlyZSgnLi90cmFuc2Zvcm1EYXRhJyk7XG52YXIgaXNDYW5jZWwgPSByZXF1aXJlKCcuLi9jYW5jZWwvaXNDYW5jZWwnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4uL2RlZmF1bHRzJyk7XG52YXIgaXNBYnNvbHV0ZVVSTCA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvY29tYmluZVVSTHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBTdXBwb3J0IGJhc2VVUkwgY29uZmlnXG4gIGlmIChjb25maWcuYmFzZVVSTCAmJiAhaXNBYnNvbHV0ZVVSTChjb25maWcudXJsKSkge1xuICAgIGNvbmZpZy51cmwgPSBjb21iaW5lVVJMcyhjb25maWcuYmFzZVVSTCwgY29uZmlnLnVybCk7XG4gIH1cblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgcmVzcG9uc2UuZGF0YSxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICApO1xuXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xuICB9LCBmdW5jdGlvbiBvbkFkYXB0ZXJSZWplY3Rpb24ocmVhc29uKSB7XG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XG4gICAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXG4gICAgICBpZiAocmVhc29uICYmIHJlYXNvbi5yZXNwb25zZSkge1xuICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSA9IHRyYW5zZm9ybURhdGEoXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEsXG4gICAgICAgICAgcmVhc29uLnJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHJlYXNvbik7XG4gIH0pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLyoqXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXG4gKlxuICogQHBhcmFtIHtPYmplY3R8U3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxuICogQHBhcmFtIHtBcnJheXxGdW5jdGlvbn0gZm5zIEEgc2luZ2xlIGZ1bmN0aW9uIG9yIEFycmF5IG9mIGZ1bmN0aW9uc1xuICogQHJldHVybnMgeyp9IFRoZSByZXN1bHRpbmcgdHJhbnNmb3JtZWQgZGF0YVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHRyYW5zZm9ybURhdGEoZGF0YSwgaGVhZGVycywgZm5zKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XG4gICAgZGF0YSA9IGZuKGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBVUkwgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQWJzb2x1dGVVUkwodXJsKSB7XG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXCI8c2NoZW1lPjovL1wiIG9yIFwiLy9cIiAocHJvdG9jb2wtcmVsYXRpdmUgVVJMKS5cbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXG4gIC8vIGJ5IGFueSBjb21iaW5hdGlvbiBvZiBsZXR0ZXJzLCBkaWdpdHMsIHBsdXMsIHBlcmlvZCwgb3IgaHlwaGVuLlxuICByZXR1cm4gL14oW2Etel1bYS16XFxkXFwrXFwtXFwuXSo6KT9cXC9cXC8vaS50ZXN0KHVybCk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBzcGVjaWZpZWQgVVJMc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlVVJMIFRoZSBiYXNlIFVSTFxuICogQHBhcmFtIHtzdHJpbmd9IHJlbGF0aXZlVVJMIFRoZSByZWxhdGl2ZSBVUkxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZWxhdGl2ZVVSTCkge1xuICByZXR1cm4gcmVsYXRpdmVVUkxcbiAgICA/IGJhc2VVUkwucmVwbGFjZSgvXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFwvKy8sICcnKVxuICAgIDogYmFzZVVSTDtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cbiAqXG4gKiBDb21tb24gdXNlIGNhc2Ugd291bGQgYmUgdG8gdXNlIGBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHlgLlxuICpcbiAqICBgYGBqc1xuICogIGZ1bmN0aW9uIGYoeCwgeSwgeikge31cbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcbiAqICBmLmFwcGx5KG51bGwsIGFyZ3MpO1xuICogIGBgYFxuICpcbiAqIFdpdGggYHNwcmVhZGAgdGhpcyBleGFtcGxlIGNhbiBiZSByZS13cml0dGVuLlxuICpcbiAqICBgYGBqc1xuICogIHNwcmVhZChmdW5jdGlvbih4LCB5LCB6KSB7fSkoWzEsIDIsIDNdKTtcbiAqICBgYGBcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybnMge0Z1bmN0aW9ufVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHNwcmVhZChjYWxsYmFjaykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcChhcnIpIHtcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgQmFzaWNJbmZvID0gKHByb3BzKSA9PiB7XG5cbiAgICBpZighcHJvcHMuaW5mbykge1xuICAgICAgcmV0dXJuIDxkaXY+TG9hZGluZyA8aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+PC9kaXY+O1xuICAgIH1cblxuICAgICQoZnVuY3Rpb24gKCkge1xuICAgICAgJCgnW2RhdGEtdG9nZ2xlPVwidG9vbHRpcFwiXScpLnRvb2x0aXAoe1xuICAgICAgICBodG1sOiB0cnVlXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICBjb25zdCB0b29sdGlwVGV4dCA9IFwiVGhpcyBDViBoYXMgYmVlbiBidWlsZCB3aXRoIE1vbmdvREIsIEV4cHJlc3MsIFJlYWN0IGFuZCBOb2RlXCI7XG5cbiAgICByZXR1cm4oXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxhIGhyZWY9XCIvZG9jcy9NYXhfX0dvbHViZXZfQ1YuZG9jeFwiIGNsYXNzTmFtZT1cImRvd25sb2FkLWljb25cIiBkYXRhLXRvZ2dsZT1cInRvb2x0aXBcIiBkYXRhLXBsYWNlbWVudD1cImxlZnRcIiB0aXRsZT1cImRvd25sb2FkIGN2LmRvY3hcIj48aSBjbGFzc05hbWU9XCJmYSBmYS1kb3dubG9hZCBmYS0yeFwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT48L2E+XG4gICAgICA8YSBjbGFzc05hbWU9XCJpbmZvXCIgaHJlZj0naHR0cHM6Ly9naXRodWIuY29tL01heEdvbC9DVl9IRVJPS1UnIGRhdGEtdG9nZ2xlPVwidG9vbHRpcFwiIGRhdGEtcGxhY2VtZW50PVwibGVmdFwiIHRpdGxlPXsgdG9vbHRpcFRleHQgfT48c3BhbiBjbGFzc05hbWU9J2ZhIGZhLTJ4IGZhLWdpdGh1Yic+PC9zcGFuPjwvYT5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy0xMlwiPlxuICAgICAgICAgICAgPGltZyBzcmM9XCIvaW1hZ2VzL21heC5wbmdcIiBjbGFzc05hbWU9XCJpbWctY2lyY2xlIGNlbnRlci1ibG9ja1wiIC8+XG4gICAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj57IHByb3BzLmluZm8ubmFtZSB9PC9oND5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+PHN0cm9uZz57IHByb3BzLmluZm8udGl0bGUgfTwvc3Ryb25nPjwvcD5cbiAgICAgICAgICAgIDxociBjbGFzc05hbWU9XCJzbWFsbC1kaXZpZGVyXCIgLz5cbiAgICAgICAgICAgIDxwIGNsYXNzTmFtZT1cInRleHQtY2VudGVyXCI+PHN0cm9uZz57IHByb3BzLmluZm8uYWRkcmVzcyB9PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj48c3Ryb25nPnsgcHJvcHMuaW5mby5lbWFpbCB9PC9zdHJvbmc+PC9wPlxuICAgICAgICAgICAgPGhyIGNsYXNzTmFtZT1cInNtYWxsLWRpdmlkZXJcIiAvPlxuICAgICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1jZW50ZXJcIj48c3Ryb25nPjA3NzM5IDM2NTQzMDwvc3Ryb25nPjwvcD5cbiAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICApO1xuICB9XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2ljSW5mbztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL2Jhc2ljaW5mby5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5cbmNvbnN0IEJpbyA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj57IHByb3BzLmluZm8udGl0bGUgfTwvaDQ+XG4gICAgICAgICAgPGhyIGNsYXNzTmFtZT1cIm5vcm1hbC1kaXZpZGVyXCIgLz5cbiAgICAgICAgICA8cD57IHByb3BzLmluZm8uYWJvdXRfbWUgfTwvcD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBCaW87XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvY29tcG9uZW50cy9iaW8uanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFNraWxsc0xpc3QgZnJvbSAnLi9za2lsbHNsaXN0JztcblxuY29uc3QgVGVjaFNraWxscyA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIGNvbnN0IHNraWxsTGlzdCA9IE9iamVjdC5rZXlzKHByb3BzLmluZm8uc2tpbGxzX3N0YWNrKS5tYXAoZnVuY3Rpb24oc2tpbGxuYW1lLCBpbmRleCl7XG4gICAgcmV0dXJuIDxTa2lsbHNMaXN0IGtleT17aW5kZXh9IG5hbWU9e3NraWxsbmFtZX0gc2tpbGxzPXtwcm9wcy5pbmZvLnNraWxsc19zdGFja1tza2lsbG5hbWVdfSAvPlxuICB9KVxuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbXBvbmVudC1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwicm93XCI+XG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyXCI+XG4gICAgICAgICAgPGg0IGNsYXNzTmFtZT1cInNlY3Rpb24tdGl0bGVcIj57IHByb3BzLmluZm8udGl0bGUgfTwvaDQ+XG4gICAgICAgICAgPGhyIGNsYXNzTmFtZT1cIm5vcm1hbC1kaXZpZGVyXCIgLz5cblxuICAgICAgICAgIHsgc2tpbGxMaXN0IH1cblxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFRlY2hTa2lsbHM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9wdWJsaWMvY29tcG9uZW50cy90ZWNoc2tpbGxzLmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcblxuY29uc3QgU2tpbGxzTGlzdCA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5za2lsbHMpIHtcbiAgICByZXR1cm4gPGRpdj48aSBjbGFzc05hbWU9XCJmYSBmYS1zcGlubmVyIGZhLXNwaW5cIiBhcmlhLWhpZGRlbj1cInRydWVcIj48L2k+PC9kaXY+O1xuICB9XG5cbiAgY29uc3Qgc2tpbGxzSXRlbXMgPSBwcm9wcy5za2lsbHMubWFwKGZ1bmN0aW9uKGl0ZW0pe1xuICAgIGlmKHByb3BzLnNraWxscy5pbmRleE9mKGl0ZW0pID09PSBwcm9wcy5za2lsbHMubGVuZ3RoLTEpe1xuICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBpdGVtICsgJywgJztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMiB0ZXh0LXJpZ2h0IGhpZGRlbi14c1wiPjxzdHJvbmc+e3Byb3BzLm5hbWV9Ojwvc3Ryb25nPjwvZGl2PlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wtc20tMiB2aXNpYmxlLXhzXCI+PHN0cm9uZz57cHJvcHMubmFtZX06PC9zdHJvbmc+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC1zbS0xMFwiPntza2lsbHNJdGVtc308L2Rpdj5cbiAgICA8L2Rpdj5cbiAgKVxufVxuXG5leHBvcnQgZGVmYXVsdCBTa2lsbHNMaXN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2NvbXBvbmVudHMvc2tpbGxzbGlzdC5qcyIsImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgRXhwZXJpZW5jZUl0ZW0gZnJvbSAnLi9leHBlcmllbnNlbGlzdCc7XG5cblxuY29uc3QgRXhwZXJpZW5jZSA9IChwcm9wcykgPT4ge1xuXG4gIGlmKCFwcm9wcy5pbmZvKSB7XG4gICAgcmV0dXJuIDxkaXY+PGkgY2xhc3NOYW1lPVwiZmEgZmEtc3Bpbm5lciBmYS1zcGluXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+PC9pPjwvZGl2PjtcbiAgfVxuXG4gIGNvbnN0IGV4cGVyaWVuY2VMaXN0SXRlbSA9IHByb3BzLmluZm8ud29yay5tYXAoZnVuY3Rpb24oaXRlbSwgaW5kZXgpe1xuICAgIHJldHVybiA8RXhwZXJpZW5jZUl0ZW0ga2V5PXtpbmRleH0gd29yaz17aXRlbX0gLz5cbiAgfSk7XG5cbiAgcmV0dXJuKFxuICAgIDxkaXYgY2xhc3NOYW1lPVwiY29tcG9uZW50LWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2wteHMtMTJcIj5cbiAgICAgICAgICA8aDQgY2xhc3NOYW1lPVwic2VjdGlvbi10aXRsZVwiPnsgcHJvcHMuaW5mby50aXRsZSB9PC9oND5cbiAgICAgICAgICA8aHIgY2xhc3NOYW1lPVwibm9ybWFsLWRpdmlkZXJcIiAvPlxuXG4gICAgICAgICAgeyBleHBlcmllbmNlTGlzdEl0ZW0gfVxuXG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcbn1cblxuZXhwb3J0IGRlZmF1bHQgRXhwZXJpZW5jZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL2V4cGVyaWVuY2UuanMiLCJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG5jb25zdCBFeHBlcmllbmNlSXRlbSA9IChwcm9wcykgPT4ge1xuXG4gIGNvbnN0IGR1dHkgPSBwcm9wcy53b3JrLmR1dHkubWFwKGZ1bmN0aW9uKGl0ZW1kdXR5LCBpbmRleCl7XG4gICAgcmV0dXJuIDxsaSBrZXk9e2luZGV4fT57aXRlbWR1dHl9PC9saT47XG4gIH0pO1xuXG4gIHJldHVybihcbiAgICA8ZGl2IGNsYXNzTmFtZT1cInJvdyB3b3JrLWluZm9cIj5cbiAgICAgIDxkaXYgY2xhc3NOYW1lPVwiY29sLXhzLTEyIGNvbC1zbS0zIGV4cC10aW1lXCI+PHN0cm9uZz57IHByb3BzLndvcmsudGltZSB9PC9zdHJvbmc+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy0xMiBjb2wtc20tOVwiPlxuICAgICAgICA8aDQ+eyBwcm9wcy53b3JrLmNvbXBhbnkgfTwvaDQ+XG4gICAgICAgIDxwPnsgcHJvcHMud29yay5vdmVydmlldyB9PC9wPlxuICAgICAgICA8aDU+PHN0cm9uZz57IHByb3BzLndvcmsuam9idGl0bGUgfTwvc3Ryb25nPjwvaDU+XG4gICAgICAgIDx1bD5cbiAgICAgICAgICB7IGR1dHkgfVxuICAgICAgICA8L3VsPlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIClcblxufVxuXG5leHBvcnQgZGVmYXVsdCBFeHBlcmllbmNlSXRlbTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL3B1YmxpYy9jb21wb25lbnRzL2V4cGVyaWVuc2VsaXN0LmpzIiwiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBPd2xDYXJvdXNlbCBmcm9tICdyZWFjdC1vd2wtY2Fyb3VzZWwyJztcblxuY29uc3QgUHJvamVjdHMgPSAocHJvcHMpID0+IHtcblxuICBpZighcHJvcHMuaW5mbykge1xuICAgIHJldHVybiA8ZGl2PjxpIGNsYXNzTmFtZT1cImZhIGZhLXNwaW5uZXIgZmEtc3BpblwiIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPjwvaT48L2Rpdj47XG4gIH1cblxuICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgaXRlbXM6IDQsXG4gICAgICBuYXY6IHRydWUsXG4gICAgICByZXdpbmQ6IHRydWUsXG4gICAgICByZXNwb25zaXZlOiB7XG4gICAgICAgIDA6IHtcbiAgICAgICAgICBpdGVtczogMSxcbiAgICAgICAgICBuYXY6IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgNjAwOiB7XG4gICAgICAgICAgaXRlbXM6IDMsXG4gICAgICAgICAgbmF2OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIDEwMDA6IHtcbiAgICAgICAgICBpdGVtczogNCxcbiAgICAgICAgICBuYXY6IHRydWVcbiAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGRpdiBjbGFzc05hbWU9XCJjb21wb25lbnQtY29udGFpbmVyXCI+XG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cInJvd1wiPlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy0xMlwiPlxuICAgICAgICAgIDxoNCBjbGFzc05hbWU9XCJzZWN0aW9uLXRpdGxlXCI+eyBwcm9wcy5pbmZvLnRpdGxlIH08L2g0PlxuICAgICAgICAgIDxociBjbGFzc05hbWU9XCJub3JtYWwtZGl2aWRlclwiIC8+XG4gICAgICAgIDwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbC14cy0xMlwiPlxuICAgICAgICAgIDxPd2xDYXJvdXNlbCBvcHRpb25zPXtvcHRpb25zfSA+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL2xlbW9uYWRlbW9uZXkuY29tL2hvbWVcIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+TGVtb25hZGU8YnIgLz4gTW9uZXk8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL2xlbW9uYWRlcmV3YXJkLmNvbVwiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5MZW1vbmFkZTxiciAvPiBSZXdhcmQ8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL2xlbW9uYWRlbW9uZXkuY29tL2J1ZGdldC9pbmNvbWVcIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+QnVkZ2V0PGJyIC8+IENhbGN1bGF0b3I8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL2xlbW9uYWRlbW9uZXkuY29tL2ZpbmFuY2lhbC1oZWFsdGgtY2hlY2svaW5jb21lXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPkZpbmFuY2lhbDxiciAvPiBIZWFsdGg8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cDovL3NpZW1lbnMubGVtb25hZGVyZXdhcmQuY29tL0RJR0lUQUwvUEFHRVMvcGVuc2lvbl9tb2RlbGxlci9cIiB0YXJnZXQ9XCJfYmxhbmtcIj48ZGl2IGNsYXNzTmFtZT1cImlubmVyLWltYWdlLWNvclwiPjxzdHJvbmc+UGVuc2lvbjxiciAvPiBNb2R1bGxlcjwvc3Ryb25nPjwvZGl2PjwvYT48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW1hZ2UtY29yIGNlbnRlci1ibG9ja1wiPjxhIGhyZWY9XCJodHRwOi8vbGVtb25hZGVtb25leS5jb20vbW9ydGdhZ2UtYXBwL3doaWNoLXByb3BlcnR5XCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPk1vcnRnYWdlPGJyIC8+IENhbGN1bGF0b3I8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL01heEdvbC9yZWFjdC1jYXJkc1wiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5DcmVkaXQ8YnIgLz4gKFJlYWN0KTwvc3Ryb25nPjwvZGl2PjwvYT48L2Rpdj5cbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiaW1hZ2UtY29yIGNlbnRlci1ibG9ja1wiPjxhIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vTWF4R29sL0NWX0hFUk9LVVwiIHRhcmdldD1cIl9ibGFua1wiPjxkaXYgY2xhc3NOYW1lPVwiaW5uZXItaW1hZ2UtY29yXCI+PHN0cm9uZz5DVjxiciAvPihSZWFjdCk8L3N0cm9uZz48L2Rpdj48L2E+PC9kaXY+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImltYWdlLWNvciBjZW50ZXItYmxvY2tcIj48YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL01heEdvbC9NRVJOXCIgdGFyZ2V0PVwiX2JsYW5rXCI+PGRpdiBjbGFzc05hbWU9XCJpbm5lci1pbWFnZS1jb3JcIj48c3Ryb25nPk1FUk48YnIgLz4gKFJlYWN0KTwvc3Ryb25nPjwvZGl2PjwvYT48L2Rpdj5cbiAgICAgICAgICA8L093bENhcm91c2VsPlxuICAgICAgICA8L2Rpdj5cbiAgICAgIDwvZGl2PlxuICAgIDwvZGl2PlxuICApXG59XG5cbmV4cG9ydCBkZWZhdWx0IFByb2plY3RzO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcHVibGljL2NvbXBvbmVudHMvcHJvamVjdHMuanMiLCIoZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpLCByZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW1wicHJvcC10eXBlc1wiLCBcInJlYWN0XCIsIFwicmVhY3QtZG9tXCJdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcInJlYWN0LW93bC1jYXJvdXNlbDJcIl0gPSBmYWN0b3J5KHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpLCByZXF1aXJlKFwicmVhY3RcIiksIHJlcXVpcmUoXCJyZWFjdC1kb21cIikpO1xuXHRlbHNlXG5cdFx0cm9vdFtcInJlYWN0LW93bC1jYXJvdXNlbDJcIl0gPSBmYWN0b3J5KHJvb3RbXCJQcm9wVHlwZXNcIl0sIHJvb3RbXCJSZWFjdFwiXSwgcm9vdFtcIlJlYWN0RE9NXCJdKTtcbn0pKHRoaXMsIGZ1bmN0aW9uKF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfNl9fLCBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzdfXywgX19XRUJQQUNLX0VYVEVSTkFMX01PRFVMRV84X18pIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fSxcbi8qKioqKiovIFx0XHRcdGlkOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGxvYWRlZDogZmFsc2Vcbi8qKioqKiovIFx0XHR9O1xuXG4vKioqKioqLyBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuXG5cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyoqKioqKi8gfSlcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyAoW1xuLyogMCAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXZhbChcIid1c2Ugc3RyaWN0JztcXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXFxcIl9fZXNNb2R1bGVcXFwiLCB7XFxuXFx0dmFsdWU6IHRydWVcXG59KTtcXG5cXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbnZhciBfcmVhY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xcblxcbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xcblxcbnZhciBfcmVhY3REb20gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xcblxcbnZhciBfcHJvcFR5cGVzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcXG5cXG52YXIgX3Byb3BUeXBlczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9wcm9wVHlwZXMpO1xcblxcbl9fd2VicGFja19yZXF1aXJlX18oNSk7XFxuXFxuX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcXG5cXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxcblxcbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7IGlmICghc2VsZikgeyB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXFxcInRoaXMgaGFzbid0IGJlZW4gaW5pdGlhbGlzZWQgLSBzdXBlcigpIGhhc24ndCBiZWVuIGNhbGxlZFxcXCIpOyB9IHJldHVybiBjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXFxcIm9iamVjdFxcXCIgfHwgdHlwZW9mIGNhbGwgPT09IFxcXCJmdW5jdGlvblxcXCIpID8gY2FsbCA6IHNlbGY7IH1cXG5cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgaWYgKHR5cGVvZiBzdXBlckNsYXNzICE9PSBcXFwiZnVuY3Rpb25cXFwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb24sIG5vdCBcXFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpOyB9IHN1YkNsYXNzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDbGFzcyAmJiBzdXBlckNsYXNzLnByb3RvdHlwZSwgeyBjb25zdHJ1Y3RvcjogeyB2YWx1ZTogc3ViQ2xhc3MsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0gfSk7IGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzczsgfVxcblxcbnZhciBvd2xDYXJvdXNlbE9wdGlvbnMgPSB7XFxuXFx0Y29yZTogWydpdGVtcycsICdsb29wJywgJ2NlbnRlcicsICdyZXdpbmQnLCAnbW91c2VEcmFnJywgJ3RvdWNoRHJhZycsICdwdWxsRHJhZycsICdmcmVlRHJhZycsICdtYXJnaW4nLCAnc3RhZ2VQYWRkaW5nJywgJ21lcmdlJywgJ21lcmdlRml0JywgJ2F1dG9XaWR0aCcsICdzdGFydFBvc2l0aW9uJywgJ3J0bCcsICdzbWFydFNwZWVkJywgJ2ZsdWlkU3BlZWQnLCAnZHJhZ0VuZFNwZWVkJywgJ3Jlc3BvbnNpdmUnLCAncmVzcG9uc2l2ZVJlZnJlc2hSYXRlJywgJ3Jlc3BvbnNpdmVCYXNlRWxlbWVudCcsICdmYWxsYmFja0Vhc2luZycsICdpbmZvJywgJ25lc3RlZEl0ZW1TZWxlY3RvcicsICdpdGVtRWxlbWVudCcsICdzdGFnZUVsZW1lbnQnLCAncmVmcmVzaENsYXNzJywgJ2xvYWRlZENsYXNzJywgJ2xvYWRpbmdDbGFzcycsICdydGxDbGFzcycsICdyZXNwb25zaXZlQ2xhc3MnLCAnZHJhZ0NsYXNzJywgJ2l0ZW1DbGFzcycsICdzdGFnZUNsYXNzJywgJ3N0YWdlT3V0ZXJDbGFzcycsICdncmFiQ2xhc3MnXSxcXG5cXHRhdXRvcmVmcmVzaDogWydhdXRvUmVmcmVzaCcsICdhdXRvUmVmcmVzaEludGVydmFsJ10sXFxuXFx0bGF6eTogWydsYXp5TG9hZCddLFxcblxcdGF1dG9IZWlnaHQ6IFsnYXV0b0hlaWdodCcsICdhdXRvSGVpZ2h0Q2xhc3MnXSxcXG5cXHR2aWRlbzogWyd2aWRlbycsICd2aWRlb0hlaWdodCcsICd2aWRlb1dpZHRoJ10sXFxuXFx0YW5pbWF0ZTogWydhbmltYXRlT3V0JywgJ2FuaW1hdGVJbiddLFxcblxcdGF1dG9wbGF5OiBbJ2F1dG9wbGF5JywgJ2F1dG9wbGF5VGltZW91dCcsICdhdXRvcGxheUhvdmVyUGF1c2UnLCAnYXV0b3BsYXlTcGVlZCddLFxcblxcdG5hdmlnYXRpb246IFsnbmF2JywgJ25hdlRleHQnLCAnbmF2U3BlZWQnLCAnbmF2RWxlbWVudCcsICduYXZDb250YWluZXInLCAnbmF2Q29udGFpbmVyQ2xhc3MnLCAnbmF2Q2xhc3MnLCAnc2xpZGVCeScsICdkb3RDbGFzcycsICdkb3RzQ2xhc3MnLCAnZG90cycsICdkb3RzRWFjaCcsICdkb3RzRGF0YScsICdkb3RzU3BlZWQnLCAnZG90c0NvbnRhaW5lciddLFxcblxcdGhhc2g6IFsnVVJMaGFzaExpc3RlbmVyJ11cXG59O1xcblxcbnZhciBvd2xDYXJvdXNlbEV2ZW50cyA9IHtcXG5cXHRjb3JlOiBbJ29uSW5pdGlhbGl6ZScsICdvbkluaXRpYWxpemVkJywgJ29uUmVzaXplJywgJ29uUmVzaXplZCcsICdvblJlZnJlc2gnLCAnb25SZWZyZXNoZWQnLCAnb25EcmFnJywgJ29uRHJhZ2dlZCcsICdvblRyYW5zbGF0ZScsICdvblRyYW5zbGF0ZWQnLCAnb25DaGFuZ2UnLCAnb25DaGFuZ2VkJ10sXFxuXFx0bGF6eTogWydvbkxvYWRMYXp5JywgJ29uTG9hZGVkTGF6eSddLFxcblxcdHZpZGVvOiBbJ29uU3RvcFZpZGVvJywgJ29uUGxheVZpZGVvJ11cXG59O1xcblxcbnZhciBPd2xDYXJvdXNlbCA9IGZ1bmN0aW9uIChfUmVhY3QkQ29tcG9uZW50KSB7XFxuXFx0X2luaGVyaXRzKE93bENhcm91c2VsLCBfUmVhY3QkQ29tcG9uZW50KTtcXG5cXG5cXHRmdW5jdGlvbiBPd2xDYXJvdXNlbChwcm9wcywgY29udGV4dCkge1xcblxcdFxcdF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPd2xDYXJvdXNlbCk7XFxuXFxuXFx0XFx0dmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKE93bENhcm91c2VsLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2YoT3dsQ2Fyb3VzZWwpKS5jYWxsKHRoaXMsIHByb3BzLCBjb250ZXh0KSk7XFxuXFxuXFx0XFx0X3RoaXMub25UcmFuc2xhdGUgPSBmdW5jdGlvbiAobmV4dCkge1xcblxcdFxcdFxcdHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcXG5cXHRcXHRcXHRcXHRfdGhpcy5jdXJyZW50UG9zaXRpb24gPSBldmVudC5pdGVtLmluZGV4O1xcblxcdFxcdFxcdFxcdGlmIChuZXh0KSBuZXh0KGV2ZW50KTtcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH07XFxuXFxuXFx0XFx0X3RoaXMubmV4dCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gX3RoaXMuJGNhci5uZXh0KCk7XFxuXFx0XFx0fTtcXG5cXHRcXHRfdGhpcy5wcmV2ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHJldHVybiBfdGhpcy4kY2FyLnByZXYoKTtcXG5cXHRcXHR9O1xcblxcdFxcdF90aGlzLmdvVG8gPSBmdW5jdGlvbiAoeCkge1xcblxcdFxcdFxcdHJldHVybiBfdGhpcy4kY2FyLnRvKHgpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0X3RoaXMuY3VycmVudFBvc2l0aW9uID0gMDtcXG5cXHRcXHRfdGhpcy5vblRyYW5zbGF0ZSA9IF90aGlzLm9uVHJhbnNsYXRlLmJpbmQoX3RoaXMpO1xcblxcdFxcdHJldHVybiBfdGhpcztcXG5cXHR9XFxuXFxuXFx0X2NyZWF0ZUNsYXNzKE93bENhcm91c2VsLCBbe1xcblxcdFxcdGtleTogJ2NvbXBvbmVudERpZE1vdW50JyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50RGlkTW91bnQoKSB7XFxuXFx0XFx0XFx0dGhpcy4kbm9kZSA9ICQoKDAsIF9yZWFjdERvbS5maW5kRE9NTm9kZSkodGhpcykpO1xcblxcdFxcdFxcdHZhciBvcHRpb25zID0gdGhpcy5nZXRPcHRpb25zKCk7XFxuXFx0XFx0XFx0dGhpcy5pbml0KG9wdGlvbnMpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0a2V5OiAnY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcycsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XFxuXFx0XFx0XFx0dGhpcy5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdjb21wb25lbnREaWRVcGRhdGUnLFxcblxcdFxcdHZhbHVlOiBmdW5jdGlvbiBjb21wb25lbnREaWRVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IHRoaXMuZ2V0T3B0aW9ucygpO1xcblxcdFxcdFxcdG9wdGlvbnMuc3RhcnRQb3NpdGlvbiA9IHRoaXMuY3VycmVudFBvc2l0aW9uO1xcblxcdFxcdFxcdHRoaXMuaW5pdChvcHRpb25zKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGtleTogJ2NvbXBvbmVudFdpbGxVbm1vdW50JyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XFxuXFx0XFx0XFx0dGhpcy5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdpbml0JyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XFxuXFx0XFx0XFx0dmFyIG5leHQgPSBvcHRpb25zLm9uVHJhbnNsYXRlO1xcblxcdFxcdFxcdG9wdGlvbnMub25UcmFuc2xhdGUgPSB0aGlzLm9uVHJhbnNsYXRlKG5leHQpO1xcblxcdFxcdFxcdHRoaXMuJG5vZGUub3dsQ2Fyb3VzZWwob3B0aW9ucyk7XFxuXFx0XFx0XFx0dGhpcy4kY2FyID0gdGhpcy4kbm9kZS5kYXRhKCdvd2wuY2Fyb3VzZWwnKTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGtleTogJ2Rlc3Ryb3knLFxcblxcdFxcdHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xcblxcdFxcdFxcdHRoaXMuJGNhci5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRrZXk6ICdnZXRPcHRpb25zJyxcXG5cXHRcXHR2YWx1ZTogZnVuY3Rpb24gZ2V0T3B0aW9ucygpIHtcXG5cXHRcXHRcXHR2YXIgX3RoaXMyID0gdGhpcztcXG5cXG5cXHRcXHRcXHR2YXIgb3B0aW9ucyA9IHt9O1xcblxcblxcdFxcdFxcdHZhciBjYXJPcHRpb25zID0gT2JqZWN0LnZhbHVlcyhvd2xDYXJvdXNlbE9wdGlvbnMpLnJlZHVjZShmdW5jdGlvbiAoYSwgdikge1xcblxcdFxcdFxcdFxcdHJldHVybiBhLmNvbmNhdCh2KTtcXG5cXHRcXHRcXHR9LCBbXSk7XFxuXFxuXFx0XFx0XFx0Y2FyT3B0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcXG5cXHRcXHRcXHRcXHRpZiAodmFsIGluIF90aGlzMi5wcm9wcy5vcHRpb25zKSBvcHRpb25zW3ZhbF0gPSBfdGhpczIucHJvcHMub3B0aW9uc1t2YWxdO1xcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHZhciBjYXJFdmVudHMgPSBPYmplY3QudmFsdWVzKG93bENhcm91c2VsRXZlbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGEsIHYpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gYS5jb25jYXQodik7XFxuXFx0XFx0XFx0fSwgW10pO1xcblxcblxcdFxcdFxcdGNhckV2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uICh2YWwpIHtcXG5cXHRcXHRcXHRcXHRpZiAodmFsIGluIF90aGlzMi5wcm9wcy5ldmVudHMpIG9wdGlvbnNbdmFsXSA9IF90aGlzMi5wcm9wcy5ldmVudHNbdmFsXTtcXG5cXHRcXHRcXHR9KTtcXG5cXG5cXHRcXHRcXHRyZXR1cm4gb3B0aW9ucztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGtleTogJ3JlbmRlcicsXFxuXFx0XFx0dmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcXG5cXHRcXHRcXHR2YXIgX3Byb3BzID0gdGhpcy5wcm9wcyxcXG5cXHRcXHRcXHQgICAgb3B0aW9ucyA9IF9wcm9wcy5vcHRpb25zLFxcblxcdFxcdFxcdCAgICBldmVudHMgPSBfcHJvcHMuZXZlbnRzLFxcblxcdFxcdFxcdCAgICBjaGlsZHJlbiA9IF9wcm9wcy5jaGlsZHJlbixcXG5cXHRcXHRcXHQgICAgcHJvcHMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX3Byb3BzLCBbJ29wdGlvbnMnLCAnZXZlbnRzJywgJ2NoaWxkcmVuJ10pO1xcblxcblxcdFxcdFxcdHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChcXG5cXHRcXHRcXHRcXHQnZGl2JyxcXG5cXHRcXHRcXHRcXHRfZXh0ZW5kcyh7IGNsYXNzTmFtZTogJ293bC1jYXJvdXNlbCBvd2wtdGhlbWUnIH0sIHByb3BzKSxcXG5cXHRcXHRcXHRcXHRjaGlsZHJlblxcblxcdFxcdFxcdCk7XFxuXFx0XFx0fVxcblxcdH1dKTtcXG5cXG5cXHRyZXR1cm4gT3dsQ2Fyb3VzZWw7XFxufShfcmVhY3QyLmRlZmF1bHQuQ29tcG9uZW50KTtcXG5cXG5Pd2xDYXJvdXNlbC5wcm9wVHlwZXMgPSB7XFxuXFx0Y2hpbGRyZW46IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LmVsZW1lbnQsIF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXlPZihfcHJvcFR5cGVzMi5kZWZhdWx0LmVsZW1lbnQuaXNSZXF1aXJlZCldKS5pc1JlcXVpcmVkLFxcblxcblxcdHN0eWxlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9iamVjdCxcXG5cXHRpZDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFxuXFx0b3B0aW9uczogX3Byb3BUeXBlczIuZGVmYXVsdC5zaGFwZSh7XFxuXFx0XFx0Ly8gY29yZVxcblxcdFxcdGl0ZW1zOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcXG5cXHRcXHRsb29wOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0Y2VudGVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0cmV3aW5kOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0bW91c2VEcmFnOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0dG91Y2hEcmFnOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0cHVsbERyYWc6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRmcmVlRHJhZzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdG1hcmdpbjogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0c3RhZ2VQYWRkaW5nOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcXG5cXG5cXHRcXHRtZXJnZTogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdG1lcmdlRml0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0YXV0b1dpZHRoOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0c3RhcnRQb3NpdGlvbjogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0cnRsOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0c21hcnRTcGVlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0Zmx1aWRTcGVlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGRyYWdFbmRTcGVlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdHJlc3BvbnNpdmU6IF9wcm9wVHlwZXMyLmRlZmF1bHQub25lT2ZUeXBlKFtfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsIF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0XSksXFxuXFx0XFx0cmVzcG9uc2l2ZVJlZnJlc2hSYXRlOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcXG5cXHRcXHRyZXNwb25zaXZlQmFzZUVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQub2JqZWN0LFxcblxcblxcdFxcdGZhbGxiYWNrRWFzaW5nOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXG5cXHRcXHRpbmZvOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0bmVzdGVkSXRlbVNlbGVjdG9yOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0aXRlbUVsZW1lbnQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdHN0YWdlRWxlbWVudDogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFxuXFx0XFx0cmVmcmVzaENsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRsb2FkZWRDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0bG9hZGluZ0NsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRydGxDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0cmVzcG9uc2l2ZUNsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRkcmFnQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdGl0ZW1DbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0c3RhZ2VDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0c3RhZ2VPdXRlckNsYXNzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRncmFiQ2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcblxcdFxcdC8vIGF1dG9SZWZyZXNoXFxuXFx0XFx0YXV0b1JlZnJlc2g6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRhdXRvUmVmcmVzaEludGVydmFsOiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcXG5cXG5cXHRcXHQvLyBsYXp5XFxuXFx0XFx0bGF6eUxvYWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXG5cXHRcXHQvLyBhdXRvSGVpZ2h0XFxuXFx0XFx0YXV0b0hlaWdodDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGF1dG9IZWlnaHRDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFxuXFx0XFx0Ly8gdmlkZW9cXG5cXHRcXHR2aWRlbzogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdHZpZGVvSGVpZ2h0OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0dmlkZW9XaWR0aDogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcblxcdFxcdC8vIGFuaW1hdGVcXG5cXHRcXHRhbmltYXRlT3V0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm9uZU9mVHlwZShbX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLCBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZ10pLFxcblxcdFxcdGFuaW1hdGVJbjogX3Byb3BUeXBlczIuZGVmYXVsdC5vbmVPZlR5cGUoW19wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCwgX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmddKSxcXG5cXG5cXHRcXHQvLyBhdXRvcGxheVxcblxcdFxcdGF1dG9wbGF5OiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0YXV0b3BsYXlUaW1lb3V0OiBfcHJvcFR5cGVzMi5kZWZhdWx0Lm51bWJlcixcXG5cXHRcXHRhdXRvcGxheUhvdmVyUGF1c2U6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRhdXRvcGxheVNwZWVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0Ly8gbmF2aWdhdGlvblxcblxcdFxcdG5hdjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdG5hdlRleHQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXksXFxuXFx0XFx0bmF2U3BlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRuYXZFbGVtZW50OiBfcHJvcFR5cGVzMi5kZWZhdWx0LnN0cmluZyxcXG5cXHRcXHRuYXZDb250YWluZXI6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRuYXZDb250YWluZXJDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0bmF2Q2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYXJyYXksXFxuXFx0XFx0c2xpZGVCeTogX3Byb3BUeXBlczIuZGVmYXVsdC5udW1iZXIsXFxuXFx0XFx0ZG90Q2xhc3M6IF9wcm9wVHlwZXMyLmRlZmF1bHQuc3RyaW5nLFxcblxcdFxcdGRvdHNDbGFzczogX3Byb3BUeXBlczIuZGVmYXVsdC5zdHJpbmcsXFxuXFx0XFx0ZG90czogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sLFxcblxcdFxcdGRvdHNFYWNoOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFx0XFx0ZG90c0RhdGE6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRkb3RzU3BlZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuYm9vbCxcXG5cXHRcXHRkb3RzQ29udGFpbmVyOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmJvb2wsXFxuXFxuXFx0XFx0Ly8gaGFzaFxcblxcdFxcdFVSTGhhc2hMaXN0ZW5lcjogX3Byb3BUeXBlczIuZGVmYXVsdC5ib29sXFxuXFx0fSksXFxuXFxuXFx0ZXZlbnRzOiBfcHJvcFR5cGVzMi5kZWZhdWx0LnNoYXBlKHtcXG5cXHRcXHQvLyBjb3JlXFxuXFx0XFx0b25Jbml0aWFsaXplOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25Jbml0aWFsaXplZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uUmVzaXplOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25SZXNpemVkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25SZWZyZXNoOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25SZWZyZXNoZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvbkRyYWc6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvbkRyYWdnZWQ6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvblRyYW5zbGF0ZTogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uVHJhbnNsYXRlZDogX3Byb3BUeXBlczIuZGVmYXVsdC5mdW5jLFxcblxcdFxcdG9uQ2hhbmdlOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25DaGFuZ2VkOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFxuXFx0XFx0Ly8gbGF6eVxcblxcdFxcdG9uTG9hZExhenk6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXHRcXHRvbkxvYWRlZExhenk6IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuYyxcXG5cXG5cXHRcXHQvLyB2aWRlb1xcblxcdFxcdG9uU3RvcFZpZGVvOiBfcHJvcFR5cGVzMi5kZWZhdWx0LmZ1bmMsXFxuXFx0XFx0b25QbGF5VmlkZW86IF9wcm9wVHlwZXMyLmRlZmF1bHQuZnVuY1xcblxcdH0pXFxufTtcXG5cXG5Pd2xDYXJvdXNlbC5kZWZhdWx0UHJvcHMgPSB7XFxuXFx0b3B0aW9uczoge30sXFxuXFx0ZXZlbnRzOiB7fVxcbn07XFxuXFxuZXhwb3J0cy5kZWZhdWx0ID0gT3dsQ2Fyb3VzZWw7XFxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIC4vY29tcG9uZW50cy9Pd2xDYXJvdXNlbC5qc3hcXG4gKiogbW9kdWxlIGlkID0gMFxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9jb21wb25lbnRzL093bENhcm91c2VsLmpzeD9cIik7XG5cbi8qKiovIH0sXG4vKiAxICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRldmFsKFwiJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcXFwic3ltYm9sXFxcIiA/IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmo7IH0gOiBmdW5jdGlvbiAob2JqKSB7IHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcXFwic3ltYm9sXFxcIiA6IHR5cGVvZiBvYmo7IH07XFxuXFxuLyoqXFxuICogT3dsIENhcm91c2VsIHYyLjIuMVxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTcgRGF2aWQgRGV1dHNjaFxcbiAqIExpY2Vuc2VkIHVuZGVyICAoKVxcbiAqL1xcbi8qKlxcbiAqIE93bCBjYXJvdXNlbFxcbiAqIEB2ZXJzaW9uIDIuMS42XFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKiBAdG9kbyBMYXp5IExvYWQgSWNvblxcbiAqIEB0b2RvIHByZXZlbnQgYW5pbWF0aW9uZW5kIGJ1YmxpbmdcXG4gKiBAdG9kbyBpdGVtc1NjYWxlVXBcXG4gKiBAdG9kbyBUZXN0IFplcHRvXFxuICogQHRvZG8gc3RhZ2VQYWRkaW5nIGNhbGN1bGF0ZSB3cm9uZyBhY3RpdmUgY2xhc3Nlc1xcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIGEgY2Fyb3VzZWwuXFxuICAqIEBjbGFzcyBUaGUgT3dsIENhcm91c2VsLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gY3JlYXRlIHRoZSBjYXJvdXNlbCBmb3IuXFxuICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBUaGUgb3B0aW9uc1xcbiAgKi9cXG5cXHRmdW5jdGlvbiBPd2woZWxlbWVudCwgb3B0aW9ucykge1xcblxcblxcdFxcdC8qKlxcbiAgICogQ3VycmVudCBzZXR0aW5ncyBmb3IgdGhlIGNhcm91c2VsLlxcbiAgICogQHB1YmxpY1xcbiAgICovXFxuXFx0XFx0dGhpcy5zZXR0aW5ncyA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50IG9wdGlvbnMgc2V0IGJ5IHRoZSBjYWxsZXIgaW5jbHVkaW5nIGRlZmF1bHRzLlxcbiAgICogQHB1YmxpY1xcbiAgICovXFxuXFx0XFx0dGhpcy5vcHRpb25zID0gJC5leHRlbmQoe30sIE93bC5EZWZhdWx0cywgb3B0aW9ucyk7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBQbHVnaW4gZWxlbWVudC5cXG4gICAqIEBwdWJsaWNcXG4gICAqL1xcblxcdFxcdHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcblxcblxcdFxcdC8qKlxcbiAgICogUHJveGllZCBldmVudCBoYW5kbGVycy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2VzIHRvIHRoZSBydW5uaW5nIHBsdWdpbnMgb2YgdGhpcyBjYXJvdXNlbC5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX3BsdWdpbnMgPSB7fTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEN1cnJlbnRseSBzdXBwcmVzc2VkIGV2ZW50cyB0byBwcmV2ZW50IHRoZW0gZnJvbSBiZWVpbmcgcmV0cmlnZ2VyZWQuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9zdXByZXNzID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBYnNvbHV0ZSBjdXJyZW50IHBvc2l0aW9uLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5fY3VycmVudCA9IG51bGw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICovXFxuXFx0XFx0dGhpcy5fc3BlZWQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQ29vcmRpbmF0ZXMgb2YgYWxsIGl0ZW1zIGluIHBpeGVsLlxcbiAgICogQHRvZG8gVGhlIG5hbWUgb2YgdGhpcyBtZW1iZXIgaXMgbWlzc2xlYWRpbmcuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9jb29yZGluYXRlcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogQ3VycmVudCBicmVha3BvaW50LlxcbiAgICogQHRvZG8gUmVhbCBtZWRpYSBxdWVyaWVzIHdvdWxkIGJlIG5pY2UuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9icmVha3BvaW50ID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEN1cnJlbnQgd2lkdGggb2YgdGhlIHBsdWdpbiBlbGVtZW50LlxcbiAgICovXFxuXFx0XFx0dGhpcy5fd2lkdGggPSBudWxsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIHJlYWwgaXRlbXMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9pdGVtcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIGNsb25lZCBpdGVtcy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX2Nsb25lcyA9IFtdO1xcblxcblxcdFxcdC8qKlxcbiAgICogTWVyZ2UgdmFsdWVzIG9mIGFsbCBpdGVtcy5cXG4gICAqIEB0b2RvIE1heWJlIHRoaXMgY291bGQgYmUgcGFydCBvZiBhIHBsdWdpbi5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX21lcmdlcnMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFdpZHRocyBvZiBhbGwgaXRlbXMuXFxuICAgKi9cXG5cXHRcXHR0aGlzLl93aWR0aHMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEludmFsaWRhdGVkIHBhcnRzIHdpdGhpbiB0aGUgdXBkYXRlIHByb2Nlc3MuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKi9cXG5cXHRcXHR0aGlzLl9pbnZhbGlkYXRlZCA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogT3JkZXJlZCBsaXN0IG9mIHdvcmtlcnMgZm9yIHRoZSB1cGRhdGUgcHJvY2Vzcy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX3BpcGUgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEN1cnJlbnQgc3RhdGUgaW5mb3JtYXRpb24gZm9yIHRoZSBkcmFnIG9wZXJhdGlvbi5cXG4gICAqIEB0b2RvICMyNjFcXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX2RyYWcgPSB7XFxuXFx0XFx0XFx0dGltZTogbnVsbCxcXG5cXHRcXHRcXHR0YXJnZXQ6IG51bGwsXFxuXFx0XFx0XFx0cG9pbnRlcjogbnVsbCxcXG5cXHRcXHRcXHRzdGFnZToge1xcblxcdFxcdFxcdFxcdHN0YXJ0OiBudWxsLFxcblxcdFxcdFxcdFxcdGN1cnJlbnQ6IG51bGxcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdGRpcmVjdGlvbjogbnVsbFxcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50IHN0YXRlIGluZm9ybWF0aW9uIGFuZCB0aGVpciB0YWdzLlxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqL1xcblxcdFxcdHRoaXMuX3N0YXRlcyA9IHtcXG5cXHRcXHRcXHRjdXJyZW50OiB7fSxcXG5cXHRcXHRcXHR0YWdzOiB7XFxuXFx0XFx0XFx0XFx0J2luaXRpYWxpemluZyc6IFsnYnVzeSddLFxcblxcdFxcdFxcdFxcdCdhbmltYXRpbmcnOiBbJ2J1c3knXSxcXG5cXHRcXHRcXHRcXHQnZHJhZ2dpbmcnOiBbJ2ludGVyYWN0aW5nJ11cXG5cXHRcXHRcXHR9XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQkLmVhY2goWydvblJlc2l6ZScsICdvblRocm90dGxlZFJlc2l6ZSddLCAkLnByb3h5KGZ1bmN0aW9uIChpLCBoYW5kbGVyKSB7XFxuXFx0XFx0XFx0dGhpcy5faGFuZGxlcnNbaGFuZGxlcl0gPSAkLnByb3h5KHRoaXNbaGFuZGxlcl0sIHRoaXMpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQkLmVhY2goT3dsLlBsdWdpbnMsICQucHJveHkoZnVuY3Rpb24gKGtleSwgcGx1Z2luKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGx1Z2luc1trZXkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkgKyBrZXkuc2xpY2UoMSldID0gbmV3IHBsdWdpbih0aGlzKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0JC5lYWNoKE93bC5Xb3JrZXJzLCAkLnByb3h5KGZ1bmN0aW9uIChwcmlvcml0eSwgd29ya2VyKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGlwZS5wdXNoKHtcXG5cXHRcXHRcXHRcXHQnZmlsdGVyJzogd29ya2VyLmZpbHRlcixcXG5cXHRcXHRcXHRcXHQncnVuJzogJC5wcm94eSh3b3JrZXIucnVuLCB0aGlzKVxcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHR0aGlzLnNldHVwKCk7XFxuXFx0XFx0dGhpcy5pbml0aWFsaXplKCk7XFxuXFx0fVxcblxcblxcdC8qKlxcbiAgKiBEZWZhdWx0IG9wdGlvbnMgZm9yIHRoZSBjYXJvdXNlbC5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRPd2wuRGVmYXVsdHMgPSB7XFxuXFx0XFx0aXRlbXM6IDMsXFxuXFx0XFx0bG9vcDogZmFsc2UsXFxuXFx0XFx0Y2VudGVyOiBmYWxzZSxcXG5cXHRcXHRyZXdpbmQ6IGZhbHNlLFxcblxcblxcdFxcdG1vdXNlRHJhZzogdHJ1ZSxcXG5cXHRcXHR0b3VjaERyYWc6IHRydWUsXFxuXFx0XFx0cHVsbERyYWc6IHRydWUsXFxuXFx0XFx0ZnJlZURyYWc6IGZhbHNlLFxcblxcblxcdFxcdG1hcmdpbjogMCxcXG5cXHRcXHRzdGFnZVBhZGRpbmc6IDAsXFxuXFxuXFx0XFx0bWVyZ2U6IGZhbHNlLFxcblxcdFxcdG1lcmdlRml0OiB0cnVlLFxcblxcdFxcdGF1dG9XaWR0aDogZmFsc2UsXFxuXFxuXFx0XFx0c3RhcnRQb3NpdGlvbjogMCxcXG5cXHRcXHRydGw6IGZhbHNlLFxcblxcblxcdFxcdHNtYXJ0U3BlZWQ6IDI1MCxcXG5cXHRcXHRmbHVpZFNwZWVkOiBmYWxzZSxcXG5cXHRcXHRkcmFnRW5kU3BlZWQ6IGZhbHNlLFxcblxcblxcdFxcdHJlc3BvbnNpdmU6IHt9LFxcblxcdFxcdHJlc3BvbnNpdmVSZWZyZXNoUmF0ZTogMjAwLFxcblxcdFxcdHJlc3BvbnNpdmVCYXNlRWxlbWVudDogd2luZG93LFxcblxcblxcdFxcdGZhbGxiYWNrRWFzaW5nOiAnc3dpbmcnLFxcblxcblxcdFxcdGluZm86IGZhbHNlLFxcblxcblxcdFxcdG5lc3RlZEl0ZW1TZWxlY3RvcjogZmFsc2UsXFxuXFx0XFx0aXRlbUVsZW1lbnQ6ICdkaXYnLFxcblxcdFxcdHN0YWdlRWxlbWVudDogJ2RpdicsXFxuXFxuXFx0XFx0cmVmcmVzaENsYXNzOiAnb3dsLXJlZnJlc2gnLFxcblxcdFxcdGxvYWRlZENsYXNzOiAnb3dsLWxvYWRlZCcsXFxuXFx0XFx0bG9hZGluZ0NsYXNzOiAnb3dsLWxvYWRpbmcnLFxcblxcdFxcdHJ0bENsYXNzOiAnb3dsLXJ0bCcsXFxuXFx0XFx0cmVzcG9uc2l2ZUNsYXNzOiAnb3dsLXJlc3BvbnNpdmUnLFxcblxcdFxcdGRyYWdDbGFzczogJ293bC1kcmFnJyxcXG5cXHRcXHRpdGVtQ2xhc3M6ICdvd2wtaXRlbScsXFxuXFx0XFx0c3RhZ2VDbGFzczogJ293bC1zdGFnZScsXFxuXFx0XFx0c3RhZ2VPdXRlckNsYXNzOiAnb3dsLXN0YWdlLW91dGVyJyxcXG5cXHRcXHRncmFiQ2xhc3M6ICdvd2wtZ3JhYidcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBFbnVtZXJhdGlvbiBmb3Igd2lkdGguXFxuICAqIEBwdWJsaWNcXG4gICogQHJlYWRvbmx5XFxuICAqIEBlbnVtIHtTdHJpbmd9XFxuICAqL1xcblxcdE93bC5XaWR0aCA9IHtcXG5cXHRcXHREZWZhdWx0OiAnZGVmYXVsdCcsXFxuXFx0XFx0SW5uZXI6ICdpbm5lcicsXFxuXFx0XFx0T3V0ZXI6ICdvdXRlcidcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBFbnVtZXJhdGlvbiBmb3IgdHlwZXMuXFxuICAqIEBwdWJsaWNcXG4gICogQHJlYWRvbmx5XFxuICAqIEBlbnVtIHtTdHJpbmd9XFxuICAqL1xcblxcdE93bC5UeXBlID0ge1xcblxcdFxcdEV2ZW50OiAnZXZlbnQnLFxcblxcdFxcdFN0YXRlOiAnc3RhdGUnXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ29udGFpbnMgYWxsIHJlZ2lzdGVyZWQgcGx1Z2lucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRPd2wuUGx1Z2lucyA9IHt9O1xcblxcblxcdC8qKlxcbiAgKiBMaXN0IG9mIHdvcmtlcnMgaW52b2x2ZWQgaW4gdGhlIHVwZGF0ZSBwcm9jZXNzLlxcbiAgKi9cXG5cXHRPd2wuV29ya2VycyA9IFt7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dGhpcy5fd2lkdGggPSB0aGlzLiRlbGVtZW50LndpZHRoKCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bihjYWNoZSkge1xcblxcdFxcdFxcdGNhY2hlLmN1cnJlbnQgPSB0aGlzLl9pdGVtcyAmJiB0aGlzLl9pdGVtc1t0aGlzLnJlbGF0aXZlKHRoaXMuX2N1cnJlbnQpXTtcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWydpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bihjYWNoZSkge1xcblxcdFxcdFxcdHZhciBtYXJnaW4gPSB0aGlzLnNldHRpbmdzLm1hcmdpbiB8fCAnJyxcXG5cXHRcXHRcXHQgICAgZ3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcXG5cXHRcXHRcXHQgICAgcnRsID0gdGhpcy5zZXR0aW5ncy5ydGwsXFxuXFx0XFx0XFx0ICAgIGNzcyA9IHtcXG5cXHRcXHRcXHRcXHQnd2lkdGgnOiAnYXV0bycsXFxuXFx0XFx0XFx0XFx0J21hcmdpbi1sZWZ0JzogcnRsID8gbWFyZ2luIDogJycsXFxuXFx0XFx0XFx0XFx0J21hcmdpbi1yaWdodCc6IHJ0bCA/ICcnIDogbWFyZ2luXFxuXFx0XFx0XFx0fTtcXG5cXG5cXHRcXHRcXHQhZ3JpZCAmJiB0aGlzLiRzdGFnZS5jaGlsZHJlbigpLmNzcyhjc3MpO1xcblxcblxcdFxcdFxcdGNhY2hlLmNzcyA9IGNzcztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKGNhY2hlKSB7XFxuXFx0XFx0XFx0dmFyIHdpZHRoID0gKHRoaXMud2lkdGgoKSAvIHRoaXMuc2V0dGluZ3MuaXRlbXMpLnRvRml4ZWQoMykgLSB0aGlzLnNldHRpbmdzLm1hcmdpbixcXG5cXHRcXHRcXHQgICAgbWVyZ2UgPSBudWxsLFxcblxcdFxcdFxcdCAgICBpdGVyYXRvciA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgZ3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcXG5cXHRcXHRcXHQgICAgd2lkdGhzID0gW107XFxuXFxuXFx0XFx0XFx0Y2FjaGUuaXRlbXMgPSB7XFxuXFx0XFx0XFx0XFx0bWVyZ2U6IGZhbHNlLFxcblxcdFxcdFxcdFxcdHdpZHRoOiB3aWR0aFxcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcXG5cXHRcXHRcXHRcXHRtZXJnZSA9IHRoaXMuX21lcmdlcnNbaXRlcmF0b3JdO1xcblxcdFxcdFxcdFxcdG1lcmdlID0gdGhpcy5zZXR0aW5ncy5tZXJnZUZpdCAmJiBNYXRoLm1pbihtZXJnZSwgdGhpcy5zZXR0aW5ncy5pdGVtcykgfHwgbWVyZ2U7XFxuXFxuXFx0XFx0XFx0XFx0Y2FjaGUuaXRlbXMubWVyZ2UgPSBtZXJnZSA+IDEgfHwgY2FjaGUuaXRlbXMubWVyZ2U7XFxuXFxuXFx0XFx0XFx0XFx0d2lkdGhzW2l0ZXJhdG9yXSA9ICFncmlkID8gdGhpcy5faXRlbXNbaXRlcmF0b3JdLndpZHRoKCkgOiB3aWR0aCAqIG1lcmdlO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLl93aWR0aHMgPSB3aWR0aHM7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bigpIHtcXG5cXHRcXHRcXHR2YXIgY2xvbmVzID0gW10sXFxuXFx0XFx0XFx0ICAgIGl0ZW1zID0gdGhpcy5faXRlbXMsXFxuXFx0XFx0XFx0ICAgIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcXG5cXG5cXHRcXHRcXHQvLyBUT0RPOiBTaG91bGQgYmUgY29tcHV0ZWQgZnJvbSBudW1iZXIgb2YgbWluIHdpZHRoIGl0ZW1zIGluIHN0YWdlXFxuXFx0XFx0XFx0dmlldyA9IE1hdGgubWF4KHNldHRpbmdzLml0ZW1zICogMiwgNCksXFxuXFx0XFx0XFx0ICAgIHNpemUgPSBNYXRoLmNlaWwoaXRlbXMubGVuZ3RoIC8gMikgKiAyLFxcblxcdFxcdFxcdCAgICByZXBlYXQgPSBzZXR0aW5ncy5sb29wICYmIGl0ZW1zLmxlbmd0aCA/IHNldHRpbmdzLnJld2luZCA/IHZpZXcgOiBNYXRoLm1heCh2aWV3LCBzaXplKSA6IDAsXFxuXFx0XFx0XFx0ICAgIGFwcGVuZCA9ICcnLFxcblxcdFxcdFxcdCAgICBwcmVwZW5kID0gJyc7XFxuXFxuXFx0XFx0XFx0cmVwZWF0IC89IDI7XFxuXFxuXFx0XFx0XFx0d2hpbGUgKHJlcGVhdC0tKSB7XFxuXFx0XFx0XFx0XFx0Ly8gU3dpdGNoIHRvIG9ubHkgdXNpbmcgYXBwZW5kZWQgY2xvbmVzXFxuXFx0XFx0XFx0XFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoY2xvbmVzLmxlbmd0aCAvIDIsIHRydWUpKTtcXG5cXHRcXHRcXHRcXHRhcHBlbmQgPSBhcHBlbmQgKyBpdGVtc1tjbG9uZXNbY2xvbmVzLmxlbmd0aCAtIDFdXVswXS5vdXRlckhUTUw7XFxuXFx0XFx0XFx0XFx0Y2xvbmVzLnB1c2godGhpcy5ub3JtYWxpemUoaXRlbXMubGVuZ3RoIC0gMSAtIChjbG9uZXMubGVuZ3RoIC0gMSkgLyAyLCB0cnVlKSk7XFxuXFx0XFx0XFx0XFx0cHJlcGVuZCA9IGl0ZW1zW2Nsb25lc1tjbG9uZXMubGVuZ3RoIC0gMV1dWzBdLm91dGVySFRNTCArIHByZXBlbmQ7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2Nsb25lcyA9IGNsb25lcztcXG5cXG5cXHRcXHRcXHQkKGFwcGVuZCkuYWRkQ2xhc3MoJ2Nsb25lZCcpLmFwcGVuZFRvKHRoaXMuJHN0YWdlKTtcXG5cXHRcXHRcXHQkKHByZXBlbmQpLmFkZENsYXNzKCdjbG9uZWQnKS5wcmVwZW5kVG8odGhpcy4kc3RhZ2UpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxcblxcdFxcdFxcdCAgICBzaXplID0gdGhpcy5fY2xvbmVzLmxlbmd0aCArIHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgaXRlcmF0b3IgPSAtMSxcXG5cXHRcXHRcXHQgICAgcHJldmlvdXMgPSAwLFxcblxcdFxcdFxcdCAgICBjdXJyZW50ID0gMCxcXG5cXHRcXHRcXHQgICAgY29vcmRpbmF0ZXMgPSBbXTtcXG5cXG5cXHRcXHRcXHR3aGlsZSAoKytpdGVyYXRvciA8IHNpemUpIHtcXG5cXHRcXHRcXHRcXHRwcmV2aW91cyA9IGNvb3JkaW5hdGVzW2l0ZXJhdG9yIC0gMV0gfHwgMDtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gdGhpcy5fd2lkdGhzW3RoaXMucmVsYXRpdmUoaXRlcmF0b3IpXSArIHRoaXMuc2V0dGluZ3MubWFyZ2luO1xcblxcdFxcdFxcdFxcdGNvb3JkaW5hdGVzLnB1c2gocHJldmlvdXMgKyBjdXJyZW50ICogcnRsKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMgPSBjb29yZGluYXRlcztcXG5cXHRcXHR9XFxuXFx0fSwge1xcblxcdFxcdGZpbHRlcjogWyd3aWR0aCcsICdpdGVtcycsICdzZXR0aW5ncyddLFxcblxcdFxcdHJ1bjogZnVuY3Rpb24gcnVuKCkge1xcblxcdFxcdFxcdHZhciBwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcsXFxuXFx0XFx0XFx0ICAgIGNvb3JkaW5hdGVzID0gdGhpcy5fY29vcmRpbmF0ZXMsXFxuXFx0XFx0XFx0ICAgIGNzcyA9IHtcXG5cXHRcXHRcXHRcXHQnd2lkdGgnOiBNYXRoLmNlaWwoTWF0aC5hYnMoY29vcmRpbmF0ZXNbY29vcmRpbmF0ZXMubGVuZ3RoIC0gMV0pKSArIHBhZGRpbmcgKiAyLFxcblxcdFxcdFxcdFxcdCdwYWRkaW5nLWxlZnQnOiBwYWRkaW5nIHx8ICcnLFxcblxcdFxcdFxcdFxcdCdwYWRkaW5nLXJpZ2h0JzogcGFkZGluZyB8fCAnJ1xcblxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuY3NzKGNzcyk7XFxuXFx0XFx0fVxcblxcdH0sIHtcXG5cXHRcXHRmaWx0ZXI6IFsnd2lkdGgnLCAnaXRlbXMnLCAnc2V0dGluZ3MnXSxcXG5cXHRcXHRydW46IGZ1bmN0aW9uIHJ1bihjYWNoZSkge1xcblxcdFxcdFxcdHZhciBpdGVyYXRvciA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHRcXHQgICAgZ3JpZCA9ICF0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCxcXG5cXHRcXHRcXHQgICAgaXRlbXMgPSB0aGlzLiRzdGFnZS5jaGlsZHJlbigpO1xcblxcblxcdFxcdFxcdGlmIChncmlkICYmIGNhY2hlLml0ZW1zLm1lcmdlKSB7XFxuXFx0XFx0XFx0XFx0d2hpbGUgKGl0ZXJhdG9yLS0pIHtcXG5cXHRcXHRcXHRcXHRcXHRjYWNoZS5jc3Mud2lkdGggPSB0aGlzLl93aWR0aHNbdGhpcy5yZWxhdGl2ZShpdGVyYXRvcildO1xcblxcdFxcdFxcdFxcdFxcdGl0ZW1zLmVxKGl0ZXJhdG9yKS5jc3MoY2FjaGUuY3NzKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChncmlkKSB7XFxuXFx0XFx0XFx0XFx0Y2FjaGUuY3NzLndpZHRoID0gY2FjaGUuaXRlbXMud2lkdGg7XFxuXFx0XFx0XFx0XFx0aXRlbXMuY3NzKGNhY2hlLmNzcyk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ2l0ZW1zJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29vcmRpbmF0ZXMubGVuZ3RoIDwgMSAmJiB0aGlzLiRzdGFnZS5yZW1vdmVBdHRyKCdzdHlsZScpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oY2FjaGUpIHtcXG5cXHRcXHRcXHRjYWNoZS5jdXJyZW50ID0gY2FjaGUuY3VycmVudCA/IHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuaW5kZXgoY2FjaGUuY3VycmVudCkgOiAwO1xcblxcdFxcdFxcdGNhY2hlLmN1cnJlbnQgPSBNYXRoLm1heCh0aGlzLm1pbmltdW0oKSwgTWF0aC5taW4odGhpcy5tYXhpbXVtKCksIGNhY2hlLmN1cnJlbnQpKTtcXG5cXHRcXHRcXHR0aGlzLnJlc2V0KGNhY2hlLmN1cnJlbnQpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3Bvc2l0aW9uJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXModGhpcy5fY3VycmVudCkpO1xcblxcdFxcdH1cXG5cXHR9LCB7XFxuXFx0XFx0ZmlsdGVyOiBbJ3dpZHRoJywgJ3Bvc2l0aW9uJywgJ2l0ZW1zJywgJ3NldHRpbmdzJ10sXFxuXFx0XFx0cnVuOiBmdW5jdGlvbiBydW4oKSB7XFxuXFx0XFx0XFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsID8gMSA6IC0xLFxcblxcdFxcdFxcdCAgICBwYWRkaW5nID0gdGhpcy5zZXR0aW5ncy5zdGFnZVBhZGRpbmcgKiAyLFxcblxcdFxcdFxcdCAgICBiZWdpbiA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5jdXJyZW50KCkpICsgcGFkZGluZyxcXG5cXHRcXHRcXHQgICAgZW5kID0gYmVnaW4gKyB0aGlzLndpZHRoKCkgKiBydGwsXFxuXFx0XFx0XFx0ICAgIGlubmVyLFxcblxcdFxcdFxcdCAgICBvdXRlcixcXG5cXHRcXHRcXHQgICAgbWF0Y2hlcyA9IFtdLFxcblxcdFxcdFxcdCAgICBpLFxcblxcdFxcdFxcdCAgICBuO1xcblxcblxcdFxcdFxcdGZvciAoaSA9IDAsIG4gPSB0aGlzLl9jb29yZGluYXRlcy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcXG5cXHRcXHRcXHRcXHRpbm5lciA9IHRoaXMuX2Nvb3JkaW5hdGVzW2kgLSAxXSB8fCAwO1xcblxcdFxcdFxcdFxcdG91dGVyID0gTWF0aC5hYnModGhpcy5fY29vcmRpbmF0ZXNbaV0pICsgcGFkZGluZyAqIHJ0bDtcXG5cXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5vcChpbm5lciwgJzw9JywgYmVnaW4pICYmIHRoaXMub3AoaW5uZXIsICc+JywgZW5kKSB8fCB0aGlzLm9wKG91dGVyLCAnPCcsIGJlZ2luKSAmJiB0aGlzLm9wKG91dGVyLCAnPicsIGVuZCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRtYXRjaGVzLnB1c2goaSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignLmFjdGl2ZScpLnJlbW92ZUNsYXNzKCdhY3RpdmUnKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jaGlsZHJlbignOmVxKCcgKyBtYXRjaGVzLmpvaW4oJyksIDplcSgnKSArICcpJykuYWRkQ2xhc3MoJ2FjdGl2ZScpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmNlbnRlcikge1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2VudGVyJykucmVtb3ZlQ2xhc3MoJ2NlbnRlcicpO1xcblxcdFxcdFxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5jdXJyZW50KCkpLmFkZENsYXNzKCdjZW50ZXInKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1dO1xcblxcblxcdC8qKlxcbiAgKiBJbml0aWFsaXplcyB0aGUgY2Fyb3VzZWwuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuZW50ZXIoJ2luaXRpYWxpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5zZXR0aW5ncy5ydGxDbGFzcywgdGhpcy5zZXR0aW5ncy5ydGwpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCAmJiAhdGhpcy5pcygncHJlLWxvYWRpbmcnKSkge1xcblxcdFxcdFxcdHZhciBpbWdzLCBuZXN0ZWRTZWxlY3Rvciwgd2lkdGg7XFxuXFx0XFx0XFx0aW1ncyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyk7XFxuXFx0XFx0XFx0bmVzdGVkU2VsZWN0b3IgPSB0aGlzLnNldHRpbmdzLm5lc3RlZEl0ZW1TZWxlY3RvciA/ICcuJyArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yIDogdW5kZWZpbmVkO1xcblxcdFxcdFxcdHdpZHRoID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihuZXN0ZWRTZWxlY3Rvcikud2lkdGgoKTtcXG5cXG5cXHRcXHRcXHRpZiAoaW1ncy5sZW5ndGggJiYgd2lkdGggPD0gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMucHJlbG9hZEF1dG9XaWR0aEltYWdlcyhpbWdzKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxvYWRpbmdDbGFzcyk7XFxuXFxuXFx0XFx0Ly8gSEFDSzogRElTQUJMRSBTQ1JPTExCQVJcXG5cXHRcXHR2YXIgb3ZlcmZsb3dWYWwgPSAkKCdib2R5JykuY3NzKCdvdmVyZmxvdycpO1xcblxcdFxcdCQoJ2JvZHknKS5jc3MoeyAnb3ZlcmZsb3cnOiAnaGlkZGVuJyB9KTtcXG5cXG5cXHRcXHQvLyBjcmVhdGUgc3RhZ2VcXG5cXHRcXHR0aGlzLiRzdGFnZSA9ICQoJzwnICsgdGhpcy5zZXR0aW5ncy5zdGFnZUVsZW1lbnQgKyAnIGNsYXNzPVxcXCInICsgdGhpcy5zZXR0aW5ncy5zdGFnZUNsYXNzICsgJ1xcXCIvPicpLndyYXAoJzxkaXYgY2xhc3M9XFxcIicgKyB0aGlzLnNldHRpbmdzLnN0YWdlT3V0ZXJDbGFzcyArICdcXFwiLz4nKTtcXG5cXG5cXHRcXHQvLyBhcHBlbmQgc3RhZ2VcXG5cXHRcXHR0aGlzLiRlbGVtZW50LmFwcGVuZCh0aGlzLiRzdGFnZS5wYXJlbnQoKSk7XFxuXFxuXFx0XFx0Ly8gYXBwZW5kIGNvbnRlbnRcXG5cXHRcXHR0aGlzLnJlcGxhY2UodGhpcy4kZWxlbWVudC5jaGlsZHJlbigpLm5vdCh0aGlzLiRzdGFnZS5wYXJlbnQoKSkpO1xcblxcblxcdFxcdC8vIGNoZWNrIHZpc2liaWxpdHlcXG5cXHRcXHRpZiAodGhpcy4kZWxlbWVudC5pcygnOnZpc2libGUnKSkge1xcblxcdFxcdFxcdC8vIHVwZGF0ZSB2aWV3XFxuXFx0XFx0XFx0dGhpcy5yZWZyZXNoKCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQvLyBpbnZhbGlkYXRlIHdpZHRoXFxuXFx0XFx0XFx0dGhpcy5pbnZhbGlkYXRlKCd3aWR0aCcpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHQvLyBIQUNLOiBSRVNUT1JFIFNDUk9MTEJBUlxcblxcdFxcdCQoJ2JvZHknKS5jc3MoeyAnb3ZlcmZsb3cnOiBvdmVyZmxvd1ZhbCB9KTtcXG5cXG5cXHRcXHR0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sb2FkaW5nQ2xhc3MpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sb2FkZWRDbGFzcyk7XFxuXFxuXFx0XFx0Ly8gcmVnaXN0ZXIgZXZlbnQgaGFuZGxlcnNcXG5cXHRcXHR0aGlzLnJlZ2lzdGVyRXZlbnRIYW5kbGVycygpO1xcblxcblxcdFxcdHRoaXMubGVhdmUoJ2luaXRpYWxpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcignaW5pdGlhbGl6ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTZXR1cHMgdGhlIGN1cnJlbnQgc2V0dGluZ3MuXFxuICAqIEB0b2RvIFJlbW92ZSByZXNwb25zaXZlIGNsYXNzZXMuIFdoeSBzaG91bGQgYWRhcHRpdmUgZGVzaWducyBiZSBicm91Z2h0IGludG8gSUU4P1xcbiAgKiBAdG9kbyBTdXBwb3J0IGZvciBtZWRpYSBxdWVyaWVzIGJ5IHVzaW5nIGBtYXRjaE1lZGlhYCB3b3VsZCBiZSBuaWNlLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuc2V0dXAgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIHZpZXdwb3J0ID0gdGhpcy52aWV3cG9ydCgpLFxcblxcdFxcdCAgICBvdmVyd3JpdGVzID0gdGhpcy5vcHRpb25zLnJlc3BvbnNpdmUsXFxuXFx0XFx0ICAgIG1hdGNoID0gLTEsXFxuXFx0XFx0ICAgIHNldHRpbmdzID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoIW92ZXJ3cml0ZXMpIHtcXG5cXHRcXHRcXHRzZXR0aW5ncyA9ICQuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMpO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JC5lYWNoKG92ZXJ3cml0ZXMsIGZ1bmN0aW9uIChicmVha3BvaW50KSB7XFxuXFx0XFx0XFx0XFx0aWYgKGJyZWFrcG9pbnQgPD0gdmlld3BvcnQgJiYgYnJlYWtwb2ludCA+IG1hdGNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0bWF0Y2ggPSBOdW1iZXIoYnJlYWtwb2ludCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHNldHRpbmdzID0gJC5leHRlbmQoe30sIHRoaXMub3B0aW9ucywgb3ZlcndyaXRlc1ttYXRjaF0pO1xcblxcdFxcdFxcdGlmICh0eXBlb2Ygc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0c2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gc2V0dGluZ3Muc3RhZ2VQYWRkaW5nKCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGRlbGV0ZSBzZXR0aW5ncy5yZXNwb25zaXZlO1xcblxcblxcdFxcdFxcdC8vIHJlc3BvbnNpdmUgY2xhc3NcXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MucmVzcG9uc2l2ZUNsYXNzKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy4kZWxlbWVudC5hdHRyKCdjbGFzcycsIHRoaXMuJGVsZW1lbnQuYXR0cignY2xhc3MnKS5yZXBsYWNlKG5ldyBSZWdFeHAoJygnICsgdGhpcy5vcHRpb25zLnJlc3BvbnNpdmVDbGFzcyArICctKVxcXFxcXFxcUytcXFxcXFxcXHMnLCAnZycpLCAnJDEnICsgbWF0Y2gpKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMudHJpZ2dlcignY2hhbmdlJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAnc2V0dGluZ3MnLCB2YWx1ZTogc2V0dGluZ3MgfSB9KTtcXG5cXHRcXHR0aGlzLl9icmVha3BvaW50ID0gbWF0Y2g7XFxuXFx0XFx0dGhpcy5zZXR0aW5ncyA9IHNldHRpbmdzO1xcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnc2V0dGluZ3MnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdzZXR0aW5ncycsIHZhbHVlOiB0aGlzLnNldHRpbmdzIH0gfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVXBkYXRlcyBvcHRpb24gbG9naWMgaWYgbmVjZXNzZXJ5LlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub3B0aW9uc0xvZ2ljID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmF1dG9XaWR0aCkge1xcblxcdFxcdFxcdHRoaXMuc2V0dGluZ3Muc3RhZ2VQYWRkaW5nID0gZmFsc2U7XFxuXFx0XFx0XFx0dGhpcy5zZXR0aW5ncy5tZXJnZSA9IGZhbHNlO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBQcmVwYXJlcyBhbiBpdGVtIGJlZm9yZSBhZGQuXFxuICAqIEB0b2RvIFJlbmFtZSBldmVudCBwYXJhbWV0ZXIgYGNvbnRlbnRgIHRvIGBpdGVtYC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcmV0dXJucyB7alF1ZXJ5fEhUTUxFbGVtZW50fSAtIFRoZSBpdGVtIGNvbnRhaW5lci5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5wcmVwYXJlID0gZnVuY3Rpb24gKGl0ZW0pIHtcXG5cXHRcXHR2YXIgZXZlbnQgPSB0aGlzLnRyaWdnZXIoJ3ByZXBhcmUnLCB7IGNvbnRlbnQ6IGl0ZW0gfSk7XFxuXFxuXFx0XFx0aWYgKCFldmVudC5kYXRhKSB7XFxuXFx0XFx0XFx0ZXZlbnQuZGF0YSA9ICQoJzwnICsgdGhpcy5zZXR0aW5ncy5pdGVtRWxlbWVudCArICcvPicpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pdGVtQ2xhc3MpLmFwcGVuZChpdGVtKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdwcmVwYXJlZCcsIHsgY29udGVudDogZXZlbnQuZGF0YSB9KTtcXG5cXG5cXHRcXHRyZXR1cm4gZXZlbnQuZGF0YTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBVcGRhdGVzIHRoZSB2aWV3LlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBpID0gMCxcXG5cXHRcXHQgICAgbiA9IHRoaXMuX3BpcGUubGVuZ3RoLFxcblxcdFxcdCAgICBmaWx0ZXIgPSAkLnByb3h5KGZ1bmN0aW9uIChwKSB7XFxuXFx0XFx0XFx0cmV0dXJuIHRoaXNbcF07XFxuXFx0XFx0fSwgdGhpcy5faW52YWxpZGF0ZWQpLFxcblxcdFxcdCAgICBjYWNoZSA9IHt9O1xcblxcblxcdFxcdHdoaWxlIChpIDwgbikge1xcblxcdFxcdFxcdGlmICh0aGlzLl9pbnZhbGlkYXRlZC5hbGwgfHwgJC5ncmVwKHRoaXMuX3BpcGVbaV0uZmlsdGVyLCBmaWx0ZXIpLmxlbmd0aCA+IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9waXBlW2ldLnJ1bihjYWNoZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGkrKztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5faW52YWxpZGF0ZWQgPSB7fTtcXG5cXG5cXHRcXHQhdGhpcy5pcygndmFsaWQnKSAmJiB0aGlzLmVudGVyKCd2YWxpZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIHdpZHRoIG9mIHRoZSB2aWV3LlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7T3dsLldpZHRofSBbZGltZW5zaW9uPU93bC5XaWR0aC5EZWZhdWx0XSAtIFRoZSBkaW1lbnNpb24gdG8gcmV0dXJuLlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB3aWR0aCBvZiB0aGUgdmlldyBpbiBwaXhlbC5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS53aWR0aCA9IGZ1bmN0aW9uIChkaW1lbnNpb24pIHtcXG5cXHRcXHRkaW1lbnNpb24gPSBkaW1lbnNpb24gfHwgT3dsLldpZHRoLkRlZmF1bHQ7XFxuXFx0XFx0c3dpdGNoIChkaW1lbnNpb24pIHtcXG5cXHRcXHRcXHRjYXNlIE93bC5XaWR0aC5Jbm5lcjpcXG5cXHRcXHRcXHRjYXNlIE93bC5XaWR0aC5PdXRlcjpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fd2lkdGg7XFxuXFx0XFx0XFx0ZGVmYXVsdDpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5fd2lkdGggLSB0aGlzLnNldHRpbmdzLnN0YWdlUGFkZGluZyAqIDIgKyB0aGlzLnNldHRpbmdzLm1hcmdpbjtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVmcmVzaGVzIHRoZSBjYXJvdXNlbCBwcmltYXJpbHkgZm9yIGFkYXB0aXZlIHB1cnBvc2VzLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0aGlzLmVudGVyKCdyZWZyZXNoaW5nJyk7XFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZWZyZXNoJyk7XFxuXFxuXFx0XFx0dGhpcy5zZXR1cCgpO1xcblxcblxcdFxcdHRoaXMub3B0aW9uc0xvZ2ljKCk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKTtcXG5cXG5cXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLnJlZnJlc2hDbGFzcyk7XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgncmVmcmVzaGluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVmcmVzaGVkJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uVGhyb3R0bGVkUmVzaXplID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lcik7XFxuXFx0XFx0dGhpcy5yZXNpemVUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuX2hhbmRsZXJzLm9uUmVzaXplLCB0aGlzLnNldHRpbmdzLnJlc3BvbnNpdmVSZWZyZXNoUmF0ZSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ2hlY2tzIHdpbmRvdyBgcmVzaXplYCBldmVudC5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uUmVzaXplID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGlmICghdGhpcy5faXRlbXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5fd2lkdGggPT09IHRoaXMuJGVsZW1lbnQud2lkdGgoKSkge1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKCF0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmVudGVyKCdyZXNpemluZycpO1xcblxcblxcdFxcdGlmICh0aGlzLnRyaWdnZXIoJ3Jlc2l6ZScpLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XFxuXFx0XFx0XFx0dGhpcy5sZWF2ZSgncmVzaXppbmcnKTtcXG5cXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnd2lkdGgnKTtcXG5cXG5cXHRcXHR0aGlzLnJlZnJlc2goKTtcXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdyZXNpemluZycpO1xcblxcdFxcdHRoaXMudHJpZ2dlcigncmVzaXplZCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlZ2lzdGVycyBldmVudCBoYW5kbGVycy5cXG4gICogQHRvZG8gQ2hlY2sgYG1zUG9pbnRlckVuYWJsZWRgXFxuICAqIEB0b2RvICMyNjFcXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlZ2lzdGVyRXZlbnRIYW5kbGVycyA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAoJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbigkLnN1cHBvcnQudHJhbnNpdGlvbi5lbmQgKyAnLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uVHJhbnNpdGlvbkVuZCwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5yZXNwb25zaXZlICE9PSBmYWxzZSkge1xcblxcdFxcdFxcdHRoaXMub24od2luZG93LCAncmVzaXplJywgdGhpcy5faGFuZGxlcnMub25UaHJvdHRsZWRSZXNpemUpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5tb3VzZURyYWcpIHtcXG5cXHRcXHRcXHR0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5kcmFnQ2xhc3MpO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLm9uKCdtb3VzZWRvd24ub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbignZHJhZ3N0YXJ0Lm93bC5jb3JlIHNlbGVjdHN0YXJ0Lm93bC5jb3JlJywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MudG91Y2hEcmFnKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2Uub24oJ3RvdWNoc3RhcnQub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnU3RhcnQsIHRoaXMpKTtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5vbigndG91Y2hjYW5jZWwub3dsLmNvcmUnLCAkLnByb3h5KHRoaXMub25EcmFnRW5kLCB0aGlzKSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEhhbmRsZXMgYHRvdWNoc3RhcnRgIGFuZCBgbW91c2Vkb3duYCBldmVudHMuXFxuICAqIEB0b2RvIEhvcml6b250YWwgc3dpcGUgdGhyZXNob2xkIGFzIG9wdGlvblxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uRHJhZ1N0YXJ0ID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHN0YWdlID0gbnVsbDtcXG5cXG5cXHRcXHRpZiAoZXZlbnQud2hpY2ggPT09IDMpIHtcXG5cXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtKSB7XFxuXFx0XFx0XFx0c3RhZ2UgPSB0aGlzLiRzdGFnZS5jc3MoJ3RyYW5zZm9ybScpLnJlcGxhY2UoLy4qXFxcXCh8XFxcXCl8IC9nLCAnJykuc3BsaXQoJywnKTtcXG5cXHRcXHRcXHRzdGFnZSA9IHtcXG5cXHRcXHRcXHRcXHR4OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTIgOiA0XSxcXG5cXHRcXHRcXHRcXHR5OiBzdGFnZVtzdGFnZS5sZW5ndGggPT09IDE2ID8gMTMgOiA1XVxcblxcdFxcdFxcdH07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRzdGFnZSA9IHRoaXMuJHN0YWdlLnBvc2l0aW9uKCk7XFxuXFx0XFx0XFx0c3RhZ2UgPSB7XFxuXFx0XFx0XFx0XFx0eDogdGhpcy5zZXR0aW5ncy5ydGwgPyBzdGFnZS5sZWZ0ICsgdGhpcy4kc3RhZ2Uud2lkdGgoKSAtIHRoaXMud2lkdGgoKSArIHRoaXMuc2V0dGluZ3MubWFyZ2luIDogc3RhZ2UubGVmdCxcXG5cXHRcXHRcXHRcXHR5OiBzdGFnZS50b3BcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5pcygnYW5pbWF0aW5nJykpIHtcXG5cXHRcXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtID8gdGhpcy5hbmltYXRlKHN0YWdlLngpIDogdGhpcy4kc3RhZ2Uuc3RvcCgpO1xcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC50b2dnbGVDbGFzcyh0aGlzLm9wdGlvbnMuZ3JhYkNsYXNzLCBldmVudC50eXBlID09PSAnbW91c2Vkb3duJyk7XFxuXFxuXFx0XFx0dGhpcy5zcGVlZCgwKTtcXG5cXG5cXHRcXHR0aGlzLl9kcmFnLnRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHRcXHR0aGlzLl9kcmFnLnRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KTtcXG5cXHRcXHR0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50ID0gc3RhZ2U7XFxuXFx0XFx0dGhpcy5fZHJhZy5wb2ludGVyID0gdGhpcy5wb2ludGVyKGV2ZW50KTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbignbW91c2V1cC5vd2wuY29yZSB0b3VjaGVuZC5vd2wuY29yZScsICQucHJveHkodGhpcy5vbkRyYWdFbmQsIHRoaXMpKTtcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vbmUoJ21vdXNlbW92ZS5vd2wuY29yZSB0b3VjaG1vdmUub3dsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdHZhciBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpO1xcblxcblxcdFxcdFxcdCQoZG9jdW1lbnQpLm9uKCdtb3VzZW1vdmUub3dsLmNvcmUgdG91Y2htb3ZlLm93bC5jb3JlJywgJC5wcm94eSh0aGlzLm9uRHJhZ01vdmUsIHRoaXMpKTtcXG5cXG5cXHRcXHRcXHRpZiAoTWF0aC5hYnMoZGVsdGEueCkgPCBNYXRoLmFicyhkZWx0YS55KSAmJiB0aGlzLmlzKCd2YWxpZCcpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ2RyYWdnaW5nJyk7XFxuXFx0XFx0XFx0dGhpcy50cmlnZ2VyKCdkcmFnJyk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEhhbmRsZXMgdGhlIGB0b3VjaG1vdmVgIGFuZCBgbW91c2Vtb3ZlYCBldmVudHMuXFxuICAqIEB0b2RvICMyNjFcXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnTW92ZSA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdHZhciBtaW5pbXVtID0gbnVsbCxcXG5cXHRcXHQgICAgbWF4aW11bSA9IG51bGwsXFxuXFx0XFx0ICAgIHB1bGwgPSBudWxsLFxcblxcdFxcdCAgICBkZWx0YSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnBvaW50ZXIsIHRoaXMucG9pbnRlcihldmVudCkpLFxcblxcdFxcdCAgICBzdGFnZSA9IHRoaXMuZGlmZmVyZW5jZSh0aGlzLl9kcmFnLnN0YWdlLnN0YXJ0LCBkZWx0YSk7XFxuXFxuXFx0XFx0aWYgKCF0aGlzLmlzKCdkcmFnZ2luZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcblxcdFxcdGlmICh0aGlzLnNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRtaW5pbXVtID0gdGhpcy5jb29yZGluYXRlcyh0aGlzLm1pbmltdW0oKSk7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuY29vcmRpbmF0ZXModGhpcy5tYXhpbXVtKCkgKyAxKSAtIG1pbmltdW07XFxuXFx0XFx0XFx0c3RhZ2UueCA9ICgoc3RhZ2UueCAtIG1pbmltdW0pICUgbWF4aW11bSArIG1heGltdW0pICUgbWF4aW11bSArIG1pbmltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtaW5pbXVtID0gdGhpcy5zZXR0aW5ncy5ydGwgPyB0aGlzLmNvb3JkaW5hdGVzKHRoaXMubWF4aW11bSgpKSA6IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpO1xcblxcdFxcdFxcdG1heGltdW0gPSB0aGlzLnNldHRpbmdzLnJ0bCA/IHRoaXMuY29vcmRpbmF0ZXModGhpcy5taW5pbXVtKCkpIDogdGhpcy5jb29yZGluYXRlcyh0aGlzLm1heGltdW0oKSk7XFxuXFx0XFx0XFx0cHVsbCA9IHRoaXMuc2V0dGluZ3MucHVsbERyYWcgPyAtMSAqIGRlbHRhLnggLyA1IDogMDtcXG5cXHRcXHRcXHRzdGFnZS54ID0gTWF0aC5tYXgoTWF0aC5taW4oc3RhZ2UueCwgbWluaW11bSArIHB1bGwpLCBtYXhpbXVtICsgcHVsbCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2RyYWcuc3RhZ2UuY3VycmVudCA9IHN0YWdlO1xcblxcblxcdFxcdHRoaXMuYW5pbWF0ZShzdGFnZS54KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBIYW5kbGVzIHRoZSBgdG91Y2hlbmRgIGFuZCBgbW91c2V1cGAgZXZlbnRzLlxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEB0b2RvIFRocmVzaG9sZCBmb3IgY2xpY2sgZXZlbnRcXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub25EcmFnRW5kID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0dmFyIGRlbHRhID0gdGhpcy5kaWZmZXJlbmNlKHRoaXMuX2RyYWcucG9pbnRlciwgdGhpcy5wb2ludGVyKGV2ZW50KSksXFxuXFx0XFx0ICAgIHN0YWdlID0gdGhpcy5fZHJhZy5zdGFnZS5jdXJyZW50LFxcblxcdFxcdCAgICBkaXJlY3Rpb24gPSBkZWx0YS54ID4gMCBeIHRoaXMuc2V0dGluZ3MucnRsID8gJ2xlZnQnIDogJ3JpZ2h0JztcXG5cXG5cXHRcXHQkKGRvY3VtZW50KS5vZmYoJy5vd2wuY29yZScpO1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcyk7XFxuXFxuXFx0XFx0aWYgKGRlbHRhLnggIT09IDAgJiYgdGhpcy5pcygnZHJhZ2dpbmcnKSB8fCAhdGhpcy5pcygndmFsaWQnKSkge1xcblxcdFxcdFxcdHRoaXMuc3BlZWQodGhpcy5zZXR0aW5ncy5kcmFnRW5kU3BlZWQgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcXG5cXHRcXHRcXHR0aGlzLmN1cnJlbnQodGhpcy5jbG9zZXN0KHN0YWdlLngsIGRlbHRhLnggIT09IDAgPyBkaXJlY3Rpb24gOiB0aGlzLl9kcmFnLmRpcmVjdGlvbikpO1xcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcblxcdFxcdFxcdHRoaXMuX2RyYWcuZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xcblxcblxcdFxcdFxcdGlmIChNYXRoLmFicyhkZWx0YS54KSA+IDMgfHwgbmV3IERhdGUoKS5nZXRUaW1lKCkgLSB0aGlzLl9kcmFnLnRpbWUgPiAzMDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9kcmFnLnRhcmdldC5vbmUoJ2NsaWNrLm93bC5jb3JlJywgZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICghdGhpcy5pcygnZHJhZ2dpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5sZWF2ZSgnZHJhZ2dpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2RyYWdnZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBjbG9zZXN0IGl0ZW0gZm9yIGEgY29vcmRpbmF0ZS5cXG4gICogQHRvZG8gU2V0dGluZyBgZnJlZURyYWdgIG1ha2VzIGBjbG9zZXN0YCBub3QgcmV1c2FibGUuIFNlZSAjMTY1LlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb29yZGluYXRlIC0gVGhlIGNvb3JkaW5hdGUgaW4gcGl4ZWwuXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBkaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIHRvIGNoZWNrIGZvciB0aGUgY2xvc2VzdCBpdGVtLiBFdGhlciBgbGVmdGAgb3IgYHJpZ2h0YC5cXG4gICogQHJldHVybiB7TnVtYmVyfSAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY2xvc2VzdCBpdGVtLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNsb3Nlc3QgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZSwgZGlyZWN0aW9uKSB7XFxuXFx0XFx0dmFyIHBvc2l0aW9uID0gLTEsXFxuXFx0XFx0ICAgIHB1bGwgPSAzMCxcXG5cXHRcXHQgICAgd2lkdGggPSB0aGlzLndpZHRoKCksXFxuXFx0XFx0ICAgIGNvb3JkaW5hdGVzID0gdGhpcy5jb29yZGluYXRlcygpO1xcblxcblxcdFxcdGlmICghdGhpcy5zZXR0aW5ncy5mcmVlRHJhZykge1xcblxcdFxcdFxcdC8vIGNoZWNrIGNsb3Nlc3QgaXRlbVxcblxcdFxcdFxcdCQuZWFjaChjb29yZGluYXRlcywgJC5wcm94eShmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0Ly8gb24gYSBsZWZ0IHB1bGwsIGNoZWNrIG9uIGN1cnJlbnQgaW5kZXhcXG5cXHRcXHRcXHRcXHRpZiAoZGlyZWN0aW9uID09PSAnbGVmdCcgJiYgY29vcmRpbmF0ZSA+IHZhbHVlIC0gcHVsbCAmJiBjb29yZGluYXRlIDwgdmFsdWUgKyBwdWxsKSB7XFxuXFx0XFx0XFx0XFx0XFx0cG9zaXRpb24gPSBpbmRleDtcXG5cXHRcXHRcXHRcXHRcXHQvLyBvbiBhIHJpZ2h0IHB1bGwsIGNoZWNrIG9uIHByZXZpb3VzIGluZGV4XFxuXFx0XFx0XFx0XFx0XFx0Ly8gdG8gZG8gc28sIHN1YnRyYWN0IHdpZHRoIGZyb20gdmFsdWUgYW5kIHNldCBwb3NpdGlvbiA9IGluZGV4ICsgMVxcblxcdFxcdFxcdFxcdH0gZWxzZSBpZiAoZGlyZWN0aW9uID09PSAncmlnaHQnICYmIGNvb3JkaW5hdGUgPiB2YWx1ZSAtIHdpZHRoIC0gcHVsbCAmJiBjb29yZGluYXRlIDwgdmFsdWUgLSB3aWR0aCArIHB1bGwpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGluZGV4ICsgMTtcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKHRoaXMub3AoY29vcmRpbmF0ZSwgJzwnLCB2YWx1ZSkgJiYgdGhpcy5vcChjb29yZGluYXRlLCAnPicsIGNvb3JkaW5hdGVzW2luZGV4ICsgMV0gfHwgdmFsdWUgLSB3aWR0aCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGRpcmVjdGlvbiA9PT0gJ2xlZnQnID8gaW5kZXggKyAxIDogaW5kZXg7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBwb3NpdGlvbiA9PT0gLTE7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoIXRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdC8vIG5vbiBsb29wIGJvdW5kcmllc1xcblxcdFxcdFxcdGlmICh0aGlzLm9wKGNvb3JkaW5hdGUsICc+JywgY29vcmRpbmF0ZXNbdGhpcy5taW5pbXVtKCldKSkge1xcblxcdFxcdFxcdFxcdHBvc2l0aW9uID0gY29vcmRpbmF0ZSA9IHRoaXMubWluaW11bSgpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAodGhpcy5vcChjb29yZGluYXRlLCAnPCcsIGNvb3JkaW5hdGVzW3RoaXMubWF4aW11bSgpXSkpIHtcXG5cXHRcXHRcXHRcXHRwb3NpdGlvbiA9IGNvb3JkaW5hdGUgPSB0aGlzLm1heGltdW0oKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBwb3NpdGlvbjtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBBbmltYXRlcyB0aGUgc3RhZ2UuXFxuICAqIEB0b2RvICMyNzBcXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gY29vcmRpbmF0ZSAtIFRoZSBjb29yZGluYXRlIGluIHBpeGVscy5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5hbmltYXRlID0gZnVuY3Rpb24gKGNvb3JkaW5hdGUpIHtcXG5cXHRcXHR2YXIgYW5pbWF0ZSA9IHRoaXMuc3BlZWQoKSA+IDA7XFxuXFxuXFx0XFx0dGhpcy5pcygnYW5pbWF0aW5nJykgJiYgdGhpcy5vblRyYW5zaXRpb25FbmQoKTtcXG5cXG5cXHRcXHRpZiAoYW5pbWF0ZSkge1xcblxcdFxcdFxcdHRoaXMuZW50ZXIoJ2FuaW1hdGluZycpO1xcblxcdFxcdFxcdHRoaXMudHJpZ2dlcigndHJhbnNsYXRlJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmICgkLnN1cHBvcnQudHJhbnNmb3JtM2QgJiYgJC5zdXBwb3J0LnRyYW5zaXRpb24pIHtcXG5cXHRcXHRcXHR0aGlzLiRzdGFnZS5jc3Moe1xcblxcdFxcdFxcdFxcdHRyYW5zZm9ybTogJ3RyYW5zbGF0ZTNkKCcgKyBjb29yZGluYXRlICsgJ3B4LDBweCwwcHgpJyxcXG5cXHRcXHRcXHRcXHR0cmFuc2l0aW9uOiB0aGlzLnNwZWVkKCkgLyAxMDAwICsgJ3MnXFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fSBlbHNlIGlmIChhbmltYXRlKSB7XFxuXFx0XFx0XFx0dGhpcy4kc3RhZ2UuYW5pbWF0ZSh7XFxuXFx0XFx0XFx0XFx0bGVmdDogY29vcmRpbmF0ZSArICdweCdcXG5cXHRcXHRcXHR9LCB0aGlzLnNwZWVkKCksIHRoaXMuc2V0dGluZ3MuZmFsbGJhY2tFYXNpbmcsICQucHJveHkodGhpcy5vblRyYW5zaXRpb25FbmQsIHRoaXMpKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmNzcyh7XFxuXFx0XFx0XFx0XFx0bGVmdDogY29vcmRpbmF0ZSArICdweCdcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ2hlY2tzIHdoZXRoZXIgdGhlIGNhcm91c2VsIGlzIGluIGEgc3BlY2lmaWMgc3RhdGUgb3Igbm90LlxcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RhdGUgLSBUaGUgc3RhdGUgdG8gY2hlY2suXFxuICAqIEByZXR1cm5zIHtCb29sZWFufSAtIFRoZSBmbGFnIHdoaWNoIGluZGljYXRlcyBpZiB0aGUgY2Fyb3VzZWwgaXMgYnVzeS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5pcyA9IGZ1bmN0aW9uIChzdGF0ZSkge1xcblxcdFxcdHJldHVybiB0aGlzLl9zdGF0ZXMuY3VycmVudFtzdGF0ZV0gJiYgdGhpcy5fc3RhdGVzLmN1cnJlbnRbc3RhdGVdID4gMDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIG5ldyBhYnNvbHV0ZSBwb3NpdGlvbiBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cXG4gICogQHJldHVybnMge051bWJlcn0gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGN1cnJlbnQgaXRlbS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5fY3VycmVudDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCkge1xcblxcdFxcdFxcdHJldHVybiB1bmRlZmluZWQ7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLl9jdXJyZW50ICE9PSBwb3NpdGlvbikge1xcblxcdFxcdFxcdHZhciBldmVudCA9IHRoaXMudHJpZ2dlcignY2hhbmdlJywgeyBwcm9wZXJ0eTogeyBuYW1lOiAncG9zaXRpb24nLCB2YWx1ZTogcG9zaXRpb24gfSB9KTtcXG5cXG5cXHRcXHRcXHRpZiAoZXZlbnQuZGF0YSAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShldmVudC5kYXRhKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY3VycmVudCA9IHBvc2l0aW9uO1xcblxcblxcdFxcdFxcdHRoaXMuaW52YWxpZGF0ZSgncG9zaXRpb24nKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRyaWdnZXIoJ2NoYW5nZWQnLCB7IHByb3BlcnR5OiB7IG5hbWU6ICdwb3NpdGlvbicsIHZhbHVlOiB0aGlzLl9jdXJyZW50IH0gfSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB0aGlzLl9jdXJyZW50O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEludmFsaWRhdGVzIHRoZSBnaXZlbiBwYXJ0IG9mIHRoZSB1cGRhdGUgcm91dGluZS5cXG4gICogQHBhcmFtIHtTdHJpbmd9IFtwYXJ0XSAtIFRoZSBwYXJ0IHRvIGludmFsaWRhdGUuXFxuICAqIEByZXR1cm5zIHtBcnJheS48U3RyaW5nPn0gLSBUaGUgaW52YWxpZGF0ZWQgcGFydHMuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuaW52YWxpZGF0ZSA9IGZ1bmN0aW9uIChwYXJ0KSB7XFxuXFx0XFx0aWYgKCQudHlwZShwYXJ0KSA9PT0gJ3N0cmluZycpIHtcXG5cXHRcXHRcXHR0aGlzLl9pbnZhbGlkYXRlZFtwYXJ0XSA9IHRydWU7XFxuXFx0XFx0XFx0dGhpcy5pcygndmFsaWQnKSAmJiB0aGlzLmxlYXZlKCd2YWxpZCcpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5faW52YWxpZGF0ZWQsIGZ1bmN0aW9uICh2LCBpKSB7XFxuXFx0XFx0XFx0cmV0dXJuIGk7XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVzZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgY3VycmVudCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbmV3IGl0ZW0uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcXG5cXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uKTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fc3BlZWQgPSAwO1xcblxcdFxcdHRoaXMuX2N1cnJlbnQgPSBwb3NpdGlvbjtcXG5cXG5cXHRcXHR0aGlzLnN1cHByZXNzKFsndHJhbnNsYXRlJywgJ3RyYW5zbGF0ZWQnXSk7XFxuXFxuXFx0XFx0dGhpcy5hbmltYXRlKHRoaXMuY29vcmRpbmF0ZXMocG9zaXRpb24pKTtcXG5cXG5cXHRcXHR0aGlzLnJlbGVhc2UoWyd0cmFuc2xhdGUnLCAndHJhbnNsYXRlZCddKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBOb3JtYWxpemVzIGFuIGFic29sdXRlIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24gb2YgYW4gaXRlbS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgYWJzb2x1dGUgb3IgcmVsYXRpdmUgcG9zaXRpb24gdG8gbm9ybWFsaXplLlxcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtyZWxhdGl2ZT1mYWxzZV0gLSBXaGV0aGVyIHRoZSBnaXZlbiBwb3NpdGlvbiBpcyByZWxhdGl2ZSBvciBub3QuXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9IC0gVGhlIG5vcm1hbGl6ZWQgcG9zaXRpb24uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUubm9ybWFsaXplID0gZnVuY3Rpb24gKHBvc2l0aW9uLCByZWxhdGl2ZSkge1xcblxcdFxcdHZhciBuID0gdGhpcy5faXRlbXMubGVuZ3RoLFxcblxcdFxcdCAgICBtID0gcmVsYXRpdmUgPyAwIDogdGhpcy5fY2xvbmVzLmxlbmd0aDtcXG5cXG5cXHRcXHRpZiAoIXRoaXMuaXNOdW1lcmljKHBvc2l0aW9uKSB8fCBuIDwgMSkge1xcblxcdFxcdFxcdHBvc2l0aW9uID0gdW5kZWZpbmVkO1xcblxcdFxcdH0gZWxzZSBpZiAocG9zaXRpb24gPCAwIHx8IHBvc2l0aW9uID49IG4gKyBtKSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSAoKHBvc2l0aW9uIC0gbSAvIDIpICUgbiArIG4pICUgbiArIG0gLyAyO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ29udmVydHMgYW4gYWJzb2x1dGUgcG9zaXRpb24gb2YgYW4gaXRlbSBpbnRvIGEgcmVsYXRpdmUgb25lLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiB0byBjb252ZXJ0LlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSBjb252ZXJ0ZWQgcG9zaXRpb24uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucmVsYXRpdmUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcXG5cXHRcXHRwb3NpdGlvbiAtPSB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHRcXHRyZXR1cm4gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIG1heGltdW0gcG9zaXRpb24gZm9yIHRoZSBjdXJyZW50IGl0ZW0uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtCb29sZWFufSBbcmVsYXRpdmU9ZmFsc2VdIC0gV2hldGhlciB0byByZXR1cm4gYW4gYWJzb2x1dGUgcG9zaXRpb24gb3IgYSByZWxhdGl2ZSBwb3NpdGlvbi5cXG4gICogQHJldHVybnMge051bWJlcn1cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5tYXhpbXVtID0gZnVuY3Rpb24gKHJlbGF0aXZlKSB7XFxuXFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncyxcXG5cXHRcXHQgICAgbWF4aW11bSA9IHRoaXMuX2Nvb3JkaW5hdGVzLmxlbmd0aCxcXG5cXHRcXHQgICAgaXRlcmF0b3IsXFxuXFx0XFx0ICAgIHJlY2lwcm9jYWxJdGVtc1dpZHRoLFxcblxcdFxcdCAgICBlbGVtZW50V2lkdGg7XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLmxvb3ApIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDIgKyB0aGlzLl9pdGVtcy5sZW5ndGggLSAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLm1lcmdlKSB7XFxuXFx0XFx0XFx0aXRlcmF0b3IgPSB0aGlzLl9pdGVtcy5sZW5ndGg7XFxuXFx0XFx0XFx0cmVjaXByb2NhbEl0ZW1zV2lkdGggPSB0aGlzLl9pdGVtc1stLWl0ZXJhdG9yXS53aWR0aCgpO1xcblxcdFxcdFxcdGVsZW1lbnRXaWR0aCA9IHRoaXMuJGVsZW1lbnQud2lkdGgoKTtcXG5cXHRcXHRcXHR3aGlsZSAoaXRlcmF0b3ItLSkge1xcblxcdFxcdFxcdFxcdHJlY2lwcm9jYWxJdGVtc1dpZHRoICs9IHRoaXMuX2l0ZW1zW2l0ZXJhdG9yXS53aWR0aCgpICsgdGhpcy5zZXR0aW5ncy5tYXJnaW47XFxuXFx0XFx0XFx0XFx0aWYgKHJlY2lwcm9jYWxJdGVtc1dpZHRoID4gZWxlbWVudFdpZHRoKSB7XFxuXFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRtYXhpbXVtID0gaXRlcmF0b3IgKyAxO1xcblxcdFxcdH0gZWxzZSBpZiAoc2V0dGluZ3MuY2VudGVyKSB7XFxuXFx0XFx0XFx0bWF4aW11bSA9IHRoaXMuX2l0ZW1zLmxlbmd0aCAtIDE7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRtYXhpbXVtID0gdGhpcy5faXRlbXMubGVuZ3RoIC0gc2V0dGluZ3MuaXRlbXM7XFxuXFx0XFx0fVxcblxcblxcdFxcdGlmIChyZWxhdGl2ZSkge1xcblxcdFxcdFxcdG1heGltdW0gLT0gdGhpcy5fY2xvbmVzLmxlbmd0aCAvIDI7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBNYXRoLm1heChtYXhpbXVtLCAwKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSBtaW5pbXVtIHBvc2l0aW9uIGZvciB0aGUgY3VycmVudCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlbGF0aXZlPWZhbHNlXSAtIFdoZXRoZXIgdG8gcmV0dXJuIGFuIGFic29sdXRlIHBvc2l0aW9uIG9yIGEgcmVsYXRpdmUgcG9zaXRpb24uXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ9XFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUubWluaW11bSA9IGZ1bmN0aW9uIChyZWxhdGl2ZSkge1xcblxcdFxcdHJldHVybiByZWxhdGl2ZSA/IDAgOiB0aGlzLl9jbG9uZXMubGVuZ3RoIC8gMjtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG4gICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLml0ZW1zID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0aWYgKHBvc2l0aW9uID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRyZXR1cm4gdGhpcy5faXRlbXMuc2xpY2UoKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cG9zaXRpb24gPSB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFx0XFx0cmV0dXJuIHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIGFuIGl0ZW0gYXQgdGhlIHNwZWNpZmllZCByZWxhdGl2ZSBwb3NpdGlvbi5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3Bvc2l0aW9uXSAtIFRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG4gICogQHJldHVybiB7alF1ZXJ5fEFycmF5LjxqUXVlcnk+fSAtIFRoZSBpdGVtIGF0IHRoZSBnaXZlbiBwb3NpdGlvbiBvciBhbGwgaXRlbXMgaWYgbm8gcG9zaXRpb24gd2FzIGdpdmVuLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm1lcmdlcnMgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzLnNsaWNlKCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHBvc2l0aW9uID0gdGhpcy5ub3JtYWxpemUocG9zaXRpb24sIHRydWUpO1xcblxcdFxcdHJldHVybiB0aGlzLl9tZXJnZXJzW3Bvc2l0aW9uXTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbnMgb2YgY2xvbmVzIGZvciBhbiBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtLlxcbiAgKiBAcmV0dXJucyB7QXJyYXkuPE51bWJlcj59IC0gVGhlIGFic29sdXRlIHBvc2l0aW9ucyBvZiBjbG9uZXMgZm9yIHRoZSBpdGVtIG9yIGFsbCBpZiBubyBwb3NpdGlvbiB3YXMgZ2l2ZW4uXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUuY2xvbmVzID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG9kZCA9IHRoaXMuX2Nsb25lcy5sZW5ndGggLyAyLFxcblxcdFxcdCAgICBldmVuID0gb2RkICsgdGhpcy5faXRlbXMubGVuZ3RoLFxcblxcdFxcdCAgICBtYXAgPSBmdW5jdGlvbiBtYXAoaW5kZXgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gaW5kZXggJSAyID09PSAwID8gZXZlbiArIGluZGV4IC8gMiA6IG9kZCAtIChpbmRleCArIDEpIC8gMjtcXG5cXHRcXHR9O1xcblxcblxcdFxcdGlmIChwb3NpdGlvbiA9PT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0cmV0dXJuICQubWFwKHRoaXMuX2Nsb25lcywgZnVuY3Rpb24gKHYsIGkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gbWFwKGkpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gJC5tYXAodGhpcy5fY2xvbmVzLCBmdW5jdGlvbiAodiwgaSkge1xcblxcdFxcdFxcdHJldHVybiB2ID09PSBwb3NpdGlvbiA/IG1hcChpKSA6IG51bGw7XFxuXFx0XFx0fSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2V0cyB0aGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGluIG1pbGxpc2Vjb25kcyBvciBub3RoaW5nIHRvIGxlYXZlIGl0IHVuY2hhbmdlZC5cXG4gICogQHJldHVybnMge051bWJlcn0gLSBUaGUgY3VycmVudCBhbmltYXRpb24gc3BlZWQgaW4gbWlsbGlzZWNvbmRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnNwZWVkID0gZnVuY3Rpb24gKHNwZWVkKSB7XFxuXFx0XFx0aWYgKHNwZWVkICE9PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHR0aGlzLl9zcGVlZCA9IHNwZWVkO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gdGhpcy5fc3BlZWQ7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB0aGUgY29vcmRpbmF0ZSBvZiBhbiBpdGVtLlxcbiAgKiBAdG9kbyBUaGUgbmFtZSBvZiB0aGlzIG1ldGhvZCBpcyBtaXNzbGVhbmRpbmcuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIGFic29sdXRlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHdpdGhpbiBgbWluaW11bSgpYCBhbmQgYG1heGltdW0oKWAuXFxuICAqIEByZXR1cm5zIHtOdW1iZXJ8QXJyYXkuPE51bWJlcj59IC0gVGhlIGNvb3JkaW5hdGUgb2YgdGhlIGl0ZW0gaW4gcGl4ZWwgb3IgYWxsIGNvb3JkaW5hdGVzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmNvb3JkaW5hdGVzID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyIG11bHRpcGxpZXIgPSAxLFxcblxcdFxcdCAgICBuZXdQb3NpdGlvbiA9IHBvc2l0aW9uIC0gMSxcXG5cXHRcXHQgICAgY29vcmRpbmF0ZTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybiAkLm1hcCh0aGlzLl9jb29yZGluYXRlcywgJC5wcm94eShmdW5jdGlvbiAoY29vcmRpbmF0ZSwgaW5kZXgpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gdGhpcy5jb29yZGluYXRlcyhpbmRleCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5jZW50ZXIpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5ydGwpIHtcXG5cXHRcXHRcXHRcXHRtdWx0aXBsaWVyID0gLTE7XFxuXFx0XFx0XFx0XFx0bmV3UG9zaXRpb24gPSBwb3NpdGlvbiArIDE7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGNvb3JkaW5hdGUgPSB0aGlzLl9jb29yZGluYXRlc1twb3NpdGlvbl07XFxuXFx0XFx0XFx0Y29vcmRpbmF0ZSArPSAodGhpcy53aWR0aCgpIC0gY29vcmRpbmF0ZSArICh0aGlzLl9jb29yZGluYXRlc1tuZXdQb3NpdGlvbl0gfHwgMCkpIC8gMiAqIG11bHRpcGxpZXI7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRjb29yZGluYXRlID0gdGhpcy5fY29vcmRpbmF0ZXNbbmV3UG9zaXRpb25dIHx8IDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvb3JkaW5hdGUgPSBNYXRoLmNlaWwoY29vcmRpbmF0ZSk7XFxuXFxuXFx0XFx0cmV0dXJuIGNvb3JkaW5hdGU7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ2FsY3VsYXRlcyB0aGUgc3BlZWQgZm9yIGEgdHJhbnNsYXRpb24uXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtOdW1iZXJ9IGZyb20gLSBUaGUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIHN0YXJ0IGl0ZW0uXFxuICAqIEBwYXJhbSB7TnVtYmVyfSB0byAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGl0ZW0uXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbZmFjdG9yPXVuZGVmaW5lZF0gLSBUaGUgdGltZSBmYWN0b3IgaW4gbWlsbGlzZWNvbmRzLlxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zbGF0aW9uLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmR1cmF0aW9uID0gZnVuY3Rpb24gKGZyb20sIHRvLCBmYWN0b3IpIHtcXG5cXHRcXHRpZiAoZmFjdG9yID09PSAwKSB7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBNYXRoLm1pbihNYXRoLm1heChNYXRoLmFicyh0byAtIGZyb20pLCAxKSwgNikgKiBNYXRoLmFicyhmYWN0b3IgfHwgdGhpcy5zZXR0aW5ncy5zbWFydFNwZWVkKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTbGlkZXMgdG8gdGhlIHNwZWNpZmllZCBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnRvID0gZnVuY3Rpb24gKHBvc2l0aW9uLCBzcGVlZCkge1xcblxcdFxcdHZhciBjdXJyZW50ID0gdGhpcy5jdXJyZW50KCksXFxuXFx0XFx0ICAgIHJldmVydCA9IG51bGwsXFxuXFx0XFx0ICAgIGRpc3RhbmNlID0gcG9zaXRpb24gLSB0aGlzLnJlbGF0aXZlKGN1cnJlbnQpLFxcblxcdFxcdCAgICBkaXJlY3Rpb24gPSAoZGlzdGFuY2UgPiAwKSAtIChkaXN0YW5jZSA8IDApLFxcblxcdFxcdCAgICBpdGVtcyA9IHRoaXMuX2l0ZW1zLmxlbmd0aCxcXG5cXHRcXHQgICAgbWluaW11bSA9IHRoaXMubWluaW11bSgpLFxcblxcdFxcdCAgICBtYXhpbXVtID0gdGhpcy5tYXhpbXVtKCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MubG9vcCkge1xcblxcdFxcdFxcdGlmICghdGhpcy5zZXR0aW5ncy5yZXdpbmQgJiYgTWF0aC5hYnMoZGlzdGFuY2UpID4gaXRlbXMgLyAyKSB7XFxuXFx0XFx0XFx0XFx0ZGlzdGFuY2UgKz0gZGlyZWN0aW9uICogLTEgKiBpdGVtcztcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cG9zaXRpb24gPSBjdXJyZW50ICsgZGlzdGFuY2U7XFxuXFx0XFx0XFx0cmV2ZXJ0ID0gKChwb3NpdGlvbiAtIG1pbmltdW0pICUgaXRlbXMgKyBpdGVtcykgJSBpdGVtcyArIG1pbmltdW07XFxuXFxuXFx0XFx0XFx0aWYgKHJldmVydCAhPT0gcG9zaXRpb24gJiYgcmV2ZXJ0IC0gZGlzdGFuY2UgPD0gbWF4aW11bSAmJiByZXZlcnQgLSBkaXN0YW5jZSA+IDApIHtcXG5cXHRcXHRcXHRcXHRjdXJyZW50ID0gcmV2ZXJ0IC0gZGlzdGFuY2U7XFxuXFx0XFx0XFx0XFx0cG9zaXRpb24gPSByZXZlcnQ7XFxuXFx0XFx0XFx0XFx0dGhpcy5yZXNldChjdXJyZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSBlbHNlIGlmICh0aGlzLnNldHRpbmdzLnJld2luZCkge1xcblxcdFxcdFxcdG1heGltdW0gKz0gMTtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IChwb3NpdGlvbiAlIG1heGltdW0gKyBtYXhpbXVtKSAlIG1heGltdW07XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IE1hdGgubWF4KG1pbmltdW0sIE1hdGgubWluKG1heGltdW0sIHBvc2l0aW9uKSk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuc3BlZWQodGhpcy5kdXJhdGlvbihjdXJyZW50LCBwb3NpdGlvbiwgc3BlZWQpKTtcXG5cXHRcXHR0aGlzLmN1cnJlbnQocG9zaXRpb24pO1xcblxcblxcdFxcdGlmICh0aGlzLiRlbGVtZW50LmlzKCc6dmlzaWJsZScpKSB7XFxuXFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2xpZGVzIHRvIHRoZSBuZXh0IGl0ZW0uXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcXG5cXHRcXHRzcGVlZCA9IHNwZWVkIHx8IGZhbHNlO1xcblxcdFxcdHRoaXMudG8odGhpcy5yZWxhdGl2ZSh0aGlzLmN1cnJlbnQoKSkgKyAxLCBzcGVlZCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2xpZGVzIHRvIHRoZSBwcmV2aW91cyBpdGVtLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5wcmV2ID0gZnVuY3Rpb24gKHNwZWVkKSB7XFxuXFx0XFx0c3BlZWQgPSBzcGVlZCB8fCBmYWxzZTtcXG5cXHRcXHR0aGlzLnRvKHRoaXMucmVsYXRpdmUodGhpcy5jdXJyZW50KCkpIC0gMSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEhhbmRsZXMgdGhlIGVuZCBvZiBhbiBhbmltYXRpb24uXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgYXJndW1lbnRzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLm9uVHJhbnNpdGlvbkVuZCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcblxcdFxcdC8vIGlmIGNzczIgYW5pbWF0aW9uIHRoZW4gZXZlbnQgb2JqZWN0IGlzIHVuZGVmaW5lZFxcblxcdFxcdGlmIChldmVudCAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0XFx0XFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XFxuXFxuXFx0XFx0XFx0Ly8gQ2F0Y2ggb25seSBvd2wtc3RhZ2UgdHJhbnNpdGlvbkVuZCBldmVudFxcblxcdFxcdFxcdGlmICgoZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQgfHwgZXZlbnQub3JpZ2luYWxUYXJnZXQpICE9PSB0aGlzLiRzdGFnZS5nZXQoMCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZmFsc2U7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmxlYXZlKCdhbmltYXRpbmcnKTtcXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ3RyYW5zbGF0ZWQnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHZpZXdwb3J0IHdpZHRoLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEByZXR1cm4ge051bWJlcn0gLSBUaGUgd2lkdGggaW4gcGl4ZWwuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUudmlld3BvcnQgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIHdpZHRoO1xcblxcdFxcdGlmICh0aGlzLm9wdGlvbnMucmVzcG9uc2l2ZUJhc2VFbGVtZW50ICE9PSB3aW5kb3cpIHtcXG5cXHRcXHRcXHR3aWR0aCA9ICQodGhpcy5vcHRpb25zLnJlc3BvbnNpdmVCYXNlRWxlbWVudCkud2lkdGgoKTtcXG5cXHRcXHR9IGVsc2UgaWYgKHdpbmRvdy5pbm5lcldpZHRoKSB7XFxuXFx0XFx0XFx0d2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcXG5cXHRcXHR9IGVsc2UgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgpIHtcXG5cXHRcXHRcXHR3aWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdGNvbnNvbGUud2FybignQ2FuIG5vdCBkZXRlY3Qgdmlld3BvcnQgd2lkdGguJyk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB3aWR0aDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCBjb250ZW50LlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR8alF1ZXJ5fFN0cmluZ30gY29udGVudCAtIFRoZSBuZXcgY29udGVudC5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZXBsYWNlID0gZnVuY3Rpb24gKGNvbnRlbnQpIHtcXG5cXHRcXHR0aGlzLiRzdGFnZS5lbXB0eSgpO1xcblxcdFxcdHRoaXMuX2l0ZW1zID0gW107XFxuXFxuXFx0XFx0aWYgKGNvbnRlbnQpIHtcXG5cXHRcXHRcXHRjb250ZW50ID0gY29udGVudCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRlbnQgOiAkKGNvbnRlbnQpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAodGhpcy5zZXR0aW5ncy5uZXN0ZWRJdGVtU2VsZWN0b3IpIHtcXG5cXHRcXHRcXHRjb250ZW50ID0gY29udGVudC5maW5kKCcuJyArIHRoaXMuc2V0dGluZ3MubmVzdGVkSXRlbVNlbGVjdG9yKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Y29udGVudC5maWx0ZXIoZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdHJldHVybiB0aGlzLm5vZGVUeXBlID09PSAxO1xcblxcdFxcdH0pLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaW5kZXgsIGl0ZW0pIHtcXG5cXHRcXHRcXHRpdGVtID0gdGhpcy5wcmVwYXJlKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuJHN0YWdlLmFwcGVuZChpdGVtKTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5wdXNoKGl0ZW0pO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMucHVzaChpdGVtLmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcblxcdFxcdHRoaXMucmVzZXQodGhpcy5pc051bWVyaWModGhpcy5zZXR0aW5ncy5zdGFydFBvc2l0aW9uKSA/IHRoaXMuc2V0dGluZ3Muc3RhcnRQb3NpdGlvbiA6IDApO1xcblxcblxcdFxcdHRoaXMuaW52YWxpZGF0ZSgnaXRlbXMnKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBBZGRzIGFuIGl0ZW0uXFxuICAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudHxqUXVlcnl8U3RyaW5nfSBjb250ZW50IC0gVGhlIGl0ZW0gY29udGVudCB0byBhZGQuXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbcG9zaXRpb25dIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIGF0IHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbSBvdGhlcndpc2UgdGhlIGl0ZW0gd2lsbCBiZSBhZGRlZCB0byB0aGUgZW5kLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChjb250ZW50LCBwb3NpdGlvbikge1xcblxcdFxcdHZhciBjdXJyZW50ID0gdGhpcy5yZWxhdGl2ZSh0aGlzLl9jdXJyZW50KTtcXG5cXG5cXHRcXHRwb3NpdGlvbiA9IHBvc2l0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLl9pdGVtcy5sZW5ndGggOiB0aGlzLm5vcm1hbGl6ZShwb3NpdGlvbiwgdHJ1ZSk7XFxuXFx0XFx0Y29udGVudCA9IGNvbnRlbnQgaW5zdGFuY2VvZiBqUXVlcnkgPyBjb250ZW50IDogJChjb250ZW50KTtcXG5cXG5cXHRcXHR0aGlzLnRyaWdnZXIoJ2FkZCcsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xcblxcblxcdFxcdGNvbnRlbnQgPSB0aGlzLnByZXBhcmUoY29udGVudCk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuX2l0ZW1zLmxlbmd0aCA9PT0gMCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5faXRlbXMubGVuZ3RoKSB7XFxuXFx0XFx0XFx0dGhpcy5faXRlbXMubGVuZ3RoID09PSAwICYmIHRoaXMuJHN0YWdlLmFwcGVuZChjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5sZW5ndGggIT09IDAgJiYgdGhpcy5faXRlbXNbcG9zaXRpb24gLSAxXS5hZnRlcihjb250ZW50KTtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtcy5wdXNoKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX21lcmdlcnMucHVzaChjb250ZW50LmZpbmQoJ1tkYXRhLW1lcmdlXScpLmFkZEJhY2soJ1tkYXRhLW1lcmdlXScpLmF0dHIoJ2RhdGEtbWVyZ2UnKSAqIDEgfHwgMSk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHR0aGlzLl9pdGVtc1twb3NpdGlvbl0uYmVmb3JlKGNvbnRlbnQpO1xcblxcdFxcdFxcdHRoaXMuX2l0ZW1zLnNwbGljZShwb3NpdGlvbiwgMCwgY29udGVudCk7XFxuXFx0XFx0XFx0dGhpcy5fbWVyZ2Vycy5zcGxpY2UocG9zaXRpb24sIDAsIGNvbnRlbnQuZmluZCgnW2RhdGEtbWVyZ2VdJykuYWRkQmFjaygnW2RhdGEtbWVyZ2VdJykuYXR0cignZGF0YS1tZXJnZScpICogMSB8fCAxKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5faXRlbXNbY3VycmVudF0gJiYgdGhpcy5yZXNldCh0aGlzLl9pdGVtc1tjdXJyZW50XS5pbmRleCgpKTtcXG5cXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdhZGRlZCcsIHsgY29udGVudDogY29udGVudCwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFJlbW92ZXMgYW4gaXRlbSBieSBpdHMgcG9zaXRpb24uXFxuICAqIEB0b2RvIFVzZSBgaXRlbWAgaW5zdGVhZCBvZiBgY29udGVudGAgZm9yIHRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IHBvc2l0aW9uIC0gVGhlIHJlbGF0aXZlIHBvc2l0aW9uIG9mIHRoZSBpdGVtIHRvIHJlbW92ZS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAocG9zaXRpb24pIHtcXG5cXHRcXHRwb3NpdGlvbiA9IHRoaXMubm9ybWFsaXplKHBvc2l0aW9uLCB0cnVlKTtcXG5cXG5cXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZW1vdmUnLCB7IGNvbnRlbnQ6IHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXSwgcG9zaXRpb246IHBvc2l0aW9uIH0pO1xcblxcblxcdFxcdHRoaXMuX2l0ZW1zW3Bvc2l0aW9uXS5yZW1vdmUoKTtcXG5cXHRcXHR0aGlzLl9pdGVtcy5zcGxpY2UocG9zaXRpb24sIDEpO1xcblxcdFxcdHRoaXMuX21lcmdlcnMuc3BsaWNlKHBvc2l0aW9uLCAxKTtcXG5cXG5cXHRcXHR0aGlzLmludmFsaWRhdGUoJ2l0ZW1zJyk7XFxuXFxuXFx0XFx0dGhpcy50cmlnZ2VyKCdyZW1vdmVkJywgeyBjb250ZW50OiBudWxsLCBwb3NpdGlvbjogcG9zaXRpb24gfSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUHJlbG9hZHMgaW1hZ2VzIHdpdGggYXV0byB3aWR0aC5cXG4gICogQHRvZG8gUmVwbGFjZSBieSBhIG1vcmUgZ2VuZXJpYyBhcHByb2FjaFxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUucHJlbG9hZEF1dG9XaWR0aEltYWdlcyA9IGZ1bmN0aW9uIChpbWFnZXMpIHtcXG5cXHRcXHRpbWFnZXMuZWFjaCgkLnByb3h5KGZ1bmN0aW9uIChpLCBlbGVtZW50KSB7XFxuXFx0XFx0XFx0dGhpcy5lbnRlcigncHJlLWxvYWRpbmcnKTtcXG5cXHRcXHRcXHRlbGVtZW50ID0gJChlbGVtZW50KTtcXG5cXHRcXHRcXHQkKG5ldyBJbWFnZSgpKS5vbmUoJ2xvYWQnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0ZWxlbWVudC5hdHRyKCdzcmMnLCBlLnRhcmdldC5zcmMpO1xcblxcdFxcdFxcdFxcdGVsZW1lbnQuY3NzKCdvcGFjaXR5JywgMSk7XFxuXFx0XFx0XFx0XFx0dGhpcy5sZWF2ZSgncHJlLWxvYWRpbmcnKTtcXG5cXHRcXHRcXHRcXHQhdGhpcy5pcygncHJlLWxvYWRpbmcnKSAmJiAhdGhpcy5pcygnaW5pdGlhbGl6aW5nJykgJiYgdGhpcy5yZWZyZXNoKCk7XFxuXFx0XFx0XFx0fSwgdGhpcykpLmF0dHIoJ3NyYycsIGVsZW1lbnQuYXR0cignc3JjJykgfHwgZWxlbWVudC5hdHRyKCdkYXRhLXNyYycpIHx8IGVsZW1lbnQuYXR0cignZGF0YS1zcmMtcmV0aW5hJykpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgY2Fyb3VzZWwuXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcblxcdFxcdHRoaXMuJGVsZW1lbnQub2ZmKCcub3dsLmNvcmUnKTtcXG5cXHRcXHR0aGlzLiRzdGFnZS5vZmYoJy5vd2wuY29yZScpO1xcblxcdFxcdCQoZG9jdW1lbnQpLm9mZignLm93bC5jb3JlJyk7XFxuXFxuXFx0XFx0aWYgKHRoaXMuc2V0dGluZ3MucmVzcG9uc2l2ZSAhPT0gZmFsc2UpIHtcXG5cXHRcXHRcXHR3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMucmVzaXplVGltZXIpO1xcblxcdFxcdFxcdHRoaXMub2ZmKHdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuX2hhbmRsZXJzLm9uVGhyb3R0bGVkUmVzaXplKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9wbHVnaW5zKSB7XFxuXFx0XFx0XFx0dGhpcy5fcGx1Z2luc1tpXS5kZXN0cm95KCk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCcuY2xvbmVkJykucmVtb3ZlKCk7XFxuXFxuXFx0XFx0dGhpcy4kc3RhZ2UudW53cmFwKCk7XFxuXFx0XFx0dGhpcy4kc3RhZ2UuY2hpbGRyZW4oKS5jb250ZW50cygpLnVud3JhcCgpO1xcblxcdFxcdHRoaXMuJHN0YWdlLmNoaWxkcmVuKCkudW53cmFwKCk7XFxuXFxuXFx0XFx0dGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMucmVmcmVzaENsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGluZ0NsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubG9hZGVkQ2xhc3MpLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5ydGxDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmRyYWdDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmdyYWJDbGFzcykuYXR0cignY2xhc3MnLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2NsYXNzJykucmVwbGFjZShuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXNwb25zaXZlQ2xhc3MgKyAnLVxcXFxcXFxcUytcXFxcXFxcXHMnLCAnZycpLCAnJykpLnJlbW92ZURhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIE9wZXJhdG9ycyB0byBjYWxjdWxhdGUgcmlnaHQtdG8tbGVmdCBhbmQgbGVmdC10by1yaWdodC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge051bWJlcn0gW2FdIC0gVGhlIGxlZnQgc2lkZSBvcGVyYW5kLlxcbiAgKiBAcGFyYW0ge1N0cmluZ30gW29dIC0gVGhlIG9wZXJhdG9yLlxcbiAgKiBAcGFyYW0ge051bWJlcn0gW2JdIC0gVGhlIHJpZ2h0IHNpZGUgb3BlcmFuZC5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vcCA9IGZ1bmN0aW9uIChhLCBvLCBiKSB7XFxuXFx0XFx0dmFyIHJ0bCA9IHRoaXMuc2V0dGluZ3MucnRsO1xcblxcdFxcdHN3aXRjaCAobykge1xcblxcdFxcdFxcdGNhc2UgJzwnOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhID4gYiA6IGEgPCBiO1xcblxcdFxcdFxcdGNhc2UgJz4nOlxcblxcdFxcdFxcdFxcdHJldHVybiBydGwgPyBhIDwgYiA6IGEgPiBiO1xcblxcdFxcdFxcdGNhc2UgJz49JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA8PSBiIDogYSA+PSBiO1xcblxcdFxcdFxcdGNhc2UgJzw9JzpcXG5cXHRcXHRcXHRcXHRyZXR1cm4gcnRsID8gYSA+PSBiIDogYSA8PSBiO1xcblxcdFxcdFxcdGRlZmF1bHQ6XFxuXFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEF0dGFjaGVzIHRvIGFuIGludGVybmFsIGV2ZW50LlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnQgLSBUaGUgZXZlbnQgc291cmNlLlxcbiAgKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgbmFtZS5cXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBUaGUgZXZlbnQgaGFuZGxlciB0byBhdHRhY2guXFxuICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZSAtIFdldGhlciB0aGUgZXZlbnQgc2hvdWxkIGJlIGhhbmRsZWQgYXQgdGhlIGNhcHR1cmluZyBwaGFzZSBvciBub3QuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XFxuXFx0XFx0aWYgKGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xcblxcdFxcdH0gZWxzZSBpZiAoZWxlbWVudC5hdHRhY2hFdmVudCkge1xcblxcdFxcdFxcdGVsZW1lbnQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERldGFjaGVzIGZyb20gYW4gaW50ZXJuYWwgZXZlbnQuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIFRoZSBldmVudCBzb3VyY2UuXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAtIFRoZSBldmVudCBuYW1lLlxcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIFRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHRvIGRldGFjaC5cXG4gICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlIC0gV2V0aGVyIHRoZSBhdHRhY2hlZCBldmVudCBoYW5kbGVyIHdhcyByZWdpc3RlcmVkIGFzIGEgY2FwdHVyaW5nIGxpc3RlbmVyIG9yIG5vdC5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoZWxlbWVudCwgZXZlbnQsIGxpc3RlbmVyLCBjYXB0dXJlKSB7XFxuXFx0XFx0aWYgKGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xcblxcdFxcdFxcdGVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGNhcHR1cmUpO1xcblxcdFxcdH0gZWxzZSBpZiAoZWxlbWVudC5kZXRhY2hFdmVudCkge1xcblxcdFxcdFxcdGVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBsaXN0ZW5lcik7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFRyaWdnZXJzIGEgcHVibGljIGV2ZW50LlxcbiAgKiBAdG9kbyBSZW1vdmUgYHN0YXR1c2AsIGByZWxhdGVkVGFyZ2V0YCBzaG91bGQgYmUgdXNlZCBpbnN0ZWFkLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gVGhlIGV2ZW50IG5hbWUuXFxuICAqIEBwYXJhbSB7Kn0gW2RhdGE9bnVsbF0gLSBUaGUgZXZlbnQgZGF0YS5cXG4gICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lc3BhY2U9Y2Fyb3VzZWxdIC0gVGhlIGV2ZW50IG5hbWVzcGFjZS5cXG4gICogQHBhcmFtIHtTdHJpbmd9IFtzdGF0ZV0gLSBUaGUgc3RhdGUgd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBldmVudC5cXG4gICogQHBhcmFtIHtCb29sZWFufSBbZW50ZXI9ZmFsc2VdIC0gSW5kaWNhdGVzIGlmIHRoZSBjYWxsIGVudGVycyB0aGUgc3BlY2lmaWVkIHN0YXRlIG9yIG5vdC5cXG4gICogQHJldHVybnMge0V2ZW50fSAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqL1xcblxcdE93bC5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lLCBkYXRhLCBuYW1lc3BhY2UsIHN0YXRlLCBlbnRlcikge1xcblxcdFxcdHZhciBzdGF0dXMgPSB7XFxuXFx0XFx0XFx0aXRlbTogeyBjb3VudDogdGhpcy5faXRlbXMubGVuZ3RoLCBpbmRleDogdGhpcy5jdXJyZW50KCkgfVxcblxcdFxcdH0sXFxuXFx0XFx0ICAgIGhhbmRsZXIgPSAkLmNhbWVsQ2FzZSgkLmdyZXAoWydvbicsIG5hbWUsIG5hbWVzcGFjZV0sIGZ1bmN0aW9uICh2KSB7XFxuXFx0XFx0XFx0cmV0dXJuIHY7XFxuXFx0XFx0fSkuam9pbignLScpLnRvTG93ZXJDYXNlKCkpLFxcblxcdFxcdCAgICBldmVudCA9ICQuRXZlbnQoW25hbWUsICdvd2wnLCBuYW1lc3BhY2UgfHwgJ2Nhcm91c2VsJ10uam9pbignLicpLnRvTG93ZXJDYXNlKCksICQuZXh0ZW5kKHsgcmVsYXRlZFRhcmdldDogdGhpcyB9LCBzdGF0dXMsIGRhdGEpKTtcXG5cXG5cXHRcXHRpZiAoIXRoaXMuX3N1cHJlc3NbbmFtZV0pIHtcXG5cXHRcXHRcXHQkLmVhY2godGhpcy5fcGx1Z2lucywgZnVuY3Rpb24gKG5hbWUsIHBsdWdpbikge1xcblxcdFxcdFxcdFxcdGlmIChwbHVnaW4ub25UcmlnZ2VyKSB7XFxuXFx0XFx0XFx0XFx0XFx0cGx1Z2luLm9uVHJpZ2dlcihldmVudCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0pO1xcblxcblxcdFxcdFxcdHRoaXMucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogbmFtZSB9KTtcXG5cXHRcXHRcXHR0aGlzLiRlbGVtZW50LnRyaWdnZXIoZXZlbnQpO1xcblxcblxcdFxcdFxcdGlmICh0aGlzLnNldHRpbmdzICYmIHR5cGVvZiB0aGlzLnNldHRpbmdzW2hhbmRsZXJdID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5zZXR0aW5nc1toYW5kbGVyXS5jYWxsKHRoaXMsIGV2ZW50KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiBldmVudDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBFbnRlcnMgYSBzdGF0ZS5cXG4gICogQHBhcmFtIG5hbWUgLSBUaGUgc3RhdGUgbmFtZS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuXFx0XFx0JC5lYWNoKFtuYW1lXS5jb25jYXQodGhpcy5fc3RhdGVzLnRhZ3NbbmFtZV0gfHwgW10pLCAkLnByb3h5KGZ1bmN0aW9uIChpLCBuYW1lKSB7XFxuXFx0XFx0XFx0aWYgKHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdID09PSB1bmRlZmluZWQpIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXSA9IDA7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX3N0YXRlcy5jdXJyZW50W25hbWVdKys7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIExlYXZlcyBhIHN0YXRlLlxcbiAgKiBAcGFyYW0gbmFtZSAtIFRoZSBzdGF0ZSBuYW1lLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKG5hbWUpIHtcXG5cXHRcXHQkLmVhY2goW25hbWVdLmNvbmNhdCh0aGlzLl9zdGF0ZXMudGFnc1tuYW1lXSB8fCBbXSksICQucHJveHkoZnVuY3Rpb24gKGksIG5hbWUpIHtcXG5cXHRcXHRcXHR0aGlzLl9zdGF0ZXMuY3VycmVudFtuYW1lXS0tO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBSZWdpc3RlcnMgYW4gZXZlbnQgb3Igc3RhdGUuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCAtIFRoZSBldmVudCBvciBzdGF0ZSB0byByZWdpc3Rlci5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5yZWdpc3RlciA9IGZ1bmN0aW9uIChvYmplY3QpIHtcXG5cXHRcXHRpZiAob2JqZWN0LnR5cGUgPT09IE93bC5UeXBlLkV2ZW50KSB7XFxuXFx0XFx0XFx0aWYgKCEkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdKSB7XFxuXFx0XFx0XFx0XFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXSA9IHt9O1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoISQuZXZlbnQuc3BlY2lhbFtvYmplY3QubmFtZV0ub3dsKSB7XFxuXFx0XFx0XFx0XFx0dmFyIF9kZWZhdWx0ID0gJC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5fZGVmYXVsdDtcXG5cXHRcXHRcXHRcXHQkLmV2ZW50LnNwZWNpYWxbb2JqZWN0Lm5hbWVdLl9kZWZhdWx0ID0gZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoX2RlZmF1bHQgJiYgX2RlZmF1bHQuYXBwbHkgJiYgKCFlLm5hbWVzcGFjZSB8fCBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA9PT0gLTEpKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0cmV0dXJuIF9kZWZhdWx0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBlLm5hbWVzcGFjZSAmJiBlLm5hbWVzcGFjZS5pbmRleE9mKCdvd2wnKSA+IC0xO1xcblxcdFxcdFxcdFxcdH07XFxuXFx0XFx0XFx0XFx0JC5ldmVudC5zcGVjaWFsW29iamVjdC5uYW1lXS5vd2wgPSB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2UgaWYgKG9iamVjdC50eXBlID09PSBPd2wuVHlwZS5TdGF0ZSkge1xcblxcdFxcdFxcdGlmICghdGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdKSB7XFxuXFx0XFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gb2JqZWN0LnRhZ3M7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0gPSB0aGlzLl9zdGF0ZXMudGFnc1tvYmplY3QubmFtZV0uY29uY2F0KG9iamVjdC50YWdzKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fc3RhdGVzLnRhZ3Nbb2JqZWN0Lm5hbWVdID0gJC5ncmVwKHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSwgJC5wcm94eShmdW5jdGlvbiAodGFnLCBpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICQuaW5BcnJheSh0YWcsIHRoaXMuX3N0YXRlcy50YWdzW29iamVjdC5uYW1lXSkgPT09IGk7XFxuXFx0XFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBTdXBwcmVzc2VzIGV2ZW50cy5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge0FycmF5LjxTdHJpbmc+fSBldmVudHMgLSBUaGUgZXZlbnRzIHRvIHN1cHByZXNzLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnN1cHByZXNzID0gZnVuY3Rpb24gKGV2ZW50cykge1xcblxcdFxcdCQuZWFjaChldmVudHMsICQucHJveHkoZnVuY3Rpb24gKGluZGV4LCBldmVudCkge1xcblxcdFxcdFxcdHRoaXMuX3N1cHJlc3NbZXZlbnRdID0gdHJ1ZTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVsZWFzZXMgc3VwcHJlc3NlZCBldmVudHMuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtBcnJheS48U3RyaW5nPn0gZXZlbnRzIC0gVGhlIGV2ZW50cyB0byByZWxlYXNlLlxcbiAgKi9cXG5cXHRPd2wucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAoZXZlbnRzKSB7XFxuXFx0XFx0JC5lYWNoKGV2ZW50cywgJC5wcm94eShmdW5jdGlvbiAoaW5kZXgsIGV2ZW50KSB7XFxuXFx0XFx0XFx0ZGVsZXRlIHRoaXMuX3N1cHJlc3NbZXZlbnRdO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHVuaWZpZWQgcG9pbnRlciBjb29yZGluYXRlcyBmcm9tIGV2ZW50LlxcbiAgKiBAdG9kbyAjMjYxXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtFdmVudH0gLSBUaGUgYG1vdXNlZG93bmAgb3IgYHRvdWNoc3RhcnRgIGV2ZW50LlxcbiAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIENvbnRhaW5zIGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIG9mIGN1cnJlbnQgcG9pbnRlciBwb3NpdGlvbi5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5wb2ludGVyID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHJlc3VsdCA9IHsgeDogbnVsbCwgeTogbnVsbCB9O1xcblxcblxcdFxcdGV2ZW50ID0gZXZlbnQub3JpZ2luYWxFdmVudCB8fCBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XFxuXFxuXFx0XFx0ZXZlbnQgPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID8gZXZlbnQudG91Y2hlc1swXSA6IGV2ZW50LmNoYW5nZWRUb3VjaGVzICYmIGV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aCA/IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdIDogZXZlbnQ7XFxuXFxuXFx0XFx0aWYgKGV2ZW50LnBhZ2VYKSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5wYWdlWDtcXG5cXHRcXHRcXHRyZXN1bHQueSA9IGV2ZW50LnBhZ2VZO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVzdWx0LnggPSBldmVudC5jbGllbnRYO1xcblxcdFxcdFxcdHJlc3VsdC55ID0gZXZlbnQuY2xpZW50WTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXRlcm1pbmVzIGlmIHRoZSBpbnB1dCBpcyBhIE51bWJlciBvciBzb21ldGhpbmcgdGhhdCBjYW4gYmUgY29lcmNlZCB0byBhIE51bWJlclxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7TnVtYmVyfFN0cmluZ3xPYmplY3R8QXJyYXl8Qm9vbGVhbnxSZWdFeHB8RnVuY3Rpb258U3ltYm9sfSAtIFRoZSBpbnB1dCB0byBiZSB0ZXN0ZWRcXG4gICogQHJldHVybnMge0Jvb2xlYW59IC0gQW4gaW5kaWNhdGlvbiBpZiB0aGUgaW5wdXQgaXMgYSBOdW1iZXIgb3IgY2FuIGJlIGNvZXJjZWQgdG8gYSBOdW1iZXJcXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5pc051bWVyaWMgPSBmdW5jdGlvbiAobnVtYmVyKSB7XFxuXFx0XFx0cmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG51bWJlcikpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIGRpZmZlcmVuY2Ugb2YgdHdvIHZlY3RvcnMuXFxuICAqIEB0b2RvICMyNjFcXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgZmlyc3QgdmVjdG9yLlxcbiAgKiBAcGFyYW0ge09iamVjdH0gLSBUaGUgc2Vjb25kIHZlY3Rvci5cXG4gICogQHJldHVybnMge09iamVjdH0gLSBUaGUgZGlmZmVyZW5jZS5cXG4gICovXFxuXFx0T3dsLnByb3RvdHlwZS5kaWZmZXJlbmNlID0gZnVuY3Rpb24gKGZpcnN0LCBzZWNvbmQpIHtcXG5cXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdHg6IGZpcnN0LnggLSBzZWNvbmQueCxcXG5cXHRcXHRcXHR5OiBmaXJzdC55IC0gc2Vjb25kLnlcXG5cXHRcXHR9O1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFRoZSBqUXVlcnkgUGx1Z2luIGZvciB0aGUgT3dsIENhcm91c2VsXFxuICAqIEB0b2RvIE5hdmlnYXRpb24gcGx1Z2luIGBuZXh0YCBhbmQgYHByZXZgXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbCA9IGZ1bmN0aW9uIChvcHRpb24pIHtcXG5cXHRcXHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XFxuXFxuXFx0XFx0cmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0dmFyICR0aGlzID0gJCh0aGlzKSxcXG5cXHRcXHRcXHQgICAgZGF0YSA9ICR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcpO1xcblxcblxcdFxcdFxcdGlmICghZGF0YSkge1xcblxcdFxcdFxcdFxcdGRhdGEgPSBuZXcgT3dsKHRoaXMsICh0eXBlb2Ygb3B0aW9uID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihvcHRpb24pKSA9PSAnb2JqZWN0JyAmJiBvcHRpb24pO1xcblxcdFxcdFxcdFxcdCR0aGlzLmRhdGEoJ293bC5jYXJvdXNlbCcsIGRhdGEpO1xcblxcblxcdFxcdFxcdFxcdCQuZWFjaChbJ25leHQnLCAncHJldicsICd0bycsICdkZXN0cm95JywgJ3JlZnJlc2gnLCAncmVwbGFjZScsICdhZGQnLCAncmVtb3ZlJ10sIGZ1bmN0aW9uIChpLCBldmVudCkge1xcblxcdFxcdFxcdFxcdFxcdGRhdGEucmVnaXN0ZXIoeyB0eXBlOiBPd2wuVHlwZS5FdmVudCwgbmFtZTogZXZlbnQgfSk7XFxuXFx0XFx0XFx0XFx0XFx0ZGF0YS4kZWxlbWVudC5vbihldmVudCArICcub3dsLmNhcm91c2VsLmNvcmUnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIGUucmVsYXRlZFRhcmdldCAhPT0gdGhpcykge1xcblxcdFxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3VwcHJlc3MoW2V2ZW50XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0XFx0ZGF0YVtldmVudF0uYXBwbHkodGhpcywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcXG5cXHRcXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnJlbGVhc2UoW2V2ZW50XSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdH0sIGRhdGEpKTtcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKHR5cGVvZiBvcHRpb24gPT0gJ3N0cmluZycgJiYgb3B0aW9uLmNoYXJBdCgwKSAhPT0gJ18nKSB7XFxuXFx0XFx0XFx0XFx0ZGF0YVtvcHRpb25dLmFwcGx5KGRhdGEsIGFyZ3MpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBUaGUgY29uc3RydWN0b3IgZm9yIHRoZSBqUXVlcnkgUGx1Z2luXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3RvciA9IE93bDtcXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogQXV0b1JlZnJlc2ggUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgYXV0byByZWZyZXNoIHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBBdXRvIFJlZnJlc2ggUGx1Z2luXFxuICAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG4gICovXFxuXFx0dmFyIEF1dG9SZWZyZXNoID0gZnVuY3Rpb24gQXV0b1JlZnJlc2goY2Fyb3VzZWwpIHtcXG5cXHRcXHQvKipcXG4gICAqIFJlZmVyZW5jZSB0byB0aGUgY29yZS5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPd2x9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9jb3JlID0gY2Fyb3VzZWw7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSZWZyZXNoIGludGVydmFsLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge251bWJlcn1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2ludGVydmFsID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFdoZXRoZXIgdGhlIGVsZW1lbnQgaXMgY3VycmVudGx5IHZpc2libGUgb3Igbm90LlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge0Jvb2xlYW59XFxuICAgKi9cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCBldmVudCBoYW5kbGVycy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9oYW5kbGVycyA9IHtcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9SZWZyZXNoKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy53YXRjaCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBdXRvUmVmcmVzaC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBdXRvUmVmcmVzaC5EZWZhdWx0cyA9IHtcXG5cXHRcXHRhdXRvUmVmcmVzaDogdHJ1ZSxcXG5cXHRcXHRhdXRvUmVmcmVzaEludGVydmFsOiA1MDBcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBXYXRjaGVzIHRoZSBlbGVtZW50LlxcbiAgKi9cXG5cXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUud2F0Y2ggPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0aWYgKHRoaXMuX2ludGVydmFsKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl92aXNpYmxlID0gdGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKTtcXG5cXHRcXHR0aGlzLl9pbnRlcnZhbCA9IHdpbmRvdy5zZXRJbnRlcnZhbCgkLnByb3h5KHRoaXMucmVmcmVzaCwgdGhpcyksIHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b1JlZnJlc2hJbnRlcnZhbCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogUmVmcmVzaGVzIHRoZSBlbGVtZW50LlxcbiAgKi9cXG5cXHRBdXRvUmVmcmVzaC5wcm90b3R5cGUucmVmcmVzaCA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRpZiAodGhpcy5fY29yZS4kZWxlbWVudC5pcygnOnZpc2libGUnKSA9PT0gdGhpcy5fdmlzaWJsZSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSA9ICF0aGlzLl92aXNpYmxlO1xcblxcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQudG9nZ2xlQ2xhc3MoJ293bC1oaWRkZW4nLCAhdGhpcy5fdmlzaWJsZSk7XFxuXFxuXFx0XFx0dGhpcy5fdmlzaWJsZSAmJiB0aGlzLl9jb3JlLmludmFsaWRhdGUoJ3dpZHRoJykgJiYgdGhpcy5fY29yZS5yZWZyZXNoKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG4gICovXFxuXFx0QXV0b1JlZnJlc2gucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdHdpbmRvdy5jbGVhckludGVydmFsKHRoaXMuX2ludGVydmFsKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQXV0b1JlZnJlc2ggPSBBdXRvUmVmcmVzaDtcXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogTGF6eSBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQmFydG9zeiBXb2pjaWVjaG93c2tpXFxuICogQGF1dGhvciBEYXZpZCBEZXV0c2NoXFxuICogQGxpY2Vuc2UgVGhlIE1JVCBMaWNlbnNlIChNSVQpXFxuICovXFxuOyhmdW5jdGlvbiAoJCwgd2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIGxhenkgcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIExhenkgUGx1Z2luXFxuICAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG4gICovXFxuXFx0dmFyIExhenkgPSBmdW5jdGlvbiBMYXp5KGNhcm91c2VsKSB7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxyZWFkeSBsb2FkZWQgaXRlbXMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7QXJyYXkuPGpRdWVyeT59XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9sb2FkZWQgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEV2ZW50IGhhbmRsZXJzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgY2hhbmdlLm93bC5jYXJvdXNlbCByZXNpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHRpZiAoIXRoaXMuX2NvcmUuc2V0dGluZ3MgfHwgIXRoaXMuX2NvcmUuc2V0dGluZ3MubGF6eUxvYWQpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdGlmIChlLnByb3BlcnR5ICYmIGUucHJvcGVydHkubmFtZSA9PSAncG9zaXRpb24nIHx8IGUudHlwZSA9PSAnaW5pdGlhbGl6ZWQnKSB7XFxuXFx0XFx0XFx0XFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHRcXHRcXHRcXHQgICAgbiA9IHNldHRpbmdzLmNlbnRlciAmJiBNYXRoLmNlaWwoc2V0dGluZ3MuaXRlbXMgLyAyKSB8fCBzZXR0aW5ncy5pdGVtcyxcXG5cXHRcXHRcXHRcXHRcXHQgICAgaSA9IHNldHRpbmdzLmNlbnRlciAmJiBuICogLTEgfHwgMCxcXG5cXHRcXHRcXHRcXHRcXHQgICAgcG9zaXRpb24gPSAoZS5wcm9wZXJ0eSAmJiBlLnByb3BlcnR5LnZhbHVlICE9PSB1bmRlZmluZWQgPyBlLnByb3BlcnR5LnZhbHVlIDogdGhpcy5fY29yZS5jdXJyZW50KCkpICsgaSxcXG5cXHRcXHRcXHRcXHRcXHQgICAgY2xvbmVzID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGgsXFxuXFx0XFx0XFx0XFx0XFx0ICAgIGxvYWQgPSAkLnByb3h5KGZ1bmN0aW9uIChpLCB2KSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5sb2FkKHYpO1xcblxcdFxcdFxcdFxcdFxcdH0sIHRoaXMpO1xcblxcblxcdFxcdFxcdFxcdFxcdHdoaWxlIChpKysgPCBuKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGhpcy5sb2FkKGNsb25lcyAvIDIgKyB0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y2xvbmVzICYmICQuZWFjaCh0aGlzLl9jb3JlLmNsb25lcyh0aGlzLl9jb3JlLnJlbGF0aXZlKHBvc2l0aW9uKSksIGxvYWQpO1xcblxcdFxcdFxcdFxcdFxcdFxcdHBvc2l0aW9uKys7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IHRoZSBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTGF6eS5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVmYXVsdCBvcHRpb25zLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdExhenkuRGVmYXVsdHMgPSB7XFxuXFx0XFx0bGF6eUxvYWQ6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogTG9hZHMgYWxsIHJlc291cmNlcyBvZiBhbiBpdGVtIGF0IHRoZSBzcGVjaWZpZWQgcG9zaXRpb24uXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBwb3NpdGlvbiAtIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgaXRlbS5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHRMYXp5LnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKHBvc2l0aW9uKSB7XFxuXFx0XFx0dmFyICRpdGVtID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKS5lcShwb3NpdGlvbiksXFxuXFx0XFx0ICAgICRlbGVtZW50cyA9ICRpdGVtICYmICRpdGVtLmZpbmQoJy5vd2wtbGF6eScpO1xcblxcblxcdFxcdGlmICghJGVsZW1lbnRzIHx8ICQuaW5BcnJheSgkaXRlbS5nZXQoMCksIHRoaXMuX2xvYWRlZCkgPiAtMSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0JGVsZW1lbnRzLmVhY2goJC5wcm94eShmdW5jdGlvbiAoaW5kZXgsIGVsZW1lbnQpIHtcXG5cXHRcXHRcXHR2YXIgJGVsZW1lbnQgPSAkKGVsZW1lbnQpLFxcblxcdFxcdFxcdCAgICBpbWFnZSxcXG5cXHRcXHRcXHQgICAgdXJsID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxICYmICRlbGVtZW50LmF0dHIoJ2RhdGEtc3JjLXJldGluYScpIHx8ICRlbGVtZW50LmF0dHIoJ2RhdGEtc3JjJyk7XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkJywgeyBlbGVtZW50OiAkZWxlbWVudCwgdXJsOiB1cmwgfSwgJ2xhenknKTtcXG5cXG5cXHRcXHRcXHRpZiAoJGVsZW1lbnQuaXMoJ2ltZycpKSB7XFxuXFx0XFx0XFx0XFx0JGVsZW1lbnQub25lKCdsb2FkLm93bC5sYXp5JywgJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0XFx0JGVsZW1lbnQuY3NzKCdvcGFjaXR5JywgMSk7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdsb2FkZWQnLCB7IGVsZW1lbnQ6ICRlbGVtZW50LCB1cmw6IHVybCB9LCAnbGF6eScpO1xcblxcdFxcdFxcdFxcdH0sIHRoaXMpKS5hdHRyKCdzcmMnLCB1cmwpO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aW1hZ2UgPSBuZXcgSW1hZ2UoKTtcXG5cXHRcXHRcXHRcXHRpbWFnZS5vbmxvYWQgPSAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3Moe1xcblxcdFxcdFxcdFxcdFxcdFxcdCdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybChcXFwiJyArIHVybCArICdcXFwiKScsXFxuXFx0XFx0XFx0XFx0XFx0XFx0J29wYWNpdHknOiAnMSdcXG5cXHRcXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2xvYWRlZCcsIHsgZWxlbWVudDogJGVsZW1lbnQsIHVybDogdXJsIH0sICdsYXp5Jyk7XFxuXFx0XFx0XFx0XFx0fSwgdGhpcyk7XFxuXFx0XFx0XFx0XFx0aW1hZ2Uuc3JjID0gdXJsO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFxuXFx0XFx0dGhpcy5fbG9hZGVkLnB1c2goJGl0ZW0uZ2V0KDApKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdExhenkucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGhhbmRsZXIsIHByb3BlcnR5O1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLmhhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTGF6eSA9IExhenk7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEF1dG9IZWlnaHQgUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIHRoZSBhdXRvIGhlaWdodCBwbHVnaW4uXFxuICAqIEBjbGFzcyBUaGUgQXV0byBIZWlnaHQgUGx1Z2luXFxuICAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG4gICovXFxuXFx0dmFyIEF1dG9IZWlnaHQgPSBmdW5jdGlvbiBBdXRvSGVpZ2h0KGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwgcmVmcmVzaGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvSGVpZ2h0KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnbG9hZGVkLm93bC5sYXp5JzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHQgJiYgZS5lbGVtZW50LmNsb3Nlc3QoJy4nICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtQ2xhc3MpLmluZGV4KCkgPT09IHRoaXMuX2NvcmUuY3VycmVudCgpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy51cGRhdGUoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b0hlaWdodC5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBdXRvSGVpZ2h0LkRlZmF1bHRzID0ge1xcblxcdFxcdGF1dG9IZWlnaHQ6IGZhbHNlLFxcblxcdFxcdGF1dG9IZWlnaHRDbGFzczogJ293bC1oZWlnaHQnXFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogVXBkYXRlcyB0aGUgdmlldy5cXG4gICovXFxuXFx0QXV0b0hlaWdodC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBzdGFydCA9IHRoaXMuX2NvcmUuX2N1cnJlbnQsXFxuXFx0XFx0ICAgIGVuZCA9IHN0YXJ0ICsgdGhpcy5fY29yZS5zZXR0aW5ncy5pdGVtcyxcXG5cXHRcXHQgICAgdmlzaWJsZSA9IHRoaXMuX2NvcmUuJHN0YWdlLmNoaWxkcmVuKCkudG9BcnJheSgpLnNsaWNlKHN0YXJ0LCBlbmQpLFxcblxcdFxcdCAgICBoZWlnaHRzID0gW10sXFxuXFx0XFx0ICAgIG1heGhlaWdodCA9IDA7XFxuXFxuXFx0XFx0JC5lYWNoKHZpc2libGUsIGZ1bmN0aW9uIChpbmRleCwgaXRlbSkge1xcblxcdFxcdFxcdGhlaWdodHMucHVzaCgkKGl0ZW0pLmhlaWdodCgpKTtcXG5cXHRcXHR9KTtcXG5cXG5cXHRcXHRtYXhoZWlnaHQgPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRzdGFnZS5wYXJlbnQoKS5oZWlnaHQobWF4aGVpZ2h0KS5hZGRDbGFzcyh0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9IZWlnaHRDbGFzcyk7XFxuXFx0fTtcXG5cXG5cXHRBdXRvSGVpZ2h0LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQXV0b0hlaWdodCA9IEF1dG9IZWlnaHQ7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIFZpZGVvIFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgdmlkZW8gcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIFZpZGVvIFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gY2Fyb3VzZWwgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBWaWRlbyA9IGZ1bmN0aW9uIFZpZGVvKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogQ2FjaGUgYWxsIHZpZGVvIFVSTHMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5fdmlkZW9zID0ge307XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBDdXJyZW50IHBsYXlpbmcgaXRlbS5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtqUXVlcnl9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9wbGF5aW5nID0gbnVsbDtcXG5cXG5cXHRcXHQvKipcXG4gICAqIEFsbCBldmVudCBoYW5kbGVycy5cXG4gICAqIEB0b2RvIFRoZSBjbG9uZWQgY29udGVudCByZW1vdmFsZSBpcyB0b28gbGF0ZVxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdpbml0aWFsaXplZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS5yZWdpc3Rlcih7IHR5cGU6ICdzdGF0ZScsIG5hbWU6ICdwbGF5aW5nJywgdGFnczogWydpbnRlcmFjdGluZyddIH0pO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncmVzaXplLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy52aWRlbyAmJiB0aGlzLmlzSW5GdWxsU2NyZWVuKCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRlLnByZXZlbnREZWZhdWx0KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdyZWZyZXNoZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLmlzKCdyZXNpemluZycpKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS4kc3RhZ2UuZmluZCgnLmNsb25lZCAub3dsLXZpZGVvLWZyYW1lJykucmVtb3ZlKCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAncG9zaXRpb24nICYmIHRoaXMuX3BsYXlpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoIWUubmFtZXNwYWNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRcXHR2YXIgJGVsZW1lbnQgPSAkKGUuY29udGVudCkuZmluZCgnLm93bC12aWRlbycpO1xcblxcblxcdFxcdFxcdFxcdGlmICgkZWxlbWVudC5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHRcXHQkZWxlbWVudC5jc3MoJ2Rpc3BsYXknLCAnbm9uZScpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZmV0Y2goJGVsZW1lbnQsICQoZS5jb250ZW50KSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyBzZXQgZGVmYXVsdCBvcHRpb25zXFxuXFx0XFx0dGhpcy5fY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIFZpZGVvLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGhhbmRsZXJzXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbih0aGlzLl9oYW5kbGVycyk7XFxuXFxuXFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vbignY2xpY2sub3dsLnZpZGVvJywgJy5vd2wtdmlkZW8tcGxheS1pY29uJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdHRoaXMucGxheShlKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVmYXVsdCBvcHRpb25zLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdFZpZGVvLkRlZmF1bHRzID0ge1xcblxcdFxcdHZpZGVvOiBmYWxzZSxcXG5cXHRcXHR2aWRlb0hlaWdodDogZmFsc2UsXFxuXFx0XFx0dmlkZW9XaWR0aDogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBHZXRzIHRoZSB2aWRlbyBJRCBhbmQgdGhlIHR5cGUgKFlvdVR1YmUvVmltZW8vdnphYXIgb25seSkuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHBhcmFtIHtqUXVlcnl9IHRhcmdldCAtIFRoZSB0YXJnZXQgY29udGFpbmluZyB0aGUgdmlkZW8gZGF0YS5cXG4gICogQHBhcmFtIHtqUXVlcnl9IGl0ZW0gLSBUaGUgaXRlbSBjb250YWluaW5nIHRoZSB2aWRlby5cXG4gICovXFxuXFx0VmlkZW8ucHJvdG90eXBlLmZldGNoID0gZnVuY3Rpb24gKHRhcmdldCwgaXRlbSkge1xcblxcdFxcdHZhciB0eXBlID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdGlmICh0YXJnZXQuYXR0cignZGF0YS12aW1lby1pZCcpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICd2aW1lbyc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmICh0YXJnZXQuYXR0cignZGF0YS12emFhci1pZCcpKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuICd2emFhcic7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gJ3lvdXR1YmUnO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KCksXFxuXFx0XFx0ICAgIGlkID0gdGFyZ2V0LmF0dHIoJ2RhdGEtdmltZW8taWQnKSB8fCB0YXJnZXQuYXR0cignZGF0YS15b3V0dWJlLWlkJykgfHwgdGFyZ2V0LmF0dHIoJ2RhdGEtdnphYXItaWQnKSxcXG5cXHRcXHQgICAgd2lkdGggPSB0YXJnZXQuYXR0cignZGF0YS13aWR0aCcpIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MudmlkZW9XaWR0aCxcXG5cXHRcXHQgICAgaGVpZ2h0ID0gdGFyZ2V0LmF0dHIoJ2RhdGEtaGVpZ2h0JykgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy52aWRlb0hlaWdodCxcXG5cXHRcXHQgICAgdXJsID0gdGFyZ2V0LmF0dHIoJ2hyZWYnKTtcXG5cXG5cXHRcXHRpZiAodXJsKSB7XFxuXFxuXFx0XFx0XFx0LypcXG4gICBcXHRcXHRQYXJzZXMgdGhlIGlkJ3Mgb3V0IG9mIHRoZSBmb2xsb3dpbmcgdXJscyAoYW5kIHByb2JhYmx5IG1vcmUpOlxcbiAgIFxcdFxcdGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9OmlkXFxuICAgXFx0XFx0aHR0cHM6Ly95b3V0dS5iZS86aWRcXG4gICBcXHRcXHRodHRwczovL3ZpbWVvLmNvbS86aWRcXG4gICBcXHRcXHRodHRwczovL3ZpbWVvLmNvbS9jaGFubmVscy86Y2hhbm5lbC86aWRcXG4gICBcXHRcXHRodHRwczovL3ZpbWVvLmNvbS9ncm91cHMvOmdyb3VwL3ZpZGVvcy86aWRcXG4gICBcXHRcXHRodHRwczovL2FwcC52emFhci5jb20vdmlkZW9zLzppZFxcbiAgIFxcdFxcdFxcdFZpc3VhbCBleGFtcGxlOiBodHRwczovL3JlZ2V4cGVyLmNvbS8jKGh0dHAlM0ElN0NodHRwcyUzQSU3QyklNUMlMkYlNUMlMkYocGxheWVyLiU3Q3d3dy4lN0NhcHAuKSUzRih2aW1lbyU1Qy5jb20lN0N5b3V0dShiZSU1Qy5jb20lN0MlNUMuYmUlN0NiZSU1Qy5nb29nbGVhcGlzJTVDLmNvbSklN0N2emFhciU1Qy5jb20pJTVDJTJGKHZpZGVvJTVDJTJGJTdDdmlkZW9zJTVDJTJGJTdDZW1iZWQlNUMlMkYlN0NjaGFubmVscyU1QyUyRi4lMkIlNUMlMkYlN0Nncm91cHMlNUMlMkYuJTJCJTVDJTJGJTdDd2F0Y2glNUMlM0Z2JTNEJTdDdiU1QyUyRiklM0YoJTVCQS1aYS16MC05Ll8lMjUtJTVEKikoJTVDJTI2JTVDUyUyQiklM0ZcXG4gICAqL1xcblxcblxcdFxcdFxcdGlkID0gdXJsLm1hdGNoKC8oaHR0cDp8aHR0cHM6fClcXFxcL1xcXFwvKHBsYXllci58d3d3LnxhcHAuKT8odmltZW9cXFxcLmNvbXx5b3V0dShiZVxcXFwuY29tfFxcXFwuYmV8YmVcXFxcLmdvb2dsZWFwaXNcXFxcLmNvbSl8dnphYXJcXFxcLmNvbSlcXFxcLyh2aWRlb1xcXFwvfHZpZGVvc1xcXFwvfGVtYmVkXFxcXC98Y2hhbm5lbHNcXFxcLy4rXFxcXC98Z3JvdXBzXFxcXC8uK1xcXFwvfHdhdGNoXFxcXD92PXx2XFxcXC8pPyhbQS1aYS16MC05Ll8lLV0qKShcXFxcJlxcXFxTKyk/Lyk7XFxuXFxuXFx0XFx0XFx0aWYgKGlkWzNdLmluZGV4T2YoJ3lvdXR1JykgPiAtMSkge1xcblxcdFxcdFxcdFxcdHR5cGUgPSAneW91dHViZSc7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChpZFszXS5pbmRleE9mKCd2aW1lbycpID4gLTEpIHtcXG5cXHRcXHRcXHRcXHR0eXBlID0gJ3ZpbWVvJztcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKGlkWzNdLmluZGV4T2YoJ3Z6YWFyJykgPiAtMSkge1xcblxcdFxcdFxcdFxcdHR5cGUgPSAndnphYXInO1xcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3IEVycm9yKCdWaWRlbyBVUkwgbm90IHN1cHBvcnRlZC4nKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0aWQgPSBpZFs2XTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHRocm93IG5ldyBFcnJvcignTWlzc2luZyB2aWRlbyBVUkwuJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX3ZpZGVvc1t1cmxdID0ge1xcblxcdFxcdFxcdHR5cGU6IHR5cGUsXFxuXFx0XFx0XFx0aWQ6IGlkLFxcblxcdFxcdFxcdHdpZHRoOiB3aWR0aCxcXG5cXHRcXHRcXHRoZWlnaHQ6IGhlaWdodFxcblxcdFxcdH07XFxuXFxuXFx0XFx0aXRlbS5hdHRyKCdkYXRhLXZpZGVvJywgdXJsKTtcXG5cXG5cXHRcXHR0aGlzLnRodW1ibmFpbCh0YXJnZXQsIHRoaXMuX3ZpZGVvc1t1cmxdKTtcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIHZpZGVvIHRodW1ibmFpbC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcGFyYW0ge2pRdWVyeX0gdGFyZ2V0IC0gVGhlIHRhcmdldCBjb250YWluaW5nIHRoZSB2aWRlbyBkYXRhLlxcbiAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRoZSB2aWRlbyBpbmZvIG9iamVjdC5cXG4gICogQHNlZSBgZmV0Y2hgXFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS50aHVtYm5haWwgPSBmdW5jdGlvbiAodGFyZ2V0LCB2aWRlbykge1xcblxcdFxcdHZhciB0bkxpbmssXFxuXFx0XFx0ICAgIGljb24sXFxuXFx0XFx0ICAgIHBhdGgsXFxuXFx0XFx0ICAgIGRpbWVuc2lvbnMgPSB2aWRlby53aWR0aCAmJiB2aWRlby5oZWlnaHQgPyAnc3R5bGU9XFxcIndpZHRoOicgKyB2aWRlby53aWR0aCArICdweDtoZWlnaHQ6JyArIHZpZGVvLmhlaWdodCArICdweDtcXFwiJyA6ICcnLFxcblxcdFxcdCAgICBjdXN0b21UbiA9IHRhcmdldC5maW5kKCdpbWcnKSxcXG5cXHRcXHQgICAgc3JjVHlwZSA9ICdzcmMnLFxcblxcdFxcdCAgICBsYXp5Q2xhc3MgPSAnJyxcXG5cXHRcXHQgICAgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxcblxcdFxcdCAgICBjcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUocGF0aCkge1xcblxcdFxcdFxcdGljb24gPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXBsYXktaWNvblxcXCI+PC9kaXY+JztcXG5cXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MubGF6eUxvYWQpIHtcXG5cXHRcXHRcXHRcXHR0bkxpbmsgPSAnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLXRuICcgKyBsYXp5Q2xhc3MgKyAnXFxcIiAnICsgc3JjVHlwZSArICc9XFxcIicgKyBwYXRoICsgJ1xcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdHRuTGluayA9ICc8ZGl2IGNsYXNzPVxcXCJvd2wtdmlkZW8tdG5cXFwiIHN0eWxlPVxcXCJvcGFjaXR5OjE7YmFja2dyb3VuZC1pbWFnZTp1cmwoJyArIHBhdGggKyAnKVxcXCI+PC9kaXY+JztcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGFyZ2V0LmFmdGVyKHRuTGluayk7XFxuXFx0XFx0XFx0dGFyZ2V0LmFmdGVyKGljb24pO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gd3JhcCB2aWRlbyBjb250ZW50IGludG8gb3dsLXZpZGVvLXdyYXBwZXIgZGl2XFxuXFx0XFx0dGFyZ2V0LndyYXAoJzxkaXYgY2xhc3M9XFxcIm93bC12aWRlby13cmFwcGVyXFxcIicgKyBkaW1lbnNpb25zICsgJz48L2Rpdj4nKTtcXG5cXG5cXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5sYXp5TG9hZCkge1xcblxcdFxcdFxcdHNyY1R5cGUgPSAnZGF0YS1zcmMnO1xcblxcdFxcdFxcdGxhenlDbGFzcyA9ICdvd2wtbGF6eSc7XFxuXFx0XFx0fVxcblxcblxcdFxcdC8vIGN1c3RvbSB0aHVtYm5haWxcXG5cXHRcXHRpZiAoY3VzdG9tVG4ubGVuZ3RoKSB7XFxuXFx0XFx0XFx0Y3JlYXRlKGN1c3RvbVRuLmF0dHIoc3JjVHlwZSkpO1xcblxcdFxcdFxcdGN1c3RvbVRuLnJlbW92ZSgpO1xcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdHBhdGggPSBcXFwiLy9pbWcueW91dHViZS5jb20vdmkvXFxcIiArIHZpZGVvLmlkICsgXFxcIi9ocWRlZmF1bHQuanBnXFxcIjtcXG5cXHRcXHRcXHRjcmVhdGUocGF0aCk7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndmltZW8nKSB7XFxuXFx0XFx0XFx0JC5hamF4KHtcXG5cXHRcXHRcXHRcXHR0eXBlOiAnR0VUJyxcXG5cXHRcXHRcXHRcXHR1cmw6ICcvL3ZpbWVvLmNvbS9hcGkvdjIvdmlkZW8vJyArIHZpZGVvLmlkICsgJy5qc29uJyxcXG5cXHRcXHRcXHRcXHRqc29ucDogJ2NhbGxiYWNrJyxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogJ2pzb25wJyxcXG5cXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXRoID0gZGF0YVswXS50aHVtYm5haWxfbGFyZ2U7XFxuXFx0XFx0XFx0XFx0XFx0Y3JlYXRlKHBhdGgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHR9IGVsc2UgaWYgKHZpZGVvLnR5cGUgPT09ICd2emFhcicpIHtcXG5cXHRcXHRcXHQkLmFqYXgoe1xcblxcdFxcdFxcdFxcdHR5cGU6ICdHRVQnLFxcblxcdFxcdFxcdFxcdHVybDogJy8vdnphYXIuY29tL2FwaS92aWRlb3MvJyArIHZpZGVvLmlkICsgJy5qc29uJyxcXG5cXHRcXHRcXHRcXHRqc29ucDogJ2NhbGxiYWNrJyxcXG5cXHRcXHRcXHRcXHRkYXRhVHlwZTogJ2pzb25wJyxcXG5cXHRcXHRcXHRcXHRzdWNjZXNzOiBmdW5jdGlvbiBzdWNjZXNzKGRhdGEpIHtcXG5cXHRcXHRcXHRcXHRcXHRwYXRoID0gZGF0YS5mcmFtZWdyYWJfdXJsO1xcblxcdFxcdFxcdFxcdFxcdGNyZWF0ZShwYXRoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFN0b3BzIHRoZSBjdXJyZW50IHZpZGVvLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcCcsIG51bGwsICd2aWRlbycpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcuZmluZCgnLm93bC12aWRlby1mcmFtZScpLnJlbW92ZSgpO1xcblxcdFxcdHRoaXMuX3BsYXlpbmcucmVtb3ZlQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IG51bGw7XFxuXFx0XFx0dGhpcy5fY29yZS5sZWF2ZSgncGxheWluZycpO1xcblxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcignc3RvcHBlZCcsIG51bGwsICd2aWRlbycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFN0YXJ0cyB0aGUgY3VycmVudCB2aWRlby5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBldmVudCBhcmd1bWVudHMuXFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHRhcmdldCA9ICQoZXZlbnQudGFyZ2V0KSxcXG5cXHRcXHQgICAgaXRlbSA9IHRhcmdldC5jbG9zZXN0KCcuJyArIHRoaXMuX2NvcmUuc2V0dGluZ3MuaXRlbUNsYXNzKSxcXG5cXHRcXHQgICAgdmlkZW8gPSB0aGlzLl92aWRlb3NbaXRlbS5hdHRyKCdkYXRhLXZpZGVvJyldLFxcblxcdFxcdCAgICB3aWR0aCA9IHZpZGVvLndpZHRoIHx8ICcxMDAlJyxcXG5cXHRcXHQgICAgaGVpZ2h0ID0gdmlkZW8uaGVpZ2h0IHx8IHRoaXMuX2NvcmUuJHN0YWdlLmhlaWdodCgpLFxcblxcdFxcdCAgICBodG1sO1xcblxcblxcdFxcdGlmICh0aGlzLl9wbGF5aW5nKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb3JlLmVudGVyKCdwbGF5aW5nJyk7XFxuXFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdwbGF5JywgbnVsbCwgJ3ZpZGVvJyk7XFxuXFxuXFx0XFx0aXRlbSA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZShpdGVtLmluZGV4KCkpKTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLnJlc2V0KGl0ZW0uaW5kZXgoKSk7XFxuXFxuXFx0XFx0aWYgKHZpZGVvLnR5cGUgPT09ICd5b3V0dWJlJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSB3aWR0aD1cXFwiJyArIHdpZHRoICsgJ1xcXCIgaGVpZ2h0PVxcXCInICsgaGVpZ2h0ICsgJ1xcXCIgc3JjPVxcXCIvL3d3dy55b3V0dWJlLmNvbS9lbWJlZC8nICsgdmlkZW8uaWQgKyAnP2F1dG9wbGF5PTEmcmVsPTAmdj0nICsgdmlkZW8uaWQgKyAnXFxcIiBmcmFtZWJvcmRlcj1cXFwiMFxcXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPic7XFxuXFx0XFx0fSBlbHNlIGlmICh2aWRlby50eXBlID09PSAndmltZW8nKSB7XFxuXFx0XFx0XFx0aHRtbCA9ICc8aWZyYW1lIHNyYz1cXFwiLy9wbGF5ZXIudmltZW8uY29tL3ZpZGVvLycgKyB2aWRlby5pZCArICc/YXV0b3BsYXk9MVxcXCIgd2lkdGg9XFxcIicgKyB3aWR0aCArICdcXFwiIGhlaWdodD1cXFwiJyArIGhlaWdodCArICdcXFwiIGZyYW1lYm9yZGVyPVxcXCIwXFxcIiB3ZWJraXRhbGxvd2Z1bGxzY3JlZW4gbW96YWxsb3dmdWxsc2NyZWVuIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nO1xcblxcdFxcdH0gZWxzZSBpZiAodmlkZW8udHlwZSA9PT0gJ3Z6YWFyJykge1xcblxcdFxcdFxcdGh0bWwgPSAnPGlmcmFtZSBmcmFtZWJvcmRlcj1cXFwiMFxcXCInICsgJ2hlaWdodD1cXFwiJyArIGhlaWdodCArICdcXFwiJyArICd3aWR0aD1cXFwiJyArIHdpZHRoICsgJ1xcXCIgYWxsb3dmdWxsc2NyZWVuIG1vemFsbG93ZnVsbHNjcmVlbiB3ZWJraXRBbGxvd0Z1bGxTY3JlZW4gJyArICdzcmM9XFxcIi8vdmlldy52emFhci5jb20vJyArIHZpZGVvLmlkICsgJy9wbGF5ZXI/YXV0b3BsYXk9dHJ1ZVxcXCI+PC9pZnJhbWU+JztcXG5cXHRcXHR9XFxuXFxuXFx0XFx0JCgnPGRpdiBjbGFzcz1cXFwib3dsLXZpZGVvLWZyYW1lXFxcIj4nICsgaHRtbCArICc8L2Rpdj4nKS5pbnNlcnRBZnRlcihpdGVtLmZpbmQoJy5vd2wtdmlkZW8nKSk7XFxuXFxuXFx0XFx0dGhpcy5fcGxheWluZyA9IGl0ZW0uYWRkQ2xhc3MoJ293bC12aWRlby1wbGF5aW5nJyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogQ2hlY2tzIHdoZXRoZXIgYW4gdmlkZW8gaXMgY3VycmVudGx5IGluIGZ1bGwgc2NyZWVuIG1vZGUgb3Igbm90LlxcbiAgKiBAdG9kbyBCYWQgc3R5bGUgYmVjYXVzZSBsb29rcyBsaWtlIGEgcmVhZG9ubHkgbWV0aG9kIGJ1dCBjaGFuZ2VzIG1lbWJlcnMuXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHJldHVybnMge0Jvb2xlYW59XFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5pc0luRnVsbFNjcmVlbiA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgZWxlbWVudCA9IGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50IHx8IGRvY3VtZW50LndlYmtpdEZ1bGxzY3JlZW5FbGVtZW50O1xcblxcblxcdFxcdHJldHVybiBlbGVtZW50ICYmICQoZWxlbWVudCkucGFyZW50KCkuaGFzQ2xhc3MoJ293bC12aWRlby1mcmFtZScpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqL1xcblxcdFZpZGVvLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZignY2xpY2sub3dsLnZpZGVvJyk7XFxuXFxuXFx0XFx0Zm9yIChoYW5kbGVyIGluIHRoaXMuX2hhbmRsZXJzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5faGFuZGxlcnNbaGFuZGxlcl0pO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IgKHByb3BlcnR5IGluIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRoaXMpKSB7XFxuXFx0XFx0XFx0dHlwZW9mIHRoaXNbcHJvcGVydHldICE9ICdmdW5jdGlvbicgJiYgKHRoaXNbcHJvcGVydHldID0gbnVsbCk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0JC5mbi5vd2xDYXJvdXNlbC5Db25zdHJ1Y3Rvci5QbHVnaW5zLlZpZGVvID0gVmlkZW87XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEFuaW1hdGUgUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEJhcnRvc3ogV29qY2llY2hvd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdC8qKlxcbiAgKiBDcmVhdGVzIHRoZSBhbmltYXRlIHBsdWdpbi5cXG4gICogQGNsYXNzIFRoZSBOYXZpZ2F0aW9uIFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBBbmltYXRlID0gZnVuY3Rpb24gQW5pbWF0ZShzY29wZSkge1xcblxcdFxcdHRoaXMuY29yZSA9IHNjb3BlO1xcblxcdFxcdHRoaXMuY29yZS5vcHRpb25zID0gJC5leHRlbmQoe30sIEFuaW1hdGUuRGVmYXVsdHMsIHRoaXMuY29yZS5vcHRpb25zKTtcXG5cXHRcXHR0aGlzLnN3YXBwaW5nID0gdHJ1ZTtcXG5cXHRcXHR0aGlzLnByZXZpb3VzID0gdW5kZWZpbmVkO1xcblxcdFxcdHRoaXMubmV4dCA9IHVuZGVmaW5lZDtcXG5cXG5cXHRcXHR0aGlzLmhhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdjaGFuZ2Uub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucHJldmlvdXMgPSB0aGlzLmNvcmUuY3VycmVudCgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMubmV4dCA9IGUucHJvcGVydHkudmFsdWU7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdkcmFnLm93bC5jYXJvdXNlbCBkcmFnZ2VkLm93bC5jYXJvdXNlbCB0cmFuc2xhdGVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN3YXBwaW5nID0gZS50eXBlID09ICd0cmFuc2xhdGVkJztcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RyYW5zbGF0ZS5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuc3dhcHBpbmcgJiYgKHRoaXMuY29yZS5vcHRpb25zLmFuaW1hdGVPdXQgfHwgdGhpcy5jb3JlLm9wdGlvbnMuYW5pbWF0ZUluKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuc3dhcCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0dGhpcy5jb3JlLiRlbGVtZW50Lm9uKHRoaXMuaGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBbmltYXRlLkRlZmF1bHRzID0ge1xcblxcdFxcdGFuaW1hdGVPdXQ6IGZhbHNlLFxcblxcdFxcdGFuaW1hdGVJbjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBUb2dnbGVzIHRoZSBhbmltYXRpb24gY2xhc3NlcyB3aGVuZXZlciBhbiB0cmFuc2xhdGlvbnMgc3RhcnRzLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEByZXR1cm5zIHtCb29sZWFufHVuZGVmaW5lZH1cXG4gICovXFxuXFx0QW5pbWF0ZS5wcm90b3R5cGUuc3dhcCA9IGZ1bmN0aW9uICgpIHtcXG5cXG5cXHRcXHRpZiAodGhpcy5jb3JlLnNldHRpbmdzLml0ZW1zICE9PSAxKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAoISQuc3VwcG9ydC5hbmltYXRpb24gfHwgISQuc3VwcG9ydC50cmFuc2l0aW9uKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLmNvcmUuc3BlZWQoMCk7XFxuXFxuXFx0XFx0dmFyIGxlZnQsXFxuXFx0XFx0ICAgIGNsZWFyID0gJC5wcm94eSh0aGlzLmNsZWFyLCB0aGlzKSxcXG5cXHRcXHQgICAgcHJldmlvdXMgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5wcmV2aW91cyksXFxuXFx0XFx0ICAgIG5leHQgPSB0aGlzLmNvcmUuJHN0YWdlLmNoaWxkcmVuKCkuZXEodGhpcy5uZXh0KSxcXG5cXHRcXHQgICAgaW5jb21pbmcgPSB0aGlzLmNvcmUuc2V0dGluZ3MuYW5pbWF0ZUluLFxcblxcdFxcdCAgICBvdXRnb2luZyA9IHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0O1xcblxcblxcdFxcdGlmICh0aGlzLmNvcmUuY3VycmVudCgpID09PSB0aGlzLnByZXZpb3VzKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpZiAob3V0Z29pbmcpIHtcXG5cXHRcXHRcXHRsZWZ0ID0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMucHJldmlvdXMpIC0gdGhpcy5jb3JlLmNvb3JkaW5hdGVzKHRoaXMubmV4dCk7XFxuXFx0XFx0XFx0cHJldmlvdXMub25lKCQuc3VwcG9ydC5hbmltYXRpb24uZW5kLCBjbGVhcikuY3NzKHsgJ2xlZnQnOiBsZWZ0ICsgJ3B4JyB9KS5hZGRDbGFzcygnYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLW91dCcpLmFkZENsYXNzKG91dGdvaW5nKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGluY29taW5nKSB7XFxuXFx0XFx0XFx0bmV4dC5vbmUoJC5zdXBwb3J0LmFuaW1hdGlvbi5lbmQsIGNsZWFyKS5hZGRDbGFzcygnYW5pbWF0ZWQgb3dsLWFuaW1hdGVkLWluJykuYWRkQ2xhc3MoaW5jb21pbmcpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdEFuaW1hdGUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHQkKGUudGFyZ2V0KS5jc3MoeyAnbGVmdCc6ICcnIH0pLnJlbW92ZUNsYXNzKCdhbmltYXRlZCBvd2wtYW5pbWF0ZWQtb3V0IG93bC1hbmltYXRlZC1pbicpLnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlSW4pLnJlbW92ZUNsYXNzKHRoaXMuY29yZS5zZXR0aW5ncy5hbmltYXRlT3V0KTtcXG5cXHRcXHR0aGlzLmNvcmUub25UcmFuc2l0aW9uRW5kKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVzdHJveXMgdGhlIHBsdWdpbi5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBbmltYXRlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuY29yZS4kZWxlbWVudC5vZmYoaGFuZGxlciwgdGhpcy5oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuQW5pbWF0ZSA9IEFuaW1hdGU7XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEF1dG9wbGF5IFBsdWdpblxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBCYXJ0b3N6IFdvamNpZWNob3dza2lcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgYXV0b3BsYXkgcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIEF1dG9wbGF5IFBsdWdpblxcbiAgKiBAcGFyYW0ge093bH0gc2NvcGUgLSBUaGUgT3dsIENhcm91c2VsXFxuICAqL1xcblxcdHZhciBBdXRvcGxheSA9IGZ1bmN0aW9uIEF1dG9wbGF5KGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogVGhlIGF1dG9wbGF5IHRpbWVvdXQuXFxuICAgKiBAdHlwZSB7VGltZW91dH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX3RpbWVvdXQgPSBudWxsO1xcblxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIHdoZW5ldmVyIHRoZSBhdXRvcGxheSBpcyBwYXVzZWQuXFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xcblxcblxcdFxcdC8qKlxcbiAgICogQWxsIGV2ZW50IGhhbmRsZXJzLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhbmRsZXJzID0ge1xcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09PSAnc2V0dGluZ3MnKSB7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRoaXMuc3RvcCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYgKGUubmFtZXNwYWNlICYmIGUucHJvcGVydHkubmFtZSA9PT0gJ3Bvc2l0aW9uJykge1xcblxcdFxcdFxcdFxcdFxcdC8vY29uc29sZS5sb2coJ3BsYXk/JywgZSk7XFxuXFx0XFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXkpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHR0aGlzLl9zZXRBdXRvUGxheUludGVydmFsKCk7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnaW5pdGlhbGl6ZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmF1dG9wbGF5KSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdwbGF5Lm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24gKGUsIHQsIHMpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkodCwgcyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdzdG9wLm93bC5hdXRvcGxheSc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnN0b3AoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J21vdXNlb3Zlci5vd2wuYXV0b3BsYXknOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGF1c2UoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J21vdXNlbGVhdmUub3dsLmF1dG9wbGF5JzogJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlICYmIHRoaXMuX2NvcmUuaXMoJ3JvdGF0aW5nJykpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnBsYXkoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RvdWNoc3RhcnQub3dsLmNvcmUnOiAkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHRpZiAodGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheUhvdmVyUGF1c2UgJiYgdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMucGF1c2UoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3RvdWNoZW5kLm93bC5jb3JlJzogJC5wcm94eShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlIb3ZlclBhdXNlKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5wbGF5KCk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpXFxuXFx0XFx0fTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQXV0b3BsYXkuRGVmYXVsdHMsIHRoaXMuX2NvcmUub3B0aW9ucyk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVmYXVsdCBvcHRpb25zLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdEF1dG9wbGF5LkRlZmF1bHRzID0ge1xcblxcdFxcdGF1dG9wbGF5OiBmYWxzZSxcXG5cXHRcXHRhdXRvcGxheVRpbWVvdXQ6IDUwMDAsXFxuXFx0XFx0YXV0b3BsYXlIb3ZlclBhdXNlOiBmYWxzZSxcXG5cXHRcXHRhdXRvcGxheVNwZWVkOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFN0YXJ0cyB0aGUgYXV0b3BsYXkuXFxuICAqIEBwdWJsaWNcXG4gICogQHBhcmFtIHtOdW1iZXJ9IFt0aW1lb3V0XSAtIFRoZSBpbnRlcnZhbCBiZWZvcmUgdGhlIG5leHQgYW5pbWF0aW9uIHN0YXJ0cy5cXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgYW5pbWF0aW9uIHNwZWVkIGZvciB0aGUgYW5pbWF0aW9ucy5cXG4gICovXFxuXFx0QXV0b3BsYXkucHJvdG90eXBlLnBsYXkgPSBmdW5jdGlvbiAodGltZW91dCwgc3BlZWQpIHtcXG5cXHRcXHR0aGlzLl9wYXVzZWQgPSBmYWxzZTtcXG5cXG5cXHRcXHRpZiAodGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0dGhpcy5fY29yZS5lbnRlcigncm90YXRpbmcnKTtcXG5cXG5cXHRcXHR0aGlzLl9zZXRBdXRvUGxheUludGVydmFsKCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyBhIG5ldyB0aW1lb3V0XFxuICAqIEBwcml2YXRlXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbdGltZW91dF0gLSBUaGUgaW50ZXJ2YWwgYmVmb3JlIHRoZSBuZXh0IGFuaW1hdGlvbiBzdGFydHMuXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWRdIC0gVGhlIGFuaW1hdGlvbiBzcGVlZCBmb3IgdGhlIGFuaW1hdGlvbnMuXFxuICAqIEByZXR1cm4ge1RpbWVvdXR9XFxuICAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5fZ2V0TmV4dFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCwgc3BlZWQpIHtcXG5cXHRcXHRpZiAodGhpcy5fdGltZW91dCkge1xcblxcdFxcdFxcdHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiB3aW5kb3cuc2V0VGltZW91dCgkLnByb3h5KGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodGhpcy5fcGF1c2VkIHx8IHRoaXMuX2NvcmUuaXMoJ2J1c3knKSB8fCB0aGlzLl9jb3JlLmlzKCdpbnRlcmFjdGluZycpIHx8IGRvY3VtZW50LmhpZGRlbikge1xcblxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0dGhpcy5fY29yZS5uZXh0KHNwZWVkIHx8IHRoaXMuX2NvcmUuc2V0dGluZ3MuYXV0b3BsYXlTcGVlZCk7XFxuXFx0XFx0fSwgdGhpcyksIHRpbWVvdXQgfHwgdGhpcy5fY29yZS5zZXR0aW5ncy5hdXRvcGxheVRpbWVvdXQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNldHMgYXV0b3BsYXkgaW4gbW90aW9uLlxcbiAgKiBAcHJpdmF0ZVxcbiAgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUuX3NldEF1dG9QbGF5SW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dGhpcy5fdGltZW91dCA9IHRoaXMuX2dldE5leHRUaW1lb3V0KCk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU3RvcHMgdGhlIGF1dG9wbGF5LlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdGlmICghdGhpcy5fY29yZS5pcygncm90YXRpbmcnKSkge1xcblxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0d2luZG93LmNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcXG5cXHRcXHR0aGlzLl9jb3JlLmxlYXZlKCdyb3RhdGluZycpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFN0b3BzIHRoZSBhdXRvcGxheS5cXG4gICogQHB1YmxpY1xcbiAgKi9cXG5cXHRBdXRvcGxheS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0aWYgKCF0aGlzLl9jb3JlLmlzKCdyb3RhdGluZycpKSB7XFxuXFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9wYXVzZWQgPSB0cnVlO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqL1xcblxcdEF1dG9wbGF5LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBoYW5kbGVyLCBwcm9wZXJ0eTtcXG5cXG5cXHRcXHR0aGlzLnN0b3AoKTtcXG5cXG5cXHRcXHRmb3IgKGhhbmRsZXIgaW4gdGhpcy5faGFuZGxlcnMpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb3JlLiRlbGVtZW50Lm9mZihoYW5kbGVyLCB0aGlzLl9oYW5kbGVyc1toYW5kbGVyXSk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAocHJvcGVydHkgaW4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcXG5cXHRcXHRcXHR0eXBlb2YgdGhpc1twcm9wZXJ0eV0gIT0gJ2Z1bmN0aW9uJyAmJiAodGhpc1twcm9wZXJ0eV0gPSBudWxsKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuYXV0b3BsYXkgPSBBdXRvcGxheTtcXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogTmF2aWdhdGlvbiBQbHVnaW5cXG4gKiBAdmVyc2lvbiAyLjEuMFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcdCd1c2Ugc3RyaWN0JztcXG5cXG5cXHQvKipcXG4gICogQ3JlYXRlcyB0aGUgbmF2aWdhdGlvbiBwbHVnaW4uXFxuICAqIEBjbGFzcyBUaGUgTmF2aWdhdGlvbiBQbHVnaW5cXG4gICogQHBhcmFtIHtPd2x9IGNhcm91c2VsIC0gVGhlIE93bCBDYXJvdXNlbC5cXG4gICovXFxuXFxuXFx0dmFyIE5hdmlnYXRpb24gPSBmdW5jdGlvbiBOYXZpZ2F0aW9uKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogSW5kaWNhdGVzIHdoZXRoZXIgdGhlIHBsdWdpbiBpcyBpbml0aWFsaXplZCBvciBub3QuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2luaXRpYWxpemVkID0gZmFsc2U7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBUaGUgY3VycmVudCBwYWdpbmcgaW5kZXhlcy5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtBcnJheX1cXG4gICAqL1xcblxcdFxcdHRoaXMuX3BhZ2VzID0gW107XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbGwgRE9NIGVsZW1lbnRzIG9mIHRoZSB1c2VyIGludGVyZmFjZS5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9jb250cm9scyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogTWFya3VwIGZvciBhbiBpbmRpY2F0b3IuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7QXJyYXkuPFN0cmluZz59XFxuICAgKi9cXG5cXHRcXHR0aGlzLl90ZW1wbGF0ZXMgPSBbXTtcXG5cXG5cXHRcXHQvKipcXG4gICAqIFRoZSBjYXJvdXNlbCBlbGVtZW50LlxcbiAgICogQHR5cGUge2pRdWVyeX1cXG4gICAqL1xcblxcdFxcdHRoaXMuJGVsZW1lbnQgPSB0aGlzLl9jb3JlLiRlbGVtZW50O1xcblxcblxcdFxcdC8qKlxcbiAgICogT3ZlcnJpZGRlbiBtZXRob2RzIG9mIHRoZSBjYXJvdXNlbC5cXG4gICAqIEBwcm90ZWN0ZWRcXG4gICAqIEB0eXBlIHtPYmplY3R9XFxuICAgKi9cXG5cXHRcXHR0aGlzLl9vdmVycmlkZXMgPSB7XFxuXFx0XFx0XFx0bmV4dDogdGhpcy5fY29yZS5uZXh0LFxcblxcdFxcdFxcdHByZXY6IHRoaXMuX2NvcmUucHJldixcXG5cXHRcXHRcXHR0bzogdGhpcy5fY29yZS50b1xcblxcdFxcdH07XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J3ByZXBhcmVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5wdXNoKCc8ZGl2IGNsYXNzPVxcXCInICsgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RDbGFzcyArICdcXFwiPicgKyAkKGUuY29udGVudCkuZmluZCgnW2RhdGEtZG90XScpLmFkZEJhY2soJ1tkYXRhLWRvdF0nKS5hdHRyKCdkYXRhLWRvdCcpICsgJzwvZGl2PicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQnYWRkZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiB0aGlzLl9jb3JlLnNldHRpbmdzLmRvdHNEYXRhKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fdGVtcGxhdGVzLnNwbGljZShlLnBvc2l0aW9uLCAwLCB0aGlzLl90ZW1wbGF0ZXMucG9wKCkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncmVtb3ZlLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5kb3RzRGF0YSkge1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX3RlbXBsYXRlcy5zcGxpY2UoZS5wb3NpdGlvbiwgMSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0sIHRoaXMpLFxcblxcdFxcdFxcdCdjaGFuZ2VkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgZS5wcm9wZXJ0eS5uYW1lID09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmRyYXcoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgIXRoaXMuX2luaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdpbml0aWFsaXplJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLmluaXRpYWxpemUoKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLl9jb3JlLnRyaWdnZXIoJ2luaXRpYWxpemVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J3JlZnJlc2hlZC5vd2wuY2Fyb3VzZWwnOiAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGUubmFtZXNwYWNlICYmIHRoaXMuX2luaXRpYWxpemVkKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fY29yZS50cmlnZ2VyKCdyZWZyZXNoJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHRcXHR0aGlzLnVwZGF0ZSgpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuZHJhdygpO1xcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2NvcmUudHJpZ2dlcigncmVmcmVzaGVkJywgbnVsbCwgJ25hdmlnYXRpb24nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcylcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIHNldCBkZWZhdWx0IG9wdGlvbnNcXG5cXHRcXHR0aGlzLl9jb3JlLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgTmF2aWdhdGlvbi5EZWZhdWx0cywgdGhpcy5fY29yZS5vcHRpb25zKTtcXG5cXG5cXHRcXHQvLyByZWdpc3RlciBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlZmF1bHQgb3B0aW9ucy5cXG4gICogQHB1YmxpY1xcbiAgKiBAdG9kbyBSZW5hbWUgYHNsaWRlQnlgIHRvIGBuYXZCeWBcXG4gICovXFxuXFx0TmF2aWdhdGlvbi5EZWZhdWx0cyA9IHtcXG5cXHRcXHRuYXY6IGZhbHNlLFxcblxcdFxcdG5hdlRleHQ6IFsncHJldicsICduZXh0J10sXFxuXFx0XFx0bmF2U3BlZWQ6IGZhbHNlLFxcblxcdFxcdG5hdkVsZW1lbnQ6ICdkaXYnLFxcblxcdFxcdG5hdkNvbnRhaW5lcjogZmFsc2UsXFxuXFx0XFx0bmF2Q29udGFpbmVyQ2xhc3M6ICdvd2wtbmF2JyxcXG5cXHRcXHRuYXZDbGFzczogWydvd2wtcHJldicsICdvd2wtbmV4dCddLFxcblxcdFxcdHNsaWRlQnk6IDEsXFxuXFx0XFx0ZG90Q2xhc3M6ICdvd2wtZG90JyxcXG5cXHRcXHRkb3RzQ2xhc3M6ICdvd2wtZG90cycsXFxuXFx0XFx0ZG90czogdHJ1ZSxcXG5cXHRcXHRkb3RzRWFjaDogZmFsc2UsXFxuXFx0XFx0ZG90c0RhdGE6IGZhbHNlLFxcblxcdFxcdGRvdHNTcGVlZDogZmFsc2UsXFxuXFx0XFx0ZG90c0NvbnRhaW5lcjogZmFsc2VcXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBJbml0aWFsaXplcyB0aGUgbGF5b3V0IG9mIHRoZSBwbHVnaW4gYW5kIGV4dGVuZHMgdGhlIGNhcm91c2VsLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIG92ZXJyaWRlLFxcblxcdFxcdCAgICBzZXR0aW5ncyA9IHRoaXMuX2NvcmUuc2V0dGluZ3M7XFxuXFxuXFx0XFx0Ly8gY3JlYXRlIERPTSBzdHJ1Y3R1cmUgZm9yIHJlbGF0aXZlIG5hdmlnYXRpb25cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kcmVsYXRpdmUgPSAoc2V0dGluZ3MubmF2Q29udGFpbmVyID8gJChzZXR0aW5ncy5uYXZDb250YWluZXIpIDogJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDb250YWluZXJDbGFzcykuYXBwZW5kVG8odGhpcy4kZWxlbWVudCkpLmFkZENsYXNzKCdkaXNhYmxlZCcpO1xcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRwcmV2aW91cyA9ICQoJzwnICsgc2V0dGluZ3MubmF2RWxlbWVudCArICc+JykuYWRkQ2xhc3Moc2V0dGluZ3MubmF2Q2xhc3NbMF0pLmh0bWwoc2V0dGluZ3MubmF2VGV4dFswXSkucHJlcGVuZFRvKHRoaXMuX2NvbnRyb2xzLiRyZWxhdGl2ZSkub24oJ2NsaWNrJywgJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdHRoaXMucHJldihzZXR0aW5ncy5uYXZTcGVlZCk7XFxuXFx0XFx0fSwgdGhpcykpO1xcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRuZXh0ID0gJCgnPCcgKyBzZXR0aW5ncy5uYXZFbGVtZW50ICsgJz4nKS5hZGRDbGFzcyhzZXR0aW5ncy5uYXZDbGFzc1sxXSkuaHRtbChzZXR0aW5ncy5uYXZUZXh0WzFdKS5hcHBlbmRUbyh0aGlzLl9jb250cm9scy4kcmVsYXRpdmUpLm9uKCdjbGljaycsICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHR0aGlzLm5leHQoc2V0dGluZ3MubmF2U3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQvLyBjcmVhdGUgRE9NIHN0cnVjdHVyZSBmb3IgYWJzb2x1dGUgbmF2aWdhdGlvblxcblxcdFxcdGlmICghc2V0dGluZ3MuZG90c0RhdGEpIHtcXG5cXHRcXHRcXHR0aGlzLl90ZW1wbGF0ZXMgPSBbJCgnPGRpdj4nKS5hZGRDbGFzcyhzZXR0aW5ncy5kb3RDbGFzcykuYXBwZW5kKCQoJzxzcGFuPicpKS5wcm9wKCdvdXRlckhUTUwnKV07XFxuXFx0XFx0fVxcblxcblxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZSA9IChzZXR0aW5ncy5kb3RzQ29udGFpbmVyID8gJChzZXR0aW5ncy5kb3RzQ29udGFpbmVyKSA6ICQoJzxkaXY+JykuYWRkQ2xhc3Moc2V0dGluZ3MuZG90c0NsYXNzKS5hcHBlbmRUbyh0aGlzLiRlbGVtZW50KSkuYWRkQ2xhc3MoJ2Rpc2FibGVkJyk7XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLm9uKCdjbGljaycsICdkaXYnLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0dmFyIGluZGV4ID0gJChlLnRhcmdldCkucGFyZW50KCkuaXModGhpcy5fY29udHJvbHMuJGFic29sdXRlKSA/ICQoZS50YXJnZXQpLmluZGV4KCkgOiAkKGUudGFyZ2V0KS5wYXJlbnQoKS5pbmRleCgpO1xcblxcblxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXG5cXHRcXHRcXHR0aGlzLnRvKGluZGV4LCBzZXR0aW5ncy5kb3RzU3BlZWQpO1xcblxcdFxcdH0sIHRoaXMpKTtcXG5cXG5cXHRcXHQvLyBvdmVycmlkZSBwdWJsaWMgbWV0aG9kcyBvZiB0aGUgY2Fyb3VzZWxcXG5cXHRcXHRmb3IgKG92ZXJyaWRlIGluIHRoaXMuX292ZXJyaWRlcykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gJC5wcm94eSh0aGlzW292ZXJyaWRlXSwgdGhpcyk7XFxuXFx0XFx0fVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqIEBwcm90ZWN0ZWRcXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgY29udHJvbCwgcHJvcGVydHksIG92ZXJyaWRlO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChjb250cm9sIGluIHRoaXMuX2NvbnRyb2xzKSB7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHNbY29udHJvbF0ucmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdFxcdGZvciAob3ZlcnJpZGUgaW4gdGhpcy5vdmVyaWRlcykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmVbb3ZlcnJpZGVdID0gdGhpcy5fb3ZlcnJpZGVzW292ZXJyaWRlXTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdC8qKlxcbiAgKiBVcGRhdGVzIHRoZSBpbnRlcm5hbCBzdGF0ZS5cXG4gICogQHByb3RlY3RlZFxcbiAgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGksXFxuXFx0XFx0ICAgIGosXFxuXFx0XFx0ICAgIGssXFxuXFx0XFx0ICAgIGxvd2VyID0gdGhpcy5fY29yZS5jbG9uZXMoKS5sZW5ndGggLyAyLFxcblxcdFxcdCAgICB1cHBlciA9IGxvd2VyICsgdGhpcy5fY29yZS5pdGVtcygpLmxlbmd0aCxcXG5cXHRcXHQgICAgbWF4aW11bSA9IHRoaXMuX2NvcmUubWF4aW11bSh0cnVlKSxcXG5cXHRcXHQgICAgc2V0dGluZ3MgPSB0aGlzLl9jb3JlLnNldHRpbmdzLFxcblxcdFxcdCAgICBzaXplID0gc2V0dGluZ3MuY2VudGVyIHx8IHNldHRpbmdzLmF1dG9XaWR0aCB8fCBzZXR0aW5ncy5kb3RzRGF0YSA/IDEgOiBzZXR0aW5ncy5kb3RzRWFjaCB8fCBzZXR0aW5ncy5pdGVtcztcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3Muc2xpZGVCeSAhPT0gJ3BhZ2UnKSB7XFxuXFx0XFx0XFx0c2V0dGluZ3Muc2xpZGVCeSA9IE1hdGgubWluKHNldHRpbmdzLnNsaWRlQnksIHNldHRpbmdzLml0ZW1zKTtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKHNldHRpbmdzLmRvdHMgfHwgc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcXG5cXHRcXHRcXHR0aGlzLl9wYWdlcyA9IFtdO1xcblxcblxcdFxcdFxcdGZvciAoaSA9IGxvd2VyLCBqID0gMCwgayA9IDA7IGkgPCB1cHBlcjsgaSsrKSB7XFxuXFx0XFx0XFx0XFx0aWYgKGogPj0gc2l6ZSB8fCBqID09PSAwKSB7XFxuXFx0XFx0XFx0XFx0XFx0dGhpcy5fcGFnZXMucHVzaCh7XFxuXFx0XFx0XFx0XFx0XFx0XFx0c3RhcnQ6IE1hdGgubWluKG1heGltdW0sIGkgLSBsb3dlciksXFxuXFx0XFx0XFx0XFx0XFx0XFx0ZW5kOiBpIC0gbG93ZXIgKyBzaXplIC0gMVxcblxcdFxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdFxcdFxcdGlmIChNYXRoLm1pbihtYXhpbXVtLCBpIC0gbG93ZXIpID09PSBtYXhpbXVtKSB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0YnJlYWs7XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdGogPSAwLCArK2s7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGogKz0gdGhpcy5fY29yZS5tZXJnZXJzKHRoaXMuX2NvcmUucmVsYXRpdmUoaSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRHJhd3MgdGhlIHVzZXIgaW50ZXJmYWNlLlxcbiAgKiBAdG9kbyBUaGUgb3B0aW9uIGBkb3RzRGF0YWAgd29udCB3b3JrLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiAoKSB7XFxuXFx0XFx0dmFyIGRpZmZlcmVuY2UsXFxuXFx0XFx0ICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncyxcXG5cXHRcXHQgICAgZGlzYWJsZWQgPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoIDw9IHNldHRpbmdzLml0ZW1zLFxcblxcdFxcdCAgICBpbmRleCA9IHRoaXMuX2NvcmUucmVsYXRpdmUodGhpcy5fY29yZS5jdXJyZW50KCkpLFxcblxcdFxcdCAgICBsb29wID0gc2V0dGluZ3MubG9vcCB8fCBzZXR0aW5ncy5yZXdpbmQ7XFxuXFxuXFx0XFx0dGhpcy5fY29udHJvbHMuJHJlbGF0aXZlLnRvZ2dsZUNsYXNzKCdkaXNhYmxlZCcsICFzZXR0aW5ncy5uYXYgfHwgZGlzYWJsZWQpO1xcblxcblxcdFxcdGlmIChzZXR0aW5ncy5uYXYpIHtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9scy4kcHJldmlvdXMudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIWxvb3AgJiYgaW5kZXggPD0gdGhpcy5fY29yZS5taW5pbXVtKHRydWUpKTtcXG5cXHRcXHRcXHR0aGlzLl9jb250cm9scy4kbmV4dC50b2dnbGVDbGFzcygnZGlzYWJsZWQnLCAhbG9vcCAmJiBpbmRleCA+PSB0aGlzLl9jb3JlLm1heGltdW0odHJ1ZSkpO1xcblxcdFxcdH1cXG5cXG5cXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUudG9nZ2xlQ2xhc3MoJ2Rpc2FibGVkJywgIXNldHRpbmdzLmRvdHMgfHwgZGlzYWJsZWQpO1xcblxcblxcdFxcdGlmIChzZXR0aW5ncy5kb3RzKSB7XFxuXFx0XFx0XFx0ZGlmZmVyZW5jZSA9IHRoaXMuX3BhZ2VzLmxlbmd0aCAtIHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5jaGlsZHJlbigpLmxlbmd0aDtcXG5cXG5cXHRcXHRcXHRpZiAoc2V0dGluZ3MuZG90c0RhdGEgJiYgZGlmZmVyZW5jZSAhPT0gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5odG1sKHRoaXMuX3RlbXBsYXRlcy5qb2luKCcnKSk7XFxuXFx0XFx0XFx0fSBlbHNlIGlmIChkaWZmZXJlbmNlID4gMCkge1xcblxcdFxcdFxcdFxcdHRoaXMuX2NvbnRyb2xzLiRhYnNvbHV0ZS5hcHBlbmQobmV3IEFycmF5KGRpZmZlcmVuY2UgKyAxKS5qb2luKHRoaXMuX3RlbXBsYXRlc1swXSkpO1xcblxcdFxcdFxcdH0gZWxzZSBpZiAoZGlmZmVyZW5jZSA8IDApIHtcXG5cXHRcXHRcXHRcXHR0aGlzLl9jb250cm9scy4kYWJzb2x1dGUuY2hpbGRyZW4oKS5zbGljZShkaWZmZXJlbmNlKS5yZW1vdmUoKTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmZpbmQoJy5hY3RpdmUnKS5yZW1vdmVDbGFzcygnYWN0aXZlJyk7XFxuXFx0XFx0XFx0dGhpcy5fY29udHJvbHMuJGFic29sdXRlLmNoaWxkcmVuKCkuZXEoJC5pbkFycmF5KHRoaXMuY3VycmVudCgpLCB0aGlzLl9wYWdlcykpLmFkZENsYXNzKCdhY3RpdmUnKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRXh0ZW5kcyBldmVudCBkYXRhLlxcbiAgKiBAcHJvdGVjdGVkXFxuICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IG9iamVjdCB3aGljaCBnZXRzIHRocm93bi5cXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUub25UcmlnZ2VyID0gZnVuY3Rpb24gKGV2ZW50KSB7XFxuXFx0XFx0dmFyIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncztcXG5cXG5cXHRcXHRldmVudC5wYWdlID0ge1xcblxcdFxcdFxcdGluZGV4OiAkLmluQXJyYXkodGhpcy5jdXJyZW50KCksIHRoaXMuX3BhZ2VzKSxcXG5cXHRcXHRcXHRjb3VudDogdGhpcy5fcGFnZXMubGVuZ3RoLFxcblxcdFxcdFxcdHNpemU6IHNldHRpbmdzICYmIChzZXR0aW5ncy5jZW50ZXIgfHwgc2V0dGluZ3MuYXV0b1dpZHRoIHx8IHNldHRpbmdzLmRvdHNEYXRhID8gMSA6IHNldHRpbmdzLmRvdHNFYWNoIHx8IHNldHRpbmdzLml0ZW1zKVxcblxcdFxcdH07XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogR2V0cyB0aGUgY3VycmVudCBwYWdlIHBvc2l0aW9uIG9mIHRoZSBjYXJvdXNlbC5cXG4gICogQHByb3RlY3RlZFxcbiAgKiBAcmV0dXJucyB7TnVtYmVyfVxcbiAgKi9cXG5cXHROYXZpZ2F0aW9uLnByb3RvdHlwZS5jdXJyZW50ID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHZhciBjdXJyZW50ID0gdGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSk7XFxuXFx0XFx0cmV0dXJuICQuZ3JlcCh0aGlzLl9wYWdlcywgJC5wcm94eShmdW5jdGlvbiAocGFnZSwgaW5kZXgpIHtcXG5cXHRcXHRcXHRyZXR1cm4gcGFnZS5zdGFydCA8PSBjdXJyZW50ICYmIHBhZ2UuZW5kID49IGN1cnJlbnQ7XFxuXFx0XFx0fSwgdGhpcykpLnBvcCgpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIEdldHMgdGhlIGN1cnJlbnQgc3VjY2Vzb3IvcHJlZGVjZXNzb3IgcG9zaXRpb24uXFxuICAqIEBwcm90ZWN0ZWRcXG4gICogQHJldHVybnMge051bWJlcn1cXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiAoc3VjY2Vzc29yKSB7XFxuXFx0XFx0dmFyIHBvc2l0aW9uLFxcblxcdFxcdCAgICBsZW5ndGgsXFxuXFx0XFx0ICAgIHNldHRpbmdzID0gdGhpcy5fY29yZS5zZXR0aW5ncztcXG5cXG5cXHRcXHRpZiAoc2V0dGluZ3Muc2xpZGVCeSA9PSAncGFnZScpIHtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9ICQuaW5BcnJheSh0aGlzLmN1cnJlbnQoKSwgdGhpcy5fcGFnZXMpO1xcblxcdFxcdFxcdGxlbmd0aCA9IHRoaXMuX3BhZ2VzLmxlbmd0aDtcXG5cXHRcXHRcXHRzdWNjZXNzb3IgPyArK3Bvc2l0aW9uIDogLS1wb3NpdGlvbjtcXG5cXHRcXHRcXHRwb3NpdGlvbiA9IHRoaXMuX3BhZ2VzWyhwb3NpdGlvbiAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0O1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cG9zaXRpb24gPSB0aGlzLl9jb3JlLnJlbGF0aXZlKHRoaXMuX2NvcmUuY3VycmVudCgpKTtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9jb3JlLml0ZW1zKCkubGVuZ3RoO1xcblxcdFxcdFxcdHN1Y2Nlc3NvciA/IHBvc2l0aW9uICs9IHNldHRpbmdzLnNsaWRlQnkgOiBwb3NpdGlvbiAtPSBzZXR0aW5ncy5zbGlkZUJ5O1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gcG9zaXRpb247XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogU2xpZGVzIHRvIHRoZSBuZXh0IGl0ZW0gb3IgcGFnZS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gW3NwZWVkPWZhbHNlXSAtIFRoZSB0aW1lIGluIG1pbGxpc2Vjb25kcyBmb3IgdGhlIHRyYW5zaXRpb24uXFxuICAqL1xcblxcdE5hdmlnYXRpb24ucHJvdG90eXBlLm5leHQgPSBmdW5jdGlvbiAoc3BlZWQpIHtcXG5cXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkodGhpcy5nZXRQb3NpdGlvbih0cnVlKSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNsaWRlcyB0byB0aGUgcHJldmlvdXMgaXRlbSBvciBwYWdlLlxcbiAgKiBAcHVibGljXFxuICAqIEBwYXJhbSB7TnVtYmVyfSBbc3BlZWQ9ZmFsc2VdIC0gVGhlIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGUgdHJhbnNpdGlvbi5cXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUucHJldiA9IGZ1bmN0aW9uIChzcGVlZCkge1xcblxcdFxcdCQucHJveHkodGhpcy5fb3ZlcnJpZGVzLnRvLCB0aGlzLl9jb3JlKSh0aGlzLmdldFBvc2l0aW9uKGZhbHNlKSwgc3BlZWQpO1xcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIFNsaWRlcyB0byB0aGUgc3BlY2lmaWVkIGl0ZW0gb3IgcGFnZS5cXG4gICogQHB1YmxpY1xcbiAgKiBAcGFyYW0ge051bWJlcn0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIGl0ZW0gb3IgcGFnZS5cXG4gICogQHBhcmFtIHtOdW1iZXJ9IFtzcGVlZF0gLSBUaGUgdGltZSBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZSB0cmFuc2l0aW9uLlxcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IFtzdGFuZGFyZD1mYWxzZV0gLSBXaGV0aGVyIHRvIHVzZSB0aGUgc3RhbmRhcmQgYmVoYXZpb3VyIG9yIG5vdC5cXG4gICovXFxuXFx0TmF2aWdhdGlvbi5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiAocG9zaXRpb24sIHNwZWVkLCBzdGFuZGFyZCkge1xcblxcdFxcdHZhciBsZW5ndGg7XFxuXFxuXFx0XFx0aWYgKCFzdGFuZGFyZCAmJiB0aGlzLl9wYWdlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRsZW5ndGggPSB0aGlzLl9wYWdlcy5sZW5ndGg7XFxuXFx0XFx0XFx0JC5wcm94eSh0aGlzLl9vdmVycmlkZXMudG8sIHRoaXMuX2NvcmUpKHRoaXMuX3BhZ2VzWyhwb3NpdGlvbiAlIGxlbmd0aCArIGxlbmd0aCkgJSBsZW5ndGhdLnN0YXJ0LCBzcGVlZCk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHQkLnByb3h5KHRoaXMuX292ZXJyaWRlcy50bywgdGhpcy5fY29yZSkocG9zaXRpb24sIHNwZWVkKTtcXG5cXHRcXHR9XFxuXFx0fTtcXG5cXG5cXHQkLmZuLm93bENhcm91c2VsLkNvbnN0cnVjdG9yLlBsdWdpbnMuTmF2aWdhdGlvbiA9IE5hdmlnYXRpb247XFxufSkod2luZG93LlplcHRvIHx8IHdpbmRvdy5qUXVlcnksIHdpbmRvdywgZG9jdW1lbnQpO1xcblxcbi8qKlxcbiAqIEhhc2ggUGx1Z2luXFxuICogQHZlcnNpb24gMi4xLjBcXG4gKiBAYXV0aG9yIEFydHVzIEtvbGFub3dza2lcXG4gKiBAYXV0aG9yIERhdmlkIERldXRzY2hcXG4gKiBAbGljZW5zZSBUaGUgTUlUIExpY2Vuc2UgKE1JVClcXG4gKi9cXG47KGZ1bmN0aW9uICgkLCB3aW5kb3csIGRvY3VtZW50LCB1bmRlZmluZWQpIHtcXG5cXHQndXNlIHN0cmljdCc7XFxuXFxuXFx0LyoqXFxuICAqIENyZWF0ZXMgdGhlIGhhc2ggcGx1Z2luLlxcbiAgKiBAY2xhc3MgVGhlIEhhc2ggUGx1Z2luXFxuICAqIEBwYXJhbSB7T3dsfSBjYXJvdXNlbCAtIFRoZSBPd2wgQ2Fyb3VzZWxcXG4gICovXFxuXFxuXFx0dmFyIEhhc2ggPSBmdW5jdGlvbiBIYXNoKGNhcm91c2VsKSB7XFxuXFx0XFx0LyoqXFxuICAgKiBSZWZlcmVuY2UgdG8gdGhlIGNvcmUuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T3dsfVxcbiAgICovXFxuXFx0XFx0dGhpcy5fY29yZSA9IGNhcm91c2VsO1xcblxcblxcdFxcdC8qKlxcbiAgICogSGFzaCBpbmRleCBmb3IgdGhlIGl0ZW1zLlxcbiAgICogQHByb3RlY3RlZFxcbiAgICogQHR5cGUge09iamVjdH1cXG4gICAqL1xcblxcdFxcdHRoaXMuX2hhc2hlcyA9IHt9O1xcblxcblxcdFxcdC8qKlxcbiAgICogVGhlIGNhcm91c2VsIGVsZW1lbnQuXFxuICAgKiBAdHlwZSB7alF1ZXJ5fVxcbiAgICovXFxuXFx0XFx0dGhpcy4kZWxlbWVudCA9IHRoaXMuX2NvcmUuJGVsZW1lbnQ7XFxuXFxuXFx0XFx0LyoqXFxuICAgKiBBbGwgZXZlbnQgaGFuZGxlcnMuXFxuICAgKiBAcHJvdGVjdGVkXFxuICAgKiBAdHlwZSB7T2JqZWN0fVxcbiAgICovXFxuXFx0XFx0dGhpcy5faGFuZGxlcnMgPSB7XFxuXFx0XFx0XFx0J2luaXRpYWxpemVkLm93bC5jYXJvdXNlbCc6ICQucHJveHkoZnVuY3Rpb24gKGUpIHtcXG5cXHRcXHRcXHRcXHRpZiAoZS5uYW1lc3BhY2UgJiYgdGhpcy5fY29yZS5zZXR0aW5ncy5zdGFydFBvc2l0aW9uID09PSAnVVJMSGFzaCcpIHtcXG5cXHRcXHRcXHRcXHRcXHQkKHdpbmRvdykudHJpZ2dlcignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKSxcXG5cXHRcXHRcXHQncHJlcGFyZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSkge1xcblxcdFxcdFxcdFxcdFxcdHZhciBoYXNoID0gJChlLmNvbnRlbnQpLmZpbmQoJ1tkYXRhLWhhc2hdJykuYWRkQmFjaygnW2RhdGEtaGFzaF0nKS5hdHRyKCdkYXRhLWhhc2gnKTtcXG5cXG5cXHRcXHRcXHRcXHRcXHRpZiAoIWhhc2gpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHRoaXMuX2hhc2hlc1toYXNoXSA9IGUuY29udGVudDtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSwgdGhpcyksXFxuXFx0XFx0XFx0J2NoYW5nZWQub3dsLmNhcm91c2VsJzogJC5wcm94eShmdW5jdGlvbiAoZSkge1xcblxcdFxcdFxcdFxcdGlmIChlLm5hbWVzcGFjZSAmJiBlLnByb3BlcnR5Lm5hbWUgPT09ICdwb3NpdGlvbicpIHtcXG5cXHRcXHRcXHRcXHRcXHR2YXIgY3VycmVudCA9IHRoaXMuX2NvcmUuaXRlbXModGhpcy5fY29yZS5yZWxhdGl2ZSh0aGlzLl9jb3JlLmN1cnJlbnQoKSkpLFxcblxcdFxcdFxcdFxcdFxcdCAgICBoYXNoID0gJC5tYXAodGhpcy5faGFzaGVzLCBmdW5jdGlvbiAoaXRlbSwgaGFzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybiBpdGVtID09PSBjdXJyZW50ID8gaGFzaCA6IG51bGw7XFxuXFx0XFx0XFx0XFx0XFx0fSkuam9pbigpO1xcblxcblxcdFxcdFxcdFxcdFxcdGlmICghaGFzaCB8fCB3aW5kb3cubG9jYXRpb24uaGFzaC5zbGljZSgxKSA9PT0gaGFzaCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdHJldHVybjtcXG5cXHRcXHRcXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0XFx0XFx0d2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9LCB0aGlzKVxcblxcdFxcdH07XFxuXFxuXFx0XFx0Ly8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcblxcdFxcdHRoaXMuX2NvcmUub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBIYXNoLkRlZmF1bHRzLCB0aGlzLl9jb3JlLm9wdGlvbnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIHRoZSBldmVudCBoYW5kbGVyc1xcblxcdFxcdHRoaXMuJGVsZW1lbnQub24odGhpcy5faGFuZGxlcnMpO1xcblxcblxcdFxcdC8vIHJlZ2lzdGVyIGV2ZW50IGxpc3RlbmVyIGZvciBoYXNoIG5hdmlnYXRpb25cXG5cXHRcXHQkKHdpbmRvdykub24oJ2hhc2hjaGFuZ2Uub3dsLm5hdmlnYXRpb24nLCAkLnByb3h5KGZ1bmN0aW9uIChlKSB7XFxuXFx0XFx0XFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zdWJzdHJpbmcoMSksXFxuXFx0XFx0XFx0ICAgIGl0ZW1zID0gdGhpcy5fY29yZS4kc3RhZ2UuY2hpbGRyZW4oKSxcXG5cXHRcXHRcXHQgICAgcG9zaXRpb24gPSB0aGlzLl9oYXNoZXNbaGFzaF0gJiYgaXRlbXMuaW5kZXgodGhpcy5faGFzaGVzW2hhc2hdKTtcXG5cXG5cXHRcXHRcXHRpZiAocG9zaXRpb24gPT09IHVuZGVmaW5lZCB8fCBwb3NpdGlvbiA9PT0gdGhpcy5fY29yZS5jdXJyZW50KCkpIHtcXG5cXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHRoaXMuX2NvcmUudG8odGhpcy5fY29yZS5yZWxhdGl2ZShwb3NpdGlvbiksIGZhbHNlLCB0cnVlKTtcXG5cXHRcXHR9LCB0aGlzKSk7XFxuXFx0fTtcXG5cXG5cXHQvKipcXG4gICogRGVmYXVsdCBvcHRpb25zLlxcbiAgKiBAcHVibGljXFxuICAqL1xcblxcdEhhc2guRGVmYXVsdHMgPSB7XFxuXFx0XFx0VVJMaGFzaExpc3RlbmVyOiBmYWxzZVxcblxcdH07XFxuXFxuXFx0LyoqXFxuICAqIERlc3Ryb3lzIHRoZSBwbHVnaW4uXFxuICAqIEBwdWJsaWNcXG4gICovXFxuXFx0SGFzaC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR2YXIgaGFuZGxlciwgcHJvcGVydHk7XFxuXFxuXFx0XFx0JCh3aW5kb3cpLm9mZignaGFzaGNoYW5nZS5vd2wubmF2aWdhdGlvbicpO1xcblxcblxcdFxcdGZvciAoaGFuZGxlciBpbiB0aGlzLl9oYW5kbGVycykge1xcblxcdFxcdFxcdHRoaXMuX2NvcmUuJGVsZW1lbnQub2ZmKGhhbmRsZXIsIHRoaXMuX2hhbmRsZXJzW2hhbmRsZXJdKTtcXG5cXHRcXHR9XFxuXFx0XFx0Zm9yIChwcm9wZXJ0eSBpbiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0aGlzKSkge1xcblxcdFxcdFxcdHR5cGVvZiB0aGlzW3Byb3BlcnR5XSAhPSAnZnVuY3Rpb24nICYmICh0aGlzW3Byb3BlcnR5XSA9IG51bGwpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdCQuZm4ub3dsQ2Fyb3VzZWwuQ29uc3RydWN0b3IuUGx1Z2lucy5IYXNoID0gSGFzaDtcXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqXFxuICogU3VwcG9ydCBQbHVnaW5cXG4gKlxcbiAqIEB2ZXJzaW9uIDIuMS4wXFxuICogQGF1dGhvciBWaXZpZCBQbGFuZXQgU29mdHdhcmUgR21iSFxcbiAqIEBhdXRob3IgQXJ0dXMgS29sYW5vd3NraVxcbiAqIEBhdXRob3IgRGF2aWQgRGV1dHNjaFxcbiAqIEBsaWNlbnNlIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxcbiAqL1xcbjsoZnVuY3Rpb24gKCQsIHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xcblxcblxcdHZhciBzdHlsZSA9ICQoJzxzdXBwb3J0PicpLmdldCgwKS5zdHlsZSxcXG5cXHQgICAgcHJlZml4ZXMgPSAnV2Via2l0IE1veiBPIG1zJy5zcGxpdCgnICcpLFxcblxcdCAgICBldmVudHMgPSB7XFxuXFx0XFx0dHJhbnNpdGlvbjoge1xcblxcdFxcdFxcdGVuZDoge1xcblxcdFxcdFxcdFxcdFdlYmtpdFRyYW5zaXRpb246ICd3ZWJraXRUcmFuc2l0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRNb3pUcmFuc2l0aW9uOiAndHJhbnNpdGlvbmVuZCcsXFxuXFx0XFx0XFx0XFx0T1RyYW5zaXRpb246ICdvVHJhbnNpdGlvbkVuZCcsXFxuXFx0XFx0XFx0XFx0dHJhbnNpdGlvbjogJ3RyYW5zaXRpb25lbmQnXFxuXFx0XFx0XFx0fVxcblxcdFxcdH0sXFxuXFx0XFx0YW5pbWF0aW9uOiB7XFxuXFx0XFx0XFx0ZW5kOiB7XFxuXFx0XFx0XFx0XFx0V2Via2l0QW5pbWF0aW9uOiAnd2Via2l0QW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRNb3pBbmltYXRpb246ICdhbmltYXRpb25lbmQnLFxcblxcdFxcdFxcdFxcdE9BbmltYXRpb246ICdvQW5pbWF0aW9uRW5kJyxcXG5cXHRcXHRcXHRcXHRhbmltYXRpb246ICdhbmltYXRpb25lbmQnXFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9LFxcblxcdCAgICB0ZXN0cyA9IHtcXG5cXHRcXHRjc3N0cmFuc2Zvcm1zOiBmdW5jdGlvbiBjc3N0cmFuc2Zvcm1zKCkge1xcblxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ3RyYW5zZm9ybScpO1xcblxcdFxcdH0sXFxuXFx0XFx0Y3NzdHJhbnNmb3JtczNkOiBmdW5jdGlvbiBjc3N0cmFuc2Zvcm1zM2QoKSB7XFxuXFx0XFx0XFx0cmV0dXJuICEhdGVzdCgncGVyc3BlY3RpdmUnKTtcXG5cXHRcXHR9LFxcblxcdFxcdGNzc3RyYW5zaXRpb25zOiBmdW5jdGlvbiBjc3N0cmFuc2l0aW9ucygpIHtcXG5cXHRcXHRcXHRyZXR1cm4gISF0ZXN0KCd0cmFuc2l0aW9uJyk7XFxuXFx0XFx0fSxcXG5cXHRcXHRjc3NhbmltYXRpb25zOiBmdW5jdGlvbiBjc3NhbmltYXRpb25zKCkge1xcblxcdFxcdFxcdHJldHVybiAhIXRlc3QoJ2FuaW1hdGlvbicpO1xcblxcdFxcdH1cXG5cXHR9O1xcblxcblxcdGZ1bmN0aW9uIHRlc3QocHJvcGVydHksIHByZWZpeGVkKSB7XFxuXFx0XFx0dmFyIHJlc3VsdCA9IGZhbHNlLFxcblxcdFxcdCAgICB1cHBlciA9IHByb3BlcnR5LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcHJvcGVydHkuc2xpY2UoMSk7XFxuXFxuXFx0XFx0JC5lYWNoKChwcm9wZXJ0eSArICcgJyArIHByZWZpeGVzLmpvaW4odXBwZXIgKyAnICcpICsgdXBwZXIpLnNwbGl0KCcgJyksIGZ1bmN0aW9uIChpLCBwcm9wZXJ0eSkge1xcblxcdFxcdFxcdGlmIChzdHlsZVtwcm9wZXJ0eV0gIT09IHVuZGVmaW5lZCkge1xcblxcdFxcdFxcdFxcdHJlc3VsdCA9IHByZWZpeGVkID8gcHJvcGVydHkgOiB0cnVlO1xcblxcdFxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fSk7XFxuXFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcHJlZml4ZWQocHJvcGVydHkpIHtcXG5cXHRcXHRyZXR1cm4gdGVzdChwcm9wZXJ0eSwgdHJ1ZSk7XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3N0cmFuc2l0aW9ucygpKSB7XFxuXFx0XFx0LyoganNoaW50IC1XMDUzICovXFxuXFx0XFx0JC5zdXBwb3J0LnRyYW5zaXRpb24gPSBuZXcgU3RyaW5nKHByZWZpeGVkKCd0cmFuc2l0aW9uJykpO1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2l0aW9uLmVuZCA9IGV2ZW50cy50cmFuc2l0aW9uLmVuZFskLnN1cHBvcnQudHJhbnNpdGlvbl07XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3NhbmltYXRpb25zKCkpIHtcXG5cXHRcXHQvKiBqc2hpbnQgLVcwNTMgKi9cXG5cXHRcXHQkLnN1cHBvcnQuYW5pbWF0aW9uID0gbmV3IFN0cmluZyhwcmVmaXhlZCgnYW5pbWF0aW9uJykpO1xcblxcdFxcdCQuc3VwcG9ydC5hbmltYXRpb24uZW5kID0gZXZlbnRzLmFuaW1hdGlvbi5lbmRbJC5zdXBwb3J0LmFuaW1hdGlvbl07XFxuXFx0fVxcblxcblxcdGlmICh0ZXN0cy5jc3N0cmFuc2Zvcm1zKCkpIHtcXG5cXHRcXHQvKiBqc2hpbnQgLVcwNTMgKi9cXG5cXHRcXHQkLnN1cHBvcnQudHJhbnNmb3JtID0gbmV3IFN0cmluZyhwcmVmaXhlZCgndHJhbnNmb3JtJykpO1xcblxcdFxcdCQuc3VwcG9ydC50cmFuc2Zvcm0zZCA9IHRlc3RzLmNzc3RyYW5zZm9ybXMzZCgpO1xcblxcdH1cXG59KSh3aW5kb3cuWmVwdG8gfHwgd2luZG93LmpRdWVyeSwgd2luZG93LCBkb2N1bWVudCk7XFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIC4vc3JjL293bC5jYXJvdXNlbC5qc1xcbiAqKiBtb2R1bGUgaWQgPSAxXFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXFxuICoqL1xcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy8uL3NyYy9vd2wuY2Fyb3VzZWwuanM/XCIpO1xuXG4vKioqLyB9LFxuLyogMiAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXZhbChcImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19yZXF1aXJlX18oMykoKTtcXG4vLyBpbXBvcnRzXFxuXFxuXFxuLy8gbW9kdWxlXFxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFxcXCIvKipcXFxcbiAqIE93bCBDYXJvdXNlbCB2Mi4yLjFcXFxcbiAqIENvcHlyaWdodCAyMDEzLTIwMTcgRGF2aWQgRGV1dHNjaFxcXFxuICogTGljZW5zZWQgdW5kZXIgICgpXFxcXG4gKi9cXFxcbi8qXFxcXG4gKiAgT3dsIENhcm91c2VsIC0gQ29yZVxcXFxuICovXFxcXG4ub3dsLWNhcm91c2VsIHtcXFxcbiAgZGlzcGxheTogbm9uZTtcXFxcbiAgd2lkdGg6IDEwMCU7XFxcXG4gIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxcXG4gIC8qIHBvc2l0aW9uIHJlbGF0aXZlIGFuZCB6LWluZGV4IGZpeCB3ZWJraXQgcmVuZGVyaW5nIGZvbnRzIGlzc3VlICovXFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgei1pbmRleDogMTsgfVxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtc3RhZ2Uge1xcXFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgICAtbXMtdG91Y2gtYWN0aW9uOiBwYW4tWTtcXFxcbiAgICAtbW96LWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgICAvKiBmaXggZmlyZWZveCBhbmltYXRpb24gZ2xpdGNoICovIH1cXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLXN0YWdlOmFmdGVyIHtcXFxcbiAgICBjb250ZW50OiBcXFxcXFxcIi5cXFxcXFxcIjtcXFxcbiAgICBkaXNwbGF5OiBibG9jaztcXFxcbiAgICBjbGVhcjogYm90aDtcXFxcbiAgICB2aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgbGluZS1oZWlnaHQ6IDA7XFxcXG4gICAgaGVpZ2h0OiAwOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1zdGFnZS1vdXRlciB7XFxcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcXFxuICAgIG92ZXJmbG93OiBoaWRkZW47XFxcXG4gICAgLyogZml4IGZvciBmbGFzaGluZyBiYWNrZ3JvdW5kICovXFxcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDBweCwgMHB4LCAwcHgpOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC13cmFwcGVyLFxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtaXRlbSB7XFxcXG4gICAgLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgLW1vei1iYWNrZmFjZS12aXNpYmlsaXR5OiBoaWRkZW47XFxcXG4gICAgLW1zLWJhY2tmYWNlLXZpc2liaWxpdHk6IGhpZGRlbjtcXFxcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogdHJhbnNsYXRlM2QoMCwgMCwgMCk7XFxcXG4gICAgLW1vei10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApO1xcXFxuICAgIC1tcy10cmFuc2Zvcm06IHRyYW5zbGF0ZTNkKDAsIDAsIDApOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIHtcXFxcbiAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gICAgbWluLWhlaWdodDogMXB4O1xcXFxuICAgIGZsb2F0OiBsZWZ0O1xcXFxuICAgIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICAgIC13ZWJraXQtdGFwLWhpZ2hsaWdodC1jb2xvcjogdHJhbnNwYXJlbnQ7XFxcXG4gICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIGltZyB7XFxcXG4gICAgZGlzcGxheTogYmxvY2s7XFxcXG4gICAgd2lkdGg6IDEwMCU7IH1cXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLW5hdi5kaXNhYmxlZCxcXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLWRvdHMuZGlzYWJsZWQge1xcXFxuICAgIGRpc3BsYXk6IG5vbmU7IH1cXFxcbiAgLm93bC1jYXJvdXNlbCAub3dsLW5hdiAub3dsLXByZXYsXFxcXG4gIC5vd2wtY2Fyb3VzZWwgLm93bC1uYXYgLm93bC1uZXh0LFxcXFxuICAub3dsLWNhcm91c2VsIC5vd2wtZG90IHtcXFxcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gICAgY3Vyc29yOiBoYW5kO1xcXFxuICAgIC13ZWJraXQtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTtcXFxcbiAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgdXNlci1zZWxlY3Q6IG5vbmU7IH1cXFxcbiAgLm93bC1jYXJvdXNlbC5vd2wtbG9hZGVkIHtcXFxcbiAgICBkaXNwbGF5OiBibG9jazsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1sb2FkaW5nIHtcXFxcbiAgICBvcGFjaXR5OiAwO1xcXFxuICAgIGRpc3BsYXk6IGJsb2NrOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwub3dsLWhpZGRlbiB7XFxcXG4gICAgb3BhY2l0eTogMDsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1yZWZyZXNoIC5vd2wtaXRlbSB7XFxcXG4gICAgdmlzaWJpbGl0eTogaGlkZGVuOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwub3dsLWRyYWcgLm93bC1pdGVtIHtcXFxcbiAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XFxcXG4gICAgLW1zLXVzZXItc2VsZWN0OiBub25lO1xcXFxuICAgIHVzZXItc2VsZWN0OiBub25lOyB9XFxcXG4gIC5vd2wtY2Fyb3VzZWwub3dsLWdyYWIge1xcXFxuICAgIGN1cnNvcjogbW92ZTtcXFxcbiAgICBjdXJzb3I6IC13ZWJraXQtZ3JhYjtcXFxcbiAgICBjdXJzb3I6IGdyYWI7IH1cXFxcbiAgLm93bC1jYXJvdXNlbC5vd2wtcnRsIHtcXFxcbiAgICBkaXJlY3Rpb246IHJ0bDsgfVxcXFxuICAub3dsLWNhcm91c2VsLm93bC1ydGwgLm93bC1pdGVtIHtcXFxcbiAgICBmbG9hdDogcmlnaHQ7IH1cXFxcblxcXFxuLyogTm8gSnMgKi9cXFxcbi5uby1qcyAub3dsLWNhcm91c2VsIHtcXFxcbiAgZGlzcGxheTogYmxvY2s7IH1cXFxcblxcXFxuLypcXFxcbiAqICBPd2wgQ2Fyb3VzZWwgLSBBbmltYXRlIFBsdWdpblxcXFxuICovXFxcXG4ub3dsLWNhcm91c2VsIC5hbmltYXRlZCB7XFxcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uLWR1cmF0aW9uOiAxMDAwbXM7XFxcXG4gIC13ZWJraXQtYW5pbWF0aW9uLWZpbGwtbW9kZTogYm90aDtcXFxcbiAgICAgICAgICBhbmltYXRpb24tZmlsbC1tb2RlOiBib3RoOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC1hbmltYXRlZC1pbiB7XFxcXG4gIHotaW5kZXg6IDA7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLWFuaW1hdGVkLW91dCB7XFxcXG4gIHotaW5kZXg6IDE7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAuZmFkZU91dCB7XFxcXG4gIC13ZWJraXQtYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXQ7XFxcXG4gICAgICAgICAgYW5pbWF0aW9uLW5hbWU6IGZhZGVPdXQ7IH1cXFxcblxcXFxuQC13ZWJraXQta2V5ZnJhbWVzIGZhZGVPdXQge1xcXFxuICAwJSB7XFxcXG4gICAgb3BhY2l0eTogMTsgfVxcXFxuICAxMDAlIHtcXFxcbiAgICBvcGFjaXR5OiAwOyB9IH1cXFxcblxcXFxuQGtleWZyYW1lcyBmYWRlT3V0IHtcXFxcbiAgMCUge1xcXFxuICAgIG9wYWNpdHk6IDE7IH1cXFxcbiAgMTAwJSB7XFxcXG4gICAgb3BhY2l0eTogMDsgfSB9XFxcXG5cXFxcbi8qXFxcXG4gKiBcXFxcdE93bCBDYXJvdXNlbCAtIEF1dG8gSGVpZ2h0IFBsdWdpblxcXFxuICovXFxcXG4ub3dsLWhlaWdodCB7XFxcXG4gIHRyYW5zaXRpb246IGhlaWdodCA1MDBtcyBlYXNlLWluLW91dDsgfVxcXFxuXFxcXG4vKlxcXFxuICogXFxcXHRPd2wgQ2Fyb3VzZWwgLSBMYXp5IExvYWQgUGx1Z2luXFxcXG4gKi9cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC1pdGVtIC5vd2wtbGF6eSB7XFxcXG4gIG9wYWNpdHk6IDA7XFxcXG4gIHRyYW5zaXRpb246IG9wYWNpdHkgNDAwbXMgZWFzZTsgfVxcXFxuXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtaXRlbSBpbWcub3dsLWxhenkge1xcXFxuICAtd2Via2l0LXRyYW5zZm9ybS1zdHlsZTogcHJlc2VydmUtM2Q7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtLXN0eWxlOiBwcmVzZXJ2ZS0zZDsgfVxcXFxuXFxcXG4vKlxcXFxuICogXFxcXHRPd2wgQ2Fyb3VzZWwgLSBWaWRlbyBQbHVnaW5cXFxcbiAqL1xcXFxuLm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXdyYXBwZXIge1xcXFxuICBwb3NpdGlvbjogcmVsYXRpdmU7XFxcXG4gIGhlaWdodDogMTAwJTtcXFxcbiAgYmFja2dyb3VuZDogIzAwMDsgfVxcXFxuXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tcGxheS1pY29uIHtcXFxcbiAgcG9zaXRpb246IGFic29sdXRlO1xcXFxuICBoZWlnaHQ6IDgwcHg7XFxcXG4gIHdpZHRoOiA4MHB4O1xcXFxuICBsZWZ0OiA1MCU7XFxcXG4gIHRvcDogNTAlO1xcXFxuICBtYXJnaW4tbGVmdDogLTQwcHg7XFxcXG4gIG1hcmdpbi10b3A6IC00MHB4O1xcXFxuICAvKiBiYWNrZ3JvdW5kOiB1cmwoXFxcXFxcXCJvd2wudmlkZW8ucGxheS5wbmdcXFxcXFxcIikgbm8tcmVwZWF0OyAqL1xcXFxuICBjdXJzb3I6IHBvaW50ZXI7XFxcXG4gIHotaW5kZXg6IDE7XFxcXG4gIC13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTogaGlkZGVuO1xcXFxuICB0cmFuc2l0aW9uOiAtd2Via2l0LXRyYW5zZm9ybSAxMDBtcyBlYXNlO1xcXFxuICB0cmFuc2l0aW9uOiB0cmFuc2Zvcm0gMTAwbXMgZWFzZTtcXFxcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDEwMG1zIGVhc2UsIC13ZWJraXQtdHJhbnNmb3JtIDEwMG1zIGVhc2U7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXBsYXktaWNvbjpob3ZlciB7XFxcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgxLjMsIDEuMyk7XFxcXG4gICAgICAgICAgdHJhbnNmb3JtOiBzY2FsZSgxLjMsIDEuMyk7IH1cXFxcblxcXFxuLm93bC1jYXJvdXNlbCAub3dsLXZpZGVvLXBsYXlpbmcgLm93bC12aWRlby10bixcXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1wbGF5aW5nIC5vd2wtdmlkZW8tcGxheS1pY29uIHtcXFxcbiAgZGlzcGxheTogbm9uZTsgfVxcXFxuXFxcXG4ub3dsLWNhcm91c2VsIC5vd2wtdmlkZW8tdG4ge1xcXFxuICBvcGFjaXR5OiAwO1xcXFxuICBoZWlnaHQ6IDEwMCU7XFxcXG4gIGJhY2tncm91bmQtcG9zaXRpb246IGNlbnRlciBjZW50ZXI7XFxcXG4gIGJhY2tncm91bmQtcmVwZWF0OiBuby1yZXBlYXQ7XFxcXG4gIGJhY2tncm91bmQtc2l6ZTogY29udGFpbjtcXFxcbiAgdHJhbnNpdGlvbjogb3BhY2l0eSA0MDBtcyBlYXNlOyB9XFxcXG5cXFxcbi5vd2wtY2Fyb3VzZWwgLm93bC12aWRlby1mcmFtZSB7XFxcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXFxcbiAgei1pbmRleDogMTtcXFxcbiAgaGVpZ2h0OiAxMDAlO1xcXFxuICB3aWR0aDogMTAwJTsgfVxcXFxuXFxcIiwgXFxcIlxcXCJdKTtcXG5cXG4vLyBleHBvcnRzXFxuXFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIC4vfi9jc3MtbG9hZGVyIS4vfi9wb3N0Y3NzLWxvYWRlciEuL3NyYy9vd2wuY2Fyb3VzZWwuY3NzXFxuICoqIG1vZHVsZSBpZCA9IDJcXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcXG4gKiovXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vLy4vc3JjL293bC5jYXJvdXNlbC5jc3M/Li9+L2Nzcy1sb2FkZXIhLi9+L3Bvc3Rjc3MtbG9hZGVyXCIpO1xuXG4vKioqLyB9LFxuLyogMyAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cblx0ZXZhbChcIi8qXFxyXFxuXFx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcXHJcXG5cXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXFxyXFxuKi9cXHJcXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxcclxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XFxyXFxuXFx0dmFyIGxpc3QgPSBbXTtcXHJcXG5cXHJcXG5cXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXFxyXFxuXFx0bGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xcclxcblxcdFxcdHZhciByZXN1bHQgPSBbXTtcXHJcXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xcclxcblxcdFxcdFxcdHZhciBpdGVtID0gdGhpc1tpXTtcXHJcXG5cXHRcXHRcXHRpZihpdGVtWzJdKSB7XFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnB1c2goXFxcIkBtZWRpYSBcXFwiICsgaXRlbVsyXSArIFxcXCJ7XFxcIiArIGl0ZW1bMV0gKyBcXFwifVxcXCIpO1xcclxcblxcdFxcdFxcdH0gZWxzZSB7XFxyXFxuXFx0XFx0XFx0XFx0cmVzdWx0LnB1c2goaXRlbVsxXSk7XFxyXFxuXFx0XFx0XFx0fVxcclxcblxcdFxcdH1cXHJcXG5cXHRcXHRyZXR1cm4gcmVzdWx0LmpvaW4oXFxcIlxcXCIpO1xcclxcblxcdH07XFxyXFxuXFxyXFxuXFx0Ly8gaW1wb3J0IGEgbGlzdCBvZiBtb2R1bGVzIGludG8gdGhlIGxpc3RcXHJcXG5cXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XFxyXFxuXFx0XFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFxcXCJzdHJpbmdcXFwiKVxcclxcblxcdFxcdFxcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFxcXCJcXFwiXV07XFxyXFxuXFx0XFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcXHJcXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xcclxcblxcdFxcdFxcdHZhciBpZCA9IHRoaXNbaV1bMF07XFxyXFxuXFx0XFx0XFx0aWYodHlwZW9mIGlkID09PSBcXFwibnVtYmVyXFxcIilcXHJcXG5cXHRcXHRcXHRcXHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XFxyXFxuXFx0XFx0fVxcclxcblxcdFxcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcXHJcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XFxyXFxuXFx0XFx0XFx0Ly8gc2tpcCBhbHJlYWR5IGltcG9ydGVkIG1vZHVsZVxcclxcblxcdFxcdFxcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXFxyXFxuXFx0XFx0XFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cXHJcXG5cXHRcXHRcXHQvLyAgSSBob3BlIHRoaXMgd2lsbCBuZXZlciBvY2N1ciAoSGV5IHRoaXMgd2F5IHdlIGhhdmUgc21hbGxlciBidW5kbGVzKVxcclxcblxcdFxcdFxcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcXFwibnVtYmVyXFxcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xcclxcblxcdFxcdFxcdFxcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcXHJcXG5cXHRcXHRcXHRcXHRcXHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcXHJcXG5cXHRcXHRcXHRcXHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xcclxcblxcdFxcdFxcdFxcdFxcdGl0ZW1bMl0gPSBcXFwiKFxcXCIgKyBpdGVtWzJdICsgXFxcIikgYW5kIChcXFwiICsgbWVkaWFRdWVyeSArIFxcXCIpXFxcIjtcXHJcXG5cXHRcXHRcXHRcXHR9XFxyXFxuXFx0XFx0XFx0XFx0bGlzdC5wdXNoKGl0ZW0pO1xcclxcblxcdFxcdFxcdH1cXHJcXG5cXHRcXHR9XFxyXFxuXFx0fTtcXHJcXG5cXHRyZXR1cm4gbGlzdDtcXHJcXG59O1xcclxcblxcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiAuL34vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcXG4gKiogbW9kdWxlIGlkID0gM1xcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzP1wiKTtcblxuLyoqKi8gfSxcbi8qIDQgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cdGV2YWwoXCIvKlxcblxcdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXFxuXFx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxcbiovXFxudmFyIHN0eWxlc0luRG9tID0ge30sXFxuXFx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XFxuXFx0XFx0dmFyIG1lbW87XFxuXFx0XFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRpZiAodHlwZW9mIG1lbW8gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG5cXHRcXHRcXHRyZXR1cm4gbWVtbztcXG5cXHRcXHR9O1xcblxcdH0sXFxuXFx0aXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24oKSB7XFxuXFx0XFx0cmV0dXJuIC9tc2llIFs2LTldXFxcXGIvLnRlc3Qoc2VsZi5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xcblxcdH0pLFxcblxcdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XFxuXFx0XFx0cmV0dXJuIGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcImhlYWRcXFwiKVswXTtcXG5cXHR9KSxcXG5cXHRzaW5nbGV0b25FbGVtZW50ID0gbnVsbCxcXG5cXHRzaW5nbGV0b25Db3VudGVyID0gMCxcXG5cXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcCA9IFtdO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xcblxcdGlmKGZhbHNlKSB7XFxuXFx0XFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcXFwib2JqZWN0XFxcIikgdGhyb3cgbmV3IEVycm9yKFxcXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcXFwiKTtcXG5cXHR9XFxuXFxuXFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XFxuXFx0Ly8gdGFncyBpdCB3aWxsIGFsbG93IG9uIGEgcGFnZVxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gPT09IFxcXCJ1bmRlZmluZWRcXFwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcXG5cXG5cXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgPGhlYWQ+LlxcblxcdGlmICh0eXBlb2Ygb3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcXFwiYm90dG9tXFxcIjtcXG5cXG5cXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QpO1xcblxcdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XFxuXFxuXFx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XFxuXFx0XFx0dmFyIG1heVJlbW92ZSA9IFtdO1xcblxcdFxcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcXG5cXHRcXHRcXHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcXG5cXHRcXHRcXHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcXG5cXHRcXHRcXHRkb21TdHlsZS5yZWZzLS07XFxuXFx0XFx0XFx0bWF5UmVtb3ZlLnB1c2goZG9tU3R5bGUpO1xcblxcdFxcdH1cXG5cXHRcXHRpZihuZXdMaXN0KSB7XFxuXFx0XFx0XFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcXG5cXHRcXHRcXHRhZGRTdHlsZXNUb0RvbShuZXdTdHlsZXMsIG9wdGlvbnMpO1xcblxcdFxcdH1cXG5cXHRcXHRmb3IodmFyIGkgPSAwOyBpIDwgbWF5UmVtb3ZlLmxlbmd0aDsgaSsrKSB7XFxuXFx0XFx0XFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xcblxcdFxcdFxcdGlmKGRvbVN0eWxlLnJlZnMgPT09IDApIHtcXG5cXHRcXHRcXHRcXHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspXFxuXFx0XFx0XFx0XFx0XFx0ZG9tU3R5bGUucGFydHNbal0oKTtcXG5cXHRcXHRcXHRcXHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG59XFxuXFxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XFxuXFx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xcblxcdFxcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xcblxcdFxcdGlmKGRvbVN0eWxlKSB7XFxuXFx0XFx0XFx0ZG9tU3R5bGUucmVmcysrO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBkb21TdHlsZS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xcblxcdFxcdFxcdFxcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHZhciBwYXJ0cyA9IFtdO1xcblxcdFxcdFxcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XFxuXFx0XFx0XFx0XFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xcblxcdFxcdH1cXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGxpc3RUb1N0eWxlcyhsaXN0KSB7XFxuXFx0dmFyIHN0eWxlcyA9IFtdO1xcblxcdHZhciBuZXdTdHlsZXMgPSB7fTtcXG5cXHRmb3IodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xcblxcdFxcdHZhciBpdGVtID0gbGlzdFtpXTtcXG5cXHRcXHR2YXIgaWQgPSBpdGVtWzBdO1xcblxcdFxcdHZhciBjc3MgPSBpdGVtWzFdO1xcblxcdFxcdHZhciBtZWRpYSA9IGl0ZW1bMl07XFxuXFx0XFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XFxuXFx0XFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xcblxcdFxcdGlmKCFuZXdTdHlsZXNbaWRdKVxcblxcdFxcdFxcdHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XFxuXFx0XFx0ZWxzZVxcblxcdFxcdFxcdG5ld1N0eWxlc1tpZF0ucGFydHMucHVzaChwYXJ0KTtcXG5cXHR9XFxuXFx0cmV0dXJuIHN0eWxlcztcXG59XFxuXFxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlRWxlbWVudCkge1xcblxcdHZhciBoZWFkID0gZ2V0SGVhZEVsZW1lbnQoKTtcXG5cXHR2YXIgbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AgPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcFtzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcXG5cXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXFxcInRvcFxcXCIpIHtcXG5cXHRcXHRpZighbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcXG5cXHRcXHRcXHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XFxuXFx0XFx0fSBlbHNlIGlmKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XFxuXFx0XFx0XFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XFxuXFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XFxuXFx0XFx0fVxcblxcdFxcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnB1c2goc3R5bGVFbGVtZW50KTtcXG5cXHR9IGVsc2UgaWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFxcXCJib3R0b21cXFwiKSB7XFxuXFx0XFx0aGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0dGhyb3cgbmV3IEVycm9yKFxcXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cXFwiKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcXG5cXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xcblxcdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XFxuXFx0aWYoaWR4ID49IDApIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5zcGxpY2UoaWR4LCAxKTtcXG5cXHR9XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSB7XFxuXFx0dmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcInN0eWxlXFxcIik7XFxuXFx0c3R5bGVFbGVtZW50LnR5cGUgPSBcXFwidGV4dC9jc3NcXFwiO1xcblxcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xcblxcdHJldHVybiBzdHlsZUVsZW1lbnQ7XFxufVxcblxcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcXG5cXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxcXCJsaW5rXFxcIik7XFxuXFx0bGlua0VsZW1lbnQucmVsID0gXFxcInN0eWxlc2hlZXRcXFwiO1xcblxcdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rRWxlbWVudCk7XFxuXFx0cmV0dXJuIGxpbmtFbGVtZW50O1xcbn1cXG5cXG5mdW5jdGlvbiBhZGRTdHlsZShvYmosIG9wdGlvbnMpIHtcXG5cXHR2YXIgc3R5bGVFbGVtZW50LCB1cGRhdGUsIHJlbW92ZTtcXG5cXG5cXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcXG5cXHRcXHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcXG5cXHRcXHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50LCBzdHlsZUluZGV4LCBmYWxzZSk7XFxuXFx0XFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCwgc3R5bGVJbmRleCwgdHJ1ZSk7XFxuXFx0fSBlbHNlIGlmKG9iai5zb3VyY2VNYXAgJiZcXG5cXHRcXHR0eXBlb2YgVVJMID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIFVSTC5jcmVhdGVPYmplY3RVUkwgPT09IFxcXCJmdW5jdGlvblxcXCIgJiZcXG5cXHRcXHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXFxcImZ1bmN0aW9uXFxcIiAmJlxcblxcdFxcdHR5cGVvZiBCbG9iID09PSBcXFwiZnVuY3Rpb25cXFwiICYmXFxuXFx0XFx0dHlwZW9mIGJ0b2EgPT09IFxcXCJmdW5jdGlvblxcXCIpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcXG5cXHRcXHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGVFbGVtZW50KTtcXG5cXHRcXHRcXHRpZihzdHlsZUVsZW1lbnQuaHJlZilcXG5cXHRcXHRcXHRcXHRVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlRWxlbWVudC5ocmVmKTtcXG5cXHRcXHR9O1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xcblxcdFxcdHVwZGF0ZSA9IGFwcGx5VG9UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQpO1xcblxcdFxcdHJlbW92ZSA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpO1xcblxcdFxcdH07XFxuXFx0fVxcblxcblxcdHVwZGF0ZShvYmopO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcXG5cXHRcXHRpZihuZXdPYmopIHtcXG5cXHRcXHRcXHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXFxuXFx0XFx0XFx0XFx0cmV0dXJuO1xcblxcdFxcdFxcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0cmVtb3ZlKCk7XFxuXFx0XFx0fVxcblxcdH07XFxufVxcblxcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XFxuXFx0dmFyIHRleHRTdG9yZSA9IFtdO1xcblxcblxcdHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XFxuXFx0XFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xcblxcdFxcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcXFxuJyk7XFxuXFx0fTtcXG59KSgpO1xcblxcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcXG5cXHR2YXIgY3NzID0gcmVtb3ZlID8gXFxcIlxcXCIgOiBvYmouY3NzO1xcblxcblxcdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xcblxcdFxcdHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdHZhciBjc3NOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKTtcXG5cXHRcXHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xcblxcdFxcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNzc05vZGUsIGNoaWxkTm9kZXNbaW5kZXhdKTtcXG5cXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdHN0eWxlRWxlbWVudC5hcHBlbmRDaGlsZChjc3NOb2RlKTtcXG5cXHRcXHR9XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiBhcHBseVRvVGFnKHN0eWxlRWxlbWVudCwgb2JqKSB7XFxuXFx0dmFyIGNzcyA9IG9iai5jc3M7XFxuXFx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xcblxcblxcdGlmKG1lZGlhKSB7XFxuXFx0XFx0c3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZShcXFwibWVkaWFcXFwiLCBtZWRpYSlcXG5cXHR9XFxuXFxuXFx0aWYoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcXG5cXHRcXHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xcblxcdH0gZWxzZSB7XFxuXFx0XFx0d2hpbGUoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcXG5cXHRcXHRcXHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xcblxcdFxcdH1cXG5cXHRcXHRzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XFxuXFx0fVxcbn1cXG5cXG5mdW5jdGlvbiB1cGRhdGVMaW5rKGxpbmtFbGVtZW50LCBvYmopIHtcXG5cXHR2YXIgY3NzID0gb2JqLmNzcztcXG5cXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcXG5cXG5cXHRpZihzb3VyY2VNYXApIHtcXG5cXHRcXHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxcblxcdFxcdGNzcyArPSBcXFwiXFxcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFxcXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXFxcIiAqL1xcXCI7XFxuXFx0fVxcblxcblxcdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXFxcInRleHQvY3NzXFxcIiB9KTtcXG5cXG5cXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcXG5cXG5cXHRsaW5rRWxlbWVudC5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcXG5cXG5cXHRpZihvbGRTcmMpXFxuXFx0XFx0VVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xcbn1cXG5cXG5cXG4vKioqKioqKioqKioqKioqKipcXG4gKiogV0VCUEFDSyBGT09URVJcXG4gKiogLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcXG4gKiogbW9kdWxlIGlkID0gNFxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9+L3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanM/XCIpO1xuXG4vKioqLyB9LFxuLyogNSAqL1xuLyoqKi8gZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblx0ZXZhbChcIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXFxuXFxuLy8gbG9hZCB0aGUgc3R5bGVzXFxudmFyIGNvbnRlbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cXG52YXIgdXBkYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KShjb250ZW50LCB7fSk7XFxuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XFxuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxcbmlmKGZhbHNlKSB7XFxuXFx0Ly8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRpZighY29udGVudC5sb2NhbHMpIHtcXG5cXHRcXHRtb2R1bGUuaG90LmFjY2VwdChcXFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuLi9ub2RlX21vZHVsZXMvcG9zdGNzcy1sb2FkZXIvaW5kZXguanMhLi9vd2wuY2Fyb3VzZWwuY3NzXFxcIiwgZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFxcXCIhIS4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4uL25vZGVfbW9kdWxlcy9wb3N0Y3NzLWxvYWRlci9pbmRleC5qcyEuL293bC5jYXJvdXNlbC5jc3NcXFwiKTtcXG5cXHRcXHRcXHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcXG5cXHRcXHRcXHR1cGRhdGUobmV3Q29udGVudCk7XFxuXFx0XFx0fSk7XFxuXFx0fVxcblxcdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcXG5cXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcXG59XFxuXFxuLyoqKioqKioqKioqKioqKioqXFxuICoqIFdFQlBBQ0sgRk9PVEVSXFxuICoqIC4vc3JjL293bC5jYXJvdXNlbC5jc3NcXG4gKiogbW9kdWxlIGlkID0gNVxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vLi9zcmMvb3dsLmNhcm91c2VsLmNzcz9cIik7XG5cbi8qKiovIH0sXG4vKiA2ICovXG4vKioqLyBmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcblxuXHRldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFXzZfXztcXG5cXG4vKioqKioqKioqKioqKioqKipcXG4gKiogV0VCUEFDSyBGT09URVJcXG4gKiogZXh0ZXJuYWwge1xcXCJyb290XFxcIjpcXFwiUHJvcFR5cGVzXFxcIixcXFwiY29tbW9uanMyXFxcIjpcXFwicHJvcC10eXBlc1xcXCIsXFxcImNvbW1vbmpzXFxcIjpcXFwicHJvcC10eXBlc1xcXCIsXFxcImFtZFxcXCI6XFxcInByb3AtdHlwZXNcXFwifVxcbiAqKiBtb2R1bGUgaWQgPSA2XFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXFxuICoqL1xcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovLy9leHRlcm5hbF8lN0IlMjJyb290JTIyOiUyMlByb3BUeXBlcyUyMiwlMjJjb21tb25qczIlMjI6JTIycHJvcC10eXBlcyUyMiwlMjJjb21tb25qcyUyMjolMjJwcm9wLXR5cGVzJTIyLCUyMmFtZCUyMjolMjJwcm9wLXR5cGVzJTIyJTdEP1wiKTtcblxuLyoqKi8gfSxcbi8qIDcgKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfN19fO1xcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiBleHRlcm5hbCB7XFxcInJvb3RcXFwiOlxcXCJSZWFjdFxcXCIsXFxcImNvbW1vbmpzMlxcXCI6XFxcInJlYWN0XFxcIixcXFwiY29tbW9uanNcXFwiOlxcXCJyZWFjdFxcXCIsXFxcImFtZFxcXCI6XFxcInJlYWN0XFxcIn1cXG4gKiogbW9kdWxlIGlkID0gN1xcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vZXh0ZXJuYWxfJTdCJTIycm9vdCUyMjolMjJSZWFjdCUyMiwlMjJjb21tb25qczIlMjI6JTIycmVhY3QlMjIsJTIyY29tbW9uanMlMjI6JTIycmVhY3QlMjIsJTIyYW1kJTIyOiUyMnJlYWN0JTIyJTdEP1wiKTtcblxuLyoqKi8gfSxcbi8qIDggKi9cbi8qKiovIGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cdGV2YWwoXCJtb2R1bGUuZXhwb3J0cyA9IF9fV0VCUEFDS19FWFRFUk5BTF9NT0RVTEVfOF9fO1xcblxcbi8qKioqKioqKioqKioqKioqKlxcbiAqKiBXRUJQQUNLIEZPT1RFUlxcbiAqKiBleHRlcm5hbCB7XFxcInJvb3RcXFwiOlxcXCJSZWFjdERPTVxcXCIsXFxcImNvbW1vbmpzMlxcXCI6XFxcInJlYWN0LWRvbVxcXCIsXFxcImNvbW1vbmpzXFxcIjpcXFwicmVhY3QtZG9tXFxcIixcXFwiYW1kXFxcIjpcXFwicmVhY3QtZG9tXFxcIn1cXG4gKiogbW9kdWxlIGlkID0gOFxcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxcbiAqKi9cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly8vZXh0ZXJuYWxfJTdCJTIycm9vdCUyMjolMjJSZWFjdERPTSUyMiwlMjJjb21tb25qczIlMjI6JTIycmVhY3QtZG9tJTIyLCUyMmNvbW1vbmpzJTIyOiUyMnJlYWN0LWRvbSUyMiwlMjJhbWQlMjI6JTIycmVhY3QtZG9tJTIyJTdEP1wiKTtcblxuLyoqKi8gfVxuLyoqKioqKi8gXSlcbn0pO1xuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9yZWFjdC1vd2wtY2Fyb3VzZWwyL2xpYi9Pd2xDYXJvdXNlbC5qcyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obW9kdWxlKSB7XG5cdGlmKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYoIW1vZHVsZS5jaGlsZHJlbikgbW9kdWxlLmNoaWxkcmVuID0gW107XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJsb2FkZWRcIiwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiBtb2R1bGUubDtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLCBcImlkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0bW9kdWxlLndlYnBhY2tQb2x5ZmlsbCA9IDE7XG5cdH1cblx0cmV0dXJuIG1vZHVsZTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG52YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuXG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xudmFyIGNoZWNrUHJvcFR5cGVzID0gcmVxdWlyZSgnLi9jaGVja1Byb3BUeXBlcycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gIC8qIGdsb2JhbCBTeW1ib2wgKi9cbiAgdmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xuICB2YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7IC8vIEJlZm9yZSBTeW1ib2wgc3BlYy5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICAgKlxuICAgKiBCZSBzdXJlIHRvIGludm9rZSB0aGUgZnVuY3Rpb24gd2l0aCB0aGUgaXRlcmFibGUgYXMgY29udGV4dDpcbiAgICpcbiAgICogICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihteUl0ZXJhYmxlKTtcbiAgICogICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAgICogICAgICAgLi4uXG4gICAqICAgICB9XG4gICAqXG4gICAqIEBwYXJhbSB7P29iamVjdH0gbWF5YmVJdGVyYWJsZVxuICAgKiBAcmV0dXJuIHs/ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IG1heWJlSXRlcmFibGUgJiYgKElURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF0pO1xuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZXJhdG9yRm47XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgbWV0aG9kcyB0aGF0IGFsbG93IGRlY2xhcmF0aW9uIGFuZCB2YWxpZGF0aW9uIG9mIHByb3BzIHRoYXQgYXJlXG4gICAqIHN1cHBsaWVkIHRvIFJlYWN0IGNvbXBvbmVudHMuIEV4YW1wbGUgdXNhZ2U6XG4gICAqXG4gICAqICAgdmFyIFByb3BzID0gcmVxdWlyZSgnUmVhY3RQcm9wVHlwZXMnKTtcbiAgICogICB2YXIgTXlBcnRpY2xlID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgIC8vIEFuIG9wdGlvbmFsIHN0cmluZyBwcm9wIG5hbWVkIFwiZGVzY3JpcHRpb25cIi5cbiAgICogICAgICAgZGVzY3JpcHRpb246IFByb3BzLnN0cmluZyxcbiAgICpcbiAgICogICAgICAgLy8gQSByZXF1aXJlZCBlbnVtIHByb3AgbmFtZWQgXCJjYXRlZ29yeVwiLlxuICAgKiAgICAgICBjYXRlZ29yeTogUHJvcHMub25lT2YoWydOZXdzJywnUGhvdG9zJ10pLmlzUmVxdWlyZWQsXG4gICAqXG4gICAqICAgICAgIC8vIEEgcHJvcCBuYW1lZCBcImRpYWxvZ1wiIHRoYXQgcmVxdWlyZXMgYW4gaW5zdGFuY2Ugb2YgRGlhbG9nLlxuICAgKiAgICAgICBkaWFsb2c6IFByb3BzLmluc3RhbmNlT2YoRGlhbG9nKS5pc1JlcXVpcmVkXG4gICAqICAgICB9LFxuICAgKiAgICAgcmVuZGVyOiBmdW5jdGlvbigpIHsgLi4uIH1cbiAgICogICB9KTtcbiAgICpcbiAgICogQSBtb3JlIGZvcm1hbCBzcGVjaWZpY2F0aW9uIG9mIGhvdyB0aGVzZSBtZXRob2RzIGFyZSB1c2VkOlxuICAgKlxuICAgKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAgICogICBkZWNsIDo9IFJlYWN0UHJvcFR5cGVzLnt0eXBlfSguaXNSZXF1aXJlZCk/XG4gICAqXG4gICAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAgICogYWxsb3dzIHRoZSBjcmVhdGlvbiBvZiBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbnMuIEZvciBleGFtcGxlOlxuICAgKlxuICAgKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAgICogICAgcHJvcFR5cGVzOiB7XG4gICAqICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIG9yIFVSSSBwcm9wIG5hbWVkIFwiaHJlZlwiLlxuICAgKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgKiAgICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICogICAgICAgIGlmIChwcm9wVmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgcHJvcFZhbHVlICE9PSAnc3RyaW5nJyAmJlxuICAgKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICAgKiAgICAgICAgICByZXR1cm4gbmV3IEVycm9yKFxuICAgKiAgICAgICAgICAgICdFeHBlY3RlZCBhIHN0cmluZyBvciBhbiBVUkkgZm9yICcgKyBwcm9wTmFtZSArICcgaW4gJyArXG4gICAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgKiAgICAgICAgICApO1xuICAgKiAgICAgICAgfVxuICAgKiAgICAgIH1cbiAgICogICAgfSxcbiAgICogICAgcmVuZGVyOiBmdW5jdGlvbigpIHsuLi59XG4gICAqICB9KTtcbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuXG4gIHZhciBBTk9OWU1PVVMgPSAnPDxhbm9ueW1vdXM+Pic7XG5cbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qc2AuXG4gIHZhciBSZWFjdFByb3BUeXBlcyA9IHtcbiAgICBhcnJheTogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2FycmF5JyksXG4gICAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgICBmdW5jOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignZnVuY3Rpb24nKSxcbiAgICBudW1iZXI6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdudW1iZXInKSxcbiAgICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgICBzdHJpbmc6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzdHJpbmcnKSxcbiAgICBzeW1ib2w6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdzeW1ib2wnKSxcblxuICAgIGFueTogY3JlYXRlQW55VHlwZUNoZWNrZXIoKSxcbiAgICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gICAgZWxlbWVudDogY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCksXG4gICAgaW5zdGFuY2VPZjogY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcixcbiAgICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICAgIG9iamVjdE9mOiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyLFxuICAgIG9uZU9mOiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIsXG4gICAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICAgIHNoYXBlOiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyLFxuICAgIGV4YWN0OiBjcmVhdGVTdHJpY3RTaGFwZVR5cGVDaGVja2VyLFxuICB9O1xuXG4gIC8qKlxuICAgKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gICAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICAgKi9cbiAgLyplc2xpbnQtZGlzYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuICBmdW5jdGlvbiBpcyh4LCB5KSB7XG4gICAgLy8gU2FtZVZhbHVlIGFsZ29yaXRobVxuICAgIGlmICh4ID09PSB5KSB7XG4gICAgICAvLyBTdGVwcyAxLTUsIDctMTBcbiAgICAgIC8vIFN0ZXBzIDYuYi02LmU6ICswICE9IC0wXG4gICAgICByZXR1cm4geCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN0ZXAgNi5hOiBOYU4gPT0gTmFOXG4gICAgICByZXR1cm4geCAhPT0geCAmJiB5ICE9PSB5O1xuICAgIH1cbiAgfVxuICAvKmVzbGludC1lbmFibGUgbm8tc2VsZi1jb21wYXJlKi9cblxuICAvKipcbiAgICogV2UgdXNlIGFuIEVycm9yLWxpa2Ugb2JqZWN0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IGFzIHBlb3BsZSBtYXkgY2FsbFxuICAgKiBQcm9wVHlwZXMgZGlyZWN0bHkgYW5kIGluc3BlY3QgdGhlaXIgb3V0cHV0LiBIb3dldmVyLCB3ZSBkb24ndCB1c2UgcmVhbFxuICAgKiBFcnJvcnMgYW55bW9yZS4gV2UgZG9uJ3QgaW5zcGVjdCB0aGVpciBzdGFjayBhbnl3YXksIGFuZCBjcmVhdGluZyB0aGVtXG4gICAqIGlzIHByb2hpYml0aXZlbHkgZXhwZW5zaXZlIGlmIHRoZXkgYXJlIGNyZWF0ZWQgdG9vIG9mdGVuLCBzdWNoIGFzIHdoYXRcbiAgICogaGFwcGVucyBpbiBvbmVPZlR5cGUoKSBmb3IgYW55IHR5cGUgYmVmb3JlIHRoZSBvbmUgdGhhdCBtYXRjaGVkLlxuICAgKi9cbiAgZnVuY3Rpb24gUHJvcFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB0aGlzLnN0YWNrID0gJyc7XG4gIH1cbiAgLy8gTWFrZSBgaW5zdGFuY2VvZiBFcnJvcmAgc3RpbGwgd29yayBmb3IgcmV0dXJuZWQgZXJyb3JzLlxuICBQcm9wVHlwZUVycm9yLnByb3RvdHlwZSA9IEVycm9yLnByb3RvdHlwZTtcblxuICBmdW5jdGlvbiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGUgPSB7fTtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA9IDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNoZWNrVHlwZShpc1JlcXVpcmVkLCBwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGNvbXBvbmVudE5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgcHJvcEZ1bGxOYW1lID0gcHJvcEZ1bGxOYW1lIHx8IHByb3BOYW1lO1xuXG4gICAgICBpZiAoc2VjcmV0ICE9PSBSZWFjdFByb3BUeXBlc1NlY3JldCkge1xuICAgICAgICBpZiAodGhyb3dPbkRpcmVjdEFjY2Vzcykge1xuICAgICAgICAgIC8vIE5ldyBiZWhhdmlvciBvbmx5IGZvciB1c2VycyBvZiBgcHJvcC10eXBlc2AgcGFja2FnZVxuICAgICAgICAgIGludmFyaWFudChcbiAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgJ1VzZSBgUHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzKClgIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAgICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgLy8gT2xkIGJlaGF2aW9yIGZvciBwZW9wbGUgdXNpbmcgUmVhY3QuUHJvcFR5cGVzXG4gICAgICAgICAgdmFyIGNhY2hlS2V5ID0gY29tcG9uZW50TmFtZSArICc6JyArIHByb3BOYW1lO1xuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICFtYW51YWxQcm9wVHlwZUNhbGxDYWNoZVtjYWNoZUtleV0gJiZcbiAgICAgICAgICAgIC8vIEF2b2lkIHNwYW1taW5nIHRoZSBjb25zb2xlIGJlY2F1c2UgdGhleSBhcmUgb2Z0ZW4gbm90IGFjdGlvbmFibGUgZXhjZXB0IGZvciBsaWIgYXV0aG9yc1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVXYXJuaW5nQ291bnQgPCAzXG4gICAgICAgICAgKSB7XG4gICAgICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgICAgJ1lvdSBhcmUgbWFudWFsbHkgY2FsbGluZyBhIFJlYWN0LlByb3BUeXBlcyB2YWxpZGF0aW9uICcgK1xuICAgICAgICAgICAgICAnZnVuY3Rpb24gZm9yIHRoZSBgJXNgIHByb3Agb24gYCVzYC4gVGhpcyBpcyBkZXByZWNhdGVkICcgK1xuICAgICAgICAgICAgICAnYW5kIHdpbGwgdGhyb3cgaW4gdGhlIHN0YW5kYWxvbmUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgICAgICAgICAnWW91IG1heSBiZSBzZWVpbmcgdGhpcyB3YXJuaW5nIGR1ZSB0byBhIHRoaXJkLXBhcnR5IFByb3BUeXBlcyAnICtcbiAgICAgICAgICAgICAgJ2xpYnJhcnkuIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmctZG9udC1jYWxsLXByb3B0eXBlcyAnICsgJ2ZvciBkZXRhaWxzLicsXG4gICAgICAgICAgICAgIHByb3BGdWxsTmFtZSxcbiAgICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSA9IHRydWU7XG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdUaGUgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGlzIG1hcmtlZCBhcyByZXF1aXJlZCAnICsgKCdpbiBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgYnV0IGl0cyB2YWx1ZSBpcyBgbnVsbGAuJykpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkIGluICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLicpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGFpbmVkQ2hlY2tUeXBlID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgZmFsc2UpO1xuICAgIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gICAgcmV0dXJuIGNoYWluZWRDaGVja1R5cGU7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09IGV4cGVjdGVkVHlwZSkge1xuICAgICAgICAvLyBgcHJvcFZhbHVlYCBiZWluZyBpbnN0YW5jZSBvZiwgc2F5LCBkYXRlL3JlZ2V4cCwgcGFzcyB0aGUgJ29iamVjdCdcbiAgICAgICAgLy8gY2hlY2ssIGJ1dCB3ZSBjYW4gb2ZmZXIgYSBtb3JlIHByZWNpc2UgZXJyb3IgbWVzc2FnZSBoZXJlIHJhdGhlciB0aGFuXG4gICAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgICAgdmFyIHByZWNpc2VUeXBlID0gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKTtcblxuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcmVjaXNlVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnYCcgKyBleHBlY3RlZFR5cGUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFueVR5cGVDaGVja2VyKCkge1xuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcihlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgYXJyYXlPZi4nKTtcbiAgICAgIH1cbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBhcnJheS4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BWYWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZXJyb3IgPSB0eXBlQ2hlY2tlcihwcm9wVmFsdWUsIGksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnWycgKyBpICsgJ10nLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBpZiAoIWlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBzaW5nbGUgUmVhY3RFbGVtZW50LicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSW5zdGFuY2VUeXBlQ2hlY2tlcihleHBlY3RlZENsYXNzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgICB2YXIgZXhwZWN0ZWRDbGFzc05hbWUgPSBleHBlY3RlZENsYXNzLm5hbWUgfHwgQU5PTllNT1VTO1xuICAgICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGV4cGVjdGVkVmFsdWVzKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4cGVjdGVkVmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpcyhwcm9wVmFsdWUsIGV4cGVjdGVkVmFsdWVzW2ldKSkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB2YWx1ZXNTdHJpbmcgPSBKU09OLnN0cmluZ2lmeShleHBlY3RlZFZhbHVlcyk7XG4gICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHZhbHVlIGAnICsgcHJvcFZhbHVlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIG9uZSBvZiAnICsgdmFsdWVzU3RyaW5nICsgJy4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHR5cGVDaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignUHJvcGVydHkgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiBjb21wb25lbnQgYCcgKyBjb21wb25lbnROYW1lICsgJ2AgaGFzIGludmFsaWQgUHJvcFR5cGUgbm90YXRpb24gaW5zaWRlIG9iamVjdE9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIG9iamVjdC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwga2V5LCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lICsgJy4nICsga2V5LCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlVW5pb25UeXBlQ2hlY2tlcihhcnJheU9mVHlwZUNoZWNrZXJzKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKSA6IHZvaWQgMDtcbiAgICAgIHJldHVybiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgIGlmICh0eXBlb2YgY2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuaW5nKFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICdJbnZhbGlkIGFyZ3VtZW50IHN1cHBsaWVkIHRvIG9uZU9mVHlwZS4gRXhwZWN0ZWQgYW4gYXJyYXkgb2YgY2hlY2sgZnVuY3Rpb25zLCBidXQgJyArXG4gICAgICAgICAgJ3JlY2VpdmVkICVzIGF0IGluZGV4ICVzLicsXG4gICAgICAgICAgZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKGNoZWNrZXIpLFxuICAgICAgICAgIGlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheU9mVHlwZUNoZWNrZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGVja2VyID0gYXJyYXlPZlR5cGVDaGVja2Vyc1tpXTtcbiAgICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lLCBSZWFjdFByb3BUeXBlc1NlY3JldCkgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlTm9kZUNoZWNrZXIoKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBpZiAoIWlzTm9kZShwcm9wc1twcm9wTmFtZV0pKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgUmVhY3ROb2RlLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIoc2hhcGVUeXBlcykge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgYWxsIGtleXMgaW4gY2FzZSBzb21lIGFyZSByZXF1aXJlZCBidXQgbWlzc2luZyBmcm9tXG4gICAgICAvLyBwcm9wcy5cbiAgICAgIHZhciBhbGxLZXlzID0gYXNzaWduKHt9LCBwcm9wc1twcm9wTmFtZV0sIHNoYXBlVHlwZXMpO1xuICAgICAgZm9yICh2YXIga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBzaGFwZVR5cGVzW2tleV07XG4gICAgICAgIGlmICghY2hlY2tlcikge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcihcbiAgICAgICAgICAgICdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBrZXkgYCcgKyBrZXkgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nICtcbiAgICAgICAgICAgICdcXG5CYWQgb2JqZWN0OiAnICsgSlNPTi5zdHJpbmdpZnkocHJvcHNbcHJvcE5hbWVdLCBudWxsLCAnICAnKSArXG4gICAgICAgICAgICAnXFxuVmFsaWQga2V5czogJyArICBKU09OLnN0cmluZ2lmeShPYmplY3Qua2V5cyhzaGFwZVR5cGVzKSwgbnVsbCwgJyAgJylcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlcnJvciA9IGNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNOb2RlKHByb3BWYWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BWYWx1ZSA9PT0gbnVsbCB8fCBpc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwocHJvcFZhbHVlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gcHJvcFZhbHVlLmVudHJpZXMpIHtcbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICAgIHZhciBlbnRyeSA9IHN0ZXAudmFsdWU7XG4gICAgICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1N5bWJvbChwcm9wVHlwZSwgcHJvcFZhbHVlKSB7XG4gICAgLy8gTmF0aXZlIFN5bWJvbC5cbiAgICBpZiAocHJvcFR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyAxOS40LjMuNSBTeW1ib2wucHJvdG90eXBlW0BAdG9TdHJpbmdUYWddID09PSAnU3ltYm9sJ1xuICAgIGlmIChwcm9wVmFsdWVbJ0BAdG9TdHJpbmdUYWcnXSA9PT0gJ1N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIEZhbGxiYWNrIGZvciBub24tc3BlYyBjb21wbGlhbnQgU3ltYm9scyB3aGljaCBhcmUgcG9seWZpbGxlZC5cbiAgICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBwcm9wVmFsdWUgaW5zdGFuY2VvZiBTeW1ib2wpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbiAgZnVuY3Rpb24gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKSB7XG4gICAgdmFyIHByb3BUeXBlID0gdHlwZW9mIHByb3BWYWx1ZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ2FycmF5JztcbiAgICB9XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgLy8gT2xkIHdlYmtpdHMgKGF0IGxlYXN0IHVudGlsIEFuZHJvaWQgNC4wKSByZXR1cm4gJ2Z1bmN0aW9uJyByYXRoZXIgdGhhblxuICAgICAgLy8gJ29iamVjdCcgZm9yIHR5cGVvZiBhIFJlZ0V4cC4gV2UnbGwgbm9ybWFsaXplIHRoaXMgaGVyZSBzbyB0aGF0IC9ibGEvXG4gICAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICAgIHJldHVybiAnb2JqZWN0JztcbiAgICB9XG4gICAgaWYgKGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ3N5bWJvbCc7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFRoaXMgaGFuZGxlcyBtb3JlIHR5cGVzIHRoYW4gYGdldFByb3BUeXBlYC4gT25seSB1c2VkIGZvciBlcnJvciBtZXNzYWdlcy5cbiAgLy8gU2VlIGBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcmAuXG4gIGZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICAgIGlmICh0eXBlb2YgcHJvcFZhbHVlID09PSAndW5kZWZpbmVkJyB8fCBwcm9wVmFsdWUgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJyArIHByb3BWYWx1ZTtcbiAgICB9XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICByZXR1cm4gJ2RhdGUnO1xuICAgICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgICAgcmV0dXJuICdyZWdleHAnO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvcFR5cGU7XG4gIH1cblxuICAvLyBSZXR1cm5zIGEgc3RyaW5nIHRoYXQgaXMgcG9zdGZpeGVkIHRvIGEgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIHR5cGUuXG4gIC8vIEZvciBleGFtcGxlLCBcInVuZGVmaW5lZFwiIG9yIFwib2YgdHlwZSBhcnJheVwiXG4gIGZ1bmN0aW9uIGdldFBvc3RmaXhGb3JUeXBlV2FybmluZyh2YWx1ZSkge1xuICAgIHZhciB0eXBlID0gZ2V0UHJlY2lzZVR5cGUodmFsdWUpO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgcmV0dXJuICdhbiAnICsgdHlwZTtcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgY2FzZSAnZGF0ZSc6XG4gICAgICBjYXNlICdyZWdleHAnOlxuICAgICAgICByZXR1cm4gJ2EgJyArIHR5cGU7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG4gIH1cblxuICAvLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuICBmdW5jdGlvbiBnZXRDbGFzc05hbWUocHJvcFZhbHVlKSB7XG4gICAgaWYgKCFwcm9wVmFsdWUuY29uc3RydWN0b3IgfHwgIXByb3BWYWx1ZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG4gICAgICByZXR1cm4gQU5PTllNT1VTO1xuICAgIH1cbiAgICByZXR1cm4gcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWU7XG4gIH1cblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGNoZWNrUHJvcFR5cGVzO1xuICBSZWFjdFByb3BUeXBlcy5Qcm9wVHlwZXMgPSBSZWFjdFByb3BUeXBlcztcblxuICByZXR1cm4gUmVhY3RQcm9wVHlwZXM7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanMiLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZXNTZWNyZXQgPSByZXF1aXJlKCcuL2xpYi9SZWFjdFByb3BUeXBlc1NlY3JldCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBzaGltKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgaWYgKHNlY3JldCA9PT0gUmVhY3RQcm9wVHlwZXNTZWNyZXQpIHtcbiAgICAgIC8vIEl0IGlzIHN0aWxsIHNhZmUgd2hlbiBjYWxsZWQgZnJvbSBSZWFjdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaW52YXJpYW50KFxuICAgICAgZmFsc2UsXG4gICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAnVXNlIFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcygpIHRvIGNhbGwgdGhlbS4gJyArXG4gICAgICAnUmVhZCBtb3JlIGF0IGh0dHA6Ly9mYi5tZS91c2UtY2hlY2stcHJvcC10eXBlcydcbiAgICApO1xuICB9O1xuICBzaGltLmlzUmVxdWlyZWQgPSBzaGltO1xuICBmdW5jdGlvbiBnZXRTaGltKCkge1xuICAgIHJldHVybiBzaGltO1xuICB9O1xuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUeXBlQ2hlY2tlcnMuanNgLlxuICB2YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gICAgYXJyYXk6IHNoaW0sXG4gICAgYm9vbDogc2hpbSxcbiAgICBmdW5jOiBzaGltLFxuICAgIG51bWJlcjogc2hpbSxcbiAgICBvYmplY3Q6IHNoaW0sXG4gICAgc3RyaW5nOiBzaGltLFxuICAgIHN5bWJvbDogc2hpbSxcblxuICAgIGFueTogc2hpbSxcbiAgICBhcnJheU9mOiBnZXRTaGltLFxuICAgIGVsZW1lbnQ6IHNoaW0sXG4gICAgaW5zdGFuY2VPZjogZ2V0U2hpbSxcbiAgICBub2RlOiBzaGltLFxuICAgIG9iamVjdE9mOiBnZXRTaGltLFxuICAgIG9uZU9mOiBnZXRTaGltLFxuICAgIG9uZU9mVHlwZTogZ2V0U2hpbSxcbiAgICBzaGFwZTogZ2V0U2hpbSxcbiAgICBleGFjdDogZ2V0U2hpbVxuICB9O1xuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gZW1wdHlGdW5jdGlvbjtcbiAgUmVhY3RQcm9wVHlwZXMuUHJvcFR5cGVzID0gUmVhY3RQcm9wVHlwZXM7XG5cbiAgcmV0dXJuIFJlYWN0UHJvcFR5cGVzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyJdLCJzb3VyY2VSb290IjoiIn0=